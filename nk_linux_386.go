// Code generated by 'ccgo -o nk_linux_386.go nuklear/nuklear.c -export-externs X -export-fields "" -export-defines "" -export-enums "" -export-typedefs "" -export-structs "" -nostdlib -pkgname nk', DO NOT EDIT.

package nk

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer

const (
	BIG_ENDIAN                         = 4321
	BYTE_ORDER                         = 1234
	EXIT_FAILURE                       = 1
	EXIT_SUCCESS                       = 0
	FD_SETSIZE                         = 1024
	FP_ILOGB0                          = -2147483648
	FP_ILOGBNAN                        = -2147483648
	FP_INFINITE1                       = 1
	FP_NAN1                            = 0
	FP_NORMAL1                         = 4
	FP_SUBNORMAL1                      = 3
	FP_ZERO1                           = 2
	INT16_MAX                          = 32767
	INT16_MIN                          = -32768
	INT32_MAX                          = 2147483647
	INT32_MIN                          = -2147483648
	INT64_MAX                          = 9223372036854775807
	INT64_MIN                          = -9223372036854775808
	INT8_MAX                           = 127
	INT8_MIN                           = -128
	INTMAX_MAX                         = 9223372036854775807
	INTMAX_MIN                         = -9223372036854775808
	INTPTR_MAX                         = 9223372036854775807
	INTPTR_MIN                         = -9223372036854775808
	INT_FAST16_MAX                     = 9223372036854775807
	INT_FAST16_MIN                     = -9223372036854775808
	INT_FAST32_MAX                     = 9223372036854775807
	INT_FAST32_MIN                     = -9223372036854775808
	INT_FAST64_MAX                     = 9223372036854775807
	INT_FAST64_MIN                     = -9223372036854775808
	INT_FAST8_MAX                      = 127
	INT_FAST8_MIN                      = -128
	INT_LEAST16_MAX                    = 32767
	INT_LEAST16_MIN                    = -32768
	INT_LEAST32_MAX                    = 2147483647
	INT_LEAST32_MIN                    = -2147483648
	INT_LEAST64_MAX                    = 9223372036854775807
	INT_LEAST64_MIN                    = -9223372036854775808
	INT_LEAST8_MAX                     = 127
	INT_LEAST8_MIN                     = -128
	LITTLE_ENDIAN                      = 1234
	MATH_ERREXCEPT                     = 2
	MATH_ERRNO                         = 1
	M_1_PI                             = 0.31830988618379067154
	M_2_PI                             = 0.63661977236758134308
	M_2_SQRTPI                         = 1.12837916709551257390
	M_E                                = 2.7182818284590452354
	M_LN10                             = 2.30258509299404568402
	M_LN2                              = 0.69314718055994530942
	M_LOG10E                           = 0.43429448190325182765
	M_LOG2E                            = 1.4426950408889634074
	M_PI                               = 3.14159265358979323846
	M_PI_2                             = 1.57079632679489661923
	M_PI_4                             = 0.78539816339744830962
	M_SQRT1_2                          = 0.70710678118654752440
	M_SQRT2                            = 1.41421356237309504880
	NK_ADJACENCY_BONUS                 = 5
	NK_BUFFER_DEFAULT_INITIAL_SIZE     = 4096
	NK_BUTTON_BEHAVIOR_STACK_SIZE      = 8
	NK_CAMEL_BONUS                     = 10
	NK_CHART_MAX_SLOT                  = 4
	NK_COLOR_STACK_SIZE                = 32
	NK_CURSOR_DATA_H                   = 27
	NK_CURSOR_DATA_W                   = 90
	NK_DEFAULT                         = -1
	NK_DEFAULT_COMMAND_BUFFER_SIZE     = 4096
	NK_FLAGS_STACK_SIZE                = 32
	NK_FLOAT_PRECISION                 = 0.00000000000001
	NK_FLOAT_STACK_SIZE                = 32
	NK_FONT_STACK_SIZE                 = 8
	NK_IMPLEMENTATION                  = 0
	NK_INCLUDE_DEFAULT_ALLOCATOR       = 0
	NK_INCLUDE_DEFAULT_FONT            = 0
	NK_INCLUDE_FIXED_TYPES             = 0
	NK_INCLUDE_FONT_BAKING             = 0
	NK_INCLUDE_VERTEX_BUFFER_OUTPUT    = 0
	NK_INPUT_MAX                       = 16
	NK_INTERNAL_H                      = 0
	NK_LEADING_LETTER_PENALTY          = -3
	NK_MAX_FLOAT_PRECISION             = 2
	NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = 16
	NK_MAX_LEADING_LETTER_PENALTY      = -9
	NK_MAX_NUMBER_BUFFER               = 64
	NK_NUKLEAR_H_                      = 0
	NK_PI                              = 3.141592654
	NK_POOL_DEFAULT_CAPACITY           = 16
	NK_SCHAR_MAX                       = 127
	NK_SCHAR_MIN                       = -127
	NK_SCROLLBAR_HIDING_TIMEOUT        = 4.0
	NK_SEPARATOR_BONUS                 = 10
	NK_SINGLE_FILE                     = 0
	NK_SINT_MAX                        = 2147483647
	NK_SINT_MIN                        = -2147483647
	NK_SSHORT_MAX                      = 32767
	NK_SSHORT_MIN                      = -32767
	NK_STYLE_ITEM_STACK_SIZE           = 16
	NK_TEXTEDIT_UNDOCHARCOUNT          = 999
	NK_TEXTEDIT_UNDOSTATECOUNT         = 99
	NK_UCHAR_MAX                       = 256
	NK_UCHAR_MIN                       = 0
	NK_UINT_MAX                        = 4294967295
	NK_UINT_MIN                        = 0
	NK_UNMATCHED_LETTER_PENALTY        = -1
	NK_USHORT_MAX                      = 65535
	NK_USHORT_MIN                      = 0
	NK_UTF_INVALID                     = 0xFFFD
	NK_UTF_SIZE                        = 4
	NK_VECTOR_STACK_SIZE               = 16
	NK_WINDOW_MAX_NAME                 = 64
	PDP_ENDIAN                         = 3412
	PTRDIFF_MAX                        = 9223372036854775807
	PTRDIFF_MIN                        = -9223372036854775808
	RAND_MAX                           = 2147483647
	SIG_ATOMIC_MAX                     = 2147483647
	SIG_ATOMIC_MIN                     = -2147483648
	SIZE_MAX                           = 18446744073709551615
	STBRP__MAXVAL                      = 0xffff
	STBTT_MACSTYLE_BOLD                = 1
	STBTT_MACSTYLE_DONTCARE            = 0
	STBTT_MACSTYLE_ITALIC              = 2
	STBTT_MACSTYLE_NONE                = 8
	STBTT_MACSTYLE_UNDERSCORE          = 4
	STBTT_MAX_OVERSAMPLE               = 8
	STBTT_RASTERIZER_VERSION           = 2
	STBTT__OVER_MASK                   = 7
	STB_INCLUDE_STB_RECT_PACK_H        = 0
	STB_RECT_PACK_IMPLEMENTATION       = 0
	STB_RECT_PACK_VERSION              = 1
	STB_TRUETYPE_IMPLEMENTATION        = 0
	UINT16_MAX                         = 65535
	UINT32_MAX                         = 4294967295
	UINT64_MAX                         = 18446744073709551615
	UINT8_MAX                          = 255
	UINTMAX_MAX                        = 18446744073709551615
	UINTPTR_MAX                        = 18446744073709551615
	UINT_FAST16_MAX                    = 18446744073709551615
	UINT_FAST32_MAX                    = 18446744073709551615
	UINT_FAST64_MAX                    = 18446744073709551615
	UINT_FAST8_MAX                     = 255
	UINT_LEAST16_MAX                   = 65535
	UINT_LEAST32_MAX                   = 4294967295
	UINT_LEAST64_MAX                   = 18446744073709551615
	UINT_LEAST8_MAX                    = 255
	WCHAR_MAX                          = 2147483647
	WCHAR_MIN                          = -2147483648
	WCONTINUED                         = 8
	WEXITED                            = 4
	WINT_MAX                           = 4294967295
	WINT_MIN                           = 0
	WNOHANG                            = 1
	WNOWAIT                            = 0x01000000
	WSTOPPED                           = 2
	WUNTRACED                          = 2
	X_ALLOCA_H                         = 1
	X_ASSERT_H                         = 1
	X_ASSERT_H_DECLS                   = 0
	X_ATFILE_SOURCE                    = 1
	X_BITS_BYTESWAP_H                  = 1
	X_BITS_ENDIANNESS_H                = 1
	X_BITS_ENDIAN_H                    = 1
	X_BITS_FLOATN_COMMON_H             = 0
	X_BITS_FLOATN_H                    = 0
	X_BITS_LIBM_SIMD_DECL_STUBS_H      = 1
	X_BITS_PTHREADTYPES_ARCH_H         = 1
	X_BITS_PTHREADTYPES_COMMON_H       = 1
	X_BITS_STDINT_INTN_H               = 1
	X_BITS_STDINT_UINTN_H              = 1
	X_BITS_TIME64_H                    = 1
	X_BITS_TYPESIZES_H                 = 1
	X_BITS_TYPES_H                     = 1
	X_BITS_TYPES_LOCALE_T_H            = 1
	X_BITS_TYPES___LOCALE_T_H          = 1
	X_BITS_UINTN_IDENTITY_H            = 1
	X_BITS_WCHAR_H                     = 1
	X_BSD_SIZE_T_                      = 0
	X_BSD_SIZE_T_DEFINED_              = 0
	X_DEFAULT_SOURCE                   = 1
	X_ENDIAN_H                         = 1
	X_FEATURES_H                       = 1
	X_FILE_OFFSET_BITS                 = 64
	X_GCC_SIZE_T                       = 0
	X_GCC_WCHAR_T                      = 0
	X_GCC_WRAP_STDINT_H                = 0
	X_LP64                             = 1
	X_MATH_H                           = 1
	X_POSIX_C_SOURCE                   = 200809
	X_POSIX_SOURCE                     = 1
	X_RWLOCK_INTERNAL_H                = 0
	X_SIZET_                           = 0
	X_SIZE_T                           = 0
	X_SIZE_T_                          = 0
	X_SIZE_T_DECLARED                  = 0
	X_SIZE_T_DEFINED                   = 0
	X_SIZE_T_DEFINED_                  = 0
	X_STDC_PREDEF_H                    = 1
	X_STDINT_H                         = 1
	X_STDLIB_H                         = 1
	X_STRINGS_H                        = 1
	X_STRING_H                         = 1
	X_STRUCT_TIMESPEC                  = 1
	X_SYS_CDEFS_H                      = 1
	X_SYS_SELECT_H                     = 1
	X_SYS_SIZE_T_H                     = 0
	X_SYS_TYPES_H                      = 1
	X_THREAD_MUTEX_INTERNAL_H          = 1
	X_THREAD_SHARED_TYPES_H            = 1
	X_T_SIZE                           = 0
	X_T_SIZE_                          = 0
	X_T_WCHAR                          = 0
	X_T_WCHAR_                         = 0
	X_WCHAR_T                          = 0
	X_WCHAR_T_                         = 0
	X_WCHAR_T_DECLARED                 = 0
	X_WCHAR_T_DEFINED                  = 0
	X_WCHAR_T_DEFINED_                 = 0
	X_WCHAR_T_H                        = 0
	Linux                              = 1
	Math_errhandling                   = 3
	Unix                               = 1
)

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:853:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

const ( /* waitflags.h:52:1: */
	P_ALL  = 0 // Wait for any child.
	P_PID  = 1 // Wait for specified process.
	P_PGID = 2
)

//  Optionally select which packing heuristic the library should use. Different
//  heuristics will produce better/worse results for different data sets.
//  If you call init again, this will be reset to the default.

const ( /* nuklear.h:10765:1: */
	STBRP_HEURISTIC_Skyline_default       = 0
	STBRP_HEURISTIC_Skyline_BL_sortHeight = 0
	STBRP_HEURISTIC_Skyline_BF_sortHeight = 1
)

// ////////////////////////////////////////////////////////////////////////////
//
//      IMPLEMENTATION SECTION
//

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

const ( /* nuklear.h:10825:1: */
	STBRP__INIT_skyline = 1
)

// =============================================================================
//
//                                  DRAWING
//
// =============================================================================
///// ### Drawing
// /// This library was designed to be render backend agnostic so it does
// /// not draw anything to screen directly. Instead all drawn shapes, widgets
// /// are made of, are buffered into memory and make up a command queue.
// /// Each frame therefore fills the command buffer with draw commands
// /// that then need to be executed by the user and his own render backend.
// /// After that the command buffer needs to be cleared and a new frame can be
// /// started. It is probably important to note that the command buffer is the main
// /// drawing API and the optional vertex buffer API only takes this format and
// /// converts it into a hardware accessible format.
// ///
// /// #### Usage
// /// To draw all draw commands accumulated over a frame you need your own render
// /// backend able to draw a number of 2D primitives. This includes at least
// /// filled and stroked rectangles, circles, text, lines, triangles and scissors.
// /// As soon as this criterion is met you can iterate over each draw command
// /// and execute each draw command in a interpreter like fashion:
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// const struct nk_command *cmd = 0;
// /// nk_foreach(cmd, &ctx) {
// ///     switch (cmd->type) {
// ///     case NK_COMMAND_LINE:
// ///         your_draw_line_function(...)
// ///         break;
// ///     case NK_COMMAND_RECT
// ///         your_draw_rect_function(...)
// ///         break;
// ///     case //...:
// ///         //[...]
// ///     }
// /// }
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// In program flow context draw commands need to be executed after input has been
// /// gathered and the complete UI with windows and their contained widgets have
// /// been executed and before calling `nk_clear` which frees all previously
// /// allocated draw commands.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// struct nk_context ctx;
// /// nk_init_xxx(&ctx, ...);
// /// while (1) {
// ///     Event evt;
// ///     nk_input_begin(&ctx);
// ///     while (GetEvent(&evt)) {
// ///         if (evt.type == MOUSE_MOVE)
// ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
// ///         else if (evt.type == [...]) {
// ///             [...]
// ///         }
// ///     }
// ///     nk_input_end(&ctx);
// ///     //
// ///     // [...]
// ///     //
// ///     const struct nk_command *cmd = 0;
// ///     nk_foreach(cmd, &ctx) {
// ///     switch (cmd->type) {
// ///     case NK_COMMAND_LINE:
// ///         your_draw_line_function(...)
// ///         break;
// ///     case NK_COMMAND_RECT
// ///         your_draw_rect_function(...)
// ///         break;
// ///     case ...:
// ///         // [...]
// ///     }
// ///     nk_clear(&ctx);
// /// }
// /// nk_free(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// You probably noticed that you have to draw all of the UI each frame which is
// /// quite wasteful. While the actual UI updating loop is quite fast rendering
// /// without actually needing it is not. So there are multiple things you could do.
// ///
// /// First is only update on input. This of course is only an option if your
// /// application only depends on the UI and does not require any outside calculations.
// /// If you actually only update on input make sure to update the UI two times each
// /// frame and call `nk_clear` directly after the first pass and only draw in
// /// the second pass. In addition it is recommended to also add additional timers
// /// to make sure the UI is not drawn more than a fixed number of frames per second.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// struct nk_context ctx;
// /// nk_init_xxx(&ctx, ...);
// /// while (1) {
// ///     // [...wait for input ]
// ///     // [...do two UI passes ...]
// ///     do_ui(...)
// ///     nk_clear(&ctx);
// ///     do_ui(...)
// ///     //
// ///     // draw
// ///     const struct nk_command *cmd = 0;
// ///     nk_foreach(cmd, &ctx) {
// ///     switch (cmd->type) {
// ///     case NK_COMMAND_LINE:
// ///         your_draw_line_function(...)
// ///         break;
// ///     case NK_COMMAND_RECT
// ///         your_draw_rect_function(...)
// ///         break;
// ///     case ...:
// ///         //[...]
// ///     }
// ///     nk_clear(&ctx);
// /// }
// /// nk_free(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// The second probably more applicable trick is to only draw if anything changed.
// /// It is not really useful for applications with continuous draw loop but
// /// quite useful for desktop applications. To actually get nuklear to only
// /// draw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` and
// /// allocate a memory buffer that will store each unique drawing output.
// /// After each frame you compare the draw command memory inside the library
// /// with your allocated buffer by memcmp. If memcmp detects differences
// /// you have to copy the command buffer into the allocated buffer
// /// and then draw like usual (this example uses fixed memory but you could
// /// use dynamically allocated memory).
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// //[... other defines ...]
// /// #define NK_ZERO_COMMAND_MEMORY
// /// #include "nuklear.h"
// /// //
// /// // setup context
// /// struct nk_context ctx;
// /// void *last = calloc(1,64*1024);
// /// void *buf = calloc(1,64*1024);
// /// nk_init_fixed(&ctx, buf, 64*1024);
// /// //
// /// // loop
// /// while (1) {
// ///     // [...input...]
// ///     // [...ui...]
// ///     void *cmds = nk_buffer_memory(&ctx.memory);
// ///     if (memcmp(cmds, last, ctx.memory.allocated)) {
// ///         memcpy(last,cmds,ctx.memory.allocated);
// ///         const struct nk_command *cmd = 0;
// ///         nk_foreach(cmd, &ctx) {
// ///             switch (cmd->type) {
// ///             case NK_COMMAND_LINE:
// ///                 your_draw_line_function(...)
// ///                 break;
// ///             case NK_COMMAND_RECT
// ///                 your_draw_rect_function(...)
// ///                 break;
// ///             case ...:
// ///                 // [...]
// ///             }
// ///         }
// ///     }
// ///     nk_clear(&ctx);
// /// }
// /// nk_free(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// Finally while using draw commands makes sense for higher abstracted platforms like
// /// X11 and Win32 or drawing libraries it is often desirable to use graphics
// /// hardware directly. Therefore it is possible to just define
// /// `NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.
// /// To access the vertex output you first have to convert all draw commands into
// /// vertexes by calling `nk_convert` which takes in your preferred vertex format.
// /// After successfully converting all draw commands just iterate over and execute all
// /// vertex draw commands:
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// // fill configuration
// /// struct your_vertex
// /// {
// ///     float pos[2]; // important to keep it to 2 floats
// ///     float uv[2];
// ///     unsigned char col[4];
// /// };
// /// struct nk_convert_config cfg = {};
// /// static const struct nk_draw_vertex_layout_element vertex_layout[] = {
// ///     {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},
// ///     {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},
// ///     {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},
// ///     {NK_VERTEX_LAYOUT_END}
// /// };
// /// cfg.shape_AA = NK_ANTI_ALIASING_ON;
// /// cfg.line_AA = NK_ANTI_ALIASING_ON;
// /// cfg.vertex_layout = vertex_layout;
// /// cfg.vertex_size = sizeof(struct your_vertex);
// /// cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);
// /// cfg.circle_segment_count = 22;
// /// cfg.curve_segment_count = 22;
// /// cfg.arc_segment_count = 22;
// /// cfg.global_alpha = 1.0f;
// /// cfg.null = dev->null;
// /// //
// /// // setup buffers and convert
// /// struct nk_buffer cmds, verts, idx;
// /// nk_buffer_init_default(&cmds);
// /// nk_buffer_init_default(&verts);
// /// nk_buffer_init_default(&idx);
// /// nk_convert(&ctx, &cmds, &verts, &idx, &cfg);
// /// //
// /// // draw
// /// nk_draw_foreach(cmd, &ctx, &cmds) {
// /// if (!cmd->elem_count) continue;
// ///     //[...]
// /// }
// /// nk_buffer_free(&cms);
// /// nk_buffer_free(&verts);
// /// nk_buffer_free(&idx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// #### Reference
// /// Function            | Description
// /// --------------------|-------------------------------------------------------
// /// __nk__begin__       | Returns the first draw command in the context draw command list to be drawn
// /// __nk__next__        | Increments the draw command iterator to the next command inside the context draw command list
// /// __nk_foreach__      | Iterates over each draw command inside the context draw command list
// /// __nk_convert__      | Converts from the abstract draw commands list into a hardware accessible vertex format
// /// __nk_draw_begin__   | Returns the first vertex command in the context vertex draw list to be executed
// /// __nk__draw_next__   | Increments the vertex command iterator to the next command inside the context vertex command list
// /// __nk__draw_end__    | Returns the end of the vertex draw list
// /// __nk_draw_foreach__ | Iterates over each vertex draw command inside the vertex draw list
const ( /* nuklear.h:1160:1: */
	NK_ANTI_ALIASING_OFF = 0
	NK_ANTI_ALIASING_ON  = 1
)
const ( /* nuklear.h:1161:1: */
	NK_CONVERT_SUCCESS             = 0
	NK_CONVERT_INVALID_PARAM       = 1
	NK_CONVERT_COMMAND_BUFFER_FULL = 2
	NK_CONVERT_VERTEX_BUFFER_FULL  = 4
	NK_CONVERT_ELEMENT_BUFFER_FULL = 8
)

//  Retrieves a complete list of all of the kerning pairs provided by the font
//  stbtt_GetKerningTable never writes more than table_length entries and returns how many entries it did write.
//  The table will be sorted by (a.glyph1 == b.glyph1)?(a.glyph2 < b.glyph2):(a.glyph1 < b.glyph1)

// ////////////////////////////////////////////////////////////////////////////
//
//  GLYPH SHAPES (you probably don't need these, but they have to go before
//  the bitmaps for C declaration-order reasons)
//

const ( /* nuklear.h:12058:4: */
	STBTT_vmove  = 1
	STBTT_vline  = 2
	STBTT_vcurve = 3
	STBTT_vcubic = 4
)

//  returns the string (which may be big-endian double byte, e.g. for unicode)
//  and puts the length in bytes in *length.
//
//  some of the values for the IDs are below; for more see the truetype spec:
//      http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
//      http://www.microsoft.com/typography/otspec/name.htm

const ( /* nuklear.h:12277:1: */ //  platformID
	STBTT_PLATFORM_ID_UNICODE   = 0
	STBTT_PLATFORM_ID_MAC       = 1
	STBTT_PLATFORM_ID_ISO       = 2
	STBTT_PLATFORM_ID_MICROSOFT = 3
)

const ( /* nuklear.h:12284:1: */ //  encodingID for STBTT_PLATFORM_ID_UNICODE
	STBTT_UNICODE_EID_UNICODE_1_0      = 0
	STBTT_UNICODE_EID_UNICODE_1_1      = 1
	STBTT_UNICODE_EID_ISO_10646        = 2
	STBTT_UNICODE_EID_UNICODE_2_0_BMP  = 3
	STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4
)

const ( /* nuklear.h:12292:1: */ //  encodingID for STBTT_PLATFORM_ID_MICROSOFT
	STBTT_MS_EID_SYMBOL       = 0
	STBTT_MS_EID_UNICODE_BMP  = 1
	STBTT_MS_EID_SHIFTJIS     = 2
	STBTT_MS_EID_UNICODE_FULL = 10
)

const ( /* nuklear.h:12299:1: */ //  encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
	STBTT_MAC_EID_ROMAN        = 0
	STBTT_MAC_EID_ARABIC       = 4
	STBTT_MAC_EID_JAPANESE     = 1
	STBTT_MAC_EID_HEBREW       = 5
	STBTT_MAC_EID_CHINESE_TRAD = 2
	STBTT_MAC_EID_GREEK        = 6
	STBTT_MAC_EID_KOREAN       = 3
	STBTT_MAC_EID_RUSSIAN      = 7
)

const ( /* nuklear.h:12306:1: */ //  languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
	//  problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
	STBTT_MS_LANG_ENGLISH  = 1033
	STBTT_MS_LANG_ITALIAN  = 1040
	STBTT_MS_LANG_CHINESE  = 2052
	STBTT_MS_LANG_JAPANESE = 1041
	STBTT_MS_LANG_DUTCH    = 1043
	STBTT_MS_LANG_KOREAN   = 1042
	STBTT_MS_LANG_FRENCH   = 1036
	STBTT_MS_LANG_RUSSIAN  = 1049
	STBTT_MS_LANG_GERMAN   = 1031
	STBTT_MS_LANG_SPANISH  = 1033
	STBTT_MS_LANG_HEBREW   = 1037
	STBTT_MS_LANG_SWEDISH  = 1053
)

const ( /* nuklear.h:12316:1: */ //  languageID for STBTT_PLATFORM_ID_MAC
	STBTT_MAC_LANG_ENGLISH            = 0
	STBTT_MAC_LANG_JAPANESE           = 11
	STBTT_MAC_LANG_ARABIC             = 12
	STBTT_MAC_LANG_KOREAN             = 23
	STBTT_MAC_LANG_DUTCH              = 4
	STBTT_MAC_LANG_RUSSIAN            = 32
	STBTT_MAC_LANG_FRENCH             = 1
	STBTT_MAC_LANG_SPANISH            = 6
	STBTT_MAC_LANG_GERMAN             = 2
	STBTT_MAC_LANG_SWEDISH            = 5
	STBTT_MAC_LANG_HEBREW             = 10
	STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33
	STBTT_MAC_LANG_ITALIAN            = 3
	STBTT_MAC_LANG_CHINESE_TRAD       = 19
)

///// #### nk_draw_foreach
// /// Iterates over each vertex draw command inside a vertex draw command buffer
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// #define nk_draw_foreach(cmd,ctx, b)
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// Parameter   | Description
// /// ------------|-----------------------------------------------------------
// /// __cmd__     | `nk_draw_command`iterator set to NULL
// /// __buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer
// /// __ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame
// =============================================================================
//
//                                   WINDOW
//
//  =============================================================================
// /// ### Window
// /// Windows are the main persistent state used inside nuklear and are life time
// /// controlled by simply "retouching" (i.e. calling) each window each frame.
// /// All widgets inside nuklear can only be added inside the function pair `nk_begin_xxx`
// /// and `nk_end`. Calling any widgets outside these two functions will result in an
// /// assert in debug or no state change in release mode.<br /><br />
// ///
// /// Each window holds frame persistent state like position, size, flags, state tables,
// /// and some garbage collected internal persistent widget state. Each window
// /// is linked into a window stack list which determines the drawing and overlapping
// /// order. The topmost window thereby is the currently active window.<br /><br />
// ///
// /// To change window position inside the stack occurs either automatically by
// /// user input by being clicked on or programmatically by calling `nk_window_focus`.
// /// Windows by default are visible unless explicitly being defined with flag
// /// `NK_WINDOW_HIDDEN`, the user clicked the close button on windows with flag
// /// `NK_WINDOW_CLOSABLE` or if a window was explicitly hidden by calling
// /// `nk_window_show`. To explicitly close and destroy a window call `nk_window_close`.<br /><br />
// ///
// /// #### Usage
// /// To create and keep a window you have to call one of the two `nk_begin_xxx`
// /// functions to start window declarations and `nk_end` at the end. Furthermore it
// /// is recommended to check the return value of `nk_begin_xxx` and only process
// /// widgets inside the window if the value is not 0. Either way you have to call
// /// `nk_end` at the end of window declarations. Furthermore, do not attempt to
// /// nest `nk_begin_xxx` calls which will hopefully result in an assert or if not
// /// in a segmentation fault.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// if (nk_begin_xxx(...) {
// ///     // [... widgets ...]
// /// }
// /// nk_end(ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// In the grand concept window and widget declarations need to occur after input
// /// handling and before drawing to screen. Not doing so can result in higher
// /// latency or at worst invalid behavior. Furthermore make sure that `nk_clear`
// /// is called at the end of the frame. While nuklear's default platform backends
// /// already call `nk_clear` for you if you write your own backend not calling
// /// `nk_clear` can cause asserts or even worse undefined behavior.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// struct nk_context ctx;
// /// nk_init_xxx(&ctx, ...);
// /// while (1) {
// ///     Event evt;
// ///     nk_input_begin(&ctx);
// ///     while (GetEvent(&evt)) {
// ///         if (evt.type == MOUSE_MOVE)
// ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
// ///         else if (evt.type == [...]) {
// ///             nk_input_xxx(...);
// ///         }
// ///     }
// ///     nk_input_end(&ctx);
// ///
// ///     if (nk_begin_xxx(...) {
// ///         //[...]
// ///     }
// ///     nk_end(ctx);
// ///
// ///     const struct nk_command *cmd = 0;
// ///     nk_foreach(cmd, &ctx) {
// ///     case NK_COMMAND_LINE:
// ///         your_draw_line_function(...)
// ///         break;
// ///     case NK_COMMAND_RECT
// ///         your_draw_rect_function(...)
// ///         break;
// ///     case //...:
// ///         //[...]
// ///     }
// ///     nk_clear(&ctx);
// /// }
// /// nk_free(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// #### Reference
// /// Function                            | Description
// /// ------------------------------------|----------------------------------------
// /// nk_begin                            | Starts a new window; needs to be called every frame for every window (unless hidden) or otherwise the window gets removed
// /// nk_begin_titled                     | Extended window start with separated title and identifier to allow multiple windows with same name but not title
// /// nk_end                              | Needs to be called at the end of the window building process to process scaling, scrollbars and general cleanup
// //
// /// nk_window_find                      | Finds and returns the window with give name
// /// nk_window_get_bounds                | Returns a rectangle with screen position and size of the currently processed window.
// /// nk_window_get_position              | Returns the position of the currently processed window
// /// nk_window_get_size                  | Returns the size with width and height of the currently processed window
// /// nk_window_get_width                 | Returns the width of the currently processed window
// /// nk_window_get_height                | Returns the height of the currently processed window
// /// nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current window
// /// nk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed window
// /// nk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
// /// nk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed window
// /// nk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed window
// /// nk_window_get_canvas                | Returns the draw command buffer. Can be used to draw custom widgets
// /// nk_window_get_scroll                | Gets the scroll offset of the current window
// /// nk_window_has_focus                 | Returns if the currently processed window is currently active
// /// nk_window_is_collapsed              | Returns if the window with given name is currently minimized/collapsed
// /// nk_window_is_closed                 | Returns if the currently processed window was closed
// /// nk_window_is_hidden                 | Returns if the currently processed window was hidden
// /// nk_window_is_active                 | Same as nk_window_has_focus for some reason
// /// nk_window_is_hovered                | Returns if the currently processed window is currently being hovered by mouse
// /// nk_window_is_any_hovered            | Return if any window currently hovered
// /// nk_item_is_any_active               | Returns if any window or widgets is currently hovered or active
// //
// /// nk_window_set_bounds                | Updates position and size of the currently processed window
// /// nk_window_set_position              | Updates position of the currently process window
// /// nk_window_set_size                  | Updates the size of the currently processed window
// /// nk_window_set_focus                 | Set the currently processed window as active window
// /// nk_window_set_scroll                | Sets the scroll offset of the current window
// //
// /// nk_window_close                     | Closes the window with given window name which deletes the window at the end of the frame
// /// nk_window_collapse                  | Collapses the window with given window name
// /// nk_window_collapse_if               | Collapses the window with given window name if the given condition was met
// /// nk_window_show                      | Hides a visible or reshows a hidden window
// /// nk_window_show_if                   | Hides/shows a window depending on condition
//
// /// #### nk_panel_flags
// /// Flag                        | Description
// /// ----------------------------|----------------------------------------
// /// NK_WINDOW_BORDER            | Draws a border around the window to visually separate window from the background
// /// NK_WINDOW_MOVABLE           | The movable flag indicates that a window can be moved by user input or by dragging the window header
// /// NK_WINDOW_SCALABLE          | The scalable flag indicates that a window can be scaled by user input by dragging a scaler icon at the button of the window
// /// NK_WINDOW_CLOSABLE          | Adds a closable icon into the header
// /// NK_WINDOW_MINIMIZABLE       | Adds a minimize icon into the header
// /// NK_WINDOW_NO_SCROLLBAR      | Removes the scrollbar from the window
// /// NK_WINDOW_TITLE             | Forces a header at the top at the window showing the title
// /// NK_WINDOW_SCROLL_AUTO_HIDE  | Automatically hides the window scrollbar if no user interaction: also requires delta time in `nk_context` to be set each frame
// /// NK_WINDOW_BACKGROUND        | Always keep window in the background
// /// NK_WINDOW_SCALE_LEFT        | Puts window scaler in the left-bottom corner instead right-bottom
// /// NK_WINDOW_NO_INPUT          | Prevents window of scaling, moving or getting focus
// ///
// /// #### nk_collapse_states
// /// State           | Description
// /// ----------------|-----------------------------------------------------------
// /// __NK_MINIMIZED__| UI section is collased and not visibile until maximized
// /// __NK_MAXIMIZED__| UI section is extended and visibile until minimized
// /// <br /><br />
const ( /* nuklear.h:1468:1: */
	NK_WINDOW_BORDER           = 1
	NK_WINDOW_MOVABLE          = 2
	NK_WINDOW_SCALABLE         = 4
	NK_WINDOW_CLOSABLE         = 8
	NK_WINDOW_MINIMIZABLE      = 16
	NK_WINDOW_NO_SCROLLBAR     = 32
	NK_WINDOW_TITLE            = 64
	NK_WINDOW_SCROLL_AUTO_HIDE = 128
	NK_WINDOW_BACKGROUND       = 256
	NK_WINDOW_SCALE_LEFT       = 512
	NK_WINDOW_NO_INPUT         = 1024
)

// =============================================================================
//
//                                  WIDGET
//
// =============================================================================
const ( /* nuklear.h:3059:1: */
	NK_WIDGET_INVALID = 0 // The widget cannot be seen and is completely out of view
	NK_WIDGET_VALID   = 1 // The widget is completely inside the window and can be updated and drawn
	NK_WIDGET_ROM     = 2
)
const ( /* nuklear.h:3064:1: */
	NK_WIDGET_STATE_MODIFIED = 2
	NK_WIDGET_STATE_INACTIVE = 4  // widget is neither active nor hovered
	NK_WIDGET_STATE_ENTERED  = 8  // widget has been hovered on the current frame
	NK_WIDGET_STATE_HOVER    = 16 // widget is being hovered
	NK_WIDGET_STATE_ACTIVED  = 32 // widget is currently activated
	NK_WIDGET_STATE_LEFT     = 64 // widget is from this frame on not hovered anymore
	NK_WIDGET_STATE_HOVERED  = 18 // widget is being hovered
	NK_WIDGET_STATE_ACTIVE   = 34
)

// =============================================================================
//
//                                  TEXT
//
// =============================================================================
const ( /* nuklear.h:3090:1: */
	NK_TEXT_ALIGN_LEFT     = 1
	NK_TEXT_ALIGN_CENTERED = 2
	NK_TEXT_ALIGN_RIGHT    = 4
	NK_TEXT_ALIGN_TOP      = 8
	NK_TEXT_ALIGN_MIDDLE   = 16
	NK_TEXT_ALIGN_BOTTOM   = 32
)
const ( /* nuklear.h:3098:1: */
	NK_TEXT_LEFT     = 17
	NK_TEXT_CENTERED = 18
	NK_TEXT_RIGHT    = 20
)

// =============================================================================
//
//                                  TEXT EDIT
//
// =============================================================================
const ( /* nuklear.h:3433:1: */
	NK_EDIT_DEFAULT              = 0
	NK_EDIT_READ_ONLY            = 1
	NK_EDIT_AUTO_SELECT          = 2
	NK_EDIT_SIG_ENTER            = 4
	NK_EDIT_ALLOW_TAB            = 8
	NK_EDIT_NO_CURSOR            = 16
	NK_EDIT_SELECTABLE           = 32
	NK_EDIT_CLIPBOARD            = 64
	NK_EDIT_CTRL_ENTER_NEWLINE   = 128
	NK_EDIT_NO_HORIZONTAL_SCROLL = 256
	NK_EDIT_ALWAYS_INSERT_MODE   = 512
	NK_EDIT_MULTILINE            = 1024
	NK_EDIT_GOTO_END_ON_ACTIVATE = 2048
)
const ( /* nuklear.h:3448:1: */
	NK_EDIT_SIMPLE = 512
	NK_EDIT_FIELD  = 608
	NK_EDIT_BOX    = 1640
	NK_EDIT_EDITOR = 1128
)
const ( /* nuklear.h:3454:1: */
	NK_EDIT_ACTIVE      = 1 // edit widget is currently being modified
	NK_EDIT_INACTIVE    = 2 // edit widget is not active and is not being modified
	NK_EDIT_ACTIVATED   = 4 // edit widget went from state inactive to state active
	NK_EDIT_DEACTIVATED = 8 // edit widget went from state active to state inactive
	NK_EDIT_COMMITED    = 16
)

// =============================================================================
//
//                                  STYLE
//
// =============================================================================
const ( /* nuklear.h:3579:1: */
	NK_COLOR_TEXT                    = 0
	NK_COLOR_WINDOW                  = 1
	NK_COLOR_HEADER                  = 2
	NK_COLOR_BORDER                  = 3
	NK_COLOR_BUTTON                  = 4
	NK_COLOR_BUTTON_HOVER            = 5
	NK_COLOR_BUTTON_ACTIVE           = 6
	NK_COLOR_TOGGLE                  = 7
	NK_COLOR_TOGGLE_HOVER            = 8
	NK_COLOR_TOGGLE_CURSOR           = 9
	NK_COLOR_SELECT                  = 10
	NK_COLOR_SELECT_ACTIVE           = 11
	NK_COLOR_SLIDER                  = 12
	NK_COLOR_SLIDER_CURSOR           = 13
	NK_COLOR_SLIDER_CURSOR_HOVER     = 14
	NK_COLOR_SLIDER_CURSOR_ACTIVE    = 15
	NK_COLOR_PROPERTY                = 16
	NK_COLOR_EDIT                    = 17
	NK_COLOR_EDIT_CURSOR             = 18
	NK_COLOR_COMBO                   = 19
	NK_COLOR_CHART                   = 20
	NK_COLOR_CHART_COLOR             = 21
	NK_COLOR_CHART_COLOR_HIGHLIGHT   = 22
	NK_COLOR_SCROLLBAR               = 23
	NK_COLOR_SCROLLBAR_CURSOR        = 24
	NK_COLOR_SCROLLBAR_CURSOR_HOVER  = 25
	NK_COLOR_SCROLLBAR_CURSOR_ACTIVE = 26
	NK_COLOR_TAB_HEADER              = 27
	NK_COLOR_COUNT                   = 28
)
const ( /* nuklear.h:3610:1: */
	NK_CURSOR_ARROW                      = 0
	NK_CURSOR_TEXT                       = 1
	NK_CURSOR_MOVE                       = 2
	NK_CURSOR_RESIZE_VERTICAL            = 3
	NK_CURSOR_RESIZE_HORIZONTAL          = 4
	NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT = 5
	NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT = 6
	NK_CURSOR_COUNT                      = 7
)

const ( /* nuklear.h:3951:1: */
	NK_COORD_UV    = 0 // texture coordinates inside font glyphs are clamped between 0-1
	NK_COORD_PIXEL = 1
)

const ( /* nuklear.h:4025:1: */
	NK_FONT_ATLAS_ALPHA8 = 0
	NK_FONT_ATLAS_RGBA32 = 1
)

const ( /* nuklear.h:4122:1: */
	NK_BUFFER_FIXED   = 0
	NK_BUFFER_DYNAMIC = 1
)

const ( /* nuklear.h:4127:1: */
	NK_BUFFER_FRONT = 0
	NK_BUFFER_BACK  = 1
	NK_BUFFER_MAX   = 2
)

const ( /* nuklear.h:4290:1: */
	NK_TEXT_EDIT_SINGLE_LINE = 0
	NK_TEXT_EDIT_MULTI_LINE  = 1
)

const ( /* nuklear.h:4295:1: */
	NK_TEXT_EDIT_MODE_VIEW    = 0
	NK_TEXT_EDIT_MODE_INSERT  = 1
	NK_TEXT_EDIT_MODE_REPLACE = 2
)

// ===============================================================
//
//                          DRAWING
//
// ===============================================================
//  This library was designed to be render backend agnostic so it does
//     not draw anything to screen. Instead all drawn shapes, widgets
//     are made of, are buffered into memory and make up a command queue.
//     Each frame therefore fills the command buffer with draw commands
//     that then need to be executed by the user and his own render backend.
//     After that the command buffer needs to be cleared and a new frame can be
//     started. It is probably important to note that the command buffer is the main
//     drawing API and the optional vertex buffer API only takes this format and
//     converts it into a hardware accessible format.
//
//     To use the command queue to draw your own widgets you can access the
//     command buffer of each window by calling `nk_window_get_canvas` after
//     previously having called `nk_begin`:
//
//         void draw_red_rectangle_widget(struct nk_context *ctx)
//         {
//             struct nk_command_buffer *canvas;
//             struct nk_input *input = &ctx->input;
//             canvas = nk_window_get_canvas(ctx);
//
//             struct nk_rect space;
//             enum nk_widget_layout_states state;
//             state = nk_widget(&space, ctx);
//             if (!state) return;
//
//             if (state != NK_WIDGET_ROM)
//                 update_your_widget_by_user_input(...);
//             nk_fill_rect(canvas, space, 0, nk_rgb(255,0,0));
//         }
//
//         if (nk_begin(...)) {
//             nk_layout_row_dynamic(ctx, 25, 1);
//             draw_red_rectangle_widget(ctx);
//         }
//         nk_end(..)
//
//     Important to know if you want to create your own widgets is the `nk_widget`
//     call. It allocates space on the panel reserved for this widget to be used,
//     but also returns the state of the widget space. If your widget is not seen and does
//     not have to be updated it is '0' and you can just return. If it only has
//     to be drawn the state will be `NK_WIDGET_ROM` otherwise you can do both
//     update and draw your widget. The reason for separating is to only draw and
//     update what is actually necessary which is crucial for performance.
const ( /* nuklear.h:4395:1: */
	NK_COMMAND_NOP              = 0
	NK_COMMAND_SCISSOR          = 1
	NK_COMMAND_LINE             = 2
	NK_COMMAND_CURVE            = 3
	NK_COMMAND_RECT             = 4
	NK_COMMAND_RECT_FILLED      = 5
	NK_COMMAND_RECT_MULTI_COLOR = 6
	NK_COMMAND_CIRCLE           = 7
	NK_COMMAND_CIRCLE_FILLED    = 8
	NK_COMMAND_ARC              = 9
	NK_COMMAND_ARC_FILLED       = 10
	NK_COMMAND_TRIANGLE         = 11
	NK_COMMAND_TRIANGLE_FILLED  = 12
	NK_COMMAND_POLYGON          = 13
	NK_COMMAND_POLYGON_FILLED   = 14
	NK_COMMAND_POLYLINE         = 15
	NK_COMMAND_TEXT             = 16
	NK_COMMAND_IMAGE            = 17
	NK_COMMAND_CUSTOM           = 18
)

const ( /* nuklear.h:4578:1: */
	NK_CLIPPING_OFF = 0
	NK_CLIPPING_ON  = 1
)
const ( /* nuklear.h:4691:1: */
	NK_STROKE_OPEN = 0
	// build up path has no connection back to the beginning
	NK_STROKE_CLOSED = 1
)

const ( /* nuklear.h:4698:1: */
	NK_VERTEX_POSITION        = 0
	NK_VERTEX_COLOR           = 1
	NK_VERTEX_TEXCOORD        = 2
	NK_VERTEX_ATTRIBUTE_COUNT = 3
)

const ( /* nuklear.h:4705:1: */
	NK_FORMAT_SCHAR  = 0
	NK_FORMAT_SSHORT = 1
	NK_FORMAT_SINT   = 2
	NK_FORMAT_UCHAR  = 3
	NK_FORMAT_USHORT = 4
	NK_FORMAT_UINT   = 5
	NK_FORMAT_FLOAT  = 6
	NK_FORMAT_DOUBLE = 7

	NK_FORMAT_COLOR_BEGIN = 8
	NK_FORMAT_R8G8B8      = 8
	NK_FORMAT_R16G15B16   = 9
	NK_FORMAT_R32G32B32   = 10

	NK_FORMAT_R8G8B8A8            = 11
	NK_FORMAT_B8G8R8A8            = 12
	NK_FORMAT_R16G15B16A16        = 13
	NK_FORMAT_R32G32B32A32        = 14
	NK_FORMAT_R32G32B32A32_FLOAT  = 15
	NK_FORMAT_R32G32B32A32_DOUBLE = 16

	NK_FORMAT_RGB32     = 17
	NK_FORMAT_RGBA32    = 18
	NK_FORMAT_COLOR_END = 18
	NK_FORMAT_COUNT     = 19
)

const ( /* nuklear.h:474:1: */
	Nk_false = 0
	Nk_true  = 1
)

// ===============================================================
//
//                          GUI
//
// ===============================================================
const ( /* nuklear.h:4826:1: */
	NK_STYLE_ITEM_COLOR = 0
	NK_STYLE_ITEM_IMAGE = 1
)

const ( /* nuklear.h:487:1: */
	NK_UP    = 0
	NK_RIGHT = 1
	NK_DOWN  = 2
	NK_LEFT  = 3
)
const ( /* nuklear.h:488:1: */
	NK_BUTTON_DEFAULT  = 0
	NK_BUTTON_REPEATER = 1
)
const ( /* nuklear.h:489:1: */
	NK_FIXED      = 0
	NK_MODIFIABLE = 1
)
const ( /* nuklear.h:490:1: */
	NK_VERTICAL   = 0
	NK_HORIZONTAL = 1
)
const ( /* nuklear.h:491:1: */
	NK_MINIMIZED = 0
	NK_MAXIMIZED = 1
)
const ( /* nuklear.h:492:1: */
	NK_HIDDEN = 0
	NK_SHOWN  = 1
)
const ( /* nuklear.h:493:1: */
	NK_CHART_LINES  = 0
	NK_CHART_COLUMN = 1
	NK_CHART_MAX    = 2
)
const ( /* nuklear.h:494:1: */
	NK_CHART_HOVERING = 1
	NK_CHART_CLICKED  = 2
)
const ( /* nuklear.h:495:1: */
	NK_RGB  = 0
	NK_RGBA = 1
)
const ( /* nuklear.h:496:1: */
	NK_POPUP_STATIC  = 0
	NK_POPUP_DYNAMIC = 1
)
const ( /* nuklear.h:497:1: */
	NK_DYNAMIC = 0
	NK_STATIC  = 1
)
const ( /* nuklear.h:498:1: */
	NK_TREE_NODE = 0
	NK_TREE_TAB  = 1
)
const ( /* nuklear.h:511:1: */
	NK_SYMBOL_NONE           = 0
	NK_SYMBOL_X              = 1
	NK_SYMBOL_UNDERSCORE     = 2
	NK_SYMBOL_CIRCLE_SOLID   = 3
	NK_SYMBOL_CIRCLE_OUTLINE = 4
	NK_SYMBOL_RECT_SOLID     = 5
	NK_SYMBOL_RECT_OUTLINE   = 6
	NK_SYMBOL_TRIANGLE_UP    = 7
	NK_SYMBOL_TRIANGLE_DOWN  = 8
	NK_SYMBOL_TRIANGLE_LEFT  = 9
	NK_SYMBOL_TRIANGLE_RIGHT = 10
	NK_SYMBOL_PLUS           = 11
	NK_SYMBOL_MINUS          = 12
	NK_SYMBOL_MAX            = 13
)

const ( /* nuklear.h:5167:1: */
	NK_HEADER_LEFT  = 0
	NK_HEADER_RIGHT = 1
)

// ==============================================================
//                          PANEL
// =============================================================

const ( /* nuklear.h:5273:1: */
	NK_PANEL_NONE       = 0
	NK_PANEL_WINDOW     = 1
	NK_PANEL_GROUP      = 2
	NK_PANEL_POPUP      = 4
	NK_PANEL_CONTEXTUAL = 16
	NK_PANEL_COMBO      = 32
	NK_PANEL_MENU       = 64
	NK_PANEL_TOOLTIP    = 128
)
const ( /* nuklear.h:5283:1: */
	NK_PANEL_SET_NONBLOCK = 240
	NK_PANEL_SET_POPUP    = 244
	NK_PANEL_SET_SUB      = 246
)

const ( /* nuklear.h:5305:1: */
	NK_LAYOUT_DYNAMIC_FIXED = 0
	NK_LAYOUT_DYNAMIC_ROW   = 1
	NK_LAYOUT_DYNAMIC_FREE  = 2
	NK_LAYOUT_DYNAMIC       = 3
	NK_LAYOUT_STATIC_FIXED  = 4
	NK_LAYOUT_STATIC_ROW    = 5
	NK_LAYOUT_STATIC_FREE   = 6
	NK_LAYOUT_STATIC        = 7
	NK_LAYOUT_TEMPLATE      = 8
	NK_LAYOUT_COUNT         = 9
)
const ( /* nuklear.h:5373:1: */
	NK_WINDOW_PRIVATE = 2048
	NK_WINDOW_DYNAMIC = 2048
	// special window type growing up in height while being filled to a certain maximum height
	NK_WINDOW_ROM = 4096
	// sets window widgets into a read only mode and does not allow input changes
	NK_WINDOW_NOT_INTERACTIVE = 5120
	// prevents all interaction caused by input to either window or widgets inside
	NK_WINDOW_HIDDEN = 8192
	// Hides window and stops any window interaction and drawing
	NK_WINDOW_CLOSED = 16384
	// Directly closes and frees the window at the end of the frame
	NK_WINDOW_MINIMIZED = 32768
	// marks the window as minimized
	NK_WINDOW_REMOVE_ROM = 65536
)

// util
const ( /* nuklear.h:5822:1: */
	NK_DO_NOT_STOP_ON_NEW_LINE = 0
	NK_STOP_ON_NEW_LINE        = 1
)

// window
const ( /* nuklear.h:5880:1: */
	NK_INSERT_BACK  = 0 // inserts window into the back of list (front of screen)
	NK_INSERT_FRONT = 1
)

// toggle
const ( /* nuklear.h:5958:1: */
	NK_TOGGLE_CHECK  = 0
	NK_TOGGLE_OPTION = 1
)

// property
const ( /* nuklear.h:5998:1: */
	NK_PROPERTY_DEFAULT = 0
	NK_PROPERTY_EDIT    = 1
	NK_PROPERTY_DRAG    = 2
)
const ( /* nuklear.h:6003:1: */
	NK_FILTER_INT   = 0
	NK_FILTER_FLOAT = 1
)
const ( /* nuklear.h:6007:1: */
	NK_PROPERTY_INT    = 0
	NK_PROPERTY_FLOAT  = 1
	NK_PROPERTY_DOUBLE = 2
)

// =============================================================================
//
//                                  INPUT
//
// =============================================================================
///// ### Input
// /// The input API is responsible for holding the current input state composed of
// /// mouse, key and text input states.
// /// It is worth noting that no direct OS or window handling is done in nuklear.
// /// Instead all input state has to be provided by platform specific code. This on one hand
// /// expects more work from the user and complicates usage but on the other hand
// /// provides simple abstraction over a big number of platforms, libraries and other
// /// already provided functionality.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// nk_input_begin(&ctx);
// /// while (GetEvent(&evt)) {
// ///     if (evt.type == MOUSE_MOVE)
// ///         nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
// ///     else if (evt.type == [...]) {
// ///         // [...]
// ///     }
// /// } nk_input_end(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// #### Usage
// /// Input state needs to be provided to nuklear by first calling `nk_input_begin`
// /// which resets internal state like delta mouse position and button transistions.
// /// After `nk_input_begin` all current input state needs to be provided. This includes
// /// mouse motion, button and key pressed and released, text input and scrolling.
// /// Both event- or state-based input handling are supported by this API
// /// and should work without problems. Finally after all input state has been
// /// mirrored `nk_input_end` needs to be called to finish input process.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// struct nk_context ctx;
// /// nk_init_xxx(&ctx, ...);
// /// while (1) {
// ///     Event evt;
// ///     nk_input_begin(&ctx);
// ///     while (GetEvent(&evt)) {
// ///         if (evt.type == MOUSE_MOVE)
// ///             nk_input_motion(&ctx, evt.motion.x, evt.motion.y);
// ///         else if (evt.type == [...]) {
// ///             // [...]
// ///         }
// ///     }
// ///     nk_input_end(&ctx);
// ///     // [...]
// ///     nk_clear(&ctx);
// /// } nk_free(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// #### Reference
// /// Function            | Description
// /// --------------------|-------------------------------------------------------
// /// __nk_input_begin__  | Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls
// /// __nk_input_motion__ | Mirrors mouse cursor position
// /// __nk_input_key__    | Mirrors key state with either pressed or released
// /// __nk_input_button__ | Mirrors mouse button state with either pressed or released
// /// __nk_input_scroll__ | Mirrors mouse scroll values
// /// __nk_input_char__   | Adds a single ASCII text character into an internal text buffer
// /// __nk_input_glyph__  | Adds a single multi-byte UTF-8 character into an internal text buffer
// /// __nk_input_unicode__| Adds a single unicode rune into an internal text buffer
// /// __nk_input_end__    | Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` function referenced above after this call
const ( /* nuklear.h:753:1: */
	NK_KEY_NONE      = 0
	NK_KEY_SHIFT     = 1
	NK_KEY_CTRL      = 2
	NK_KEY_DEL       = 3
	NK_KEY_ENTER     = 4
	NK_KEY_TAB       = 5
	NK_KEY_BACKSPACE = 6
	NK_KEY_COPY      = 7
	NK_KEY_CUT       = 8
	NK_KEY_PASTE     = 9
	NK_KEY_UP        = 10
	NK_KEY_DOWN      = 11
	NK_KEY_LEFT      = 12
	NK_KEY_RIGHT     = 13
	// Shortcuts: text field
	NK_KEY_TEXT_INSERT_MODE  = 14
	NK_KEY_TEXT_REPLACE_MODE = 15
	NK_KEY_TEXT_RESET_MODE   = 16
	NK_KEY_TEXT_LINE_START   = 17
	NK_KEY_TEXT_LINE_END     = 18
	NK_KEY_TEXT_START        = 19
	NK_KEY_TEXT_END          = 20
	NK_KEY_TEXT_UNDO         = 21
	NK_KEY_TEXT_REDO         = 22
	NK_KEY_TEXT_SELECT_ALL   = 23
	NK_KEY_TEXT_WORD_LEFT    = 24
	NK_KEY_TEXT_WORD_RIGHT   = 25
	// Shortcuts: scrollbar
	NK_KEY_SCROLL_START = 26
	NK_KEY_SCROLL_END   = 27
	NK_KEY_SCROLL_DOWN  = 28
	NK_KEY_SCROLL_UP    = 29
	NK_KEY_MAX          = 30
)
const ( /* nuklear.h:788:1: */
	NK_BUTTON_LEFT   = 0
	NK_BUTTON_MIDDLE = 1
	NK_BUTTON_RIGHT  = 2
	NK_BUTTON_DOUBLE = 3
	NK_BUTTON_MAX    = 4
)

type Ptrdiff_t = int32 /* <builtin>:3:26 */

type Size_t = uint32 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__int128_t = struct {
	Lo int32
	Hi int32
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type X__uint128_t = struct {
	Lo uint32
	Hi uint32
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

// #define NK_INCLUDE_STANDARD_IO

//
// /// # Nuklear
// /// ![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)
// ///
// /// ## Contents
// /// 1. About section
// /// 2. Highlights section
// /// 3. Features section
// /// 4. Usage section
// ///     1. Flags section
// ///     2. Constants section
// ///     3. Dependencies section
// /// 5. Example section
// /// 6. API section
// ///     1. Context section
// ///     2. Input section
// ///     3. Drawing section
// ///     4. Window section
// ///     5. Layouting section
// ///     6. Groups section
// ///     7. Tree section
// ///     8. Properties section
// /// 7. License section
// /// 8. Changelog section
// /// 9. Gallery section
// /// 10. Credits section
// ///
// /// ## About
// /// This is a minimal state immediate mode graphical user interface toolkit
// /// written in ANSI C and licensed under public domain. It was designed as a simple
// /// embeddable user interface for application and does not have any dependencies,
// /// a default renderbackend or OS window and input handling but instead provides a very modular
// /// library approach by using simple input state for input and draw
// /// commands describing primitive shapes as output. So instead of providing a
// /// layered library that tries to abstract over a number of platform and
// /// render backends it only focuses on the actual UI.
// ///
// /// ## Highlights
// /// - Graphical user interface toolkit
// /// - Single header library
// /// - Written in C89 (a.k.a. ANSI C or ISO C90)
// /// - Small codebase (~18kLOC)
// /// - Focus on portability, efficiency and simplicity
// /// - No dependencies (not even the standard library if not wanted)
// /// - Fully skinnable and customizable
// /// - Low memory footprint with total memory control if needed or wanted
// /// - UTF-8 support
// /// - No global or hidden state
// /// - Customizable library modules (you can compile and use only what you need)
// /// - Optional font baker and vertex buffer output
// ///
// /// ## Features
// /// - Absolutely no platform dependent code
// /// - Memory management control ranging from/to
// ///     - Ease of use by allocating everything from standard library
// ///     - Control every byte of memory inside the library
// /// - Font handling control ranging from/to
// ///     - Use your own font implementation for everything
// ///     - Use this libraries internal font baking and handling API
// /// - Drawing output control ranging from/to
// ///     - Simple shapes for more high level APIs which already have drawing capabilities
// ///     - Hardware accessible anti-aliased vertex buffer output
// /// - Customizable colors and properties ranging from/to
// ///     - Simple changes to color by filling a simple color table
// ///     - Complete control with ability to use skinning to decorate widgets
// /// - Bendable UI library with widget ranging from/to
// ///     - Basic widgets like buttons, checkboxes, slider, ...
// ///     - Advanced widget like abstract comboboxes, contextual menus,...
// /// - Compile time configuration to only compile what you need
// ///     - Subset which can be used if you do not want to link or use the standard library
// /// - Can be easily modified to only update on user input instead of frame updates
// ///
// /// ## Usage
// /// This library is self contained in one single header file and can be used either
// /// in header only mode or in implementation mode. The header only mode is used
// /// by default when included and allows including this header in other headers
// /// and does not contain the actual implementation. <br /><br />
// ///
// /// The implementation mode requires to define  the preprocessor macro
// /// NK_IMPLEMENTATION in *one* .c/.cpp file before #includeing this file, e.g.:
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C
// ///     #define NK_IMPLEMENTATION
// ///     #include "nuklear.h"
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// Also optionally define the symbols listed in the section "OPTIONAL DEFINES"
// /// below in header and implementation mode if you want to use additional functionality
// /// or need more control over the library.
// ///
// /// !!! WARNING
// ///     Every time nuklear is included define the same compiler flags. This very important not doing so could lead to compiler errors or even worse stack corruptions.
// ///
// /// ### Flags
// /// Flag                            | Description
// /// --------------------------------|------------------------------------------
// /// NK_PRIVATE                      | If defined declares all functions as static, so they can only be accessed inside the file that contains the implementation
// /// NK_INCLUDE_FIXED_TYPES          | If defined it will include header `<stdint.h>` for fixed sized types otherwise nuklear tries to select the correct type. If that fails it will throw a compiler error and you have to select the correct types yourself.
// /// NK_INCLUDE_DEFAULT_ALLOCATOR    | If defined it will include header `<stdlib.h>` and provide additional functions to use this library without caring for memory allocation control and therefore ease memory management.
// /// NK_INCLUDE_STANDARD_IO          | If defined it will include header `<stdio.h>` and provide additional functions depending on file loading.
// /// NK_INCLUDE_STANDARD_VARARGS     | If defined it will include header <stdarg.h> and provide additional functions depending on file loading.
// /// NK_INCLUDE_STANDARD_BOOL        | If defined it will include header `<stdbool.h>` for nk_bool otherwise nuklear defines nk_bool as int.
// /// NK_INCLUDE_VERTEX_BUFFER_OUTPUT | Defining this adds a vertex draw command list backend to this library, which allows you to convert queue commands into vertex draw commands. This is mainly if you need a hardware accessible format for OpenGL, DirectX, Vulkan, Metal,...
// /// NK_INCLUDE_FONT_BAKING          | Defining this adds `stb_truetype` and `stb_rect_pack` implementation to this library and provides font baking and rendering. If you already have font handling or do not want to use this font handler you don't have to define it.
// /// NK_INCLUDE_DEFAULT_FONT         | Defining this adds the default font: ProggyClean.ttf into this library which can be loaded into a font atlas and allows using this library without having a truetype font
// /// NK_INCLUDE_COMMAND_USERDATA     | Defining this adds a userdata pointer into each command. Can be useful for example if you want to provide custom shaders depending on the used widget. Can be combined with the style structures.
// /// NK_BUTTON_TRIGGER_ON_RELEASE    | Different platforms require button clicks occurring either on buttons being pressed (up to down) or released (down to up). By default this library will react on buttons being pressed, but if you define this it will only trigger if a button is released.
// /// NK_ZERO_COMMAND_MEMORY          | Defining this will zero out memory for each drawing command added to a drawing queue (inside nk_command_buffer_push). Zeroing command memory is very useful for fast checking (using memcmp) if command buffers are equal and avoid drawing frames when nothing on screen has changed since previous frame.
// /// NK_UINT_DRAW_INDEX              | Defining this will set the size of vertex index elements when using NK_VERTEX_BUFFER_OUTPUT to 32bit instead of the default of 16bit
// /// NK_KEYSTATE_BASED_INPUT         | Define this if your backend uses key state for each frame rather than key press/release events
// ///
// /// !!! WARNING
// ///     The following flags will pull in the standard C library:
// ///     - NK_INCLUDE_DEFAULT_ALLOCATOR
// ///     - NK_INCLUDE_STANDARD_IO
// ///     - NK_INCLUDE_STANDARD_VARARGS
// ///
// /// !!! WARNING
// ///     The following flags if defined need to be defined for both header and implementation:
// ///     - NK_INCLUDE_FIXED_TYPES
// ///     - NK_INCLUDE_DEFAULT_ALLOCATOR
// ///     - NK_INCLUDE_STANDARD_VARARGS
// ///     - NK_INCLUDE_STANDARD_BOOL
// ///     - NK_INCLUDE_VERTEX_BUFFER_OUTPUT
// ///     - NK_INCLUDE_FONT_BAKING
// ///     - NK_INCLUDE_DEFAULT_FONT
// ///     - NK_INCLUDE_STANDARD_VARARGS
// ///     - NK_INCLUDE_COMMAND_USERDATA
// ///     - NK_UINT_DRAW_INDEX
// ///
// /// ### Constants
// /// Define                          | Description
// /// --------------------------------|---------------------------------------
// /// NK_BUFFER_DEFAULT_INITIAL_SIZE  | Initial buffer size allocated by all buffers while using the default allocator functions included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. If you don't want to allocate the default 4k memory then redefine it.
// /// NK_MAX_NUMBER_BUFFER            | Maximum buffer size for the conversion buffer between float and string Under normal circumstances this should be more than sufficient.
// /// NK_INPUT_MAX                    | Defines the max number of bytes which can be added as text input in one frame. Under normal circumstances this should be more than sufficient.
// ///
// /// !!! WARNING
// ///     The following constants if defined need to be defined for both header and implementation:
// ///     - NK_MAX_NUMBER_BUFFER
// ///     - NK_BUFFER_DEFAULT_INITIAL_SIZE
// ///     - NK_INPUT_MAX
// ///
// /// ### Dependencies
// /// Function    | Description
// /// ------------|---------------------------------------------------------------
// /// NK_ASSERT   | If you don't define this, nuklear will use <assert.h> with assert().
// /// NK_MEMSET   | You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version.
// /// NK_MEMCPY   | You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version.
// /// NK_SQRT     | You can define this to 'sqrt' or your own sqrt implementation replacement. If not nuklear will use its own slow and not highly accurate version.
// /// NK_SIN      | You can define this to 'sinf' or your own sine implementation replacement. If not nuklear will use its own approximation implementation.
// /// NK_COS      | You can define this to 'cosf' or your own cosine implementation replacement. If not nuklear will use its own approximation implementation.
// /// NK_STRTOD   | You can define this to `strtod` or your own string to double conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
// /// NK_DTOA     | You can define this to `dtoa` or your own double to string conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).
// /// NK_VSNPRINTF| If you define `NK_INCLUDE_STANDARD_VARARGS` as well as `NK_INCLUDE_STANDARD_IO` and want to be safe define this to `vsnprintf` on compilers supporting later versions of C or C++. By default nuklear will check for your stdlib version in C as well as compiler version in C++. if `vsnprintf` is available it will define it to `vsnprintf` directly. If not defined and if you have older versions of C or C++ it will be defined to `vsprintf` which is unsafe.
// ///
// /// !!! WARNING
// ///     The following dependencies will pull in the standard C library if not redefined:
// ///     - NK_ASSERT
// ///
// /// !!! WARNING
// ///     The following dependencies if defined need to be defined for both header and implementation:
// ///     - NK_ASSERT
// ///
// /// !!! WARNING
// ///     The following dependencies if defined need to be defined only for the implementation part:
// ///     - NK_MEMSET
// ///     - NK_MEMCPY
// ///     - NK_SQRT
// ///     - NK_SIN
// ///     - NK_COS
// ///     - NK_STRTOD
// ///     - NK_DTOA
// ///     - NK_VSNPRINTF
// ///
// /// ## Example
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// // init gui state
// /// enum {EASY, HARD};
// /// static int op = EASY;
// /// static float value = 0.6f;
// /// static int i =  20;
// /// struct nk_context ctx;
// ///
// /// nk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);
// /// if (nk_begin(&ctx, "Show", nk_rect(50, 50, 220, 220),
// ///     NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {
// ///     // fixed widget pixel width
// ///     nk_layout_row_static(&ctx, 30, 80, 1);
// ///     if (nk_button_label(&ctx, "button")) {
// ///         // event handling
// ///     }
// ///
// ///     // fixed widget window ratio width
// ///     nk_layout_row_dynamic(&ctx, 30, 2);
// ///     if (nk_option_label(&ctx, "easy", op == EASY)) op = EASY;
// ///     if (nk_option_label(&ctx, "hard", op == HARD)) op = HARD;
// ///
// ///     // custom widget pixel width
// ///     nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);
// ///     {
// ///         nk_layout_row_push(&ctx, 50);
// ///         nk_label(&ctx, "Volume:", NK_TEXT_LEFT);
// ///         nk_layout_row_push(&ctx, 110);
// ///         nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);
// ///     }
// ///     nk_layout_row_end(&ctx);
// /// }
// /// nk_end(&ctx);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// ![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)
// ///
// /// ## API
// ///

// ==============================================================
//
//                          CONSTANTS
//
// ===============================================================
// ==============================================================
//
//                          HELPER
//
// ===============================================================

// ===============================================================
//
//                          BASIC
//
// ===============================================================
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    anymore supported.

// Some user header file might have defined this before.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this works only with
//    gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// Compilers that are not clang may object to
//        #if defined __clang__ && __has_extension(...)
//    even though they do not need to evaluate the right-hand side of the &&.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC has various useful declarations that can be made with the
//    `__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonull function attribute allows to mark pointer parameters which
//    must not be NULL.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 supports this.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For others, time size is word size.

// Convenience types.
type X__u_char = uint8   /* types.h:31:23 */
type X__u_short = uint16 /* types.h:32:28 */
type X__u_int = uint32   /* types.h:33:22 */
type X__u_long = uint32  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type X__int8_t = int8     /* types.h:37:21 */
type X__uint8_t = uint8   /* types.h:38:23 */
type X__int16_t = int16   /* types.h:39:26 */
type X__uint16_t = uint16 /* types.h:40:28 */
type X__int32_t = int32   /* types.h:41:20 */
type X__uint32_t = uint32 /* types.h:42:22 */
type X__int64_t = int32   /* types.h:44:25 */
type X__uint64_t = uint32 /* types.h:45:27 */

// Smallest types with at least a given width.
type X__int_least8_t = X__int8_t     /* types.h:52:18 */
type X__uint_least8_t = X__uint8_t   /* types.h:53:19 */
type X__int_least16_t = X__int16_t   /* types.h:54:19 */
type X__uint_least16_t = X__uint16_t /* types.h:55:20 */
type X__int_least32_t = X__int32_t   /* types.h:56:19 */
type X__uint_least32_t = X__uint32_t /* types.h:57:20 */
type X__int_least64_t = X__int64_t   /* types.h:58:19 */
type X__uint_least64_t = X__uint64_t /* types.h:59:20 */

// quad_t is also 64 bits.
type X__quad_t = int32    /* types.h:63:18 */
type X__u_quad_t = uint32 /* types.h:64:27 */

// Largest integral types.
type X__intmax_t = int32   /* types.h:72:18 */
type X__uintmax_t = uint32 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type X__dev_t = uint32                     /* types.h:145:25 */ // Type of device numbers.
type X__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type X__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type X__ino_t = uint32                     /* types.h:148:25 */ // Type of file serial numbers.
type X__ino64_t = uint32                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type X__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type X__nlink_t = uint32                   /* types.h:151:27 */ // Type of file link counts.
type X__off_t = int32                      /* types.h:152:25 */ // Type of file sizes and offsets.
type X__off64_t = int32                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type X__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type X__fsid_t = struct{ X__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type X__clock_t = int32                    /* types.h:156:27 */ // Type of CPU usage counts.
type X__rlim_t = uint32                    /* types.h:157:26 */ // Type for resource measurement.
type X__rlim64_t = uint32                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type X__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type X__time_t = int32                     /* types.h:160:26 */ // Seconds since the Epoch.
type X__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type X__suseconds_t = int32                /* types.h:162:31 */ // Signed count of microseconds.

type X__daddr_t = int32 /* types.h:164:27 */ // The type of a disk address.
type X__key_t = int32   /* types.h:165:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type X__clockid_t = int32 /* types.h:168:29 */

// Timer ID returned by `timer_create'.
type X__timer_t = uintptr /* types.h:171:12 */

// Type to represent block size.
type X__blksize_t = int32 /* types.h:174:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type X__blkcnt_t = int32   /* types.h:179:28 */
type X__blkcnt64_t = int32 /* types.h:180:30 */

// Type to count file system blocks.
type X__fsblkcnt_t = uint32   /* types.h:183:30 */
type X__fsblkcnt64_t = uint32 /* types.h:184:32 */

// Type to count file system nodes.
type X__fsfilcnt_t = uint32   /* types.h:187:30 */
type X__fsfilcnt64_t = uint32 /* types.h:188:32 */

// Type of miscellaneous file system fields.
type X__fsword_t = int32 /* types.h:191:28 */

type X__ssize_t = int32 /* types.h:193:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type X__syscall_slong_t = int32 /* types.h:196:33 */
// Unsigned long type used in system calls.
type X__syscall_ulong_t = uint32 /* types.h:198:33 */

// These few don't really vary by system, they always correspond
//    to one of the other defined types.
type X__loff_t = X__off64_t /* types.h:202:19 */ // Type of file sizes and offsets (LFS).
type X__caddr_t = uintptr   /* types.h:203:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type X__intptr_t = int32 /* types.h:206:25 */

// Duplicate info from sys/socket.h.
type X__socklen_t = uint32 /* types.h:209:23 */

// C99: An integer type that can be accessed as an atomic entity,
//    even in the presence of asynchronous interrupts.
//    It is not currently necessary for this to be machine-specific.
type X__sig_atomic_t = int32 /* types.h:214:13 */

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// wchar_t type related definitions.
//    Copyright (C) 2000-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Int8_t = X__int8_t   /* stdint-intn.h:24:18 */
type Int16_t = X__int16_t /* stdint-intn.h:25:19 */
type Int32_t = X__int32_t /* stdint-intn.h:26:19 */
type Int64_t = X__int64_t /* stdint-intn.h:27:19 */

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Uint8_t = X__uint8_t   /* stdint-uintn.h:24:19 */
type Uint16_t = X__uint16_t /* stdint-uintn.h:25:20 */
type Uint32_t = X__uint32_t /* stdint-uintn.h:26:20 */
type Uint64_t = X__uint64_t /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Int_least8_t = X__int_least8_t   /* stdint.h:43:24 */
type Int_least16_t = X__int_least16_t /* stdint.h:44:25 */
type Int_least32_t = X__int_least32_t /* stdint.h:45:25 */
type Int_least64_t = X__int_least64_t /* stdint.h:46:25 */

// Unsigned.
type Uint_least8_t = X__uint_least8_t   /* stdint.h:49:25 */
type Uint_least16_t = X__uint_least16_t /* stdint.h:50:26 */
type Uint_least32_t = X__uint_least32_t /* stdint.h:51:26 */
type Uint_least64_t = X__uint_least64_t /* stdint.h:52:26 */

// Fast types.

// Signed.
type Int_fast8_t = int8   /* stdint.h:58:22 */
type Int_fast16_t = int32 /* stdint.h:60:19 */
type Int_fast32_t = int32 /* stdint.h:61:19 */
type Int_fast64_t = int32 /* stdint.h:62:19 */

// Unsigned.
type Uint_fast8_t = uint8   /* stdint.h:71:24 */
type Uint_fast16_t = uint32 /* stdint.h:73:27 */
type Uint_fast32_t = uint32 /* stdint.h:74:27 */
type Uint_fast64_t = uint32 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Intptr_t = int32   /* stdint.h:87:19 */
type Uintptr_t = uint32 /* stdint.h:90:27 */

// Largest integral types.
type Intmax_t = X__intmax_t   /* stdint.h:101:21 */
type Uintmax_t = X__uintmax_t /* stdint.h:102:22 */

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

type Nk_char = Int8_t     /* nuklear.h:410:17 */
type Nk_uchar = Uint8_t   /* nuklear.h:411:18 */
type Nk_byte = Uint8_t    /* nuklear.h:412:18 */
type Nk_short = Int16_t   /* nuklear.h:413:18 */
type Nk_ushort = Uint16_t /* nuklear.h:414:19 */
type Nk_int = Int32_t     /* nuklear.h:415:18 */
type Nk_uint = Uint32_t   /* nuklear.h:416:19 */
type Nk_size = Uintptr_t  /* nuklear.h:417:22 */
type Nk_ptr = Uintptr_t   /* nuklear.h:418:25 */
type Nk_bool = int32      /* nuklear.h:419:17 */

type Nk_hash = Nk_uint  /* nuklear.h:421:17 */
type Nk_flags = Nk_uint /* nuklear.h:422:17 */
type Nk_rune = Nk_uint  /* nuklear.h:423:17 */

// Make sure correct type size:
// This will fire with a negative subscript error if the type sizes
// are set incorrectly by the compiler, and compile out if not
type X_dummy_array428 = [1]int8 /* nuklear.h:428:1 */
type X_dummy_array429 = [1]int8 /* nuklear.h:429:1 */
type X_dummy_array430 = [1]int8 /* nuklear.h:430:1 */
type X_dummy_array431 = [1]int8 /* nuklear.h:431:1 */
type X_dummy_array432 = [1]int8 /* nuklear.h:432:1 */
type X_dummy_array433 = [1]int8 /* nuklear.h:433:1 */
type X_dummy_array434 = [1]int8 /* nuklear.h:434:1 */
type X_dummy_array435 = [1]int8 /* nuklear.h:435:1 */
type X_dummy_array436 = [1]int8 /* nuklear.h:436:1 */
type X_dummy_array440 = [1]int8 /* nuklear.h:440:1 */

// ============================================================================
//
//                                  API
//
// ===========================================================================
type Nk_buffer = struct {
	Marker [2]struct {
		Active Nk_bool
		Offset Nk_size
	}
	Pool struct {
		Userdata Nk_handle
		Alloc    Nk_plugin_alloc
		Free     Nk_plugin_free
	}
	Type   uint32
	Memory struct {
		Ptr  uintptr
		Size Nk_size
	}
	Grow_factor float32
	Allocated   Nk_size
	Needed      Nk_size
	Calls       Nk_size
	Size        Nk_size
} /* nuklear.h:448:1 */

type Nk_allocator = struct {
	Userdata Nk_handle
	Alloc    Nk_plugin_alloc
	Free     Nk_plugin_free
} /* nuklear.h:448:1 */

type Nk_command_buffer = struct {
	Base uintptr
	Clip struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Use_clipping int32
	Userdata     Nk_handle
	Begin        Nk_size
	End          Nk_size
	Last         Nk_size
} /* nuklear.h:450:1 */

type Nk_draw_command = struct {
	Elem_count uint32
	Clip_rect  struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Texture Nk_handle
} /* nuklear.h:451:1 */

type Nk_convert_config = struct {
	Global_alpha         float32
	Line_AA              uint32
	Shape_AA             uint32
	Circle_segment_count uint32
	Arc_segment_count    uint32
	Curve_segment_count  uint32
	Null                 struct {
		Texture Nk_handle
		Uv      struct {
			X float32
			Y float32
		}
	}
	Vertex_layout    uintptr
	Vertex_size      Nk_size
	Vertex_alignment Nk_size
} /* nuklear.h:452:1 */

type Nk_style_item = struct {
	Type uint32
	Data struct {
		Image struct {
			Handle Nk_handle
			W      uint16
			H      uint16
			Region [4]uint16
		}
	}
} /* nuklear.h:453:1 */

type Nk_text_edit = struct {
	Clip struct {
		Userdata Nk_handle
		Paste    Nk_plugin_paste
		Copy     Nk_plugin_copy
	}
	String struct {
		Buffer struct {
			Marker [2]struct {
				Active Nk_bool
				Offset Nk_size
			}
			Pool struct {
				Userdata Nk_handle
				Alloc    Nk_plugin_alloc
				Free     Nk_plugin_free
			}
			Type   uint32
			Memory struct {
				Ptr  uintptr
				Size Nk_size
			}
			Grow_factor float32
			Allocated   Nk_size
			Needed      Nk_size
			Calls       Nk_size
			Size        Nk_size
		}
		Len int32
	}
	Filter    Nk_plugin_filter
	Scrollbar struct {
		X float32
		Y float32
	}
	Cursor                int32
	Select_start          int32
	Select_end            int32
	Mode                  uint8
	Cursor_at_end_of_line uint8
	Initialized           uint8
	Has_preferred_x       uint8
	Single_line           uint8
	Active                uint8
	Padding1              uint8
	_                     [1]byte
	Preferred_x           float32
	Undo                  struct {
		Undo_rec [99]struct {
			Where         int32
			Insert_length int16
			Delete_length int16
			Char_storage  int16
			_             [2]byte
		}
		Undo_char       [999]Nk_rune
		Undo_point      int16
		Redo_point      int16
		Undo_char_point int16
		Redo_char_point int16
	}
} /* nuklear.h:454:1 */

type Nk_draw_list = struct {
	Clip_rect struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Circle_vtx [12]struct {
		X float32
		Y float32
	}
	Config struct {
		Global_alpha         float32
		Line_AA              uint32
		Shape_AA             uint32
		Circle_segment_count uint32
		Arc_segment_count    uint32
		Curve_segment_count  uint32
		Null                 struct {
			Texture Nk_handle
			Uv      struct {
				X float32
				Y float32
			}
		}
		Vertex_layout    uintptr
		Vertex_size      Nk_size
		Vertex_alignment Nk_size
	}
	Buffer        uintptr
	Vertices      uintptr
	Elements      uintptr
	Element_count uint32
	Vertex_count  uint32
	Cmd_count     uint32
	Cmd_offset    Nk_size
	Path_count    uint32
	Path_offset   uint32
	Line_AA       uint32
	Shape_AA      uint32
} /* nuklear.h:455:1 */

type Nk_user_font = struct {
	Userdata Nk_handle
	Height   float32
	Width    Nk_text_width_f
	Query    Nk_query_font_glyph_f
	Texture  Nk_handle
} /* nuklear.h:456:1 */

type Nk_panel = struct {
	Type   uint32
	Flags  Nk_flags
	Bounds struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Offset_x      uintptr
	Offset_y      uintptr
	At_x          float32
	At_y          float32
	Max_x         float32
	Footer_height float32
	Header_height float32
	Border        float32
	Has_scrolling uint32
	Clip          struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Menu struct {
		X      float32
		Y      float32
		W      float32
		H      float32
		Offset struct {
			X Nk_uint
			Y Nk_uint
		}
	}
	Row struct {
		Type        uint32
		Index       int32
		Height      float32
		Min_height  float32
		Columns     int32
		Ratio       uintptr
		Item_width  float32
		Item_height float32
		Item_offset float32
		Filled      float32
		Item        struct {
			X float32
			Y float32
			W float32
			H float32
		}
		Tree_depth int32
		Templates  [16]float32
	}
	Chart struct {
		Slot  int32
		X     float32
		Y     float32
		W     float32
		H     float32
		Slots [4]struct {
			Type  uint32
			Color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Highlight struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Min   float32
			Max   float32
			Range float32
			Count int32
			Last  struct {
				X float32
				Y float32
			}
			Index int32
		}
	}
	Buffer uintptr
	Parent uintptr
} /* nuklear.h:457:1 */

type Nk_context = struct {
	Input struct {
		Keyboard struct {
			Keys [30]struct {
				Down    Nk_bool
				Clicked uint32
			}
			Text     [16]int8
			Text_len int32
		}
		Mouse struct {
			Buttons [4]struct {
				Down        Nk_bool
				Clicked     uint32
				Clicked_pos struct {
					X float32
					Y float32
				}
			}
			Pos struct {
				X float32
				Y float32
			}
			Prev struct {
				X float32
				Y float32
			}
			Delta struct {
				X float32
				Y float32
			}
			Scroll_delta struct {
				X float32
				Y float32
			}
			Grab    uint8
			Grabbed uint8
			Ungrab  uint8
			_       [1]byte
		}
	}
	Style struct {
		Font           uintptr
		Cursors        [7]uintptr
		Cursor_active  uintptr
		Cursor_last    uintptr
		Cursor_visible int32
		Text           struct {
			Color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Padding struct {
				X float32
				Y float32
			}
		}
		Button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Contextual_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Menu_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Option struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Padding        struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Spacing    float32
			Border     float32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Checkbox struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Padding        struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Spacing    float32
			Border     float32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Selectable struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Pressed struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Normal_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Pressed_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_pressed struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_pressed_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Slider struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Bar_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Bar_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Bar_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Bar_filled struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border     float32
			Rounding   float32
			Bar_height float32
			Padding    struct {
				X float32
				Y float32
			}
			Spacing struct {
				X float32
				Y float32
			}
			Cursor_size struct {
				X float32
				Y float32
			}
			Show_buttons int32
			Inc_button   struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Inc_symbol uint32
			Dec_symbol uint32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Progress struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Rounding        float32
			Border          float32
			Cursor_border   float32
			Cursor_rounding float32
			Padding         struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Property struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Sym_left  uint32
			Sym_right uint32
			Border    float32
			Rounding  float32
			Padding   struct {
				X float32
				Y float32
			}
			Edit struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Scrollbar struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Cursor_normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Cursor_hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Cursor_active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Cursor_border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Border          float32
					Rounding        float32
					Border_cursor   float32
					Rounding_cursor float32
					Padding         struct {
						X float32
						Y float32
					}
					Show_buttons int32
					Inc_button   struct {
						Normal struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Hover struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Active struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Border_color struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_background struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_normal struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_hover struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_active struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_alignment Nk_flags
						Border         float32
						Rounding       float32
						Padding        struct {
							X float32
							Y float32
						}
						Image_padding struct {
							X float32
							Y float32
						}
						Touch_padding struct {
							X float32
							Y float32
						}
						Userdata   Nk_handle
						Draw_begin uintptr
						Draw_end   uintptr
					}
					Dec_button struct {
						Normal struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Hover struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Active struct {
							Type uint32
							Data struct {
								Image struct {
									Handle Nk_handle
									W      uint16
									H      uint16
									Region [4]uint16
								}
							}
						}
						Border_color struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_background struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_normal struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_hover struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_active struct {
							R Nk_byte
							G Nk_byte
							B Nk_byte
							A Nk_byte
						}
						Text_alignment Nk_flags
						Border         float32
						Rounding       float32
						Padding        struct {
							X float32
							Y float32
						}
						Image_padding struct {
							X float32
							Y float32
						}
						Touch_padding struct {
							X float32
							Y float32
						}
						Userdata   Nk_handle
						Draw_begin uintptr
						Draw_end   uintptr
					}
					Inc_symbol uint32
					Dec_symbol uint32
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Cursor_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Cursor_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Cursor_text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Cursor_text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Selected_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Selected_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Selected_text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Selected_text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Border         float32
				Rounding       float32
				Cursor_size    float32
				Scrollbar_size struct {
					X float32
					Y float32
				}
				Padding struct {
					X float32
					Y float32
				}
				Row_padding float32
			}
			Inc_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Edit struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Scrollbar struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Cursor_normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Border          float32
				Rounding        float32
				Border_cursor   float32
				Rounding_cursor float32
				Padding         struct {
					X float32
					Y float32
				}
				Show_buttons int32
				Inc_button   struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Dec_button struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Inc_symbol uint32
				Dec_symbol uint32
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Cursor_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border         float32
			Rounding       float32
			Cursor_size    float32
			Scrollbar_size struct {
				X float32
				Y float32
			}
			Padding struct {
				X float32
				Y float32
			}
			Row_padding float32
		}
		Chart struct {
			Background struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border   float32
			Rounding float32
			Padding  struct {
				X float32
				Y float32
			}
		}
		Scrollh struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border          float32
			Rounding        float32
			Border_cursor   float32
			Rounding_cursor float32
			Padding         struct {
				X float32
				Y float32
			}
			Show_buttons int32
			Inc_button   struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Inc_symbol uint32
			Dec_symbol uint32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Scrollv struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border          float32
			Rounding        float32
			Border_cursor   float32
			Rounding_cursor float32
			Padding         struct {
				X float32
				Y float32
			}
			Show_buttons int32
			Inc_button   struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Inc_symbol uint32
			Dec_symbol uint32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Tab struct {
			Background struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Tab_maximize_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Tab_minimize_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Node_maximize_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Node_minimize_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Sym_minimize uint32
			Sym_maximize uint32
			Border       float32
			Rounding     float32
			Indent       float32
			Padding      struct {
				X float32
				Y float32
			}
			Spacing struct {
				X float32
				Y float32
			}
		}
		Combo struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Symbol_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Symbol_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Symbol_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Sym_normal      uint32
			Sym_hover       uint32
			Sym_active      uint32
			Border          float32
			Rounding        float32
			Content_padding struct {
				X float32
				Y float32
			}
			Button_padding struct {
				X float32
				Y float32
			}
			Spacing struct {
				X float32
				Y float32
			}
		}
		Window struct {
			Header struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Close_button struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Minimize_button struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Close_symbol    uint32
				Minimize_symbol uint32
				Maximize_symbol uint32
				Label_normal    struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Label_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Label_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Align   uint32
				Padding struct {
					X float32
					Y float32
				}
				Label_padding struct {
					X float32
					Y float32
				}
				Spacing struct {
					X float32
					Y float32
				}
			}
			Fixed_background struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Popup_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Combo_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Contextual_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Menu_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Group_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Tooltip_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Scaler struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border                 float32
			Combo_border           float32
			Contextual_border      float32
			Menu_border            float32
			Group_border           float32
			Tooltip_border         float32
			Popup_border           float32
			Min_row_height_padding float32
			Rounding               float32
			Spacing                struct {
				X float32
				Y float32
			}
			Scrollbar_size struct {
				X float32
				Y float32
			}
			Min_size struct {
				X float32
				Y float32
			}
			Padding struct {
				X float32
				Y float32
			}
			Group_padding struct {
				X float32
				Y float32
			}
			Popup_padding struct {
				X float32
				Y float32
			}
			Combo_padding struct {
				X float32
				Y float32
			}
			Contextual_padding struct {
				X float32
				Y float32
			}
			Menu_padding struct {
				X float32
				Y float32
			}
			Tooltip_padding struct {
				X float32
				Y float32
			}
		}
	}
	Memory struct {
		Marker [2]struct {
			Active Nk_bool
			Offset Nk_size
		}
		Pool struct {
			Userdata Nk_handle
			Alloc    Nk_plugin_alloc
			Free     Nk_plugin_free
		}
		Type   uint32
		Memory struct {
			Ptr  uintptr
			Size Nk_size
		}
		Grow_factor float32
		Allocated   Nk_size
		Needed      Nk_size
		Calls       Nk_size
		Size        Nk_size
	}
	Clip struct {
		Userdata Nk_handle
		Paste    Nk_plugin_paste
		Copy     Nk_plugin_copy
	}
	Last_widget_state Nk_flags
	Button_behavior   uint32
	Stacks            struct {
		Style_items struct {
			Head     int32
			Elements [16]struct {
				Address   uintptr
				Old_value struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
			}
		}
		Floats struct {
			Head     int32
			Elements [32]struct {
				Address   uintptr
				Old_value float32
			}
		}
		Vectors struct {
			Head     int32
			Elements [16]struct {
				Address   uintptr
				Old_value struct {
					X float32
					Y float32
				}
			}
		}
		Flags struct {
			Head     int32
			Elements [32]struct {
				Address   uintptr
				Old_value Nk_flags
			}
		}
		Colors struct {
			Head     int32
			Elements [32]struct {
				Address   uintptr
				Old_value struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
			}
		}
		Fonts struct {
			Head     int32
			Elements [8]struct {
				Address   uintptr
				Old_value uintptr
			}
		}
		Button_behaviors struct {
			Head     int32
			Elements [8]struct {
				Address   uintptr
				Old_value uint32
			}
		}
	}
	Delta_time_seconds float32
	Draw_list          struct {
		Clip_rect struct {
			X float32
			Y float32
			W float32
			H float32
		}
		Circle_vtx [12]struct {
			X float32
			Y float32
		}
		Config struct {
			Global_alpha         float32
			Line_AA              uint32
			Shape_AA             uint32
			Circle_segment_count uint32
			Arc_segment_count    uint32
			Curve_segment_count  uint32
			Null                 struct {
				Texture Nk_handle
				Uv      struct {
					X float32
					Y float32
				}
			}
			Vertex_layout    uintptr
			Vertex_size      Nk_size
			Vertex_alignment Nk_size
		}
		Buffer        uintptr
		Vertices      uintptr
		Elements      uintptr
		Element_count uint32
		Vertex_count  uint32
		Cmd_count     uint32
		Cmd_offset    Nk_size
		Path_count    uint32
		Path_offset   uint32
		Line_AA       uint32
		Shape_AA      uint32
	}
	Text_edit struct {
		Clip struct {
			Userdata Nk_handle
			Paste    Nk_plugin_paste
			Copy     Nk_plugin_copy
		}
		String struct {
			Buffer struct {
				Marker [2]struct {
					Active Nk_bool
					Offset Nk_size
				}
				Pool struct {
					Userdata Nk_handle
					Alloc    Nk_plugin_alloc
					Free     Nk_plugin_free
				}
				Type   uint32
				Memory struct {
					Ptr  uintptr
					Size Nk_size
				}
				Grow_factor float32
				Allocated   Nk_size
				Needed      Nk_size
				Calls       Nk_size
				Size        Nk_size
			}
			Len int32
		}
		Filter    Nk_plugin_filter
		Scrollbar struct {
			X float32
			Y float32
		}
		Cursor                int32
		Select_start          int32
		Select_end            int32
		Mode                  uint8
		Cursor_at_end_of_line uint8
		Initialized           uint8
		Has_preferred_x       uint8
		Single_line           uint8
		Active                uint8
		Padding1              uint8
		_                     [1]byte
		Preferred_x           float32
		Undo                  struct {
			Undo_rec [99]struct {
				Where         int32
				Insert_length int16
				Delete_length int16
				Char_storage  int16
				_             [2]byte
			}
			Undo_char       [999]Nk_rune
			Undo_point      int16
			Redo_point      int16
			Undo_char_point int16
			Redo_char_point int16
		}
	}
	Overlay struct {
		Base uintptr
		Clip struct {
			X float32
			Y float32
			W float32
			H float32
		}
		Use_clipping int32
		Userdata     Nk_handle
		Begin        Nk_size
		End          Nk_size
		Last         Nk_size
	}
	Build    int32
	Use_pool int32
	Pool     struct {
		Alloc struct {
			Userdata Nk_handle
			Alloc    Nk_plugin_alloc
			Free     Nk_plugin_free
		}
		Type       uint32
		Page_count uint32
		Pages      uintptr
		Freelist   uintptr
		Capacity   uint32
		Size       Nk_size
		Cap        Nk_size
	}
	Begin    uintptr
	End      uintptr
	Active   uintptr
	Current  uintptr
	Freelist uintptr
	Count    uint32
	Seq      uint32
} /* nuklear.h:458:1 */

type Nk_draw_vertex_layout_element = struct {
	Attribute uint32
	Format    uint32
	Offset    Nk_size
} /* nuklear.h:452:1 */

type Nk_style_button = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_alignment Nk_flags
	Border         float32
	Rounding       float32
	Padding        struct {
		X float32
		Y float32
	}
	Image_padding struct {
		X float32
		Y float32
	}
	Touch_padding struct {
		X float32
		Y float32
	}
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_toggle = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_alignment Nk_flags
	Padding        struct {
		X float32
		Y float32
	}
	Touch_padding struct {
		X float32
		Y float32
	}
	Spacing    float32
	Border     float32
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_selectable = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Pressed struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Normal_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Pressed_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_pressed struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_normal_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_hover_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_pressed_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_alignment Nk_flags
	Rounding       float32
	Padding        struct {
		X float32
		Y float32
	}
	Touch_padding struct {
		X float32
		Y float32
	}
	Image_padding struct {
		X float32
		Y float32
	}
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_progress = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Rounding        float32
	Border          float32
	Cursor_border   float32
	Cursor_rounding float32
	Padding         struct {
		X float32
		Y float32
	}
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_scrollbar = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Border          float32
	Rounding        float32
	Border_cursor   float32
	Rounding_cursor float32
	Padding         struct {
		X float32
		Y float32
	}
	Show_buttons int32
	Inc_button   struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Dec_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Inc_symbol uint32
	Dec_symbol uint32
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_edit = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Scrollbar struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border          float32
		Rounding        float32
		Border_cursor   float32
		Rounding_cursor float32
		Padding         struct {
			X float32
			Y float32
		}
		Show_buttons int32
		Inc_button   struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Dec_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Inc_symbol uint32
		Dec_symbol uint32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Cursor_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Selected_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Selected_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Selected_text_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Selected_text_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Border         float32
	Rounding       float32
	Cursor_size    float32
	Scrollbar_size struct {
		X float32
		Y float32
	}
	Padding struct {
		X float32
		Y float32
	}
	Row_padding float32
} /* nuklear.h:458:1 */

type Nk_style_property = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Sym_left  uint32
	Sym_right uint32
	Border    float32
	Rounding  float32
	Padding   struct {
		X float32
		Y float32
	}
	Edit struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Scrollbar struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border          float32
			Rounding        float32
			Border_cursor   float32
			Rounding_cursor float32
			Padding         struct {
				X float32
				Y float32
			}
			Show_buttons int32
			Inc_button   struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Inc_symbol uint32
			Dec_symbol uint32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Cursor_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border         float32
		Rounding       float32
		Cursor_size    float32
		Scrollbar_size struct {
			X float32
			Y float32
		}
		Padding struct {
			X float32
			Y float32
		}
		Row_padding float32
	}
	Inc_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Dec_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style_chart = struct {
	Background struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Selected_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Border   float32
	Rounding float32
	Padding  struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_style_combo = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Symbol_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Symbol_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Symbol_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Sym_normal      uint32
	Sym_hover       uint32
	Sym_active      uint32
	Border          float32
	Rounding        float32
	Content_padding struct {
		X float32
		Y float32
	}
	Button_padding struct {
		X float32
		Y float32
	}
	Spacing struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_style_tab = struct {
	Background struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Tab_maximize_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Tab_minimize_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Node_maximize_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Node_minimize_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Sym_minimize uint32
	Sym_maximize uint32
	Border       float32
	Rounding     float32
	Indent       float32
	Padding      struct {
		X float32
		Y float32
	}
	Spacing struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_style_window_header = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Close_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Minimize_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Close_symbol    uint32
	Minimize_symbol uint32
	Maximize_symbol uint32
	Label_normal    struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Label_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Align   uint32
	Padding struct {
		X float32
		Y float32
	}
	Label_padding struct {
		X float32
		Y float32
	}
	Spacing struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_style_window = struct {
	Header struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Close_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Minimize_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Close_symbol    uint32
		Minimize_symbol uint32
		Maximize_symbol uint32
		Label_normal    struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Align   uint32
		Padding struct {
			X float32
			Y float32
		}
		Label_padding struct {
			X float32
			Y float32
		}
		Spacing struct {
			X float32
			Y float32
		}
	}
	Fixed_background struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Popup_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Combo_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Contextual_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Menu_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Group_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Tooltip_border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Scaler struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border                 float32
	Combo_border           float32
	Contextual_border      float32
	Menu_border            float32
	Group_border           float32
	Tooltip_border         float32
	Popup_border           float32
	Min_row_height_padding float32
	Rounding               float32
	Spacing                struct {
		X float32
		Y float32
	}
	Scrollbar_size struct {
		X float32
		Y float32
	}
	Min_size struct {
		X float32
		Y float32
	}
	Padding struct {
		X float32
		Y float32
	}
	Group_padding struct {
		X float32
		Y float32
	}
	Popup_padding struct {
		X float32
		Y float32
	}
	Combo_padding struct {
		X float32
		Y float32
	}
	Contextual_padding struct {
		X float32
		Y float32
	}
	Menu_padding struct {
		X float32
		Y float32
	}
	Tooltip_padding struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_color = struct {
	R Nk_byte
	G Nk_byte
	B Nk_byte
	A Nk_byte
} /* nuklear.h:453:1 */

type Nk_colorf = struct {
	R float32
	G float32
	B float32
	A float32
} /* nuklear.h:476:1 */

type Nk_vec2 = struct {
	X float32
	Y float32
} /* nuklear.h:452:1 */

type Nk_vec2i = struct {
	X int16
	Y int16
} /* nuklear.h:478:1 */

type Nk_rect = struct {
	X float32
	Y float32
	W float32
	H float32
} /* nuklear.h:450:1 */

type Nk_recti = struct {
	X int16
	Y int16
	W int16
	H int16
} /* nuklear.h:480:1 */

type Nk_glyph = [4]int8                /* nuklear.h:481:14 */
type Nk_handle = struct{ Ptr uintptr } /* nuklear.h:482:36 */
type Nk_image = struct {
	Handle Nk_handle
	W      uint16
	H      uint16
	Region [4]uint16
} /* nuklear.h:453:1 */

type Nk_cursor = struct {
	Img struct {
		Handle Nk_handle
		W      uint16
		H      uint16
		Region [4]uint16
	}
	Size struct {
		X float32
		Y float32
	}
	Offset struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_scroll = struct {
	X Nk_uint
	Y Nk_uint
} /* nuklear.h:457:1 */

type Nk_plugin_alloc = uintptr  /* nuklear.h:500:13 */
type Nk_plugin_free = uintptr   /* nuklear.h:501:14 */
type Nk_plugin_filter = uintptr /* nuklear.h:502:16 */
type Nk_plugin_paste = uintptr  /* nuklear.h:503:13 */
type Nk_plugin_copy = uintptr   /* nuklear.h:504:13 */
type Nk_draw_null_texture = struct {
	Texture Nk_handle
	Uv      struct {
		X float32
		Y float32
	}
} /* nuklear.h:452:1 */

///// #### nk__begin
// /// Returns a draw command list iterator to iterate all draw
// /// commands accumulated over one frame.
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// const struct nk_command* nk__begin(struct nk_context*);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// Parameter   | Description
// /// ------------|-----------------------------------------------------------
// /// __ctx__     | must point to an previously initialized `nk_context` struct at the end of a frame
// ///
// /// Returns draw command pointer pointing to the first command inside the draw command list
type Nk_command = struct {
	Type uint32
	Next Nk_size
} /* nuklear.h:1198:14 */

///// #### nk_window_find
// /// Finds and returns a window from passed name
// ///
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c
// /// struct nk_window *nk_window_find(struct nk_context *ctx, const char *name);
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ///
// /// Parameter   | Description
// /// ------------|-----------------------------------------------------------
// /// __ctx__     | Must point to an previously initialized `nk_context` struct
// /// __name__    | Window identifier
// ///
// /// Returns a `nk_window` struct pointing to the identified window or NULL if
// /// no window with the given name was found
type Nk_window = struct {
	Seq         uint32
	Name        Nk_hash
	Name_string [64]int8
	Flags       Nk_flags
	Bounds      struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Scrollbar struct {
		X Nk_uint
		Y Nk_uint
	}
	Buffer struct {
		Base uintptr
		Clip struct {
			X float32
			Y float32
			W float32
			H float32
		}
		Use_clipping int32
		Userdata     Nk_handle
		Begin        Nk_size
		End          Nk_size
		Last         Nk_size
	}
	Layout                 uintptr
	Scrollbar_hiding_timer float32
	Property               struct {
		Active       int32
		Prev         int32
		Buffer       [64]int8
		Length       int32
		Cursor       int32
		Select_start int32
		Select_end   int32
		Name         Nk_hash
		Seq          uint32
		Old          uint32
		State        int32
	}
	Popup struct {
		Win  uintptr
		Type uint32
		Buf  struct {
			Begin  Nk_size
			Parent Nk_size
			Last   Nk_size
			End    Nk_size
			Active Nk_bool
		}
		Name        Nk_hash
		Active      Nk_bool
		Combo_count uint32
		Con_count   uint32
		Con_old     uint32
		Active_con  uint32
		Header      struct {
			X float32
			Y float32
			W float32
			H float32
		}
	}
	Edit struct {
		Name      Nk_hash
		Seq       uint32
		Old       uint32
		Active    int32
		Prev      int32
		Cursor    int32
		Sel_start int32
		Sel_end   int32
		Scrollbar struct {
			X Nk_uint
			Y Nk_uint
		}
		Mode        uint8
		Single_line uint8
		_           [2]byte
	}
	Scrolled    uint32
	Tables      uintptr
	Table_count uint32
	Next        uintptr
	Prev        uintptr
	Parent      uintptr
} /* nuklear.h:458:1 */

// =============================================================================
//
//                                  LIST VIEW
//
// =============================================================================
type Nk_list_view = struct {
	Begin          int32
	End            int32
	Count          int32
	Total_height   int32
	Ctx            uintptr
	Scroll_pointer uintptr
	Scroll_value   Nk_uint
} /* nuklear.h:3043:1 */

// ===============================================================
//
//                          FONT
//
// ===============================================================
//  Font handling in this library was designed to be quite customizable and lets
//     you decide what you want to use and what you want to provide. There are three
//     different ways to use the font atlas. The first two will use your font
//     handling scheme and only requires essential data to run nuklear. The next
//     slightly more advanced features is font handling with vertex buffer output.
//     Finally the most complex API wise is using nuklear's font baking API.
//
//     1.) Using your own implementation without vertex buffer output
//     --------------------------------------------------------------
//     So first up the easiest way to do font handling is by just providing a
//     `nk_user_font` struct which only requires the height in pixel of the used
//     font and a callback to calculate the width of a string. This way of handling
//     fonts is best fitted for using the normal draw shape command API where you
//     do all the text drawing yourself and the library does not require any kind
//     of deeper knowledge about which font handling mechanism you use.
//     IMPORTANT: the `nk_user_font` pointer provided to nuklear has to persist
//     over the complete life time! I know this sucks but it is currently the only
//     way to switch between fonts.
//
//         float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
//         {
//             your_font_type *type = handle.ptr;
//             float text_width = ...;
//             return text_width;
//         }
//
//         struct nk_user_font font;
//         font.userdata.ptr = &your_font_class_or_struct;
//         font.height = your_font_height;
//         font.width = your_text_width_calculation;
//
//         struct nk_context ctx;
//         nk_init_default(&ctx, &font);
//
//     2.) Using your own implementation with vertex buffer output
//     --------------------------------------------------------------
//     While the first approach works fine if you don't want to use the optional
//     vertex buffer output it is not enough if you do. To get font handling working
//     for these cases you have to provide two additional parameters inside the
//     `nk_user_font`. First a texture atlas handle used to draw text as subimages
//     of a bigger font atlas texture and a callback to query a character's glyph
//     information (offset, size, ...). So it is still possible to provide your own
//     font and use the vertex buffer output.
//
//         float your_text_width_calculation(nk_handle handle, float height, const char *text, int len)
//         {
//             your_font_type *type = handle.ptr;
//             float text_width = ...;
//             return text_width;
//         }
//         void query_your_font_glyph(nk_handle handle, float font_height, struct nk_user_font_glyph *glyph, nk_rune codepoint, nk_rune next_codepoint)
//         {
//             your_font_type *type = handle.ptr;
//             glyph.width = ...;
//             glyph.height = ...;
//             glyph.xadvance = ...;
//             glyph.uv[0].x = ...;
//             glyph.uv[0].y = ...;
//             glyph.uv[1].x = ...;
//             glyph.uv[1].y = ...;
//             glyph.offset.x = ...;
//             glyph.offset.y = ...;
//         }
//
//         struct nk_user_font font;
//         font.userdata.ptr = &your_font_class_or_struct;
//         font.height = your_font_height;
//         font.width = your_text_width_calculation;
//         font.query = query_your_font_glyph;
//         font.texture.id = your_font_texture;
//
//         struct nk_context ctx;
//         nk_init_default(&ctx, &font);
//
//     3.) Nuklear font baker
//     ------------------------------------
//     The final approach if you do not have a font handling functionality or don't
//     want to use it in this library is by using the optional font baker.
//     The font baker APIs can be used to create a font plus font atlas texture
//     and can be used with or without the vertex buffer output.
//
//     It still uses the `nk_user_font` struct and the two different approaches
//     previously stated still work. The font baker is not located inside
//     `nk_context` like all other systems since it can be understood as more of
//     an extension to nuklear and does not really depend on any `nk_context` state.
//
//     Font baker need to be initialized first by one of the nk_font_atlas_init_xxx
//     functions. If you don't care about memory just call the default version
//     `nk_font_atlas_init_default` which will allocate all memory from the standard library.
//     If you want to control memory allocation but you don't care if the allocated
//     memory is temporary and therefore can be freed directly after the baking process
//     is over or permanent you can call `nk_font_atlas_init`.
//
//     After successfully initializing the font baker you can add Truetype(.ttf) fonts from
//     different sources like memory or from file by calling one of the `nk_font_atlas_add_xxx`.
//     functions. Adding font will permanently store each font, font config and ttf memory block(!)
//     inside the font atlas and allows to reuse the font atlas. If you don't want to reuse
//     the font baker by for example adding additional fonts you can call
//     `nk_font_atlas_cleanup` after the baking process is over (after calling nk_font_atlas_end).
//
//     As soon as you added all fonts you wanted you can now start the baking process
//     for every selected glyph to image by calling `nk_font_atlas_bake`.
//     The baking process returns image memory, width and height which can be used to
//     either create your own image object or upload it to any graphics library.
//     No matter which case you finally have to call `nk_font_atlas_end` which
//     will free all temporary memory including the font atlas image so make sure
//     you created our texture beforehand. `nk_font_atlas_end` requires a handle
//     to your font texture or object and optionally fills a `struct nk_draw_null_texture`
//     which can be used for the optional vertex output. If you don't want it just
//     set the argument to `NULL`.
//
//     At this point you are done and if you don't want to reuse the font atlas you
//     can call `nk_font_atlas_cleanup` to free all truetype blobs and configuration
//     memory. Finally if you don't use the font atlas and any of it's fonts anymore
//     you need to call `nk_font_atlas_clear` to free all memory still being used.
//
//         struct nk_font_atlas atlas;
//         nk_font_atlas_init_default(&atlas);
//         nk_font_atlas_begin(&atlas);
//         nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, 0);
//         nk_font *font2 = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font2.ttf", 16, 0);
//         const void* img = nk_font_atlas_bake(&atlas, &img_width, &img_height, NK_FONT_ATLAS_RGBA32);
//         nk_font_atlas_end(&atlas, nk_handle_id(texture), 0);
//
//         struct nk_context ctx;
//         nk_init_default(&ctx, &font->handle);
//         while (1) {
//
//         }
//         nk_font_atlas_clear(&atlas);
//
//     The font baker API is probably the most complex API inside this library and
//     I would suggest reading some of my examples `example/` to get a grip on how
//     to use the font atlas. There are a number of details I left out. For example
//     how to merge fonts, configure a font with `nk_font_config` to use other languages,
//     use another texture coordinate format and a lot more:
//
//         struct nk_font_config cfg = nk_font_config(font_pixel_height);
//         cfg.merge_mode = nk_false or nk_true;
//         cfg.range = nk_font_korean_glyph_ranges();
//         cfg.coord_type = NK_COORD_PIXEL;
//         nk_font *font = nk_font_atlas_add_from_file(&atlas, "Path/To/Your/TTF_Font.ttf", 13, &cfg);
//
type Nk_user_font_glyph = struct {
	Uv [2]struct {
		X float32
		Y float32
	}
	Offset struct {
		X float32
		Y float32
	}
	Width    float32
	Height   float32
	Xadvance float32
} /* nuklear.h:3916:1 */

type Nk_text_width_f = uintptr       /* nuklear.h:3917:14 */
type Nk_query_font_glyph_f = uintptr /* nuklear.h:3918:13 */

type Nk_font = struct {
	Next   uintptr
	Handle struct {
		Userdata Nk_handle
		Height   float32
		Width    Nk_text_width_f
		Query    Nk_query_font_glyph_f
		Texture  Nk_handle
	}
	Info struct {
		Height       float32
		Ascent       float32
		Descent      float32
		Glyph_offset Nk_rune
		Glyph_count  Nk_rune
		Ranges       uintptr
	}
	Scale              float32
	Glyphs             uintptr
	Fallback           uintptr
	Fallback_codepoint Nk_rune
	Texture            Nk_handle
	Config             uintptr
} /* nuklear.h:3956:1 */

type Nk_baked_font = struct {
	Height       float32
	Ascent       float32
	Descent      float32
	Glyph_offset Nk_rune
	Glyph_count  Nk_rune
	Ranges       uintptr
} /* nuklear.h:3956:1 */

type Nk_font_config = struct {
	Next                    uintptr
	Ttf_blob                uintptr
	Ttf_size                Nk_size
	Ttf_data_owned_by_atlas uint8
	Merge_mode              uint8
	Pixel_snap              uint8
	Oversample_v            uint8
	Oversample_h            uint8
	Padding                 [3]uint8
	Size                    float32
	Coord_type              uint32
	Spacing                 struct {
		X float32
		Y float32
	}
	Range          uintptr
	Font           uintptr
	Fallback_glyph Nk_rune
	N              uintptr
	P              uintptr
} /* nuklear.h:3956:1 */

type Nk_font_glyph = struct {
	Codepoint Nk_rune
	Xadvance  float32
	X0        float32
	Y0        float32
	X1        float32
	Y1        float32
	W         float32
	H         float32
	U0        float32
	V0        float32
	U1        float32
	V1        float32
} /* nuklear.h:3956:1 */

type Nk_font_atlas = struct {
	Pixel      uintptr
	Tex_width  int32
	Tex_height int32
	Permanent  struct {
		Userdata Nk_handle
		Alloc    Nk_plugin_alloc
		Free     Nk_plugin_free
	}
	Temporary struct {
		Userdata Nk_handle
		Alloc    Nk_plugin_alloc
		Free     Nk_plugin_free
	}
	Custom struct {
		X int16
		Y int16
		W int16
		H int16
	}
	Cursors [7]struct {
		Img struct {
			Handle Nk_handle
			W      uint16
			H      uint16
			Region [4]uint16
		}
		Size struct {
			X float32
			Y float32
		}
		Offset struct {
			X float32
			Y float32
		}
	}
	Glyph_count  int32
	Glyphs       uintptr
	Default_font uintptr
	Fonts        uintptr
	Config       uintptr
	Font_num     int32
} /* nuklear.h:4030:1 */

// ==============================================================
//
//                          MEMORY BUFFER
//
// ===============================================================
//  A basic (double)-buffer with linear allocation and resetting as only
//     freeing policy. The buffer's main purpose is to control all memory management
//     inside the GUI toolkit and still leave memory control as much as possible in
//     the hand of the user while also making sure the library is easy to use if
//     not as much control is needed.
//     In general all memory inside this library can be provided from the user in
//     three different ways.
//
//     The first way and the one providing most control is by just passing a fixed
//     size memory block. In this case all control lies in the hand of the user
//     since he can exactly control where the memory comes from and how much memory
//     the library should consume. Of course using the fixed size API removes the
//     ability to automatically resize a buffer if not enough memory is provided so
//     you have to take over the resizing. While being a fixed sized buffer sounds
//     quite limiting, it is very effective in this library since the actual memory
//     consumption is quite stable and has a fixed upper bound for a lot of cases.
//
//     If you don't want to think about how much memory the library should allocate
//     at all time or have a very dynamic UI with unpredictable memory consumption
//     habits but still want control over memory allocation you can use the dynamic
//     allocator based API. The allocator consists of two callbacks for allocating
//     and freeing memory and optional userdata so you can plugin your own allocator.
//
//     The final and easiest way can be used by defining
//     NK_INCLUDE_DEFAULT_ALLOCATOR which uses the standard library memory
//     allocation functions malloc and free and takes over complete control over
//     memory in this library.
type Nk_memory_status = struct {
	Memory    uintptr
	Type      uint32
	Size      Nk_size
	Allocated Nk_size
	Needed    Nk_size
	Calls     Nk_size
} /* nuklear.h:4113:1 */

type Nk_buffer_marker = struct {
	Active Nk_bool
	Offset Nk_size
} /* nuklear.h:448:1 */

type Nk_memory = struct {
	Ptr  uintptr
	Size Nk_size
} /* nuklear.h:448:1 */

// ==============================================================
//
//                          STRING
//
// ===============================================================
// Basic string buffer which is only used in context with the text editor
//  to manage and manipulate dynamic or fixed size string content. This is _NOT_
//  the default string handling method. The only instance you should have any contact
//  with this API is if you interact with an `nk_text_edit` object inside one of the
//  copy and paste functions and even there only for more advanced cases.
type Nk_str = struct {
	Buffer struct {
		Marker [2]struct {
			Active Nk_bool
			Offset Nk_size
		}
		Pool struct {
			Userdata Nk_handle
			Alloc    Nk_plugin_alloc
			Free     Nk_plugin_free
		}
		Type   uint32
		Memory struct {
			Ptr  uintptr
			Size Nk_size
		}
		Grow_factor float32
		Allocated   Nk_size
		Needed      Nk_size
		Calls       Nk_size
		Size        Nk_size
	}
	Len int32
} /* nuklear.h:454:1 */

type Nk_clipboard = struct {
	Userdata Nk_handle
	Paste    Nk_plugin_paste
	Copy     Nk_plugin_copy
} /* nuklear.h:454:1 */

type Nk_text_undo_record = struct {
	Where         int32
	Insert_length int16
	Delete_length int16
	Char_storage  int16
	_             [2]byte
} /* nuklear.h:454:1 */

type Nk_text_undo_state = struct {
	Undo_rec [99]struct {
		Where         int32
		Insert_length int16
		Delete_length int16
		Char_storage  int16
		_             [2]byte
	}
	Undo_char       [999]Nk_rune
	Undo_point      int16
	Redo_point      int16
	Undo_char_point int16
	Redo_char_point int16
} /* nuklear.h:454:1 */

type Nk_command_scissor = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X int16
	Y int16
	W uint16
	H uint16
} /* nuklear.h:4426:1 */

type Nk_command_line = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Line_thickness uint16
	Begin          struct {
		X int16
		Y int16
	}
	End struct {
		X int16
		Y int16
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	_ [2]byte
} /* nuklear.h:4432:1 */

type Nk_command_curve = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Line_thickness uint16
	Begin          struct {
		X int16
		Y int16
	}
	End struct {
		X int16
		Y int16
	}
	Ctrl [2]struct {
		X int16
		Y int16
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	_ [2]byte
} /* nuklear.h:4440:1 */

type Nk_command_rect = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Rounding       uint16
	Line_thickness uint16
	X              int16
	Y              int16
	W              uint16
	H              uint16
	Color          struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4449:1 */

type Nk_command_rect_filled = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Rounding uint16
	X        int16
	Y        int16
	W        uint16
	H        uint16
	Color    struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	_ [2]byte
} /* nuklear.h:4458:1 */

type Nk_command_rect_multi_color = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X    int16
	Y    int16
	W    uint16
	H    uint16
	Left struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Top struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Bottom struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Right struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4466:1 */

type Nk_command_triangle = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Line_thickness uint16
	A              struct {
		X int16
		Y int16
	}
	B struct {
		X int16
		Y int16
	}
	C struct {
		X int16
		Y int16
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	_ [2]byte
} /* nuklear.h:4476:1 */

type Nk_command_triangle_filled = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	A struct {
		X int16
		Y int16
	}
	B struct {
		X int16
		Y int16
	}
	C struct {
		X int16
		Y int16
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4485:1 */

type Nk_command_circle = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X              int16
	Y              int16
	Line_thickness uint16
	W              uint16
	H              uint16
	Color          struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	_ [2]byte
} /* nuklear.h:4493:1 */

type Nk_command_circle_filled = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X     int16
	Y     int16
	W     uint16
	H     uint16
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4501:1 */

type Nk_command_arc = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Cx             int16
	Cy             int16
	R              uint16
	Line_thickness uint16
	A              [2]float32
	Color          struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4508:1 */

type Nk_command_arc_filled = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Cx    int16
	Cy    int16
	R     uint16
	_     [2]byte
	A     [2]float32
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4517:1 */

type Nk_command_polygon = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Line_thickness uint16
	Point_count    uint16
	Points         [1]struct {
		X int16
		Y int16
	}
} /* nuklear.h:4525:1 */

type Nk_command_polygon_filled = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Point_count uint16
	Points      [1]struct {
		X int16
		Y int16
	}
	_ [2]byte
} /* nuklear.h:4533:1 */

type Nk_command_polyline = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Line_thickness uint16
	Point_count    uint16
	Points         [1]struct {
		X int16
		Y int16
	}
} /* nuklear.h:4540:1 */

type Nk_command_image = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X   int16
	Y   int16
	W   uint16
	H   uint16
	Img struct {
		Handle Nk_handle
		W      uint16
		H      uint16
		Region [4]uint16
	}
	Col struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:4548:1 */

type Nk_command_custom_callback = uintptr /* nuklear.h:4556:14 */
type Nk_command_custom = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	X             int16
	Y             int16
	W             uint16
	H             uint16
	Callback_data Nk_handle
	Callback      Nk_command_custom_callback
} /* nuklear.h:4558:1 */

type Nk_command_text = struct {
	Header struct {
		Type uint32
		Next Nk_size
	}
	Font       uintptr
	Background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Foreground struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	X      int16
	Y      int16
	W      uint16
	H      uint16
	Height float32
	Length int32
	String [1]int8
	_      [3]byte
} /* nuklear.h:4566:1 */

// ===============================================================
//
//                          INPUT
//
// ===============================================================
type Nk_mouse_button = struct {
	Down        Nk_bool
	Clicked     uint32
	Clicked_pos struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_mouse = struct {
	Buttons [4]struct {
		Down        Nk_bool
		Clicked     uint32
		Clicked_pos struct {
			X float32
			Y float32
		}
	}
	Pos struct {
		X float32
		Y float32
	}
	Prev struct {
		X float32
		Y float32
	}
	Delta struct {
		X float32
		Y float32
	}
	Scroll_delta struct {
		X float32
		Y float32
	}
	Grab    uint8
	Grabbed uint8
	Ungrab  uint8
	_       [1]byte
} /* nuklear.h:458:1 */

type Nk_key = struct {
	Down    Nk_bool
	Clicked uint32
} /* nuklear.h:458:1 */

type Nk_keyboard = struct {
	Keys [30]struct {
		Down    Nk_bool
		Clicked uint32
	}
	Text     [16]int8
	Text_len int32
} /* nuklear.h:458:1 */

type Nk_input = struct {
	Keyboard struct {
		Keys [30]struct {
			Down    Nk_bool
			Clicked uint32
		}
		Text     [16]int8
		Text_len int32
	}
	Mouse struct {
		Buttons [4]struct {
			Down        Nk_bool
			Clicked     uint32
			Clicked_pos struct {
				X float32
				Y float32
			}
		}
		Pos struct {
			X float32
			Y float32
		}
		Prev struct {
			X float32
			Y float32
		}
		Delta struct {
			X float32
			Y float32
		}
		Scroll_delta struct {
			X float32
			Y float32
		}
		Grab    uint8
		Grabbed uint8
		Ungrab  uint8
		_       [1]byte
	}
} /* nuklear.h:458:1 */

// ===============================================================
//
//                          DRAW LIST
//
// ===============================================================
//  The optional vertex buffer draw list provides a 2D drawing context
//     with antialiasing functionality which takes basic filled or outlined shapes
//     or a path and outputs vertexes, elements and draw commands.
//     The actual draw list API is not required to be used directly while using this
//     library since converting the default library draw command output is done by
//     just calling `nk_convert` but I decided to still make this library accessible
//     since it can be useful.
//
//     The draw list is based on a path buffering and polygon and polyline
//     rendering API which allows a lot of ways to draw 2D content to screen.
//     In fact it is probably more powerful than needed but allows even more crazy
//     things than this library provides by default.
type Nk_draw_index = Nk_ushort /* nuklear.h:4689:19 */

type Nk_style_item_data = struct {
	Image struct {
		Handle Nk_handle
		W      uint16
		H      uint16
		Region [4]uint16
	}
} /* nuklear.h:453:1 */

type Nk_style_text = struct {
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Padding struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_style_slider = struct {
	Normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border_color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Bar_normal struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Bar_hover struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Bar_active struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Bar_filled struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Cursor_normal struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_hover struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Cursor_active struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
	Border     float32
	Rounding   float32
	Bar_height float32
	Padding    struct {
		X float32
		Y float32
	}
	Spacing struct {
		X float32
		Y float32
	}
	Cursor_size struct {
		X float32
		Y float32
	}
	Show_buttons int32
	Inc_button   struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Dec_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Inc_symbol uint32
	Dec_symbol uint32
	Userdata   Nk_handle
	Draw_begin uintptr
	Draw_end   uintptr
} /* nuklear.h:458:1 */

type Nk_style = struct {
	Font           uintptr
	Cursors        [7]uintptr
	Cursor_active  uintptr
	Cursor_last    uintptr
	Cursor_visible int32
	Text           struct {
		Color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Padding struct {
			X float32
			Y float32
		}
	}
	Button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Contextual_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Menu_button struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Border         float32
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Option struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Padding        struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Spacing    float32
		Border     float32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Checkbox struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Padding        struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Spacing    float32
		Border     float32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Selectable struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Pressed struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Normal_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Pressed_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_pressed struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_pressed_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_alignment Nk_flags
		Rounding       float32
		Padding        struct {
			X float32
			Y float32
		}
		Touch_padding struct {
			X float32
			Y float32
		}
		Image_padding struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Slider struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Bar_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Bar_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Bar_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Bar_filled struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border     float32
		Rounding   float32
		Bar_height float32
		Padding    struct {
			X float32
			Y float32
		}
		Spacing struct {
			X float32
			Y float32
		}
		Cursor_size struct {
			X float32
			Y float32
		}
		Show_buttons int32
		Inc_button   struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Dec_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Inc_symbol uint32
		Dec_symbol uint32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Progress struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Rounding        float32
		Border          float32
		Cursor_border   float32
		Cursor_rounding float32
		Padding         struct {
			X float32
			Y float32
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Property struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Sym_left  uint32
		Sym_right uint32
		Border    float32
		Rounding  float32
		Padding   struct {
			X float32
			Y float32
		}
		Edit struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Scrollbar struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Cursor_normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Cursor_border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Border          float32
				Rounding        float32
				Border_cursor   float32
				Rounding_cursor float32
				Padding         struct {
					X float32
					Y float32
				}
				Show_buttons int32
				Inc_button   struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Dec_button struct {
					Normal struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Hover struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Active struct {
						Type uint32
						Data struct {
							Image struct {
								Handle Nk_handle
								W      uint16
								H      uint16
								Region [4]uint16
							}
						}
					}
					Border_color struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_background struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_normal struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_hover struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_active struct {
						R Nk_byte
						G Nk_byte
						B Nk_byte
						A Nk_byte
					}
					Text_alignment Nk_flags
					Border         float32
					Rounding       float32
					Padding        struct {
						X float32
						Y float32
					}
					Image_padding struct {
						X float32
						Y float32
					}
					Touch_padding struct {
						X float32
						Y float32
					}
					Userdata   Nk_handle
					Draw_begin uintptr
					Draw_end   uintptr
				}
				Inc_symbol uint32
				Dec_symbol uint32
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Cursor_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Selected_text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border         float32
			Rounding       float32
			Cursor_size    float32
			Scrollbar_size struct {
				X float32
				Y float32
			}
			Padding struct {
				X float32
				Y float32
			}
			Row_padding float32
		}
		Inc_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Dec_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Edit struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Scrollbar struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Cursor_normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Cursor_border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Border          float32
			Rounding        float32
			Border_cursor   float32
			Rounding_cursor float32
			Padding         struct {
				X float32
				Y float32
			}
			Show_buttons int32
			Inc_button   struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Dec_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Inc_symbol uint32
			Dec_symbol uint32
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Cursor_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_text_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_text_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border         float32
		Rounding       float32
		Cursor_size    float32
		Scrollbar_size struct {
			X float32
			Y float32
		}
		Padding struct {
			X float32
			Y float32
		}
		Row_padding float32
	}
	Chart struct {
		Background struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Selected_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border   float32
		Rounding float32
		Padding  struct {
			X float32
			Y float32
		}
	}
	Scrollh struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border          float32
		Rounding        float32
		Border_cursor   float32
		Rounding_cursor float32
		Padding         struct {
			X float32
			Y float32
		}
		Show_buttons int32
		Inc_button   struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Dec_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Inc_symbol uint32
		Dec_symbol uint32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Scrollv struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Cursor_normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Cursor_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border          float32
		Rounding        float32
		Border_cursor   float32
		Rounding_cursor float32
		Padding         struct {
			X float32
			Y float32
		}
		Show_buttons int32
		Inc_button   struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Dec_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Inc_symbol uint32
		Dec_symbol uint32
		Userdata   Nk_handle
		Draw_begin uintptr
		Draw_end   uintptr
	}
	Tab struct {
		Background struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Text struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Tab_maximize_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Tab_minimize_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Node_maximize_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Node_minimize_button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Sym_minimize uint32
		Sym_maximize uint32
		Border       float32
		Rounding     float32
		Indent       float32
		Padding      struct {
			X float32
			Y float32
		}
		Spacing struct {
			X float32
			Y float32
		}
	}
	Combo struct {
		Normal struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Hover struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Active struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Label_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Symbol_normal struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Symbol_hover struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Symbol_active struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Button struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Border_color struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_background struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_normal struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Text_alignment Nk_flags
			Border         float32
			Rounding       float32
			Padding        struct {
				X float32
				Y float32
			}
			Image_padding struct {
				X float32
				Y float32
			}
			Touch_padding struct {
				X float32
				Y float32
			}
			Userdata   Nk_handle
			Draw_begin uintptr
			Draw_end   uintptr
		}
		Sym_normal      uint32
		Sym_hover       uint32
		Sym_active      uint32
		Border          float32
		Rounding        float32
		Content_padding struct {
			X float32
			Y float32
		}
		Button_padding struct {
			X float32
			Y float32
		}
		Spacing struct {
			X float32
			Y float32
		}
	}
	Window struct {
		Header struct {
			Normal struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Hover struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Active struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
			Close_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Minimize_button struct {
				Normal struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Hover struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Active struct {
					Type uint32
					Data struct {
						Image struct {
							Handle Nk_handle
							W      uint16
							H      uint16
							Region [4]uint16
						}
					}
				}
				Border_color struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_background struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_normal struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_hover struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_active struct {
					R Nk_byte
					G Nk_byte
					B Nk_byte
					A Nk_byte
				}
				Text_alignment Nk_flags
				Border         float32
				Rounding       float32
				Padding        struct {
					X float32
					Y float32
				}
				Image_padding struct {
					X float32
					Y float32
				}
				Touch_padding struct {
					X float32
					Y float32
				}
				Userdata   Nk_handle
				Draw_begin uintptr
				Draw_end   uintptr
			}
			Close_symbol    uint32
			Minimize_symbol uint32
			Maximize_symbol uint32
			Label_normal    struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_hover struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Label_active struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
			Align   uint32
			Padding struct {
				X float32
				Y float32
			}
			Label_padding struct {
				X float32
				Y float32
			}
			Spacing struct {
				X float32
				Y float32
			}
		}
		Fixed_background struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Background struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Popup_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Combo_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Contextual_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Menu_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Group_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Tooltip_border_color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Scaler struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
		Border                 float32
		Combo_border           float32
		Contextual_border      float32
		Menu_border            float32
		Group_border           float32
		Tooltip_border         float32
		Popup_border           float32
		Min_row_height_padding float32
		Rounding               float32
		Spacing                struct {
			X float32
			Y float32
		}
		Scrollbar_size struct {
			X float32
			Y float32
		}
		Min_size struct {
			X float32
			Y float32
		}
		Padding struct {
			X float32
			Y float32
		}
		Group_padding struct {
			X float32
			Y float32
		}
		Popup_padding struct {
			X float32
			Y float32
		}
		Combo_padding struct {
			X float32
			Y float32
		}
		Contextual_padding struct {
			X float32
			Y float32
		}
		Menu_padding struct {
			X float32
			Y float32
		}
		Tooltip_padding struct {
			X float32
			Y float32
		}
	}
} /* nuklear.h:458:1 */

type Nk_chart_slot = struct {
	Type  uint32
	Color struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Highlight struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Min   float32
	Max   float32
	Range float32
	Count int32
	Last  struct {
		X float32
		Y float32
	}
	Index int32
} /* nuklear.h:457:1 */

type Nk_chart = struct {
	Slot  int32
	X     float32
	Y     float32
	W     float32
	H     float32
	Slots [4]struct {
		Type  uint32
		Color struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Highlight struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
		Min   float32
		Max   float32
		Range float32
		Count int32
		Last  struct {
			X float32
			Y float32
		}
		Index int32
	}
} /* nuklear.h:457:1 */

type Nk_row_layout = struct {
	Type        uint32
	Index       int32
	Height      float32
	Min_height  float32
	Columns     int32
	Ratio       uintptr
	Item_width  float32
	Item_height float32
	Item_offset float32
	Filled      float32
	Item        struct {
		X float32
		Y float32
		W float32
		H float32
	}
	Tree_depth int32
	Templates  [16]float32
} /* nuklear.h:457:1 */

type Nk_popup_buffer = struct {
	Begin  Nk_size
	Parent Nk_size
	Last   Nk_size
	End    Nk_size
	Active Nk_bool
} /* nuklear.h:458:1 */

type Nk_menu_state = struct {
	X      float32
	Y      float32
	W      float32
	H      float32
	Offset struct {
		X Nk_uint
		Y Nk_uint
	}
} /* nuklear.h:457:1 */

// ==============================================================
//                          WINDOW
// =============================================================

type Nk_table = struct {
	Seq    uint32
	Size   uint32
	Keys   [51]Nk_hash
	Values [51]Nk_uint
	Next   uintptr
	Prev   uintptr
} /* nuklear.h:458:1 */

type Nk_popup_state = struct {
	Win  uintptr
	Type uint32
	Buf  struct {
		Begin  Nk_size
		Parent Nk_size
		Last   Nk_size
		End    Nk_size
		Active Nk_bool
	}
	Name        Nk_hash
	Active      Nk_bool
	Combo_count uint32
	Con_count   uint32
	Con_old     uint32
	Active_con  uint32
	Header      struct {
		X float32
		Y float32
		W float32
		H float32
	}
} /* nuklear.h:458:1 */

type Nk_edit_state = struct {
	Name      Nk_hash
	Seq       uint32
	Old       uint32
	Active    int32
	Prev      int32
	Cursor    int32
	Sel_start int32
	Sel_end   int32
	Scrollbar struct {
		X Nk_uint
		Y Nk_uint
	}
	Mode        uint8
	Single_line uint8
	_           [2]byte
} /* nuklear.h:458:1 */

type Nk_property_state = struct {
	Active       int32
	Prev         int32
	Buffer       [64]int8
	Length       int32
	Cursor       int32
	Select_start int32
	Select_end   int32
	Name         Nk_hash
	Seq          uint32
	Old          uint32
	State        int32
} /* nuklear.h:458:1 */

// ==============================================================
//                          STACK
// =============================================================
// The style modifier stack can be used to temporarily change a
// property inside `nk_style`. For example if you want a special
// red button you can temporarily push the old button color onto a stack
// draw the button with a red color and then you just pop the old color
// back from the stack:
//
//      nk_style_push_style_item(ctx, &ctx->style.button.normal, nk_style_item_color(nk_rgb(255,0,0)));
//      nk_style_push_style_item(ctx, &ctx->style.button.hover, nk_style_item_color(nk_rgb(255,0,0)));
//      nk_style_push_style_item(ctx, &ctx->style.button.active, nk_style_item_color(nk_rgb(255,0,0)));
//      nk_style_push_vec2(ctx, &cx->style.button.padding, nk_vec2(2,2));
//
//      nk_button(...);
//
//      nk_style_pop_style_item(ctx);
//      nk_style_pop_style_item(ctx);
//      nk_style_pop_style_item(ctx);
//      nk_style_pop_vec2(ctx);
//
// Nuklear has a stack for style_items, float properties, vector properties,
// flags, colors, fonts and for button_behavior. Each has it's own fixed size stack
// which can be changed at compile time.

type Nk_config_stack_style_item_element = struct {
	Address   uintptr
	Old_value struct {
		Type uint32
		Data struct {
			Image struct {
				Handle Nk_handle
				W      uint16
				H      uint16
				Region [4]uint16
			}
		}
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_float_element = struct {
	Address   uintptr
	Old_value float32
} /* nuklear.h:458:1 */

type Nk_config_stack_vec2_element = struct {
	Address   uintptr
	Old_value struct {
		X float32
		Y float32
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_flags_element = struct {
	Address   uintptr
	Old_value Nk_flags
} /* nuklear.h:458:1 */

type Nk_config_stack_color_element = struct {
	Address   uintptr
	Old_value struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_user_font_element = struct {
	Address   uintptr
	Old_value uintptr
} /* nuklear.h:458:1 */

type Nk_config_stack_button_behavior_element = struct {
	Address   uintptr
	Old_value uint32
} /* nuklear.h:458:1 */

type Nk_config_stack_style_item = struct {
	Head     int32
	Elements [16]struct {
		Address   uintptr
		Old_value struct {
			Type uint32
			Data struct {
				Image struct {
					Handle Nk_handle
					W      uint16
					H      uint16
					Region [4]uint16
				}
			}
		}
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_float = struct {
	Head     int32
	Elements [32]struct {
		Address   uintptr
		Old_value float32
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_vec2 = struct {
	Head     int32
	Elements [16]struct {
		Address   uintptr
		Old_value struct {
			X float32
			Y float32
		}
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_flags = struct {
	Head     int32
	Elements [32]struct {
		Address   uintptr
		Old_value Nk_flags
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_color = struct {
	Head     int32
	Elements [32]struct {
		Address   uintptr
		Old_value struct {
			R Nk_byte
			G Nk_byte
			B Nk_byte
			A Nk_byte
		}
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_user_font = struct {
	Head     int32
	Elements [8]struct {
		Address   uintptr
		Old_value uintptr
	}
} /* nuklear.h:458:1 */

type Nk_config_stack_button_behavior = struct {
	Head     int32
	Elements [8]struct {
		Address   uintptr
		Old_value uint32
	}
} /* nuklear.h:458:1 */

type Nk_configuration_stacks = struct {
	Style_items struct {
		Head     int32
		Elements [16]struct {
			Address   uintptr
			Old_value struct {
				Type uint32
				Data struct {
					Image struct {
						Handle Nk_handle
						W      uint16
						H      uint16
						Region [4]uint16
					}
				}
			}
		}
	}
	Floats struct {
		Head     int32
		Elements [32]struct {
			Address   uintptr
			Old_value float32
		}
	}
	Vectors struct {
		Head     int32
		Elements [16]struct {
			Address   uintptr
			Old_value struct {
				X float32
				Y float32
			}
		}
	}
	Flags struct {
		Head     int32
		Elements [32]struct {
			Address   uintptr
			Old_value Nk_flags
		}
	}
	Colors struct {
		Head     int32
		Elements [32]struct {
			Address   uintptr
			Old_value struct {
				R Nk_byte
				G Nk_byte
				B Nk_byte
				A Nk_byte
			}
		}
	}
	Fonts struct {
		Head     int32
		Elements [8]struct {
			Address   uintptr
			Old_value uintptr
		}
	}
	Button_behaviors struct {
		Head     int32
		Elements [8]struct {
			Address   uintptr
			Old_value uint32
		}
	}
} /* nuklear.h:458:1 */

type Nk_page_data = struct {
	Tbl struct {
		Seq    uint32
		Size   uint32
		Keys   [51]Nk_hash
		Values [51]Nk_uint
		Next   uintptr
		Prev   uintptr
	}
} /* nuklear.h:458:1 */

type Nk_page_element = struct {
	Data struct {
		Tbl struct {
			Seq    uint32
			Size   uint32
			Keys   [51]Nk_hash
			Values [51]Nk_uint
			Next   uintptr
			Prev   uintptr
		}
	}
	Next uintptr
	Prev uintptr
} /* nuklear.h:458:1 */

type Nk_page = struct {
	Size uint32
	Next uintptr
	Win  [1]struct {
		Data struct {
			Tbl struct {
				Seq    uint32
				Size   uint32
				Keys   [51]Nk_hash
				Values [51]Nk_uint
				Next   uintptr
				Prev   uintptr
			}
		}
		Next uintptr
		Prev uintptr
	}
} /* nuklear.h:458:1 */

type Nk_pool = struct {
	Alloc struct {
		Userdata Nk_handle
		Alloc    Nk_plugin_alloc
		Free     Nk_plugin_free
	}
	Type       uint32
	Page_count uint32
	Pages      uintptr
	Freelist   uintptr
	Capacity   uint32
	Size       Nk_size
	Cap        Nk_size
} /* nuklear.h:458:1 */

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//    which causes a conflict if the include order is reversed.

type Idtype_t = uint32 /* waitflags.h:57:3 */
// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this
//    glibc includes corresponding *f128 interfaces for it.  The required
//    libgcc support was added some time after the basic compiler
//    support, for x86_64 and x86.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.

// The remaining of this file provides support for older compilers.

// The type _Float128 exists only since GCC 7.0.

// __builtin_huge_valf128 doesn't exist before GCC 7.0.

// Older GCC has only a subset of built-in functions for _Float128 on
//    x86, and __builtin_infq is not usable in static initializers.
//    Converting a narrower sNaN to _Float128 produces a quiet NaN, so
//    attempts to use _Float128 sNaNs will not work properly with older
//    compilers.

// In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
//    e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
//    been a __builtin_signbitf128 in GCC and the type-generic builtin is
//    only available since GCC 6.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type Div_t = struct {
	Quot int32
	Rem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type Ldiv_t = struct {
	Quot int32
	Rem  int32
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type Lldiv_t = struct {
	Quot int64
	Rem  int64
} /* stdlib.h:80:5 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type U_char = X__u_char     /* types.h:33:18 */
type U_short = X__u_short   /* types.h:34:19 */
type U_int = X__u_int       /* types.h:35:17 */
type U_long = X__u_long     /* types.h:36:18 */
type Quad_t = X__quad_t     /* types.h:37:18 */
type U_quad_t = X__u_quad_t /* types.h:38:20 */
type Fsid_t = X__fsid_t     /* types.h:39:18 */
type Loff_t = X__loff_t     /* types.h:42:18 */

type Ino_t = X__ino64_t /* types.h:49:19 */

type Dev_t = X__dev_t /* types.h:59:17 */

type Gid_t = X__gid_t /* types.h:64:17 */

type Mode_t = X__mode_t /* types.h:69:18 */

type Nlink_t = X__nlink_t /* types.h:74:19 */

type Uid_t = X__uid_t /* types.h:79:17 */

type Off_t = X__off64_t /* types.h:87:19 */

type Pid_t = X__pid_t /* types.h:97:17 */

type Id_t = X__id_t /* types.h:103:16 */

type Ssize_t = X__ssize_t /* types.h:108:19 */

type Daddr_t = X__daddr_t /* types.h:114:19 */
type Caddr_t = X__caddr_t /* types.h:115:19 */

type Key_t = X__key_t /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Clock_t = X__clock_t /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Clockid_t = X__clockid_t /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Time_t = X__time_t /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Timer_t = X__timer_t /* timer_t.h:7:19 */

// Copyright (C) 1989-2019 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type Ulong = uint32  /* types.h:148:27 */
type Ushort = uint16 /* types.h:149:28 */
type Uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These were defined by ISO C without the first `_'.
type U_int8_t = X__uint8_t   /* types.h:158:19 */
type U_int16_t = X__uint16_t /* types.h:159:20 */
type U_int32_t = X__uint32_t /* types.h:160:20 */
type U_int64_t = X__uint64_t /* types.h:161:20 */

type Register_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Get sigset_t.

type X__sigset_t = struct{ X__val [32]uint32 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Sigset_t = X__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//    microsecond but also has a range of years.
type Timeval = struct {
	Tv_sec  X__time_t
	Tv_usec X__suseconds_t
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//    has nanoseconds instead of microseconds.
type Timespec = struct {
	Tv_sec  X__time_t
	Tv_nsec X__syscall_slong_t
} /* struct_timespec.h:10:1 */

type Suseconds_t = X__suseconds_t /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type X__fd_mask = int32 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Fd_set = struct{ X__fds_bits [32]X__fd_mask } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Fd_mask = X__fd_mask /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Blksize_t = X__blksize_t /* types.h:185:21 */

// Types from the Large File Support interface.
type Blkcnt_t = X__blkcnt64_t     /* types.h:205:22 */ // Type to count number of disk blocks.
type Fsblkcnt_t = X__fsblkcnt64_t /* types.h:209:24 */ // Type to count file system blocks.
type Fsfilcnt_t = X__fsfilcnt64_t /* types.h:213:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Common definition of pthread_mutex_t.

type X__pthread_internal_list = struct {
	X__prev uintptr
	X__next uintptr
} /* thread-shared-types.h:49:9 */

// Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Common definition of pthread_mutex_t.

type X__pthread_list_t = X__pthread_internal_list /* thread-shared-types.h:53:3 */

type X__pthread_internal_slist = struct{ X__next uintptr } /* thread-shared-types.h:55:9 */

type X__pthread_slist_t = X__pthread_internal_slist /* thread-shared-types.h:58:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type X__pthread_mutex_s = struct {
	X__lock    int32
	X__count   uint32
	X__owner   int32
	X__nusers  uint32
	X__kind    int32
	X__spins   int16
	X__elision int16
	X__list    X__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2020 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type X__pthread_rwlock_arch_t = struct {
	X__readers       uint32
	X__writers       uint32
	X__wrphase_futex uint32
	X__writers_futex uint32
	X__pad3          uint32
	X__pad4          uint32
	X__cur_writer    int32
	X__shared        int32
	X__rwelision     int8
	X__pad1          [7]uint8
	X__pad2          uint32
	X__flags         uint32
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type X__pthread_cond_s = struct {
	X__0            struct{ X__wseq uint64 }
	X__8            struct{ X__g1_start uint64 }
	X__g_refs       [2]uint32
	X__g_size       [2]uint32
	X__g1_orig_size uint32
	X__wrefs        uint32
	X__g_signals    [2]uint32
} /* thread-shared-types.h:92:1 */

// Thread identifiers.  The structure of the attribute type is not
//    exposed on purpose.
type Pthread_t = uint32 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//    type is not exposed on purpose.
type Pthread_mutexattr_t = struct {
	_       [0]uint32
	X__size [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//    the attribute type is not exposed on purpose.
type Pthread_condattr_t = struct {
	_       [0]uint32
	X__size [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Pthread_attr_t1 = struct {
	_       [0]uint32
	X__size [56]int8
} /* pthreadtypes.h:56:1 */

type Pthread_attr_t = Pthread_attr_t1 /* pthreadtypes.h:62:30 */

type Pthread_mutex_t = struct {
	X__data X__pthread_mutex_s
	_       [8]byte
} /* pthreadtypes.h:72:3 */

type Pthread_cond_t = struct{ X__data X__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//    structure of the attribute type is deliberately not exposed.
type Pthread_rwlock_t = struct {
	X__data X__pthread_rwlock_arch_t
	_       [8]byte
} /* pthreadtypes.h:91:3 */

type Pthread_rwlockattr_t = struct {
	_       [0]uint32
	X__size [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//    deliberately not exposed.
type Pthread_barrier_t = struct {
	_       [0]uint32
	X__size [32]int8
} /* pthreadtypes.h:112:3 */

type Pthread_barrierattr_t = struct {
	_       [0]uint32
	X__size [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Random_data = struct {
	Fptr      uintptr
	Rptr      uintptr
	State     uintptr
	Rand_type int32
	Rand_deg  int32
	Rand_sep  int32
	End_ptr   uintptr
} /* stdlib.h:423:1 */

// Data structure for communication with thread safe versions.  This
//    type is to be regarded as opaque.  It's only exported because users
//    have to allocate objects of this type.
type Drand48_data = struct {
	X__x     [3]uint16
	X__old_x [3]uint16
	X__c     uint16
	X__init  uint16
	X__a     uint64
} /* stdlib.h:490:1 */

// Shorthand for type of comparison functions.
type X__compar_fn_t = uintptr /* stdlib.h:808:13 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// If your compiler does support `vsnprintf` I would highly recommend
// defining this to vsnprintf instead since `vsprintf` is basically
// unbelievable unsafe and should *NEVER* be used. But I have to support
// it since C89 only provides this unsafe version.

// Make sure correct type size:
// This will fire with a negative subscript error if the type sizes
// are set incorrectly by the compiler, and compile out if not
type X_dummy_array5772 = [1]int8 /* nuklear.h:5772:1 */
type X_dummy_array5773 = [1]int8 /* nuklear.h:5773:1 */
type X_dummy_array5774 = [1]int8 /* nuklear.h:5774:1 */
type X_dummy_array5775 = [1]int8 /* nuklear.h:5775:1 */
type X_dummy_array5776 = [1]int8 /* nuklear.h:5776:1 */
type X_dummy_array5777 = [1]int8 /* nuklear.h:5777:1 */
type X_dummy_array5778 = [1]int8 /* nuklear.h:5778:1 */
type X_dummy_array5779 = [1]int8 /* nuklear.h:5779:1 */
type X_dummy_array5780 = [1]int8 /* nuklear.h:5780:1 */
type X_dummy_array5784 = [1]int8 /* nuklear.h:5784:1 */

var nk_null_rect = Nk_rect{X: -8192.0, Y: -8192.0, W: float32(16384), H: float32(16384)}    /* nuklear.h:5787:32 */
var nk_white = Nk_color{R: Nk_byte(255), G: Nk_byte(255), B: Nk_byte(255), A: Nk_byte(255)} /* nuklear.h:5793:33 */

// text
type Nk_text = struct {
	Padding struct {
		X float32
		Y float32
	}
	Background struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
	Text struct {
		R Nk_byte
		G Nk_byte
		B Nk_byte
		A Nk_byte
	}
} /* nuklear.h:5934:1 */

type Nk_property = struct {
	I int32
	_ [4]byte
} /* nuklear.h:6012:1 */

type Nk_property_variant = struct {
	Kind  uint32
	Value struct {
		I int32
		_ [4]byte
	}
	Min_value struct {
		I int32
		_ [4]byte
	}
	Max_value struct {
		I int32
		_ [4]byte
	}
	Step struct {
		I int32
		_ [4]byte
	}
} /* nuklear.h:6017:1 */

// Allow consumer to define own STBTT_malloc/STBTT_free, and use the font atlas' allocator otherwise
func nk_stbtt_malloc(size Nk_size, user_data uintptr) uintptr { /* nuklear.h:6041:12: */
	var alloc uintptr = user_data
	return (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((alloc + 4 /* &.alloc */))))((*Nk_allocator)(unsafe.Pointer(alloc)).Userdata, uintptr(0), size)
}

func nk_stbtt_free(ptr uintptr, user_data uintptr) { /* nuklear.h:6048:1: */
	var alloc uintptr = user_data
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((alloc + 8 /* &.free */))))((*Nk_allocator)(unsafe.Pointer(alloc)).Userdata, ptr)
}

// ===============================================================
//
//                              MATH
//
// ===============================================================
//  Since nuklear is supposed to work on all systems providing floating point
//     math without any dependencies I also had to implement my own math functions
//     for sqrt, sin and cos. Since the actual highly accurate implementations for
//     the standard library functions are quite complex and I do not need high
//     precision for my use cases I use approximations.
//
//     Sqrt
//     ----
//     For square root nuklear uses the famous fast inverse square root:
//     https://en.wikipedia.org/wiki/Fast_inverse_square_root with
//     slightly tweaked magic constant. While on today's hardware it is
//     probably not faster it is still fast and accurate enough for
//     nuklear's use cases. IMPORTANT: this requires float format IEEE 754
//
//     Sine/Cosine
//     -----------
//     All constants inside both function are generated Remez's minimax
//     approximations for value range 0...2*PI. The reason why I decided to
//     approximate exactly that range is that nuklear only needs sine and
//     cosine to generate circles which only requires that exact range.
//     In addition I used Remez instead of Taylor for additional precision:
//     www.lolengine.net/blog/2011/12/21/better-function-approximations.
//
//     The tool I used to generate constants for both sine and cosine
//     (it can actually approximate a lot more functions) can be
//     found here: www.lolengine.net/wiki/oss/lolremez
func nk_inv_sqrt(n float32) float32 { /* nuklear.h:6099:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var x2 float32
	var threehalfs float32 = 1.5
	*(*struct{ I Nk_uint })(unsafe.Pointer(bp /* conv */)) = struct{ I Nk_uint }{}
	*(*float32)(unsafe.Pointer(bp /* &conv */)) = n
	x2 = (n * 0.5)
	*(*Nk_uint)(unsafe.Pointer(bp /* &conv */)) = (Nk_uint(0x5f375A84) - (*(*Nk_uint)(unsafe.Pointer(bp /* &conv */)) >> 1))
	*(*float32)(unsafe.Pointer(bp /* &conv */)) = (*(*float32)(unsafe.Pointer(bp /* &conv */)) * (threehalfs - ((x2 * *(*float32)(unsafe.Pointer(bp /* &conv */))) * *(*float32)(unsafe.Pointer(bp /* &conv */)))))
	return *(*float32)(unsafe.Pointer(bp /* &conv */))
}

func nk_sin(x float32) float32 { /* nuklear.h:6113:1: */
	return (a0 + (x * (a1 + (x * (a2 + (x * (a3 + (x * (a4 + (x * (a5 + (x * (a6 + (x * a7))))))))))))))
}

var a0 float32 = +1.91059300966915117e-31 /* nuklear.h:6115:28 */
var a1 float32 = +1.00086760103908896     /* nuklear.h:6116:28 */
var a2 float32 = -1.21276126894734565e-2  /* nuklear.h:6117:28 */
var a3 float32 = -1.38078780785773762e-1  /* nuklear.h:6118:28 */
var a4 float32 = -2.67353392911981221e-2  /* nuklear.h:6119:28 */
var a5 float32 = +2.08026600266304389e-2  /* nuklear.h:6120:28 */
var a6 float32 = -3.03996055049204407e-3  /* nuklear.h:6121:28 */
var a7 float32 = +1.38235642404333740e-4  /* nuklear.h:6122:28 */

func nk_cos(x float32) float32 { /* nuklear.h:6129:1: */
	return (a01 + (x * (a11 + (x * (a21 + (x * (a31 + (x * (a41 + (x * (a51 + (x * (a61 + (x * (a71 + (x * a8))))))))))))))))
}

var a01 float32 = 9.9995999154986614e-1  /* nuklear.h:6133:28 */
var a11 float32 = 1.2548995793001028e-3  /* nuklear.h:6134:28 */
var a21 float32 = -5.0648546280678015e-1 /* nuklear.h:6135:28 */
var a31 float32 = 1.2942246466519995e-2  /* nuklear.h:6136:28 */
var a41 float32 = 2.8668384702547972e-2  /* nuklear.h:6137:28 */
var a51 float32 = 7.3726485210586547e-3  /* nuklear.h:6138:28 */
var a61 float32 = -3.8510875386947414e-3 /* nuklear.h:6139:28 */
var a71 float32 = 4.7196604604366623e-4  /* nuklear.h:6140:28 */
var a8 float32 = -1.8776444013090451e-5  /* nuklear.h:6141:28 */

func nk_round_up_pow2(v Nk_uint) Nk_uint { /* nuklear.h:6146:1: */
	v--
	v = v | (v >> 1)
	v = v | (v >> 2)
	v = v | (v >> 4)
	v = v | (v >> 8)
	v = v | (v >> 16)
	v++
	return v
}

func nk_pow(x float64, n int32) float64 { /* nuklear.h:6158:1: */
	//  check the sign of n
	var r float64 = float64(1)
	var plus int32 = (Bool32(n >= 0))
	if plus != 0 {
		n = n
	} else {
		n = -n
	}
	for n > 0 {
		if (n & 1) == 1 {
			r = r * (x)
		}
		n = n / (2)
		x = x * (x)
	}
	if plus != 0 {
		return r
	}
	return (1.0 / r)
}

func nk_ifloord(x float64) int32 { /* nuklear.h:6173:1: */
	x = (float64(int32(x) - (func() int32 {
		if x < 0.0 {
			return 1
		}
		return 0
	}())))
	return int32(x)
}

func nk_ifloorf(x float32) int32 { /* nuklear.h:6179:1: */
	x = (float32(int32(x) - (func() int32 {
		if x < 0.0 {
			return 1
		}
		return 0
	}())))
	return int32(x)
}

func nk_iceilf(x float32) int32 { /* nuklear.h:6185:1: */
	if x >= float32(0) {
		var i int32 = int32(x)
		if x > float32(i) {
			return (i + 1)
		}
		return i
	} else {
		var t int32 = int32(x)
		var r float32 = (x - float32(t))
		if r > 0.0 {
			return (t + 1)
		}
		return t
	}
	return int32(0)
}

func nk_log10(n float64) int32 { /* nuklear.h:6197:1: */
	var neg int32
	var ret int32
	var exp int32 = 0

	if n < float64(0) {
		neg = 1
	} else {
		neg = 0
	}
	if neg != 0 {
		ret = int32(-n)
	} else {
		ret = int32(n)
	}
	for (ret / 10) > 0 {
		ret = ret / (10)
		exp++
	}
	if neg != 0 {
		exp = -exp
	}
	return exp
}

func Xnk_get_null_rect() Nk_rect { /* nuklear.h:6213:1: */
	return nk_null_rect
}

func Xnk_rect(x float32, y float32, w float32, h float32) Nk_rect { /* nuklear.h:6218:1: */
	var r Nk_rect
	r.X = x
	r.Y = y
	r.W = w
	r.H = h
	return r
}

func Xnk_recti(x int32, y int32, w int32, h int32) Nk_rect { /* nuklear.h:6226:1: */
	var r Nk_rect
	r.X = float32(x)
	r.Y = float32(y)
	r.W = float32(w)
	r.H = float32(h)
	return r
}

func Xnk_recta(pos Nk_vec2, size Nk_vec2) Nk_rect { /* nuklear.h:6236:1: */
	return Xnk_rect(pos.X, pos.Y, size.X, size.Y)
}

func Xnk_rectv(r uintptr) Nk_rect { /* nuklear.h:6241:1: */
	return Xnk_rect(*(*float32)(unsafe.Pointer(r)), *(*float32)(unsafe.Pointer(r + 1*4)), *(*float32)(unsafe.Pointer(r + 2*4)), *(*float32)(unsafe.Pointer(r + 3*4)))
}

func Xnk_rectiv(r uintptr) Nk_rect { /* nuklear.h:6246:1: */
	return Xnk_recti(*(*int32)(unsafe.Pointer(r)), *(*int32)(unsafe.Pointer(r + 1*4)), *(*int32)(unsafe.Pointer(r + 2*4)), *(*int32)(unsafe.Pointer(r + 3*4)))
}

func Xnk_rect_pos(r Nk_rect) Nk_vec2 { /* nuklear.h:6251:1: */
	var ret Nk_vec2
	ret.X = r.X
	ret.Y = r.Y
	return ret
}

func Xnk_rect_size(r Nk_rect) Nk_vec2 { /* nuklear.h:6258:1: */
	var ret Nk_vec2
	ret.X = r.W
	ret.Y = r.H
	return ret
}

func nk_shrink_rect(r Nk_rect, amount float32) Nk_rect { /* nuklear.h:6265:1: */
	var res Nk_rect
	r.W = func() float32 {
		if (r.W) < (float32(2) * amount) {
			return (float32(2) * amount)
		}
		return r.W
	}()
	r.H = func() float32 {
		if (r.H) < (float32(2) * amount) {
			return (float32(2) * amount)
		}
		return r.H
	}()
	res.X = (r.X + amount)
	res.Y = (r.Y + amount)
	res.W = (r.W - (float32(2) * amount))
	res.H = (r.H - (float32(2) * amount))
	return res
}

func nk_pad_rect(r Nk_rect, pad Nk_vec2) Nk_rect { /* nuklear.h:6277:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_rect)(unsafe.Pointer(bp)) = r

	(*Nk_rect)(unsafe.Pointer(bp /* &r */)).W = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &r */)).W) < (float32(2) * pad.X) {
			return (float32(2) * pad.X)
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &r */)).W
	}()
	(*Nk_rect)(unsafe.Pointer(bp /* &r */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &r */)).H) < (float32(2) * pad.Y) {
			return (float32(2) * pad.Y)
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &r */)).H
	}()
	*(*float32)(unsafe.Pointer(bp /* &r */ /* &.x */)) += (pad.X)
	*(*float32)(unsafe.Pointer(bp /* &r */ + 4 /* &.y */)) += (pad.Y)
	*(*float32)(unsafe.Pointer(bp /* &r */ + 8 /* &.w */)) -= (float32(2) * pad.X)
	*(*float32)(unsafe.Pointer(bp /* &r */ + 12 /* &.h */)) -= (float32(2) * pad.Y)
	return *(*Nk_rect)(unsafe.Pointer(bp /* r */))
}

func Xnk_vec2(x float32, y float32) Nk_vec2 { /* nuklear.h:6287:1: */
	var ret Nk_vec2
	ret.X = x
	ret.Y = y
	return ret
}

func Xnk_vec2i(x int32, y int32) Nk_vec2 { /* nuklear.h:6294:1: */
	var ret Nk_vec2
	ret.X = float32(x)
	ret.Y = float32(y)
	return ret
}

func Xnk_vec2v(v uintptr) Nk_vec2 { /* nuklear.h:6302:1: */
	return Xnk_vec2(*(*float32)(unsafe.Pointer(v)), *(*float32)(unsafe.Pointer(v + 1*4)))
}

func Xnk_vec2iv(v uintptr) Nk_vec2 { /* nuklear.h:6307:1: */
	return Xnk_vec2i(*(*int32)(unsafe.Pointer(v)), *(*int32)(unsafe.Pointer(v + 1*4)))
}

func nk_unify(clip uintptr, a uintptr, x0 float32, y0 float32, x1 float32, y1 float32) { /* nuklear.h:6312:1: */
	if a != 0 {
	} else {
		X__assert_fail(ts /* "a" */, ts+2 /* "nuklear/nuklear...." */, uint32(6315), uintptr(unsafe.Pointer(&__func__)))
	}
	if clip != 0 {
	} else {
		X__assert_fail(ts+20 /* "clip" */, ts+2 /* "nuklear/nuklear...." */, uint32(6316), uintptr(unsafe.Pointer(&__func__)))
	}
	(*Nk_rect)(unsafe.Pointer(clip)).X = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(a)).X) < (x0) {
			return x0
		}
		return (*Nk_rect)(unsafe.Pointer(a)).X
	}()
	(*Nk_rect)(unsafe.Pointer(clip)).Y = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(a)).Y) < (y0) {
			return y0
		}
		return (*Nk_rect)(unsafe.Pointer(a)).Y
	}()
	(*Nk_rect)(unsafe.Pointer(clip)).W = ((func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(a)).X + (*Nk_rect)(unsafe.Pointer(a)).W) < (x1) {
			return ((*Nk_rect)(unsafe.Pointer(a)).X + (*Nk_rect)(unsafe.Pointer(a)).W)
		}
		return x1
	}()) - (*Nk_rect)(unsafe.Pointer(clip)).X)
	(*Nk_rect)(unsafe.Pointer(clip)).H = ((func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(a)).Y + (*Nk_rect)(unsafe.Pointer(a)).H) < (y1) {
			return ((*Nk_rect)(unsafe.Pointer(a)).Y + (*Nk_rect)(unsafe.Pointer(a)).H)
		}
		return y1
	}()) - (*Nk_rect)(unsafe.Pointer(clip)).Y)
	(*Nk_rect)(unsafe.Pointer(clip)).W = func() float32 {
		if (float32(0)) < ((*Nk_rect)(unsafe.Pointer(clip)).W) {
			return (*Nk_rect)(unsafe.Pointer(clip)).W
		}
		return float32(0)
	}()
	(*Nk_rect)(unsafe.Pointer(clip)).H = func() float32 {
		if (float32(0)) < ((*Nk_rect)(unsafe.Pointer(clip)).H) {
			return (*Nk_rect)(unsafe.Pointer(clip)).H
		}
		return float32(0)
	}()
}

var __func__ = *(*[9]int8)(unsafe.Pointer(ts + 25 /* "nk_unify" */)) /* nuklear.h:6314:1 */

func Xnk_triangle_from_direction(result uintptr, r Nk_rect, pad_x float32, pad_y float32, direction uint32) { /* nuklear.h:6326:1: */
	var w_half float32
	var h_half float32
	if result != 0 {
	} else {
		X__assert_fail(ts+34 /* "result" */, ts+2 /* "nuklear/nuklear...." */, uint32(6330), uintptr(unsafe.Pointer(&__func__1)))
	}

	r.W = func() float32 {
		if (float32(2) * pad_x) < (r.W) {
			return r.W
		}
		return (float32(2) * pad_x)
	}()
	r.H = func() float32 {
		if (float32(2) * pad_y) < (r.H) {
			return r.H
		}
		return (float32(2) * pad_y)
	}()
	r.W = (r.W - (float32(2) * pad_x))
	r.H = (r.H - (float32(2) * pad_y))

	r.X = (r.X + pad_x)
	r.Y = (r.Y + pad_y)

	w_half = (r.W / 2.0)
	h_half = (r.H / 2.0)

	if int32(direction) == NK_UP {
		*(*Nk_vec2)(unsafe.Pointer(result)) = Xnk_vec2((r.X + w_half), r.Y)
		*(*Nk_vec2)(unsafe.Pointer(result + 1*8)) = Xnk_vec2((r.X + r.W), (r.Y + r.H))
		*(*Nk_vec2)(unsafe.Pointer(result + 2*8)) = Xnk_vec2(r.X, (r.Y + r.H))
	} else if int32(direction) == NK_RIGHT {
		*(*Nk_vec2)(unsafe.Pointer(result)) = Xnk_vec2(r.X, r.Y)
		*(*Nk_vec2)(unsafe.Pointer(result + 1*8)) = Xnk_vec2((r.X + r.W), (r.Y + h_half))
		*(*Nk_vec2)(unsafe.Pointer(result + 2*8)) = Xnk_vec2(r.X, (r.Y + r.H))
	} else if int32(direction) == NK_DOWN {
		*(*Nk_vec2)(unsafe.Pointer(result)) = Xnk_vec2(r.X, r.Y)
		*(*Nk_vec2)(unsafe.Pointer(result + 1*8)) = Xnk_vec2((r.X + r.W), r.Y)
		*(*Nk_vec2)(unsafe.Pointer(result + 2*8)) = Xnk_vec2((r.X + w_half), (r.Y + r.H))
	} else {
		*(*Nk_vec2)(unsafe.Pointer(result)) = Xnk_vec2(r.X, (r.Y + h_half))
		*(*Nk_vec2)(unsafe.Pointer(result + 1*8)) = Xnk_vec2((r.X + r.W), r.Y)
		*(*Nk_vec2)(unsafe.Pointer(result + 2*8)) = Xnk_vec2((r.X + r.W), (r.Y + r.H))
	}
}

var __func__1 = *(*[27]int8)(unsafe.Pointer(ts + 41 /* "nk_triangle_from..." */)) /* nuklear.h:6328:1 */

func nk_is_lower(c int32) Nk_bool { /* nuklear.h:6373:16: */
	return (Bool32(((c >= 'a') && (c <= 'z')) || ((c >= 0xE0) && (c <= 0xFF))))
}

func nk_is_upper(c int32) Nk_bool { /* nuklear.h:6374:16: */
	return (Bool32(((c >= 'A') && (c <= 'Z')) || ((c >= 0xC0) && (c <= 0xDF))))
}

func nk_to_upper(c int32) int32 { /* nuklear.h:6375:12: */
	if (c >= 'a') && (c <= 'z') {
		return (c - ('a' - 'A'))
	}
	return c
}

func nk_to_lower(c int32) int32 { /* nuklear.h:6376:12: */
	if (c >= 'A') && (c <= 'Z') {
		return (c - ('a' + 'A'))
	}
	return c
}

func nk_memcopy(dst0 uintptr, src0 uintptr, length Nk_size) uintptr { /* nuklear.h:6380:12: */
	var t Nk_ptr
	var dst uintptr
	var src uintptr
	dst = dst0
	src = src0
	if !((length == Nk_size(0)) || (dst == src)) {
		goto __1
	}
	goto done
__1:
	;

	if !(dst < src) {
		goto __2
	}
	t = Nk_ptr(src) // only need low bits
	if !(((t | Nk_ptr(dst)) & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))) != 0) {
		goto __4
	}
	if !((((t ^ Nk_ptr(dst)) & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))) != 0) || (length < Nk_size(unsafe.Sizeof(int32(0))))) {
		goto __5
	}
	t = length
	goto __6
__5:
	t = (uint32(unsafe.Sizeof(int32(0))) - (t & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))))
__6:
	;
	length = length - (t)
__7:
	*(*int8)(unsafe.Pointer(PostIncUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(PostIncUintptr(&src, 1)))
	goto __8
__8:
	if PreDecUint32(&t, 1) != 0 {
		goto __7
	}
	goto __9
__9:
	;
__4:
	;
	t = (length / Nk_size(unsafe.Sizeof(int32(0))))
	if !(t != 0) {
		goto __10
	}
__11:
	*(*int32)(unsafe.Pointer(dst)) = *(*int32)(unsafe.Pointer(src))
	src += uintptr(unsafe.Sizeof(int32(0)))
	dst += uintptr(unsafe.Sizeof(int32(0)))
	goto __12
__12:
	if PreDecUint32(&t, 1) != 0 {
		goto __11
	}
	goto __13
__13:
	;
__10:
	;
	t = (length & (uint32(unsafe.Sizeof(int32(0))) - uint32(1)))
	if !(t != 0) {
		goto __14
	}
__15:
	*(*int8)(unsafe.Pointer(PostIncUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(PostIncUintptr(&src, 1)))
	goto __16
__16:
	if PreDecUint32(&t, 1) != 0 {
		goto __15
	}
	goto __17
__17:
	;
__14:
	;
	goto __3
__2:
	src += uintptr(length)
	dst += uintptr(length)
	t = Nk_ptr(src)
	if !(((t | Nk_ptr(dst)) & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))) != 0) {
		goto __18
	}
	if !((((t ^ Nk_ptr(dst)) & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))) != 0) || (length <= Nk_size(unsafe.Sizeof(int32(0))))) {
		goto __19
	}
	t = length
	goto __20
__19:
	t = t & (uint32(unsafe.Sizeof(int32(0))) - uint32(1))
__20:
	;
	length = length - (t)
__21:
	*(*int8)(unsafe.Pointer(PreDecUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(PreDecUintptr(&src, 1)))
	goto __22
__22:
	if PreDecUint32(&t, 1) != 0 {
		goto __21
	}
	goto __23
__23:
	;
__18:
	;
	t = (length / Nk_size(unsafe.Sizeof(int32(0))))
	if !(t != 0) {
		goto __24
	}
__25:
	src -= uintptr(unsafe.Sizeof(int32(0)))
	dst -= uintptr(unsafe.Sizeof(int32(0)))
	*(*int32)(unsafe.Pointer(dst)) = *(*int32)(unsafe.Pointer(src))
	goto __26
__26:
	if PreDecUint32(&t, 1) != 0 {
		goto __25
	}
	goto __27
__27:
	;
__24:
	;
	t = (length & (uint32(unsafe.Sizeof(int32(0))) - uint32(1)))
	if !(t != 0) {
		goto __28
	}
__29:
	*(*int8)(unsafe.Pointer(PreDecUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(PreDecUintptr(&src, 1)))
	goto __30
__30:
	if PreDecUint32(&t, 1) != 0 {
		goto __29
	}
	goto __31
__31:
	;
__28:
	;
__3:
	;
done:
	return dst0
}

func nk_memset(ptr uintptr, c0 int32, size Nk_size) { /* nuklear.h:6440:1: */
	var dst uintptr = ptr
	var c uint32 = uint32(0)
	var t Nk_size = Nk_size(0)

	if (AssignUint32(&c, uint32(Nk_byte(c0)))) != uint32(0) {
		c = ((c << 8) | c) // at least 16-bits
		if uint32(unsafe.Sizeof(uint32(0))) > uint32(2) {
			c = ((c << 16) | c)
		} // at least 32-bits
	}

	// too small of a word count
	dst = ptr
	if size < (uint32(3) * uint32(unsafe.Sizeof(uint32(0)))) {
		for PostDecUint32(&size, 1) != 0 {
			*(*Nk_byte)(unsafe.Pointer(PostIncUintptr(&dst, 1))) = Nk_byte(c0)
		}
		return
	}

	// align destination
	if (AssignUint32(&t, ((Nk_size(dst)) & (uint32(unsafe.Sizeof(uint32(0))) - uint32(1))))) != Nk_size(0) {
		t = (uint32(unsafe.Sizeof(uint32(0))) - t)
		size = size - (t)
		for ok := true; ok; ok = (PreDecUint32(&t, 1) != Nk_size(0)) {
			*(*Nk_byte)(unsafe.Pointer(PostIncUintptr(&dst, 1))) = Nk_byte(c0)
		}
	}

	// fill word
	t = (size / Nk_size(unsafe.Sizeof(uint32(0))))
	for ok1 := true; ok1; ok1 = (PreDecUint32(&t, 1) != Nk_size(0)) {
		*(*uint32)(unsafe.Pointer(dst)) = c
		dst += uintptr(unsafe.Sizeof(uint32(0)))
	}

	// fill trailing bytes
	t = (size & (uint32(unsafe.Sizeof(uint32(0))) - uint32(1)))
	if t != Nk_size(0) {
		for ok2 := true; ok2; ok2 = (PreDecUint32(&t, 1) != Nk_size(0)) {
			*(*Nk_byte)(unsafe.Pointer(PostIncUintptr(&dst, 1))) = Nk_byte(c0)
		}
	}

}

func nk_zero(ptr uintptr, size Nk_size) { /* nuklear.h:6492:1: */
	if ptr != 0 {
	} else {
		X__assert_fail(ts+68 /* "ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(6494), uintptr(unsafe.Pointer(&__func__2)))
	}
	nk_memset(ptr, 0, size)
}

var __func__2 = *(*[8]int8)(unsafe.Pointer(ts + 72 /* "nk_zero" */)) /* nuklear.h:6493:1 */

func Xnk_strlen(str uintptr) int32 { /* nuklear.h:6498:1: */
	var siz int32 = 0
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(6501), uintptr(unsafe.Pointer(&__func__3)))
	}
	for (str != 0) && (int32(*(*int8)(unsafe.Pointer(PostIncUintptr(&str, 1)))) != 0) {
		siz++
	}
	return siz
}

var __func__3 = *(*[10]int8)(unsafe.Pointer(ts + 84 /* "nk_strlen" */)) /* nuklear.h:6499:1 */

func Xnk_strtoi(str uintptr, endptr uintptr) int32 { /* nuklear.h:6506:1: */
	var neg int32 = 1
	var p uintptr = str
	var value int32 = 0

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(6512), uintptr(unsafe.Pointer(&__func__4)))
	}
	if !(str != 0) {
		return 0
	}

	// skip whitespace
	for int32(*(*int8)(unsafe.Pointer(p))) == ' ' {
		p++
	}
	if int32(*(*int8)(unsafe.Pointer(p))) == '-' {
		neg = -1
		p++
	}
	for ((*(*int8)(unsafe.Pointer(p)) != 0) && (int32(*(*int8)(unsafe.Pointer(p))) >= '0')) && (int32(*(*int8)(unsafe.Pointer(p))) <= '9') {
		value = ((value * 10) + (int32(*(*int8)(unsafe.Pointer(p))) - '0'))
		p++
	}
	if endptr != 0 {
		*(*uintptr)(unsafe.Pointer(endptr)) = p
	}
	return (neg * value)
}

var __func__4 = *(*[10]int8)(unsafe.Pointer(ts + 94 /* "nk_strtoi" */)) /* nuklear.h:6507:1 */

func Xnk_strtod(str uintptr, endptr uintptr) float64 { /* nuklear.h:6530:1: */
	var m float64
	var neg float64 = 1.0
	var p uintptr = str
	var value float64 = float64(0)
	var number float64 = float64(0)

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(6538), uintptr(unsafe.Pointer(&__func__5)))
	}
	if !(str != 0) {
		return float64(0)
	}

	// skip whitespace
	for int32(*(*int8)(unsafe.Pointer(p))) == ' ' {
		p++
	}
	if int32(*(*int8)(unsafe.Pointer(p))) == '-' {
		neg = -1.0
		p++
	}

	for ((*(*int8)(unsafe.Pointer(p)) != 0) && (int32(*(*int8)(unsafe.Pointer(p))) != '.')) && (int32(*(*int8)(unsafe.Pointer(p))) != 'e') {
		value = ((value * 10.0) + (float64(int32(*(*int8)(unsafe.Pointer(p))) - '0')))
		p++
	}

	if int32(*(*int8)(unsafe.Pointer(p))) == '.' {
		p++
		for m = 0.1; (*(*int8)(unsafe.Pointer(p)) != 0) && (int32(*(*int8)(unsafe.Pointer(p))) != 'e'); p++ {
			value = (value + ((float64(int32(*(*int8)(unsafe.Pointer(p))) - '0')) * m))
			m = m * (0.1)
		}
	}
	if int32(*(*int8)(unsafe.Pointer(p))) == 'e' {
		var i int32
		var pow int32
		var div int32
		p++
		if int32(*(*int8)(unsafe.Pointer(p))) == '-' {
			div = Nk_true
			p++
		} else if int32(*(*int8)(unsafe.Pointer(p))) == '+' {
			div = Nk_false
			p++
		} else {
			div = Nk_false
		}

		for pow = 0; *(*int8)(unsafe.Pointer(p)) != 0; p++ {
			pow = ((pow * 10) + (int32(*(*int8)(unsafe.Pointer(p))) - '0'))
		}

		m = 1.0
		i = 0
		for ; i < pow; i++ {
			m = m * (10.0)
		}

		if div != 0 {
			value = value / (m)
		} else {
			value = value * (m)
		}
	}
	number = (value * neg)
	if endptr != 0 {
		*(*uintptr)(unsafe.Pointer(endptr)) = p
	}
	return number
}

var __func__5 = *(*[10]int8)(unsafe.Pointer(ts + 104 /* "nk_strtod" */)) /* nuklear.h:6531:1 */

func Xnk_strtof(str uintptr, endptr uintptr) float32 { /* nuklear.h:6587:1: */
	var float_value float32
	var double_value float64
	double_value = Xnk_strtod(str, endptr)
	float_value = float32(double_value)
	return float_value
}

func Xnk_stricmp(s1 uintptr, s2 uintptr) int32 { /* nuklear.h:6596:1: */
	var c1 Nk_int
	var c2 Nk_int
	var d Nk_int
	for ok := true; ok; ok = c1 != 0 {
		c1 = Nk_int(*(*int8)(unsafe.Pointer(PostIncUintptr(&s1, 1))))
		c2 = Nk_int(*(*int8)(unsafe.Pointer(PostIncUintptr(&s2, 1))))
		d = (c1 - c2)
		for d != 0 {
			if (c1 <= 'Z') && (c1 >= 'A') {
				d = d + ('a' - 'A')
				if !(d != 0) {
					break
				}
			}
			if (c2 <= 'Z') && (c2 >= 'A') {
				d = d - ('a' - 'A')
				if !(d != 0) {
					break
				}
			}
			return (((Bool32(d >= 0)) << 1) - 1)
		}
	}
	return 0
}

func Xnk_stricmpn(s1 uintptr, s2 uintptr, n int32) int32 { /* nuklear.h:6618:1: */
	var c1 int32
	var c2 int32
	var d int32
	if n >= 0 {
	} else {
		X__assert_fail(ts+114 /* "n >= 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(6621), uintptr(unsafe.Pointer(&__func__6)))
	}
	for ok := true; ok; ok = c1 != 0 {
		c1 = int32(*(*int8)(unsafe.Pointer(PostIncUintptr(&s1, 1))))
		c2 = int32(*(*int8)(unsafe.Pointer(PostIncUintptr(&s2, 1))))
		if !(PostDecInt32(&n, 1) != 0) {
			return 0
		}

		d = (c1 - c2)
		for d != 0 {
			if (c1 <= 'Z') && (c1 >= 'A') {
				d = d + ('a' - 'A')
				if !(d != 0) {
					break
				}
			}
			if (c2 <= 'Z') && (c2 >= 'A') {
				d = d - ('a' - 'A')
				if !(d != 0) {
					break
				}
			}
			return (((Bool32(d >= 0)) << 1) - 1)
		}
	}
	return 0
}

var __func__6 = *(*[12]int8)(unsafe.Pointer(ts + 121 /* "nk_stricmpn" */)) /* nuklear.h:6619:1 */

func nk_str_match_here(regexp uintptr, text uintptr) int32 { /* nuklear.h:6643:1: */
	if int32(*(*int8)(unsafe.Pointer(regexp))) == 0 {
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(regexp + 1))) == '*' {
		return nk_str_match_star(int32(*(*int8)(unsafe.Pointer(regexp))), (regexp + uintptr(2)), text)
	}
	if (int32(*(*int8)(unsafe.Pointer(regexp))) == '$') && (int32(*(*int8)(unsafe.Pointer(regexp + 1))) == 0) {
		return (Bool32(int32(*(*int8)(unsafe.Pointer(text))) == 0))
	}
	if (int32(*(*int8)(unsafe.Pointer(text))) != 0) && ((int32(*(*int8)(unsafe.Pointer(regexp))) == '.') || (int32(*(*int8)(unsafe.Pointer(regexp))) == int32(*(*int8)(unsafe.Pointer(text))))) {
		return nk_str_match_here((regexp + uintptr(1)), (text + uintptr(1)))
	}
	return 0
}

func nk_str_match_star(c int32, regexp uintptr, text uintptr) int32 { /* nuklear.h:6656:1: */
	for ok := true; ok; ok = ((int32(*(*int8)(unsafe.Pointer(text))) != 0) && ((int32(*(*int8)(unsafe.Pointer(PostIncUintptr(&text, 1)))) == c) || (c == '.'))) { // a '* matches zero or more instances
		if nk_str_match_here(regexp, text) != 0 {
			return 1
		}
	}
	return 0
}

func Xnk_strfilter(text uintptr, regexp uintptr) int32 { /* nuklear.h:6665:1: */
	//
	//     c    matches any literal character c
	//     .    matches any single character
	//     ^    matches the beginning of the input string
	//     $    matches the end of the input string
	//     *    matches zero or more occurrences of the previous character
	if int32(*(*int8)(unsafe.Pointer(regexp))) == '^' {
		return nk_str_match_here((regexp + uintptr(1)), text)
	}
	for ok := true; ok; ok = (int32(*(*int8)(unsafe.Pointer(PostIncUintptr(&text, 1)))) != 0) { // must look even if string is empty
		if nk_str_match_here(regexp, text) != 0 {
			return 1
		}
	}
	return 0
}

func Xnk_strmatch_fuzzy_text(str uintptr, str_len int32, pattern uintptr, out_score uintptr) int32 { /* nuklear.h:6682:1: */
	// Returns true if each character in pattern is found sequentially within str
	// if found then out_score is also set. Score value has no intrinsic meaning.
	// Range varies with pattern. Can only compare scores with same search pattern.

	// bonus for adjacent matches
	// bonus if match occurs after a separator
	// bonus if match is uppercase and prev is lower
	// penalty applied for every letter in str before the first match
	// maximum penalty for leading letters
	// penalty for every letter that doesn't matter

	// loop variables
	var score int32 = 0
	var pattern_iter uintptr = pattern
	var str_iter int32 = 0
	var prev_matched int32 = Nk_false
	var prev_lower int32 = Nk_false
	// true so if first letter match gets separator bonus
	var prev_separator int32 = Nk_true

	// use "best" matched letter if multiple string letters match the pattern
	var best_letter uintptr = uintptr(0)
	var best_letter_score int32 = 0

	// loop over strings
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(6716), uintptr(unsafe.Pointer(&__func__7)))
	}
	if pattern != 0 {
	} else {
		X__assert_fail(ts+133 /* "pattern" */, ts+2 /* "nuklear/nuklear...." */, uint32(6717), uintptr(unsafe.Pointer(&__func__7)))
	}
	if (!(str != 0) || !(str_len != 0)) || !(pattern != 0) {
		return 0
	}
	for str_iter < str_len {
		var pattern_letter int8 = *(*int8)(unsafe.Pointer(pattern_iter))
		var str_letter int8 = *(*int8)(unsafe.Pointer(str + uintptr(str_iter)))

		var next_match int32 = (Bool32((int32(*(*int8)(unsafe.Pointer(pattern_iter))) != 0) && (nk_to_lower(int32(pattern_letter)) == nk_to_lower(int32(str_letter)))))
		var rematch int32 = (Bool32((best_letter != 0) && (nk_to_upper(int32(*(*int8)(unsafe.Pointer(best_letter)))) == nk_to_upper(int32(str_letter)))))

		var advanced int32 = (Bool32((next_match != 0) && (best_letter != 0)))
		var pattern_repeat int32 = (Bool32((best_letter != 0) && (int32(*(*int8)(unsafe.Pointer(pattern_iter))) != 0)))
		pattern_repeat = (Bool32((pattern_repeat != 0) && (nk_to_lower(int32(*(*int8)(unsafe.Pointer(best_letter)))) == nk_to_lower(int32(pattern_letter)))))

		if (advanced != 0) || (pattern_repeat != 0) {
			score = score + (best_letter_score)
			best_letter = uintptr(0)
			best_letter_score = 0
		}

		if (next_match != 0) || (rematch != 0) {
			var new_score int32 = 0
			// Apply penalty for each letter before the first pattern match
			if pattern_iter == pattern {
				var count int32 = (int32((int32((str + uintptr(str_iter))) - int32(str)) / 1))
				var penalty int32 = ((-3) * count)
				if penalty < (-9) {
					penalty = -9
				}

				score = score + (penalty)
			}

			// apply bonus for consecutive bonuses
			if prev_matched != 0 {
				new_score = new_score + (NK_ADJACENCY_BONUS)
			}

			// apply bonus for matches after a separator
			if prev_separator != 0 {
				new_score = new_score + (NK_SEPARATOR_BONUS)
			}

			// apply bonus across camel case boundaries
			if (prev_lower != 0) && (nk_is_upper(int32(str_letter)) != 0) {
				new_score = new_score + (NK_CAMEL_BONUS)
			}

			// update pattern iter IFF the next pattern letter was matched
			if next_match != 0 {
				pattern_iter++
			}

			// update best letter in str which may be for a "next" letter or a rematch
			if new_score >= best_letter_score {
				// apply penalty for now skipped letter
				if best_letter != uintptr(0) {
					score = score + (-1)
				}

				best_letter = (str + uintptr(str_iter))
				best_letter_score = new_score
			}
			prev_matched = Nk_true
		} else {
			score = score + (-1)
			prev_matched = Nk_false
		}

		// separators should be more easily defined
		prev_lower = (Bool32(nk_is_lower(int32(str_letter)) != 0))
		prev_separator = (Bool32((int32(str_letter) == '_') || (int32(str_letter) == ' ')))

		str_iter++
	}

	// apply score for last match
	if best_letter != 0 {
		score = score + (best_letter_score)
	}

	// did not match full pattern
	if int32(*(*int8)(unsafe.Pointer(pattern_iter))) != 0 {
		return Nk_false
	}

	if out_score != 0 {
		*(*int32)(unsafe.Pointer(out_score)) = score
	}
	return Nk_true
}

var __func__7 = *(*[23]int8)(unsafe.Pointer(ts + 141 /* "nk_strmatch_fuzz..." */)) /* nuklear.h:6684:1 */

func Xnk_strmatch_fuzzy_string(str uintptr, pattern uintptr, out_score uintptr) int32 { /* nuklear.h:6803:1: */
	return Xnk_strmatch_fuzzy_text(str, Xnk_strlen(str), pattern, out_score)
}

func nk_string_float_limit(string uintptr, prec int32) int32 { /* nuklear.h:6808:1: */
	var dot int32 = 0
	var c uintptr = string
	for *(*int8)(unsafe.Pointer(c)) != 0 {
		if int32(*(*int8)(unsafe.Pointer(c))) == '.' {
			dot = 1
			c++
			continue
		}
		if dot == (prec + 1) {
			*(*int8)(unsafe.Pointer(c)) = int8(0)
			break
		}
		if dot > 0 {
			dot++
		}
		c++
	}
	return (int32((int32(c) - int32(string)) / 1))
}

func nk_strrev_ascii(s uintptr) { /* nuklear.h:6828:1: */
	var len int32 = Xnk_strlen(s)
	var end int32 = (len / 2)
	var i int32 = 0
	var t int8
	for ; i < end; i++ {
		t = *(*int8)(unsafe.Pointer(s + uintptr(i)))
		*(*int8)(unsafe.Pointer(s + uintptr(i))) = *(*int8)(unsafe.Pointer(s + uintptr(((len - 1) - i))))
		*(*int8)(unsafe.Pointer(s + uintptr(((len - 1) - i)))) = t
	}
}

func nk_itoa(s uintptr, n int32) uintptr { /* nuklear.h:6840:12: */
	var i int32 = 0
	if n == 0 {
		*(*int8)(unsafe.Pointer(s + uintptr(PostIncInt32(&i, 1)))) = int8('0')
		*(*int8)(unsafe.Pointer(s + uintptr(i))) = int8(0)
		return s
	}
	if n < 0 {
		*(*int8)(unsafe.Pointer(s + uintptr(PostIncInt32(&i, 1)))) = int8('-')
		n = -n
	}
	for n > 0 {
		*(*int8)(unsafe.Pointer(s + uintptr(PostIncInt32(&i, 1)))) = (int8('0' + (n % 10)))
		n = n / (10)
	}
	*(*int8)(unsafe.Pointer(s + uintptr(i))) = int8(0)
	if int32(*(*int8)(unsafe.Pointer(s))) == '-' {
		s++
	}

	nk_strrev_ascii(s)
	return s
}

func nk_dtoa(s uintptr, n float64) uintptr { /* nuklear.h:6866:12: */
	var useExp int32 = 0
	var digit int32 = 0
	var m int32 = 0
	var m1 int32 = 0
	var c uintptr = s
	var neg int32 = 0

	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(6874), uintptr(unsafe.Pointer(&__func__8)))
	}
	if !(s != 0) {
		return uintptr(0)
	}

	if n == 0.0 {
		*(*int8)(unsafe.Pointer(s)) = int8('0')
		*(*int8)(unsafe.Pointer(s + 1)) = int8(0)
		return s
	}

	neg = (Bool32(n < float64(0)))
	if neg != 0 {
		n = -n
	}

	// calculate magnitude
	m = nk_log10(n)
	useExp = (Bool32(((m >= 14) || ((neg != 0) && (m >= 9))) || (m <= -9)))
	if neg != 0 {
		*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = int8('-')
	}

	// set up for scientific notation
	if useExp != 0 {
		if m < 0 {
			m = m - (1)
		}
		n = (n / nk_pow(10.0, m))
		m1 = m
		m = 0
	}
	if float64(m) < 1.0 {
		m = 0
	}

	// convert the number
	for (n > 0.00000000000001) || (m >= 0) {
		var weight float64 = nk_pow(10.0, m)
		if weight > float64(0) {
			var t float64 = (n / weight)
			digit = nk_ifloord(t)
			n = n - (float64(digit) * weight)
			*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = (int8('0' + int32(int8(digit))))
		}
		if (m == 0) && (n > float64(0)) {
			*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = int8('.')
		}
		m--
	}

	if useExp != 0 {
		// convert the exponent
		var i int32
		var j int32
		*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = int8('e')
		if m1 > 0 {
			*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = int8('+')
		} else {
			*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = int8('-')
			m1 = -m1
		}
		m = 0
		for m1 > 0 {
			*(*int8)(unsafe.Pointer(PostIncUintptr(&c, 1))) = (int8('0' + int32((int8(m1 % 10)))))
			m1 = m1 / (10)
			m++
		}
		c -= uintptr(m)
		i = 0
		j = (m - 1)
	__1:
		if !(i < j) {
			goto __3
		}
		{
			// swap without temporary
			*(*int8)(unsafe.Pointer(c + uintptr(i))) ^= int8((int32(*(*int8)(unsafe.Pointer(c + uintptr(j))))))
			*(*int8)(unsafe.Pointer(c + uintptr(j))) ^= int8((int32(*(*int8)(unsafe.Pointer(c + uintptr(i))))))
			*(*int8)(unsafe.Pointer(c + uintptr(i))) ^= int8((int32(*(*int8)(unsafe.Pointer(c + uintptr(j))))))

		}
		goto __2
	__2:
		i++
		j--
		goto __1
		goto __3
	__3:
		;
		c += uintptr(m)
	}
	*(*int8)(unsafe.Pointer(c)) = int8(0)
	return s
}

var __func__8 = *(*[8]int8)(unsafe.Pointer(ts + 166 /* "nk_dtoa" */)) /* nuklear.h:6868:1 */

func Xnk_murmur_hash(key uintptr, len int32, seed Nk_hash) Nk_hash { /* nuklear.h:7284:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// 32-Bit MurmurHash3: https://code.google.com/p/smhasher/wiki/MurmurHash3

	var h1 Nk_uint = seed
	// var k1 Nk_uint at bp, 4

	var data uintptr = key
	var keyptr uintptr = data
	var k1ptr uintptr
	var bsize int32 = int32(unsafe.Sizeof(Nk_uint(0)))
	var nblocks int32 = (len / 4)

	var c1 Nk_uint = 0xcc9e2d51
	var c2 Nk_uint = Nk_uint(0x1b873593)
	var tail uintptr
	var i int32

	// body
	if !(key != 0) {
		return Nk_hash(0)
	}
	i = 0
__1:
	if !(i < nblocks) {
		goto __3
	}
	{
		k1ptr = bp /* &k1 */
		*(*Nk_byte)(unsafe.Pointer(k1ptr)) = *(*Nk_byte)(unsafe.Pointer(keyptr))
		*(*Nk_byte)(unsafe.Pointer(k1ptr + 1)) = *(*Nk_byte)(unsafe.Pointer(keyptr + 1))
		*(*Nk_byte)(unsafe.Pointer(k1ptr + 2)) = *(*Nk_byte)(unsafe.Pointer(keyptr + 2))
		*(*Nk_byte)(unsafe.Pointer(k1ptr + 3)) = *(*Nk_byte)(unsafe.Pointer(keyptr + 3))

		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) *= c1
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) = (((*(*Nk_uint)(unsafe.Pointer(bp /* k1 */))) << (15)) | ((*(*Nk_uint)(unsafe.Pointer(bp /* k1 */))) >> (32 - 15)))
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) *= c2

		h1 = h1 ^ (*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)))
		h1 = (((h1) << (13)) | ((h1) >> (32 - 13)))
		h1 = ((h1 * Nk_uint(5)) + 0xe6546b64)

	}
	goto __2
__2:
	i++
	keyptr += uintptr(bsize)
	goto __1
	goto __3
__3:
	;

	// tail
	tail = (data + uintptr((nblocks * 4)))
	*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) = Nk_uint(0)
	switch len & 3 {
	case 3:
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) ^= (Nk_uint(int32(*(*Nk_byte)(unsafe.Pointer(tail + 2))) << 16))
		fallthrough // fallthrough
	case 2:
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) ^= (Nk_uint(int32(*(*Nk_byte)(unsafe.Pointer(tail + 1))) << 8))
		fallthrough // fallthrough
	case 1:
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) ^= Nk_uint(*(*Nk_byte)(unsafe.Pointer(tail)))
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) *= c1
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) = (((*(*Nk_uint)(unsafe.Pointer(bp /* k1 */))) << (15)) | ((*(*Nk_uint)(unsafe.Pointer(bp /* k1 */))) >> (32 - 15)))
		*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)) *= c2
		h1 = h1 ^ (*(*Nk_uint)(unsafe.Pointer(bp /* k1 */)))
		break
	default:
		break
	}

	// finalization
	h1 = h1 ^ (Nk_uint(len))
	// fmix32
	h1 = h1 ^ (h1 >> 16)
	h1 = h1 * (0x85ebca6b)
	h1 = h1 ^ (h1 >> 13)
	h1 = h1 * (0xc2b2ae35)
	h1 = h1 ^ (h1 >> 16)

	return h1
}

func nk_text_clamp(font uintptr, text uintptr, text_len int32, space float32, glyphs uintptr, text_width uintptr, sep_list uintptr, sep_count int32) int32 { /* nuklear.h:7383:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	var glyph_len int32 = 0
	var last_width float32 = float32(0)
	*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
	var width float32 = float32(0)
	var len int32 = 0
	var g int32 = 0
	var s float32

	var sep_len int32 = 0
	var sep_g int32 = 0
	var sep_width float32 = float32(0)
	sep_count = func() int32 {
		if (sep_count) < (0) {
			return 0
		}
		return sep_count
	}()

	glyph_len = Xnk_utf_decode(text, bp /* &unicode */, text_len)
	for ((glyph_len != 0) && (width < space)) && (len < text_len) {
		len = len + (glyph_len)
		s = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, text, len)
		for i = 0; i < sep_count; i++ {
			if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) != *(*Nk_rune)(unsafe.Pointer(sep_list + uintptr(i)*4)) {
				continue
			}
			sep_width = AssignFloat32(&last_width, width)
			sep_g = (g + 1)
			sep_len = len
			break
		}
		if i == sep_count {
			last_width = AssignFloat32(&sep_width, width)
			sep_g = (g + 1)
		}
		width = s
		glyph_len = Xnk_utf_decode((text + uintptr(len)), bp /* &unicode */, (text_len - len))
		g++
	}
	if len >= text_len {
		*(*int32)(unsafe.Pointer(glyphs)) = g
		*(*float32)(unsafe.Pointer(text_width)) = last_width
		return len
	} else {
		*(*int32)(unsafe.Pointer(glyphs)) = sep_g
		*(*float32)(unsafe.Pointer(text_width)) = sep_width
		if !(sep_len != 0) {
			return len
		}
		return sep_len
	}
	return int32(0)
}

func nk_text_calculate_text_bounds(font uintptr, begin uintptr, byte_len int32, row_height float32, remaining uintptr, out_offset uintptr, glyphs uintptr, op int32) Nk_vec2 { /* nuklear.h:7431:1: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	var line_height float32 = row_height
	*(*Nk_vec2)(unsafe.Pointer(bp + 4 /* text_size */)) = Xnk_vec2(float32(0), float32(0))
	var line_width float32 = 0.0
	var glyph_width float32
	var glyph_len int32 = 0
	*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
	var text_len int32 = 0
	if (!(begin != 0) || (byte_len <= 0)) || !(font != 0) {
		return Xnk_vec2(float32(0), row_height)
	}

	glyph_len = Xnk_utf_decode(begin, bp /* &unicode */, byte_len)
	if !(glyph_len != 0) {
		return *(*Nk_vec2)(unsafe.Pointer(bp + 4 /* text_size */))
	}
	glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, begin, glyph_len)

	*(*int32)(unsafe.Pointer(glyphs)) = 0
	for (text_len < byte_len) && (glyph_len != 0) {
		if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune('\n') {
			(*Nk_vec2)(unsafe.Pointer(bp + 4 /* &text_size */)).X = func() float32 {
				if ((*Nk_vec2)(unsafe.Pointer(bp + 4 /* &text_size */)).X) < (line_width) {
					return line_width
				}
				return (*Nk_vec2)(unsafe.Pointer(bp + 4 /* &text_size */)).X
			}()
			*(*float32)(unsafe.Pointer(bp + 4 /* &text_size */ + 4 /* &.y */)) += (line_height)
			line_width = float32(0)
			*(*int32)(unsafe.Pointer(glyphs)) += (1)
			if op == NK_STOP_ON_NEW_LINE {
				break
			}

			text_len++
			glyph_len = Xnk_utf_decode((begin + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
			continue
		}

		if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune('\r') {
			text_len++
			*(*int32)(unsafe.Pointer(glyphs)) += (1)
			glyph_len = Xnk_utf_decode((begin + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
			continue
		}

		*(*int32)(unsafe.Pointer(glyphs)) = (*(*int32)(unsafe.Pointer(glyphs)) + 1)
		text_len = text_len + (glyph_len)
		line_width = line_width + (glyph_width)
		glyph_len = Xnk_utf_decode((begin + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
		glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, (begin + uintptr(text_len)), glyph_len)
		continue
	}

	if (*Nk_vec2)(unsafe.Pointer(bp+4 /* &text_size */)).X < line_width {
		(*Nk_vec2)(unsafe.Pointer(bp + 4 /* &text_size */)).X = line_width
	}
	if out_offset != 0 {
		*(*Nk_vec2)(unsafe.Pointer(out_offset)) = Xnk_vec2(line_width, ((*Nk_vec2)(unsafe.Pointer(bp+4 /* &text_size */)).Y + line_height))
	}
	if (line_width > float32(0)) || ((*Nk_vec2)(unsafe.Pointer(bp+4 /* &text_size */)).Y == 0.0) {
		*(*float32)(unsafe.Pointer(bp + 4 /* &text_size */ + 4 /* &.y */)) += (line_height)
	}
	if remaining != 0 {
		*(*uintptr)(unsafe.Pointer(remaining)) = (begin + uintptr(text_len))
	}
	return *(*Nk_vec2)(unsafe.Pointer(bp + 4 /* text_size */))
}

// ==============================================================
//
//                          COLOR
//
// ===============================================================
func nk_parse_hex(p uintptr, length int32) int32 { /* nuklear.h:7501:1: */
	var i int32 = 0
	var len int32 = 0
	for len < length {
		i <<= 4
		if (int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) >= 'a') && (int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) <= 'f') {
			i = i + ((int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) - 'a') + 10)
		} else if (int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) >= 'A') && (int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) <= 'F') {
			i = i + ((int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) - 'A') + 10)
		} else {
			i = i + (int32(*(*int8)(unsafe.Pointer(p + uintptr(len)))) - '0')
		}
		len++
	}
	return i
}

func Xnk_rgba(r int32, g int32, b int32, a int32) Nk_color { /* nuklear.h:7517:1: */
	var ret Nk_color
	ret.R = func() uint8 {
		if (func() int32 {
			if (r) < (255) {
				return r
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (r) < (255) {
				return uint8(r)
			}
			return uint8(255)
		}()
	}()
	ret.G = func() uint8 {
		if (func() int32 {
			if (g) < (255) {
				return g
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (g) < (255) {
				return uint8(g)
			}
			return uint8(255)
		}()
	}()
	ret.B = func() uint8 {
		if (func() int32 {
			if (b) < (255) {
				return b
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (b) < (255) {
				return uint8(b)
			}
			return uint8(255)
		}()
	}()
	ret.A = func() uint8 {
		if (func() int32 {
			if (a) < (255) {
				return a
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (a) < (255) {
				return uint8(a)
			}
			return uint8(255)
		}()
	}()
	return ret
}

func Xnk_rgb_hex(rgb uintptr) Nk_color { /* nuklear.h:7527:1: */
	var col Nk_color
	var c uintptr = rgb
	if int32(*(*int8)(unsafe.Pointer(c))) == '#' {
		c++
	}
	col.R = Nk_byte(nk_parse_hex(c, 2))
	col.G = Nk_byte(nk_parse_hex((c + uintptr(2)), 2))
	col.B = Nk_byte(nk_parse_hex((c + uintptr(4)), 2))
	col.A = Nk_byte(255)
	return col
}

func Xnk_rgba_hex(rgb uintptr) Nk_color { /* nuklear.h:7539:1: */
	var col Nk_color
	var c uintptr = rgb
	if int32(*(*int8)(unsafe.Pointer(c))) == '#' {
		c++
	}
	col.R = Nk_byte(nk_parse_hex(c, 2))
	col.G = Nk_byte(nk_parse_hex((c + uintptr(2)), 2))
	col.B = Nk_byte(nk_parse_hex((c + uintptr(4)), 2))
	col.A = Nk_byte(nk_parse_hex((c + uintptr(6)), 2))
	return col
}

func Xnk_color_hex_rgba(output uintptr, col Nk_color) { /* nuklear.h:7551:1: */
	*(*int8)(unsafe.Pointer(output)) = func() int8 {
		if ((int32(col.R) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.R) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.R) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 1)) = func() int8 {
		if (int32(col.R) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.R) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.R) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 2)) = func() int8 {
		if ((int32(col.G) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.G) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.G) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 3)) = func() int8 {
		if (int32(col.G) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.G) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.G) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 4)) = func() int8 {
		if ((int32(col.B) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.B) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.B) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 5)) = func() int8 {
		if (int32(col.B) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.B) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.B) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 6)) = func() int8 {
		if ((int32(col.A) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.A) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.A) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 7)) = func() int8 {
		if (int32(col.A) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.A) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.A) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 8)) = int8(0)
}

func Xnk_color_hex_rgb(output uintptr, col Nk_color) { /* nuklear.h:7566:1: */
	*(*int8)(unsafe.Pointer(output)) = func() int8 {
		if ((int32(col.R) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.R) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.R) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 1)) = func() int8 {
		if (int32(col.R) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.R) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.R) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 2)) = func() int8 {
		if ((int32(col.G) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.G) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.G) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 3)) = func() int8 {
		if (int32(col.G) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.G) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.G) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 4)) = func() int8 {
		if ((int32(col.B) & 0xF0) >> 4) <= 9 {
			return (int8('0' + ((int32(col.B) & 0xF0) >> 4)))
		}
		return (int8(('A' - 10) + ((int32(col.B) & 0xF0) >> 4)))
	}()
	*(*int8)(unsafe.Pointer(output + 5)) = func() int8 {
		if (int32(col.B) & 0x0F) <= 9 {
			return (int8('0' + (int32(col.B) & 0x0F)))
		}
		return (int8(('A' - 10) + (int32(col.B) & 0x0F)))
	}()
	*(*int8)(unsafe.Pointer(output + 6)) = int8(0)
}

func Xnk_rgba_iv(c uintptr) Nk_color { /* nuklear.h:7579:1: */
	return Xnk_rgba(*(*int32)(unsafe.Pointer(c)), *(*int32)(unsafe.Pointer(c + 1*4)), *(*int32)(unsafe.Pointer(c + 2*4)), *(*int32)(unsafe.Pointer(c + 3*4)))
}

func Xnk_rgba_bv(c uintptr) Nk_color { /* nuklear.h:7584:1: */
	return Xnk_rgba(int32(*(*Nk_byte)(unsafe.Pointer(c))), int32(*(*Nk_byte)(unsafe.Pointer(c + 1))), int32(*(*Nk_byte)(unsafe.Pointer(c + 2))), int32(*(*Nk_byte)(unsafe.Pointer(c + 3))))
}

func Xnk_rgb(r int32, g int32, b int32) Nk_color { /* nuklear.h:7589:1: */
	var ret Nk_color
	ret.R = func() uint8 {
		if (func() int32 {
			if (r) < (255) {
				return r
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (r) < (255) {
				return uint8(r)
			}
			return uint8(255)
		}()
	}()
	ret.G = func() uint8 {
		if (func() int32 {
			if (g) < (255) {
				return g
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (g) < (255) {
				return uint8(g)
			}
			return uint8(255)
		}()
	}()
	ret.B = func() uint8 {
		if (func() int32 {
			if (b) < (255) {
				return b
			}
			return 255
		}()) < (0) {
			return uint8(0)
		}
		return func() uint8 {
			if (b) < (255) {
				return uint8(b)
			}
			return uint8(255)
		}()
	}()
	ret.A = Nk_byte(255)
	return ret
}

func Xnk_rgb_iv(c uintptr) Nk_color { /* nuklear.h:7599:1: */
	return Xnk_rgb(*(*int32)(unsafe.Pointer(c)), *(*int32)(unsafe.Pointer(c + 1*4)), *(*int32)(unsafe.Pointer(c + 2*4)))
}

func Xnk_rgb_bv(c uintptr) Nk_color { /* nuklear.h:7604:1: */
	return Xnk_rgb(int32(*(*Nk_byte)(unsafe.Pointer(c))), int32(*(*Nk_byte)(unsafe.Pointer(c + 1))), int32(*(*Nk_byte)(unsafe.Pointer(c + 2))))
}

func Xnk_rgba_u32(in Nk_uint) Nk_color { /* nuklear.h:7609:1: */
	var ret Nk_color
	ret.R = (Nk_byte(in & Nk_uint(0xFF)))
	ret.G = (Nk_byte((in >> 8) & Nk_uint(0xFF)))
	ret.B = (Nk_byte((in >> 16) & Nk_uint(0xFF)))
	ret.A = (Nk_byte((in >> 24) & Nk_uint(0xFF)))
	return ret
}

func Xnk_rgba_f(r float32, g float32, b float32, a float32) Nk_color { /* nuklear.h:7619:1: */
	var ret Nk_color
	ret.R = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (r) {
				return 1.0
			}
			return r
		}()) {
			return func() float32 {
				if (1.0) < (r) {
					return 1.0
				}
				return r
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.G = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (g) {
				return 1.0
			}
			return g
		}()) {
			return func() float32 {
				if (1.0) < (g) {
					return 1.0
				}
				return g
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.B = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (b) {
				return 1.0
			}
			return b
		}()) {
			return func() float32 {
				if (1.0) < (b) {
					return 1.0
				}
				return b
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.A = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (a) {
				return 1.0
			}
			return a
		}()) {
			return func() float32 {
				if (1.0) < (a) {
					return 1.0
				}
				return a
			}()
		}
		return float32(0)
	}()) * 255.0))
	return ret
}

func Xnk_rgba_fv(c uintptr) Nk_color { /* nuklear.h:7629:1: */
	return Xnk_rgba_f(*(*float32)(unsafe.Pointer(c)), *(*float32)(unsafe.Pointer(c + 1*4)), *(*float32)(unsafe.Pointer(c + 2*4)), *(*float32)(unsafe.Pointer(c + 3*4)))
}

func Xnk_rgba_cf(c Nk_colorf) Nk_color { /* nuklear.h:7634:1: */
	return Xnk_rgba_f(c.R, c.G, c.B, c.A)
}

func Xnk_rgb_f(r float32, g float32, b float32) Nk_color { /* nuklear.h:7639:1: */
	var ret Nk_color
	ret.R = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (r) {
				return 1.0
			}
			return r
		}()) {
			return func() float32 {
				if (1.0) < (r) {
					return 1.0
				}
				return r
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.G = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (g) {
				return 1.0
			}
			return g
		}()) {
			return func() float32 {
				if (1.0) < (g) {
					return 1.0
				}
				return g
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.B = (Nk_byte((func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (b) {
				return 1.0
			}
			return b
		}()) {
			return func() float32 {
				if (1.0) < (b) {
					return 1.0
				}
				return b
			}()
		}
		return float32(0)
	}()) * 255.0))
	ret.A = Nk_byte(255)
	return ret
}

func Xnk_rgb_fv(c uintptr) Nk_color { /* nuklear.h:7649:1: */
	return Xnk_rgb_f(*(*float32)(unsafe.Pointer(c)), *(*float32)(unsafe.Pointer(c + 1*4)), *(*float32)(unsafe.Pointer(c + 2*4)))
}

func Xnk_rgb_cf(c Nk_colorf) Nk_color { /* nuklear.h:7654:1: */
	return Xnk_rgb_f(c.R, c.G, c.B)
}

func Xnk_hsv(h int32, s int32, v int32) Nk_color { /* nuklear.h:7659:1: */
	return Xnk_hsva(h, s, v, 255)
}

func Xnk_hsv_iv(c uintptr) Nk_color { /* nuklear.h:7664:1: */
	return Xnk_hsv(*(*int32)(unsafe.Pointer(c)), *(*int32)(unsafe.Pointer(c + 1*4)), *(*int32)(unsafe.Pointer(c + 2*4)))
}

func Xnk_hsv_bv(c uintptr) Nk_color { /* nuklear.h:7669:1: */
	return Xnk_hsv(int32(*(*Nk_byte)(unsafe.Pointer(c))), int32(*(*Nk_byte)(unsafe.Pointer(c + 1))), int32(*(*Nk_byte)(unsafe.Pointer(c + 2))))
}

func Xnk_hsv_f(h float32, s float32, v float32) Nk_color { /* nuklear.h:7674:1: */
	return Xnk_hsva_f(h, s, v, 1.0)
}

func Xnk_hsv_fv(c uintptr) Nk_color { /* nuklear.h:7679:1: */
	return Xnk_hsv_f(*(*float32)(unsafe.Pointer(c)), *(*float32)(unsafe.Pointer(c + 1*4)), *(*float32)(unsafe.Pointer(c + 2*4)))
}

func Xnk_hsva(h int32, s int32, v int32, a int32) Nk_color { /* nuklear.h:7684:1: */
	var hf float32 = ((func() float32 {
		if (func() int32 {
			if (h) < (255) {
				return h
			}
			return 255
		}()) < (0) {
			return float32(0)
		}
		return func() float32 {
			if (h) < (255) {
				return float32(h)
			}
			return float32(255)
		}()
	}()) / 255.0)
	var sf float32 = ((func() float32 {
		if (func() int32 {
			if (s) < (255) {
				return s
			}
			return 255
		}()) < (0) {
			return float32(0)
		}
		return func() float32 {
			if (s) < (255) {
				return float32(s)
			}
			return float32(255)
		}()
	}()) / 255.0)
	var vf float32 = ((func() float32 {
		if (func() int32 {
			if (v) < (255) {
				return v
			}
			return 255
		}()) < (0) {
			return float32(0)
		}
		return func() float32 {
			if (v) < (255) {
				return float32(v)
			}
			return float32(255)
		}()
	}()) / 255.0)
	var af float32 = ((func() float32 {
		if (func() int32 {
			if (a) < (255) {
				return a
			}
			return 255
		}()) < (0) {
			return float32(0)
		}
		return func() float32 {
			if (a) < (255) {
				return float32(a)
			}
			return float32(255)
		}()
	}()) / 255.0)
	return Xnk_hsva_f(hf, sf, vf, af)
}

func Xnk_hsva_iv(c uintptr) Nk_color { /* nuklear.h:7693:1: */
	return Xnk_hsva(*(*int32)(unsafe.Pointer(c)), *(*int32)(unsafe.Pointer(c + 1*4)), *(*int32)(unsafe.Pointer(c + 2*4)), *(*int32)(unsafe.Pointer(c + 3*4)))
}

func Xnk_hsva_bv(c uintptr) Nk_color { /* nuklear.h:7698:1: */
	return Xnk_hsva(int32(*(*Nk_byte)(unsafe.Pointer(c))), int32(*(*Nk_byte)(unsafe.Pointer(c + 1))), int32(*(*Nk_byte)(unsafe.Pointer(c + 2))), int32(*(*Nk_byte)(unsafe.Pointer(c + 3))))
}

func Xnk_hsva_colorf(h float32, s float32, v float32, a float32) Nk_colorf { /* nuklear.h:7703:1: */
	var i int32
	var p float32
	var q float32
	var t float32
	var f float32
	var out = Nk_colorf{}
	if s <= 0.0 {
		out.R = v
		out.G = v
		out.B = v
		out.A = a
		return out
	}
	h = (h / (float32(60.0) / 360.0))
	i = int32(h)
	f = (h - float32(i))
	p = (v * (1.0 - s))
	q = (v * (1.0 - (s * f)))
	t = (v * (1.0 - (s * (1.0 - f))))

	switch i {
	case 0:
		fallthrough
	default:
		out.R = v
		out.G = t
		out.B = p
		break
	case 1:
		out.R = q
		out.G = v
		out.B = p
		break
	case 2:
		out.R = p
		out.G = v
		out.B = t
		break
	case 3:
		out.R = p
		out.G = q
		out.B = v
		break
	case 4:
		out.R = t
		out.G = p
		out.B = v
		break
	case 5:
		out.R = v
		out.G = p
		out.B = q
		break
	}
	out.A = a
	return out
}

func Xnk_hsva_colorfv(c uintptr) Nk_colorf { /* nuklear.h:7730:1: */
	return Xnk_hsva_colorf(*(*float32)(unsafe.Pointer(c)), *(*float32)(unsafe.Pointer(c + 1*4)), *(*float32)(unsafe.Pointer(c + 2*4)), *(*float32)(unsafe.Pointer(c + 3*4)))
}

func Xnk_hsva_f(h float32, s float32, v float32, a float32) Nk_color { /* nuklear.h:7735:1: */
	var c = Xnk_hsva_colorf(h, s, v, a)
	return Xnk_rgba_f(c.R, c.G, c.B, c.A)
}

func Xnk_hsva_fv(c uintptr) Nk_color { /* nuklear.h:7741:1: */
	return Xnk_hsva_f(*(*float32)(unsafe.Pointer(c)), *(*float32)(unsafe.Pointer(c + 1*4)), *(*float32)(unsafe.Pointer(c + 2*4)), *(*float32)(unsafe.Pointer(c + 3*4)))
}

func Xnk_color_u32(in Nk_color) Nk_uint { /* nuklear.h:7746:1: */
	var out Nk_uint = Nk_uint(in.R)
	out = out | (Nk_uint(in.G) << 8)
	out = out | (Nk_uint(in.B) << 16)
	out = out | (Nk_uint(in.A) << 24)
	return out
}

func Xnk_color_f(r uintptr, g uintptr, b uintptr, a uintptr, in Nk_color) { /* nuklear.h:7755:1: */
	*(*float32)(unsafe.Pointer(r)) = (float32(in.R) * s)
	*(*float32)(unsafe.Pointer(g)) = (float32(in.G) * s)
	*(*float32)(unsafe.Pointer(b)) = (float32(in.B) * s)
	*(*float32)(unsafe.Pointer(a)) = (float32(in.A) * s)
}

var s float32 = (float32(1.0) / 255.0) /* nuklear.h:7757:28 */

func Xnk_color_fv(c uintptr, in Nk_color) { /* nuklear.h:7764:1: */
	Xnk_color_f((c), (c + 1*4), (c + 2*4), (c + 3*4), in)
}

func Xnk_color_cf(in Nk_color) Nk_colorf { /* nuklear.h:7769:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var o Nk_colorf at bp, 16

	Xnk_color_f((bp /* &o */ /* &.r */), (bp /* &o */ + 4 /* &.g */), (bp /* &o */ + 8 /* &.b */), (bp /* &o */ + 12 /* &.a */), in)
	return *(*Nk_colorf)(unsafe.Pointer(bp /* o */))
}

func Xnk_color_d(r uintptr, g uintptr, b uintptr, a uintptr, in Nk_color) { /* nuklear.h:7776:1: */
	*(*float64)(unsafe.Pointer(r)) = (float64(in.R) * s1)
	*(*float64)(unsafe.Pointer(g)) = (float64(in.G) * s1)
	*(*float64)(unsafe.Pointer(b)) = (float64(in.B) * s1)
	*(*float64)(unsafe.Pointer(a)) = (float64(in.A) * s1)
}

var s1 float64 = (float64(1.0) / 255.0) /* nuklear.h:7778:29 */

func Xnk_color_dv(c uintptr, in Nk_color) { /* nuklear.h:7785:1: */
	Xnk_color_d((c), (c + 1*8), (c + 2*8), (c + 3*8), in)
}

func Xnk_color_hsv_f(out_h uintptr, out_s uintptr, out_v uintptr, in Nk_color) { /* nuklear.h:7790:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var a float32 at bp, 4

	Xnk_color_hsva_f(out_h, out_s, out_v, bp /* &a */, in)
}

func Xnk_color_hsv_fv(out uintptr, in Nk_color) { /* nuklear.h:7796:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var a float32 at bp, 4

	Xnk_color_hsva_f((out), (out + 1*4), (out + 2*4), bp /* &a */, in)
}

func Xnk_colorf_hsva_f(out_h uintptr, out_s uintptr, out_v uintptr, out_a uintptr, in Nk_colorf) { /* nuklear.h:7802:1: */
	var chroma float32
	var K float32 = 0.0
	if in.G < in.B {
		var t float32 = in.G
		in.G = in.B
		in.B = t
		K = -1.
	}
	if in.R < in.G {
		var t float32 = in.R
		in.R = in.G
		in.G = t
		K = ((float32(-2.) / 6.0) - K)
	}
	chroma = (in.R - (func() float32 {
		if in.G < in.B {
			return in.G
		}
		return in.B
	}()))
	*(*float32)(unsafe.Pointer(out_h)) = func() float32 {
		if (K + ((in.G - in.B) / ((6.0 * chroma) + 1e-20))) < float32(0) {
			return -(K + ((in.G - in.B) / ((6.0 * chroma) + 1e-20)))
		}
		return (K + ((in.G - in.B) / ((6.0 * chroma) + 1e-20)))
	}()
	*(*float32)(unsafe.Pointer(out_s)) = (chroma / (in.R + 1e-20))
	*(*float32)(unsafe.Pointer(out_v)) = in.R
	*(*float32)(unsafe.Pointer(out_a)) = in.A

}

func Xnk_colorf_hsva_fv(hsva uintptr, in Nk_colorf) { /* nuklear.h:7823:1: */
	Xnk_colorf_hsva_f((hsva), (hsva + 1*4), (hsva + 2*4), (hsva + 3*4), in)
}

func Xnk_color_hsva_f(out_h uintptr, out_s uintptr, out_v uintptr, out_a uintptr, in Nk_color) { /* nuklear.h:7828:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var col Nk_colorf at bp, 16

	Xnk_color_f((bp /* &col */ /* &.r */), (bp /* &col */ + 4 /* &.g */), (bp /* &col */ + 8 /* &.b */), (bp /* &col */ + 12 /* &.a */), in)
	Xnk_colorf_hsva_f(out_h, out_s, out_v, out_a, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
}

func Xnk_color_hsva_fv(out uintptr, in Nk_color) { /* nuklear.h:7836:1: */
	Xnk_color_hsva_f((out), (out + 1*4), (out + 2*4), (out + 3*4), in)
}

func Xnk_color_hsva_i(out_h uintptr, out_s uintptr, out_v uintptr, out_a uintptr, in Nk_color) { /* nuklear.h:7841:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var h float32 at bp, 4

	// var s float32 at bp+4, 4

	// var v float32 at bp+8, 4

	// var a float32 at bp+12, 4

	Xnk_color_hsva_f(bp /* &h */, bp+4 /* &s */, bp+8 /* &v */, bp+12 /* &a */, in)
	*(*int32)(unsafe.Pointer(out_h)) = int32((Nk_byte(*(*float32)(unsafe.Pointer(bp /* h */)) * 255.0)))
	*(*int32)(unsafe.Pointer(out_s)) = int32((Nk_byte(*(*float32)(unsafe.Pointer(bp + 4 /* s */)) * 255.0)))
	*(*int32)(unsafe.Pointer(out_v)) = int32((Nk_byte(*(*float32)(unsafe.Pointer(bp + 8 /* v */)) * 255.0)))
	*(*int32)(unsafe.Pointer(out_a)) = int32((Nk_byte(*(*float32)(unsafe.Pointer(bp + 12 /* a */)) * 255.0)))
}

func Xnk_color_hsva_iv(out uintptr, in Nk_color) { /* nuklear.h:7852:1: */
	Xnk_color_hsva_i((out), (out + 1*4), (out + 2*4), (out + 3*4), in)
}

func Xnk_color_hsva_bv(out uintptr, in Nk_color) { /* nuklear.h:7857:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var tmp [4]int32 at bp, 16

	Xnk_color_hsva_i((bp /* &tmp */), (bp /* &tmp */ + 1*4), (bp /* &tmp */ + 2*4), (bp /* &tmp */ + 3*4), in)
	*(*Nk_byte)(unsafe.Pointer(out)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */)))
	*(*Nk_byte)(unsafe.Pointer(out + 1)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 1*4)))
	*(*Nk_byte)(unsafe.Pointer(out + 2)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 2*4)))
	*(*Nk_byte)(unsafe.Pointer(out + 3)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 3*4)))
}

func Xnk_color_hsva_b(h uintptr, s uintptr, v uintptr, a uintptr, in Nk_color) { /* nuklear.h:7867:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var tmp [4]int32 at bp, 16

	Xnk_color_hsva_i((bp /* &tmp */), (bp /* &tmp */ + 1*4), (bp /* &tmp */ + 2*4), (bp /* &tmp */ + 3*4), in)
	*(*Nk_byte)(unsafe.Pointer(h)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */)))
	*(*Nk_byte)(unsafe.Pointer(s)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 1*4)))
	*(*Nk_byte)(unsafe.Pointer(v)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 2*4)))
	*(*Nk_byte)(unsafe.Pointer(a)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 3*4)))
}

func Xnk_color_hsv_i(out_h uintptr, out_s uintptr, out_v uintptr, in Nk_color) { /* nuklear.h:7877:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var a int32 at bp, 4

	Xnk_color_hsva_i(out_h, out_s, out_v, bp /* &a */, in)
}

func Xnk_color_hsv_b(out_h uintptr, out_s uintptr, out_v uintptr, in Nk_color) { /* nuklear.h:7883:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var tmp [4]int32 at bp, 16

	Xnk_color_hsva_i((bp /* &tmp */), (bp /* &tmp */ + 1*4), (bp /* &tmp */ + 2*4), (bp /* &tmp */ + 3*4), in)
	*(*Nk_byte)(unsafe.Pointer(out_h)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */)))
	*(*Nk_byte)(unsafe.Pointer(out_s)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 1*4)))
	*(*Nk_byte)(unsafe.Pointer(out_v)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 2*4)))
}

func Xnk_color_hsv_iv(out uintptr, in Nk_color) { /* nuklear.h:7892:1: */
	Xnk_color_hsv_i((out), (out + 1*4), (out + 2*4), in)
}

func Xnk_color_hsv_bv(out uintptr, in Nk_color) { /* nuklear.h:7897:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var tmp [4]int32 at bp, 16

	Xnk_color_hsv_i((bp /* &tmp */), (bp /* &tmp */ + 1*4), (bp /* &tmp */ + 2*4), in)
	*(*Nk_byte)(unsafe.Pointer(out)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */)))
	*(*Nk_byte)(unsafe.Pointer(out + 1)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 1*4)))
	*(*Nk_byte)(unsafe.Pointer(out + 2)) = Nk_byte(*(*int32)(unsafe.Pointer(bp /* &tmp[0] */ + 2*4)))
}

// ===============================================================
//
//                              UTF-8
//
// ===============================================================
var nk_utfbyte = [5]Nk_byte{Nk_byte(0x80), Nk_byte(0), Nk_byte(0xC0), Nk_byte(0xE0), Nk_byte(0xF0)}              /* nuklear.h:7915:25 */
var nk_utfmask = [5]Nk_byte{Nk_byte(0xC0), Nk_byte(0x80), Nk_byte(0xE0), Nk_byte(0xF0), Nk_byte(0xF8)}           /* nuklear.h:7916:25 */
var nk_utfmin = [5]Nk_uint{Nk_uint(0), Nk_uint(0), Nk_uint(0x80), Nk_uint(0x800), Nk_uint(0x10000)}              /* nuklear.h:7917:25 */
var nk_utfmax = [5]Nk_uint{Nk_uint(0x10FFFF), Nk_uint(0x7F), Nk_uint(0x7FF), Nk_uint(0xFFFF), Nk_uint(0x10FFFF)} /* nuklear.h:7918:25 */

func nk_utf_validate(u uintptr, i int32) int32 { /* nuklear.h:7921:1: */
	if u != 0 {
	} else {
		X__assert_fail(ts+174 /* "u" */, ts+2 /* "nuklear/nuklear...." */, uint32(7923), uintptr(unsafe.Pointer(&__func__9)))
	}
	if !(u != 0) {
		return 0
	}
	if !(((nk_utfmin[i]) <= (*(*Nk_rune)(unsafe.Pointer(u)))) && ((*(*Nk_rune)(unsafe.Pointer(u))) < (nk_utfmax[i]))) || (((Nk_rune(0xD800)) <= (*(*Nk_rune)(unsafe.Pointer(u)))) && ((*(*Nk_rune)(unsafe.Pointer(u))) < (Nk_rune(0xDFFF)))) {
		*(*Nk_rune)(unsafe.Pointer(u)) = Nk_rune(NK_UTF_INVALID)
	}
	for i = 1; *(*Nk_rune)(unsafe.Pointer(u)) > nk_utfmax[i]; i++ {
	}
	return i
}

var __func__9 = *(*[16]int8)(unsafe.Pointer(ts + 176 /* "nk_utf_validate" */)) /* nuklear.h:7922:1 */

func nk_utf_decode_byte(c int8, i uintptr) Nk_rune { /* nuklear.h:7932:1: */
	if i != 0 {
	} else {
		X__assert_fail(ts+192 /* "i" */, ts+2 /* "nuklear/nuklear...." */, uint32(7934), uintptr(unsafe.Pointer(&__func__10)))
	}
	if !(i != 0) {
		return Nk_rune(0)
	}
	for *(*int32)(unsafe.Pointer(i)) = 0; *(*int32)(unsafe.Pointer(i)) < (int32(uint32(unsafe.Sizeof(nk_utfmask)) / uint32(unsafe.Sizeof(Nk_byte(0))))); (*(*int32)(unsafe.Pointer(i)))++ {
		if (int32(Nk_byte(c)) & int32(nk_utfmask[*(*int32)(unsafe.Pointer(i))])) == int32(nk_utfbyte[*(*int32)(unsafe.Pointer(i))]) {
			return Nk_rune((Nk_byte(int32(c) & ^int32(nk_utfmask[*(*int32)(unsafe.Pointer(i))]))))
		}
	}
	return Nk_rune(0)
}

var __func__10 = *(*[19]int8)(unsafe.Pointer(ts + 194 /* "nk_utf_decode_by..." */)) /* nuklear.h:7933:1 */

func Xnk_utf_decode(c uintptr, u uintptr, clen int32) int32 { /* nuklear.h:7943:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var i int32
	var j int32
	// var len int32 at bp, 4

	*(*int32)(unsafe.Pointer(bp + 4 /* type1 */)) = 0
	var udecoded Nk_rune

	if c != 0 {
	} else {
		X__assert_fail(ts+213 /* "c" */, ts+2 /* "nuklear/nuklear...." */, uint32(7948), uintptr(unsafe.Pointer(&__func__11)))
	}
	if u != 0 {
	} else {
		X__assert_fail(ts+174 /* "u" */, ts+2 /* "nuklear/nuklear...." */, uint32(7949), uintptr(unsafe.Pointer(&__func__11)))
	}

	if !(c != 0) || !(u != 0) {
		return 0
	}
	if !(clen != 0) {
		return 0
	}
	*(*Nk_rune)(unsafe.Pointer(u)) = Nk_rune(NK_UTF_INVALID)

	udecoded = nk_utf_decode_byte(*(*int8)(unsafe.Pointer(c)), bp /* &len */)
	if !(((1) <= (*(*int32)(unsafe.Pointer(bp /* len */)))) && ((*(*int32)(unsafe.Pointer(bp /* len */))) < (NK_UTF_SIZE))) {
		return 1
	}

	i = 1
	j = 1
__1:
	if !((i < clen) && (j < *(*int32)(unsafe.Pointer(bp /* len */)))) {
		goto __3
	}
	{
		udecoded = ((udecoded << 6) | nk_utf_decode_byte(*(*int8)(unsafe.Pointer(c + uintptr(i))), bp+4 /* &type1 */))
		if *(*int32)(unsafe.Pointer(bp + 4 /* type1 */)) != 0 {
			return j
		}

	}
	goto __2
__2:
	i++
	j++
	goto __1
	goto __3
__3:
	;
	if j < *(*int32)(unsafe.Pointer(bp /* len */)) {
		return 0
	}
	*(*Nk_rune)(unsafe.Pointer(u)) = udecoded
	nk_utf_validate(u, *(*int32)(unsafe.Pointer(bp /* len */)))
	return *(*int32)(unsafe.Pointer(bp /* len */))
}

var __func__11 = *(*[14]int8)(unsafe.Pointer(ts + 215 /* "nk_utf_decode" */)) /* nuklear.h:7944:1 */

func nk_utf_encode_byte(u Nk_rune, i int32) int8 { /* nuklear.h:7971:1: */
	return (int8((int32(nk_utfbyte[i])) | (int32(Nk_byte(u)) & ^int32(nk_utfmask[i]))))
}

func Xnk_utf_encode(u Nk_rune, c uintptr, clen int32) int32 { /* nuklear.h:7976:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_rune)(unsafe.Pointer(bp)) = u

	var len int32
	var i int32
	len = nk_utf_validate(bp /* &u */, 0)
	if ((clen < len) || !(len != 0)) || (len > NK_UTF_SIZE) {
		return 0
	}

	for i = (len - 1); i != 0; i-- {
		*(*int8)(unsafe.Pointer(c + uintptr(i))) = nk_utf_encode_byte(*(*Nk_rune)(unsafe.Pointer(bp /* u */)), 0)
		*(*Nk_rune)(unsafe.Pointer(bp /* u */)) >>= 6
	}
	*(*int8)(unsafe.Pointer(c)) = nk_utf_encode_byte(*(*Nk_rune)(unsafe.Pointer(bp /* u */)), len)
	return len
}

func Xnk_utf_len(str uintptr, len int32) int32 { /* nuklear.h:7991:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var text uintptr
	var glyphs int32 = 0
	var text_len int32
	var glyph_len int32
	var src_len int32 = 0
	// var unicode Nk_rune at bp, 4

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8000), uintptr(unsafe.Pointer(&__func__12)))
	}
	if !(str != 0) || !(len != 0) {
		return 0
	}

	text = str
	text_len = len
	glyph_len = Xnk_utf_decode(text, bp /* &unicode */, text_len)
	for (glyph_len != 0) && (src_len < len) {
		glyphs++
		src_len = (src_len + glyph_len)
		glyph_len = Xnk_utf_decode((text + uintptr(src_len)), bp /* &unicode */, (text_len - src_len))
	}
	return glyphs
}

var __func__12 = *(*[11]int8)(unsafe.Pointer(ts + 229 /* "nk_utf_len" */)) /* nuklear.h:7992:1 */

func Xnk_utf_at(buffer uintptr, length int32, index int32, unicode uintptr, len uintptr) uintptr { /* nuklear.h:8013:18: */
	var i int32 = 0
	var src_len int32 = 0
	var glyph_len int32 = 0
	var text uintptr
	var text_len int32

	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8023), uintptr(unsafe.Pointer(&__func__13)))
	}
	if unicode != 0 {
	} else {
		X__assert_fail(ts+247 /* "unicode" */, ts+2 /* "nuklear/nuklear...." */, uint32(8024), uintptr(unsafe.Pointer(&__func__13)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(8025), uintptr(unsafe.Pointer(&__func__13)))
	}

	if (!(buffer != 0) || !(unicode != 0)) || !(len != 0) {
		return uintptr(0)
	}
	if index < 0 {
		*(*Nk_rune)(unsafe.Pointer(unicode)) = Nk_rune(NK_UTF_INVALID)
		*(*int32)(unsafe.Pointer(len)) = 0
		return uintptr(0)
	}

	text = buffer
	text_len = length
	glyph_len = Xnk_utf_decode(text, unicode, text_len)
	for glyph_len != 0 {
		if i == index {
			*(*int32)(unsafe.Pointer(len)) = glyph_len
			break
		}

		i++
		src_len = (src_len + glyph_len)
		glyph_len = Xnk_utf_decode((text + uintptr(src_len)), unicode, (text_len - src_len))
	}
	if i != index {
		return uintptr(0)
	}
	return (buffer + uintptr(src_len))
}

var __func__13 = *(*[10]int8)(unsafe.Pointer(ts + 259 /* "nk_utf_at" */)) /* nuklear.h:8016:1 */

// ==============================================================
//
//                          BUFFER
//
// ===============================================================
func nk_malloc(unused Nk_handle, old uintptr, size Nk_size) uintptr { /* nuklear.h:8061:12: */
	_ = unused
	_ = old
	return Xmalloc(size)
}

func nk_mfree(unused Nk_handle, ptr uintptr) { /* nuklear.h:8069:1: */
	_ = unused
	Xfree(ptr)
}

func Xnk_buffer_init_default(buffer uintptr) { /* nuklear.h:8075:1: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	// var alloc Nk_allocator at bp, 12

	*(*uintptr)(unsafe.Pointer(bp /* &alloc */ /* &.userdata */)) = uintptr(0)
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Alloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, uintptr, Nk_size) uintptr
	}{nk_malloc}))
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Free = *(*uintptr)(unsafe.Pointer(&struct{ f func(Nk_handle, uintptr) }{nk_mfree}))
	Xnk_buffer_init(buffer, bp /* &alloc */, (uint32(4 * 1024)))
}

func Xnk_buffer_init(b uintptr, a uintptr, initial_size Nk_size) { /* nuklear.h:8086:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8089), uintptr(unsafe.Pointer(&__func__14)))
	}
	if a != 0 {
	} else {
		X__assert_fail(ts /* "a" */, ts+2 /* "nuklear/nuklear...." */, uint32(8090), uintptr(unsafe.Pointer(&__func__14)))
	}
	if initial_size != 0 {
	} else {
		X__assert_fail(ts+271 /* "initial_size" */, ts+2 /* "nuklear/nuklear...." */, uint32(8091), uintptr(unsafe.Pointer(&__func__14)))
	}
	if (!(b != 0) || !(a != 0)) || !(initial_size != 0) {
		return
	}

	nk_zero(b, uint32(unsafe.Sizeof(Nk_buffer{})))
	(*Nk_buffer)(unsafe.Pointer(b)).Type = NK_BUFFER_DYNAMIC
	(*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((a + 4 /* &.alloc */))))((*Nk_allocator)(unsafe.Pointer(a)).Userdata, uintptr(0), initial_size)
	(*Nk_buffer)(unsafe.Pointer(b)).Memory.Size = initial_size
	(*Nk_buffer)(unsafe.Pointer(b)).Size = initial_size
	(*Nk_buffer)(unsafe.Pointer(b)).Grow_factor = 2.0
	(*Nk_buffer)(unsafe.Pointer(b)).Pool = *(*Nk_allocator)(unsafe.Pointer(a))
}

var __func__14 = *(*[15]int8)(unsafe.Pointer(ts + 284 /* "nk_buffer_init" */)) /* nuklear.h:8088:1 */

func Xnk_buffer_init_fixed(b uintptr, m uintptr, size Nk_size) { /* nuklear.h:8103:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8105), uintptr(unsafe.Pointer(&__func__15)))
	}
	if m != 0 {
	} else {
		X__assert_fail(ts+299 /* "m" */, ts+2 /* "nuklear/nuklear...." */, uint32(8106), uintptr(unsafe.Pointer(&__func__15)))
	}
	if size != 0 {
	} else {
		X__assert_fail(ts+301 /* "size" */, ts+2 /* "nuklear/nuklear...." */, uint32(8107), uintptr(unsafe.Pointer(&__func__15)))
	}
	if (!(b != 0) || !(m != 0)) || !(size != 0) {
		return
	}

	nk_zero(b, uint32(unsafe.Sizeof(Nk_buffer{})))
	(*Nk_buffer)(unsafe.Pointer(b)).Type = NK_BUFFER_FIXED
	(*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr = m
	(*Nk_buffer)(unsafe.Pointer(b)).Memory.Size = size
	(*Nk_buffer)(unsafe.Pointer(b)).Size = size
}

var __func__15 = *(*[21]int8)(unsafe.Pointer(ts + 306 /* "nk_buffer_init_f..." */)) /* nuklear.h:8104:1 */

func nk_buffer_align(unaligned uintptr, align Nk_size, alignment uintptr, type1 uint32) uintptr { /* nuklear.h:8116:12: */
	var memory uintptr = uintptr(0)
	switch type1 {
	default:
		fallthrough
	case NK_BUFFER_MAX:
		fallthrough
	case NK_BUFFER_FRONT:
		if align != 0 {
			memory = uintptr((int32((Nk_size(((unaligned) + uintptr((align - Nk_size(1)))))) & ^(align - Nk_size(1)))))
			*(*Nk_size)(unsafe.Pointer(alignment)) = (Nk_size((int32(memory) - int32(unaligned)) / 1))
		} else {
			memory = unaligned
			*(*Nk_size)(unsafe.Pointer(alignment)) = Nk_size(0)
		}
		break
	case NK_BUFFER_BACK:
		if align != 0 {
			memory = uintptr((int32((Nk_size(unaligned)) & ^(align - Nk_size(1)))))
			*(*Nk_size)(unsafe.Pointer(alignment)) = (Nk_size((int32(unaligned) - int32(memory)) / 1))
		} else {
			memory = unaligned
			*(*Nk_size)(unsafe.Pointer(alignment)) = Nk_size(0)
		}
		break
	}
	return memory
}

func nk_buffer_realloc(b uintptr, capacity Nk_size, size uintptr) uintptr { /* nuklear.h:8146:12: */
	var temp uintptr
	var buffer_size Nk_size

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8152), uintptr(unsafe.Pointer(&__func__16)))
	}
	if size != 0 {
	} else {
		X__assert_fail(ts+301 /* "size" */, ts+2 /* "nuklear/nuklear...." */, uint32(8153), uintptr(unsafe.Pointer(&__func__16)))
	}
	if ((!(b != 0) || !(size != 0)) || !(int32((*Nk_buffer)(unsafe.Pointer(b)).Pool.Alloc) != 0)) || !(int32((*Nk_buffer)(unsafe.Pointer(b)).Pool.Free) != 0) {
		return uintptr(0)
	}

	buffer_size = (*Nk_buffer)(unsafe.Pointer(b)).Memory.Size
	temp = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((b + 16 /* &.pool */ + 4 /* &.alloc */))))((*Nk_buffer)(unsafe.Pointer(b)).Pool.Userdata, (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr, capacity)
	if temp != 0 {
	} else {
		X__assert_fail(ts+327 /* "temp" */, ts+2 /* "nuklear/nuklear...." */, uint32(8159), uintptr(unsafe.Pointer(&__func__16)))
	}
	if !(temp != 0) {
		return uintptr(0)
	}

	*(*Nk_size)(unsafe.Pointer(size)) = capacity
	if temp != (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr {
		nk_memcopy(temp, (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr, buffer_size)
		(*(*func(Nk_handle, uintptr))(unsafe.Pointer((b + 16 /* &.pool */ + 8 /* &.free */))))((*Nk_buffer)(unsafe.Pointer(b)).Pool.Userdata, (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr)
	}

	if (*Nk_buffer)(unsafe.Pointer(b)).Size == buffer_size {
		// no back buffer so just set correct size
		(*Nk_buffer)(unsafe.Pointer(b)).Size = capacity
		return temp
	} else {
		// copy back buffer to the end of the new buffer
		var dst uintptr
		var src uintptr
		var back_size Nk_size
		back_size = (buffer_size - (*Nk_buffer)(unsafe.Pointer(b)).Size)
		dst = ((temp) + uintptr((capacity - back_size)))
		src = ((temp) + uintptr(((*Nk_buffer)(unsafe.Pointer(b)).Size)))
		nk_memcopy(dst, src, back_size)
		(*Nk_buffer)(unsafe.Pointer(b)).Size = (capacity - back_size)
	}
	return temp
}

var __func__16 = *(*[18]int8)(unsafe.Pointer(ts + 332 /* "nk_buffer_reallo..." */)) /* nuklear.h:8148:1 */

func nk_buffer_alloc(b uintptr, type1 uint32, size Nk_size, align Nk_size) uintptr { /* nuklear.h:8184:12: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var full int32
	// var alignment Nk_size at bp, 4

	var unaligned uintptr
	var memory uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8193), uintptr(unsafe.Pointer(&__func__17)))
	}
	if size != 0 {
	} else {
		X__assert_fail(ts+301 /* "size" */, ts+2 /* "nuklear/nuklear...." */, uint32(8194), uintptr(unsafe.Pointer(&__func__17)))
	}
	if !(b != 0) || !(size != 0) {
		return uintptr(0)
	}
	*(*Nk_size)(unsafe.Pointer(b + 48 /* &.needed */)) += (size)

	// calculate total size with needed alignment + size
	if int32(type1) == NK_BUFFER_FRONT {
		unaligned = (((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) + uintptr(((*Nk_buffer)(unsafe.Pointer(b)).Allocated)))
	} else {
		unaligned = (((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) + uintptr(((*Nk_buffer)(unsafe.Pointer(b)).Size - size)))
	}
	memory = nk_buffer_align(unaligned, align, bp /* &alignment */, type1)

	// check if buffer has enough memory
	if int32(type1) == NK_BUFFER_FRONT {
		full = (Bool32((((*Nk_buffer)(unsafe.Pointer(b)).Allocated + size) + *(*Nk_size)(unsafe.Pointer(bp /* alignment */))) > (*Nk_buffer)(unsafe.Pointer(b)).Size))
	} else {
		full = (Bool32(((*Nk_buffer)(unsafe.Pointer(b)).Size - (func() uint32 {
			if ((*Nk_buffer)(unsafe.Pointer(b)).Size) < (size + *(*Nk_size)(unsafe.Pointer(bp /* alignment */))) {
				return (*Nk_buffer)(unsafe.Pointer(b)).Size
			}
			return (size + *(*Nk_size)(unsafe.Pointer(bp /* alignment */)))
		}())) <= (*Nk_buffer)(unsafe.Pointer(b)).Allocated))
	}

	if full != 0 {
		var capacity Nk_size
		if int32((*Nk_buffer)(unsafe.Pointer(b)).Type) != NK_BUFFER_DYNAMIC {
			return uintptr(0)
		}
		if ((*Nk_buffer)(unsafe.Pointer(b)).Pool.Alloc != 0) && ((*Nk_buffer)(unsafe.Pointer(b)).Pool.Free != 0) {
		} else {
			X__assert_fail(ts+350 /* "b->pool.alloc &&..." */, ts+2 /* "nuklear/nuklear...." */, uint32(8213), uintptr(unsafe.Pointer(&__func__17)))
		}
		if ((int32((*Nk_buffer)(unsafe.Pointer(b)).Type) != NK_BUFFER_DYNAMIC) || !(int32((*Nk_buffer)(unsafe.Pointer(b)).Pool.Alloc) != 0)) || !(int32((*Nk_buffer)(unsafe.Pointer(b)).Pool.Free) != 0) {
			return uintptr(0)
		}

		// buffer is full so allocate bigger buffer if dynamic
		capacity = (Nk_size(float32((*Nk_buffer)(unsafe.Pointer(b)).Memory.Size) * (*Nk_buffer)(unsafe.Pointer(b)).Grow_factor))
		capacity = func() uint32 {
			if (capacity) < (Nk_size(nk_round_up_pow2((Nk_uint((*Nk_buffer)(unsafe.Pointer(b)).Allocated + size))))) {
				return uint32(nk_round_up_pow2((Nk_uint((*Nk_buffer)(unsafe.Pointer(b)).Allocated + size))))
			}
			return capacity
		}()
		(*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr = nk_buffer_realloc(b, capacity, (b + 32 /* &.memory */ + 4 /* &.size */))
		if !(int32((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) != 0) {
			return uintptr(0)
		}

		// align newly allocated pointer
		if int32(type1) == NK_BUFFER_FRONT {
			unaligned = (((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) + uintptr(((*Nk_buffer)(unsafe.Pointer(b)).Allocated)))
		} else {
			unaligned = (((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) + uintptr(((*Nk_buffer)(unsafe.Pointer(b)).Size - size)))
		}
		memory = nk_buffer_align(unaligned, align, bp /* &alignment */, type1)
	}
	if int32(type1) == NK_BUFFER_FRONT {
		*(*Nk_size)(unsafe.Pointer(b + 44 /* &.allocated */)) += (size + *(*Nk_size)(unsafe.Pointer(bp /* alignment */)))
	} else {
		*(*Nk_size)(unsafe.Pointer(b + 56 /* &.size */)) -= (size + *(*Nk_size)(unsafe.Pointer(bp /* alignment */)))
	}
	*(*Nk_size)(unsafe.Pointer(b + 48 /* &.needed */)) += (*(*Nk_size)(unsafe.Pointer(bp /* alignment */)))
	(*Nk_buffer)(unsafe.Pointer(b)).Calls++
	return memory
}

var __func__17 = *(*[16]int8)(unsafe.Pointer(ts + 380 /* "nk_buffer_alloc" */)) /* nuklear.h:8187:1 */

func Xnk_buffer_push(b uintptr, type1 uint32, memory uintptr, size Nk_size, align Nk_size) { /* nuklear.h:8237:1: */
	var mem uintptr = nk_buffer_alloc(b, type1, size, align)
	if !(mem != 0) {
		return
	}
	nk_memcopy(mem, memory, size)
}

func Xnk_buffer_mark(buffer uintptr, type1 uint32) { /* nuklear.h:8245:1: */
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8247), uintptr(unsafe.Pointer(&__func__18)))
	}
	if !(buffer != 0) {
		return
	}
	(*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Active = Nk_true
	if int32(type1) == NK_BUFFER_BACK {
		(*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Offset = (*Nk_buffer)(unsafe.Pointer(buffer)).Size
	} else {
		(*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Offset = (*Nk_buffer)(unsafe.Pointer(buffer)).Allocated
	}
}

var __func__18 = *(*[15]int8)(unsafe.Pointer(ts + 396 /* "nk_buffer_mark" */)) /* nuklear.h:8246:1 */

func Xnk_buffer_reset(buffer uintptr, type1 uint32) { /* nuklear.h:8255:1: */
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8257), uintptr(unsafe.Pointer(&__func__19)))
	}
	if !(buffer != 0) {
		return
	}
	if int32(type1) == NK_BUFFER_BACK {
		// reset back buffer either back to marker or empty
		*(*Nk_size)(unsafe.Pointer(buffer + 48 /* &.needed */)) -= ((*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Size - (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */)+uintptr(type1)*8)).Offset)
		if (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */)+uintptr(type1)*8)).Active != 0 {
			(*Nk_buffer)(unsafe.Pointer(buffer)).Size = (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Offset
		} else {
			(*Nk_buffer)(unsafe.Pointer(buffer)).Size = (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Size
		}
		(*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Active = Nk_false
	} else {
		// reset front buffer either back to back marker or empty
		*(*Nk_size)(unsafe.Pointer(buffer + 48 /* &.needed */)) -= ((*Nk_buffer)(unsafe.Pointer(buffer)).Allocated - (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */)+uintptr(type1)*8)).Offset)
		if (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */)+uintptr(type1)*8)).Active != 0 {
			(*Nk_buffer)(unsafe.Pointer(buffer)).Allocated = (*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Offset
		} else {
			(*Nk_buffer)(unsafe.Pointer(buffer)).Allocated = Nk_size(0)
		}
		(*Nk_buffer_marker)(unsafe.Pointer((buffer /* &.marker */) + uintptr(type1)*8)).Active = Nk_false
	}
}

var __func__19 = *(*[16]int8)(unsafe.Pointer(ts + 411 /* "nk_buffer_reset" */)) /* nuklear.h:8256:1 */

func Xnk_buffer_clear(b uintptr) { /* nuklear.h:8276:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8278), uintptr(unsafe.Pointer(&__func__20)))
	}
	if !(b != 0) {
		return
	}
	(*Nk_buffer)(unsafe.Pointer(b)).Allocated = Nk_size(0)
	(*Nk_buffer)(unsafe.Pointer(b)).Size = (*Nk_buffer)(unsafe.Pointer(b)).Memory.Size
	(*Nk_buffer)(unsafe.Pointer(b)).Calls = Nk_size(0)
	(*Nk_buffer)(unsafe.Pointer(b)).Needed = Nk_size(0)
}

var __func__20 = *(*[16]int8)(unsafe.Pointer(ts + 427 /* "nk_buffer_clear" */)) /* nuklear.h:8277:1 */

func Xnk_buffer_free(b uintptr) { /* nuklear.h:8286:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8288), uintptr(unsafe.Pointer(&__func__21)))
	}
	if !(b != 0) || !(int32((*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr) != 0) {
		return
	}
	if int32((*Nk_buffer)(unsafe.Pointer(b)).Type) == NK_BUFFER_FIXED {
		return
	}
	if !(int32((*Nk_buffer)(unsafe.Pointer(b)).Pool.Free) != 0) {
		return
	}
	if (*Nk_buffer)(unsafe.Pointer(b)).Pool.Free != 0 {
	} else {
		X__assert_fail(ts+443 /* "b->pool.free" */, ts+2 /* "nuklear/nuklear...." */, uint32(8292), uintptr(unsafe.Pointer(&__func__21)))
	}
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((b + 16 /* &.pool */ + 8 /* &.free */))))((*Nk_buffer)(unsafe.Pointer(b)).Pool.Userdata, (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr)
}

var __func__21 = *(*[15]int8)(unsafe.Pointer(ts + 456 /* "nk_buffer_free" */)) /* nuklear.h:8287:1 */

func Xnk_buffer_info(s uintptr, b uintptr) { /* nuklear.h:8296:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8298), uintptr(unsafe.Pointer(&__func__22)))
	}
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8299), uintptr(unsafe.Pointer(&__func__22)))
	}
	if !(s != 0) || !(b != 0) {
		return
	}
	(*Nk_memory_status)(unsafe.Pointer(s)).Allocated = (*Nk_buffer)(unsafe.Pointer(b)).Allocated
	(*Nk_memory_status)(unsafe.Pointer(s)).Size = (*Nk_buffer)(unsafe.Pointer(b)).Memory.Size
	(*Nk_memory_status)(unsafe.Pointer(s)).Needed = (*Nk_buffer)(unsafe.Pointer(b)).Needed
	(*Nk_memory_status)(unsafe.Pointer(s)).Memory = (*Nk_buffer)(unsafe.Pointer(b)).Memory.Ptr
	(*Nk_memory_status)(unsafe.Pointer(s)).Calls = (*Nk_buffer)(unsafe.Pointer(b)).Calls
}

var __func__22 = *(*[15]int8)(unsafe.Pointer(ts + 471 /* "nk_buffer_info" */)) /* nuklear.h:8297:1 */

func Xnk_buffer_memory(buffer uintptr) uintptr { /* nuklear.h:8307:12: */
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8310), uintptr(unsafe.Pointer(&__func__23)))
	}
	if !(buffer != 0) {
		return uintptr(0)
	}
	return (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Ptr
}

var __func__23 = *(*[17]int8)(unsafe.Pointer(ts + 486 /* "nk_buffer_memory" */)) /* nuklear.h:8309:1 */

func Xnk_buffer_memory_const(buffer uintptr) uintptr { /* nuklear.h:8314:18: */
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8317), uintptr(unsafe.Pointer(&__func__24)))
	}
	if !(buffer != 0) {
		return uintptr(0)
	}
	return (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Ptr
}

var __func__24 = *(*[23]int8)(unsafe.Pointer(ts + 503 /* "nk_buffer_memory..." */)) /* nuklear.h:8316:1 */

func Xnk_buffer_total(buffer uintptr) Nk_size { /* nuklear.h:8322:1: */
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(8324), uintptr(unsafe.Pointer(&__func__25)))
	}
	if !(buffer != 0) {
		return Nk_size(0)
	}
	return (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Size
}

var __func__25 = *(*[16]int8)(unsafe.Pointer(ts + 526 /* "nk_buffer_total" */)) /* nuklear.h:8323:1 */

// ===============================================================
//
//                              STRING
//
// ===============================================================
func Xnk_str_init_default(str uintptr) { /* nuklear.h:8340:1: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	// var alloc Nk_allocator at bp, 12

	*(*uintptr)(unsafe.Pointer(bp /* &alloc */ /* &.userdata */)) = uintptr(0)
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Alloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, uintptr, Nk_size) uintptr
	}{nk_malloc}))
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Free = *(*uintptr)(unsafe.Pointer(&struct{ f func(Nk_handle, uintptr) }{nk_mfree}))
	Xnk_buffer_init((str /* &.buffer */), bp /* &alloc */, uint32(32))
	(*Nk_str)(unsafe.Pointer(str)).Len = 0
}

func Xnk_str_init(str uintptr, alloc uintptr, size Nk_size) { /* nuklear.h:8352:1: */
	Xnk_buffer_init((str /* &.buffer */), alloc, size)
	(*Nk_str)(unsafe.Pointer(str)).Len = 0
}

func Xnk_str_init_fixed(str uintptr, memory uintptr, size Nk_size) { /* nuklear.h:8358:1: */
	Xnk_buffer_init_fixed((str /* &.buffer */), memory, size)
	(*Nk_str)(unsafe.Pointer(str)).Len = 0
}

func Xnk_str_append_text_char(s uintptr, str uintptr, len int32) int32 { /* nuklear.h:8364:1: */
	var mem uintptr
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8367), uintptr(unsafe.Pointer(&__func__26)))
	}
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8368), uintptr(unsafe.Pointer(&__func__26)))
	}
	if (!(s != 0) || !(str != 0)) || !(len != 0) {
		return 0
	}
	mem = nk_buffer_alloc((s /* &.buffer */), NK_BUFFER_FRONT, (Nk_size(len) * Nk_size(unsafe.Sizeof(int8(0)))), uint32(0))
	if !(mem != 0) {
		return 0
	}
	nk_memcopy(mem, str, (Nk_size(len) * Nk_size(unsafe.Sizeof(int8(0)))))
	*(*int32)(unsafe.Pointer(s + 60 /* &.len */)) += (Xnk_utf_len(str, len))
	return len
}

var __func__26 = *(*[24]int8)(unsafe.Pointer(ts + 542 /* "nk_str_append_te..." */)) /* nuklear.h:8365:1 */

func Xnk_str_append_str_char(s uintptr, str uintptr) int32 { /* nuklear.h:8377:1: */
	return Xnk_str_append_text_char(s, str, Xnk_strlen(str))
}

func Xnk_str_append_text_utf8(str uintptr, text uintptr, len int32) int32 { /* nuklear.h:8382:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	var byte_len int32 = 0
	// var unicode Nk_rune at bp, 4

	if (!(str != 0) || !(text != 0)) || !(len != 0) {
		return 0
	}
	for i = 0; i < len; i++ {
		byte_len = byte_len + (Xnk_utf_decode((text + uintptr(byte_len)), bp /* &unicode */, 4))
	}
	Xnk_str_append_text_char(str, text, byte_len)
	return len
}

func Xnk_str_append_str_utf8(str uintptr, text uintptr) int32 { /* nuklear.h:8394:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var runes int32 = 0
	var byte_len int32 = 0
	var num_runes int32 = 0
	var glyph_len int32 = 0
	// var unicode Nk_rune at bp, 4

	if !(str != 0) || !(text != 0) {
		return 0
	}

	glyph_len = AssignInt32(&byte_len, Xnk_utf_decode((text+uintptr(byte_len)), bp /* &unicode */, 4))
	for (*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) != Nk_rune(0)) && (glyph_len != 0) {
		glyph_len = Xnk_utf_decode((text + uintptr(byte_len)), bp /* &unicode */, 4)
		byte_len = byte_len + (glyph_len)
		num_runes++
	}
	Xnk_str_append_text_char(str, text, byte_len)
	return runes
}

func Xnk_str_append_text_runes(str uintptr, text uintptr, len int32) int32 { /* nuklear.h:8413:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	var byte_len int32 = 0
	// var glyph Nk_glyph at bp, 4

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8419), uintptr(unsafe.Pointer(&__func__27)))
	}
	if (!(str != 0) || !(text != 0)) || !(len != 0) {
		return 0
	}
	for i = 0; i < len; i++ {
		byte_len = Xnk_utf_encode(*(*Nk_rune)(unsafe.Pointer(text + uintptr(i)*4)), bp /* &glyph[0] */, NK_UTF_SIZE)
		if !(byte_len != 0) {
			break
		}
		Xnk_str_append_text_char(str, bp /* &glyph[0] */, byte_len)
	}
	return len
}

var __func__27 = *(*[25]int8)(unsafe.Pointer(ts + 566 /* "nk_str_append_te..." */)) /* nuklear.h:8414:1 */

func Xnk_str_append_str_runes(str uintptr, runes uintptr) int32 { /* nuklear.h:8429:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	// var glyph Nk_glyph at bp, 4

	var byte_len int32
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8434), uintptr(unsafe.Pointer(&__func__28)))
	}
	if !(str != 0) || !(runes != 0) {
		return 0
	}
	for *(*Nk_rune)(unsafe.Pointer(runes + uintptr(i)*4)) != Nk_rune(0) {
		byte_len = Xnk_utf_encode(*(*Nk_rune)(unsafe.Pointer(runes + uintptr(i)*4)), bp /* &glyph[0] */, NK_UTF_SIZE)
		Xnk_str_append_text_char(str, bp /* &glyph[0] */, byte_len)
		i++
	}
	return i
}

var __func__28 = *(*[24]int8)(unsafe.Pointer(ts + 591 /* "nk_str_append_st..." */)) /* nuklear.h:8430:1 */

func Xnk_str_insert_at_char(s uintptr, pos int32, str uintptr, len int32) int32 { /* nuklear.h:8444:1: */
	var i int32
	var mem uintptr
	var src uintptr
	var dst uintptr
	var copylen int32
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8452), uintptr(unsafe.Pointer(&__func__29)))
	}
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8453), uintptr(unsafe.Pointer(&__func__29)))
	}
	if len >= 0 {
	} else {
		X__assert_fail(ts+615 /* "len >= 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(8454), uintptr(unsafe.Pointer(&__func__29)))
	}
	if ((!(s != 0) || !(str != 0)) || !(len != 0)) || (Nk_size(pos) > (*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) {
		return 0
	}
	if (((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated + Nk_size(len)) >= (*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Size) && (int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Type) == NK_BUFFER_FIXED) {
		return 0
	}

	copylen = (int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) - pos)
	if !(copylen != 0) {
		Xnk_str_append_text_char(s, str, len)
		return 1
	}
	mem = nk_buffer_alloc((s /* &.buffer */), NK_BUFFER_FRONT, (Nk_size(len) * Nk_size(unsafe.Sizeof(int8(0)))), uint32(0))
	if !(mem != 0) {
		return 0
	}

	// memmove
	if ((pos + len) + (copylen - 1)) >= 0 {
	} else {
		X__assert_fail(ts+624 /* "((int)pos + (int..." */, ts+2 /* "nuklear/nuklear...." */, uint32(8468), uintptr(unsafe.Pointer(&__func__29)))
	}
	if (pos + (copylen - 1)) >= 0 {
	} else {
		X__assert_fail(ts+672 /* "((int)pos + ((in..." */, ts+2 /* "nuklear/nuklear...." */, uint32(8469), uintptr(unsafe.Pointer(&__func__29)))
	}
	dst = (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr(((pos + len) + (copylen - 1))))
	src = (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos + (copylen - 1))))
	for i = 0; i < copylen; i++ {
		*(*int8)(unsafe.Pointer(PostDecUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(PostDecUintptr(&src, 1)))
	}
	mem = (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos)))
	nk_memcopy(mem, str, (Nk_size(len) * Nk_size(unsafe.Sizeof(int8(0)))))
	(*Nk_str)(unsafe.Pointer(s)).Len = Xnk_utf_len((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr, int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated))
	return 1
}

var __func__29 = *(*[22]int8)(unsafe.Pointer(ts + 709 /* "nk_str_insert_at..." */)) /* nuklear.h:8445:1 */

func Xnk_str_insert_at_rune(str uintptr, pos int32, cstr uintptr, len int32) int32 { /* nuklear.h:8479:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	// var glyph_len int32 at bp+4, 4

	// var unicode Nk_rune at bp, 4

	var begin uintptr
	var buffer uintptr

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8486), uintptr(unsafe.Pointer(&__func__30)))
	}
	if cstr != 0 {
	} else {
		X__assert_fail(ts+731 /* "cstr" */, ts+2 /* "nuklear/nuklear...." */, uint32(8487), uintptr(unsafe.Pointer(&__func__30)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(8488), uintptr(unsafe.Pointer(&__func__30)))
	}
	if (!(str != 0) || !(cstr != 0)) || !(len != 0) {
		return 0
	}
	begin = Xnk_str_at_rune(str, pos, bp /* &unicode */, bp+4 /* &glyph_len */)
	if !((*Nk_str)(unsafe.Pointer(str)).Len != 0) {
		return Xnk_str_append_text_char(str, cstr, len)
	}
	buffer = Xnk_str_get_const(str)
	if !(begin != 0) {
		return 0
	}
	return Xnk_str_insert_at_char(str, (int32((int32(begin) - int32(buffer)) / 1)), cstr, len)
}

var __func__30 = *(*[22]int8)(unsafe.Pointer(ts + 736 /* "nk_str_insert_at..." */)) /* nuklear.h:8480:1 */

func Xnk_str_insert_text_char(str uintptr, pos int32, text uintptr, len int32) int32 { /* nuklear.h:8498:1: */
	return Xnk_str_insert_text_utf8(str, pos, text, len)
}

func Xnk_str_insert_str_char(str uintptr, pos int32, text uintptr) int32 { /* nuklear.h:8503:1: */
	return Xnk_str_insert_text_utf8(str, pos, text, Xnk_strlen(text))
}

func Xnk_str_insert_text_utf8(str uintptr, pos int32, text uintptr, len int32) int32 { /* nuklear.h:8508:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	var byte_len int32 = 0
	// var unicode Nk_rune at bp, 4

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8514), uintptr(unsafe.Pointer(&__func__31)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(8515), uintptr(unsafe.Pointer(&__func__31)))
	}
	if (!(str != 0) || !(text != 0)) || !(len != 0) {
		return 0
	}
	for i = 0; i < len; i++ {
		byte_len = byte_len + (Xnk_utf_decode((text + uintptr(byte_len)), bp /* &unicode */, 4))
	}
	Xnk_str_insert_at_rune(str, pos, text, byte_len)
	return len
}

var __func__31 = *(*[24]int8)(unsafe.Pointer(ts + 763 /* "nk_str_insert_te..." */)) /* nuklear.h:8509:1 */

func Xnk_str_insert_str_utf8(str uintptr, pos int32, text uintptr) int32 { /* nuklear.h:8523:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var runes int32 = 0
	var byte_len int32 = 0
	var num_runes int32 = 0
	var glyph_len int32 = 0
	// var unicode Nk_rune at bp, 4

	if !(str != 0) || !(text != 0) {
		return 0
	}

	glyph_len = AssignInt32(&byte_len, Xnk_utf_decode((text+uintptr(byte_len)), bp /* &unicode */, 4))
	for (*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) != Nk_rune(0)) && (glyph_len != 0) {
		glyph_len = Xnk_utf_decode((text + uintptr(byte_len)), bp /* &unicode */, 4)
		byte_len = byte_len + (glyph_len)
		num_runes++
	}
	Xnk_str_insert_at_rune(str, pos, text, byte_len)
	return runes
}

func Xnk_str_insert_text_runes(str uintptr, pos int32, runes uintptr, len int32) int32 { /* nuklear.h:8542:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	var byte_len int32 = 0
	// var glyph Nk_glyph at bp, 4

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8548), uintptr(unsafe.Pointer(&__func__32)))
	}
	if (!(str != 0) || !(runes != 0)) || !(len != 0) {
		return 0
	}
	for i = 0; i < len; i++ {
		byte_len = Xnk_utf_encode(*(*Nk_rune)(unsafe.Pointer(runes + uintptr(i)*4)), bp /* &glyph[0] */, NK_UTF_SIZE)
		if !(byte_len != 0) {
			break
		}
		Xnk_str_insert_at_rune(str, (pos + i), bp /* &glyph[0] */, byte_len)
	}
	return len
}

var __func__32 = *(*[25]int8)(unsafe.Pointer(ts + 787 /* "nk_str_insert_te..." */)) /* nuklear.h:8543:1 */

func Xnk_str_insert_str_runes(str uintptr, pos int32, runes uintptr) int32 { /* nuklear.h:8558:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32 = 0
	// var glyph Nk_glyph at bp, 4

	var byte_len int32
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8563), uintptr(unsafe.Pointer(&__func__33)))
	}
	if !(str != 0) || !(runes != 0) {
		return 0
	}
	for *(*Nk_rune)(unsafe.Pointer(runes + uintptr(i)*4)) != Nk_rune(0) {
		byte_len = Xnk_utf_encode(*(*Nk_rune)(unsafe.Pointer(runes + uintptr(i)*4)), bp /* &glyph[0] */, NK_UTF_SIZE)
		Xnk_str_insert_at_rune(str, (pos + i), bp /* &glyph[0] */, byte_len)
		i++
	}
	return i
}

var __func__33 = *(*[24]int8)(unsafe.Pointer(ts + 812 /* "nk_str_insert_st..." */)) /* nuklear.h:8559:1 */

func Xnk_str_remove_chars(s uintptr, len int32) { /* nuklear.h:8573:1: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8575), uintptr(unsafe.Pointer(&__func__34)))
	}
	if len >= 0 {
	} else {
		X__assert_fail(ts+615 /* "len >= 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(8576), uintptr(unsafe.Pointer(&__func__34)))
	}
	if (!(s != 0) || (len < 0)) || (Nk_size(len) > (*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) {
		return
	}
	if (int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) - len) >= 0 {
	} else {
		X__assert_fail(ts+836 /* "((int)s->buffer...." */, ts+2 /* "nuklear/nuklear...." */, uint32(8578), uintptr(unsafe.Pointer(&__func__34)))
	}
	*(*Nk_size)(unsafe.Pointer(s /* &.buffer */ + 44 /* &.allocated */)) -= (Nk_size(len))
	(*Nk_str)(unsafe.Pointer(s)).Len = Xnk_utf_len((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr, int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated))
}

var __func__34 = *(*[20]int8)(unsafe.Pointer(ts + 879 /* "nk_str_remove_ch..." */)) /* nuklear.h:8574:1 */

func Xnk_str_remove_runes(str uintptr, len int32) { /* nuklear.h:8583:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)
	*(*int32)(unsafe.Pointer(bp + 4)) = len

	var index int32
	var begin uintptr
	var end uintptr
	// var unicode Nk_rune at bp, 4

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8590), uintptr(unsafe.Pointer(&__func__35)))
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* len */)) >= 0 {
	} else {
		X__assert_fail(ts+615 /* "len >= 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(8591), uintptr(unsafe.Pointer(&__func__35)))
	}
	if !(str != 0) || (*(*int32)(unsafe.Pointer(bp + 4 /* len */)) < 0) {
		return
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* len */)) >= (*Nk_str)(unsafe.Pointer(str)).Len {
		(*Nk_str)(unsafe.Pointer(str)).Len = 0
		return
	}

	index = ((*Nk_str)(unsafe.Pointer(str)).Len - *(*int32)(unsafe.Pointer(bp + 4 /* len */)))
	begin = Xnk_str_at_rune(str, index, bp /* &unicode */, bp+4 /* &len */)
	end = ((*Nk_str)(unsafe.Pointer(str)).Buffer.Memory.Ptr + uintptr((*Nk_str)(unsafe.Pointer(str)).Buffer.Allocated))
	Xnk_str_remove_chars(str, ((int32((int32(end) - int32(begin)) / 1)) + 1))
}

var __func__35 = *(*[20]int8)(unsafe.Pointer(ts + 899 /* "nk_str_remove_ru..." */)) /* nuklear.h:8584:1 */

func Xnk_str_delete_chars(s uintptr, pos int32, len int32) { /* nuklear.h:8604:1: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8606), uintptr(unsafe.Pointer(&__func__36)))
	}
	if ((!(s != 0) || !(len != 0)) || (Nk_size(pos) > (*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated)) || ((Nk_size(pos + len)) > (*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) {
		return
	}

	if (Nk_size(pos + len)) < (*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated {
		// memmove
		var dst uintptr = (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos)))
		var src uintptr = (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos + len)))
		nk_memcopy(dst, src, ((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated - (Nk_size(pos + len))))
		if (int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) - len) >= 0 {
		} else {
			X__assert_fail(ts+836 /* "((int)s->buffer...." */, ts+2 /* "nuklear/nuklear...." */, uint32(8615), uintptr(unsafe.Pointer(&__func__36)))
		}
		*(*Nk_size)(unsafe.Pointer(s /* &.buffer */ + 44 /* &.allocated */)) -= (Nk_size(len))
	} else {
		Xnk_str_remove_chars(s, len)
	}
	(*Nk_str)(unsafe.Pointer(s)).Len = Xnk_utf_len((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr, int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated))
}

var __func__36 = *(*[20]int8)(unsafe.Pointer(ts + 919 /* "nk_str_delete_ch..." */)) /* nuklear.h:8605:1 */

func Xnk_str_delete_runes(s uintptr, pos int32, len int32) { /* nuklear.h:8621:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var temp uintptr
	// var unicode Nk_rune at bp, 4

	var begin uintptr
	var end uintptr
	// var unused int32 at bp+4, 4

	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8629), uintptr(unsafe.Pointer(&__func__37)))
	}
	if (*Nk_str)(unsafe.Pointer(s)).Len >= (pos + len) {
	} else {
		X__assert_fail(ts+939 /* "s->len >= pos + ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(8630), uintptr(unsafe.Pointer(&__func__37)))
	}
	if (*Nk_str)(unsafe.Pointer(s)).Len < (pos + len) {
		len = func() int32 {
			if (func() int32 {
				if ((*Nk_str)(unsafe.Pointer(s)).Len - pos) < ((*Nk_str)(unsafe.Pointer(s)).Len) {
					return ((*Nk_str)(unsafe.Pointer(s)).Len - pos)
				}
				return (*Nk_str)(unsafe.Pointer(s)).Len
			}()) < (0) {
				return 0
			}
			return func() int32 {
				if ((*Nk_str)(unsafe.Pointer(s)).Len - pos) < ((*Nk_str)(unsafe.Pointer(s)).Len) {
					return ((*Nk_str)(unsafe.Pointer(s)).Len - pos)
				}
				return (*Nk_str)(unsafe.Pointer(s)).Len
			}()
		}()
	}
	if !(len != 0) {
		return
	}

	temp = (*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr
	begin = Xnk_str_at_rune(s, pos, bp /* &unicode */, bp+4 /* &unused */)
	if !(begin != 0) {
		return
	}
	(*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr = begin
	end = Xnk_str_at_rune(s, len, bp /* &unicode */, bp+4 /* &unused */)
	(*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr = temp
	if !(end != 0) {
		return
	}
	Xnk_str_delete_chars(s, (int32((int32(begin) - int32(temp)) / 1)), (int32((int32(end) - int32(begin)) / 1)))
}

var __func__37 = *(*[20]int8)(unsafe.Pointer(ts + 959 /* "nk_str_delete_ru..." */)) /* nuklear.h:8622:1 */

func Xnk_str_at_char(s uintptr, pos int32) uintptr { /* nuklear.h:8644:12: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8647), uintptr(unsafe.Pointer(&__func__38)))
	}
	if !(s != 0) || (pos > int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated)) {
		return uintptr(0)
	}
	return (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos)))
}

var __func__38 = *(*[15]int8)(unsafe.Pointer(ts + 979 /* "nk_str_at_char" */)) /* nuklear.h:8646:1 */

func Xnk_str_at_rune(str uintptr, pos int32, unicode uintptr, len uintptr) uintptr { /* nuklear.h:8651:12: */
	var i int32 = 0
	var src_len int32 = 0
	var glyph_len int32 = 0
	var text uintptr
	var text_len int32

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8660), uintptr(unsafe.Pointer(&__func__39)))
	}
	if unicode != 0 {
	} else {
		X__assert_fail(ts+247 /* "unicode" */, ts+2 /* "nuklear/nuklear...." */, uint32(8661), uintptr(unsafe.Pointer(&__func__39)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(8662), uintptr(unsafe.Pointer(&__func__39)))
	}

	if (!(str != 0) || !(unicode != 0)) || !(len != 0) {
		return uintptr(0)
	}
	if pos < 0 {
		*(*Nk_rune)(unsafe.Pointer(unicode)) = Nk_rune(0)
		*(*int32)(unsafe.Pointer(len)) = 0
		return uintptr(0)
	}

	text = (*Nk_str)(unsafe.Pointer(str)).Buffer.Memory.Ptr
	text_len = int32((*Nk_str)(unsafe.Pointer(str)).Buffer.Allocated)
	glyph_len = Xnk_utf_decode(text, unicode, text_len)
	for glyph_len != 0 {
		if i == pos {
			*(*int32)(unsafe.Pointer(len)) = glyph_len
			break
		}

		i++
		src_len = (src_len + glyph_len)
		glyph_len = Xnk_utf_decode((text + uintptr(src_len)), unicode, (text_len - src_len))
	}
	if i != pos {
		return uintptr(0)
	}
	return (text + uintptr(src_len))
}

var __func__39 = *(*[15]int8)(unsafe.Pointer(ts + 994 /* "nk_str_at_rune" */)) /* nuklear.h:8653:1 */

func Xnk_str_at_char_const(s uintptr, pos int32) uintptr { /* nuklear.h:8687:18: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8690), uintptr(unsafe.Pointer(&__func__40)))
	}
	if !(s != 0) || (pos > int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated)) {
		return uintptr(0)
	}
	return (((*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr) + uintptr((pos)))
}

var __func__40 = *(*[21]int8)(unsafe.Pointer(ts + 1009 /* "nk_str_at_char_c..." */)) /* nuklear.h:8689:1 */

func Xnk_str_at_const(str uintptr, pos int32, unicode uintptr, len uintptr) uintptr { /* nuklear.h:8694:18: */
	var i int32 = 0
	var src_len int32 = 0
	var glyph_len int32 = 0
	var text uintptr
	var text_len int32

	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8703), uintptr(unsafe.Pointer(&__func__41)))
	}
	if unicode != 0 {
	} else {
		X__assert_fail(ts+247 /* "unicode" */, ts+2 /* "nuklear/nuklear...." */, uint32(8704), uintptr(unsafe.Pointer(&__func__41)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(8705), uintptr(unsafe.Pointer(&__func__41)))
	}

	if (!(str != 0) || !(unicode != 0)) || !(len != 0) {
		return uintptr(0)
	}
	if pos < 0 {
		*(*Nk_rune)(unsafe.Pointer(unicode)) = Nk_rune(0)
		*(*int32)(unsafe.Pointer(len)) = 0
		return uintptr(0)
	}

	text = (*Nk_str)(unsafe.Pointer(str)).Buffer.Memory.Ptr
	text_len = int32((*Nk_str)(unsafe.Pointer(str)).Buffer.Allocated)
	glyph_len = Xnk_utf_decode(text, unicode, text_len)
	for glyph_len != 0 {
		if i == pos {
			*(*int32)(unsafe.Pointer(len)) = glyph_len
			break
		}

		i++
		src_len = (src_len + glyph_len)
		glyph_len = Xnk_utf_decode((text + uintptr(src_len)), unicode, (text_len - src_len))
	}
	if i != pos {
		return uintptr(0)
	}
	return (text + uintptr(src_len))
}

var __func__41 = *(*[16]int8)(unsafe.Pointer(ts + 1030 /* "nk_str_at_const" */)) /* nuklear.h:8696:1 */

func Xnk_str_rune_at(str uintptr, pos int32) Nk_rune { /* nuklear.h:8731:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	// var len int32 at bp+4, 4

	*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
	Xnk_str_at_const(str, pos, bp /* &unicode */, bp+4 /* &len */)
	return *(*Nk_rune)(unsafe.Pointer(bp /* unicode */))
}

func Xnk_str_get(s uintptr) uintptr { /* nuklear.h:8738:12: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8741), uintptr(unsafe.Pointer(&__func__42)))
	}
	if (!(s != 0) || !((*Nk_str)(unsafe.Pointer(s)).Len != 0)) || !(int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) != 0) {
		return uintptr(0)
	}
	return (*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr
}

var __func__42 = *(*[11]int8)(unsafe.Pointer(ts + 1046 /* "nk_str_get" */)) /* nuklear.h:8740:1 */

func Xnk_str_get_const(s uintptr) uintptr { /* nuklear.h:8745:18: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8748), uintptr(unsafe.Pointer(&__func__43)))
	}
	if (!(s != 0) || !((*Nk_str)(unsafe.Pointer(s)).Len != 0)) || !(int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) != 0) {
		return uintptr(0)
	}
	return (*Nk_str)(unsafe.Pointer(s)).Buffer.Memory.Ptr
}

var __func__43 = *(*[17]int8)(unsafe.Pointer(ts + 1057 /* "nk_str_get_const" */)) /* nuklear.h:8747:1 */

func Xnk_str_len(s uintptr) int32 { /* nuklear.h:8753:1: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8755), uintptr(unsafe.Pointer(&__func__44)))
	}
	if (!(s != 0) || !((*Nk_str)(unsafe.Pointer(s)).Len != 0)) || !(int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) != 0) {
		return 0
	}
	return (*Nk_str)(unsafe.Pointer(s)).Len
}

var __func__44 = *(*[11]int8)(unsafe.Pointer(ts + 1074 /* "nk_str_len" */)) /* nuklear.h:8754:1 */

func Xnk_str_len_char(s uintptr) int32 { /* nuklear.h:8760:1: */
	if s != 0 {
	} else {
		X__assert_fail(ts+164 /* "s" */, ts+2 /* "nuklear/nuklear...." */, uint32(8762), uintptr(unsafe.Pointer(&__func__45)))
	}
	if (!(s != 0) || !((*Nk_str)(unsafe.Pointer(s)).Len != 0)) || !(int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated) != 0) {
		return 0
	}
	return int32((*Nk_str)(unsafe.Pointer(s)).Buffer.Allocated)
}

var __func__45 = *(*[16]int8)(unsafe.Pointer(ts + 1085 /* "nk_str_len_char" */)) /* nuklear.h:8761:1 */

func Xnk_str_clear(str uintptr) { /* nuklear.h:8767:1: */
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8769), uintptr(unsafe.Pointer(&__func__46)))
	}
	Xnk_buffer_clear((str /* &.buffer */))
	(*Nk_str)(unsafe.Pointer(str)).Len = 0
}

var __func__46 = *(*[13]int8)(unsafe.Pointer(ts + 1101 /* "nk_str_clear" */)) /* nuklear.h:8768:1 */

func Xnk_str_free(str uintptr) { /* nuklear.h:8774:1: */
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(8776), uintptr(unsafe.Pointer(&__func__47)))
	}
	Xnk_buffer_free((str /* &.buffer */))
	(*Nk_str)(unsafe.Pointer(str)).Len = 0
}

var __func__47 = *(*[12]int8)(unsafe.Pointer(ts + 1114 /* "nk_str_free" */)) /* nuklear.h:8775:1 */

// ==============================================================
//
//                          DRAW
//
// ===============================================================
func nk_command_buffer_init(cb uintptr, b uintptr, clip uint32) { /* nuklear.h:8791:1: */
	if cb != 0 {
	} else {
		X__assert_fail(ts+1126 /* "cb" */, ts+2 /* "nuklear/nuklear...." */, uint32(8794), uintptr(unsafe.Pointer(&__func__48)))
	}
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8795), uintptr(unsafe.Pointer(&__func__48)))
	}
	if !(cb != 0) || !(b != 0) {
		return
	}
	(*Nk_command_buffer)(unsafe.Pointer(cb)).Base = b
	(*Nk_command_buffer)(unsafe.Pointer(cb)).Use_clipping = int32(clip)
	(*Nk_command_buffer)(unsafe.Pointer(cb)).Begin = (*Nk_buffer)(unsafe.Pointer(b)).Allocated
	(*Nk_command_buffer)(unsafe.Pointer(cb)).End = (*Nk_buffer)(unsafe.Pointer(b)).Allocated
	(*Nk_command_buffer)(unsafe.Pointer(cb)).Last = (*Nk_buffer)(unsafe.Pointer(b)).Allocated
}

var __func__48 = *(*[23]int8)(unsafe.Pointer(ts + 1129 /* "nk_command_buffe..." */)) /* nuklear.h:8793:1 */

func nk_command_buffer_reset(b uintptr) { /* nuklear.h:8804:1: */
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8806), uintptr(unsafe.Pointer(&__func__49)))
	}
	if !(b != 0) {
		return
	}
	(*Nk_command_buffer)(unsafe.Pointer(b)).Begin = Nk_size(0)
	(*Nk_command_buffer)(unsafe.Pointer(b)).End = Nk_size(0)
	(*Nk_command_buffer)(unsafe.Pointer(b)).Last = Nk_size(0)
	(*Nk_command_buffer)(unsafe.Pointer(b)).Clip = nk_null_rect
}

var __func__49 = *(*[24]int8)(unsafe.Pointer(ts + 1152 /* "nk_command_buffe..." */)) /* nuklear.h:8805:1 */

func nk_command_buffer_push(b uintptr, t uint32, size Nk_size) uintptr { /* nuklear.h:8816:12: */
	var cmd uintptr
	var alignment Nk_size
	var unaligned uintptr
	var memory uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8826), uintptr(unsafe.Pointer(&__func__50)))
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Base != 0 {
	} else {
		X__assert_fail(ts+1176 /* "b->base" */, ts+2 /* "nuklear/nuklear...." */, uint32(8827), uintptr(unsafe.Pointer(&__func__50)))
	}
	if !(b != 0) {
		return uintptr(0)
	}
	cmd = nk_buffer_alloc((*Nk_command_buffer)(unsafe.Pointer(b)).Base, NK_BUFFER_FRONT, size, align)
	if !(cmd != 0) {
		return uintptr(0)
	}

	// make sure the offset to the next command is aligned
	(*Nk_command_buffer)(unsafe.Pointer(b)).Last = (Nk_size((int32(cmd) - int32((*Nk_buffer)(unsafe.Pointer((*Nk_command_buffer)(unsafe.Pointer(b)).Base)).Memory.Ptr)) / 1))
	unaligned = (cmd + uintptr(size))
	memory = uintptr((int32((Nk_size(((unaligned) + uintptr((align - Nk_size(1)))))) & ^(align - Nk_size(1)))))
	alignment = (Nk_size((int32(memory) - int32(unaligned)) / 1))

	(*Nk_command)(unsafe.Pointer(cmd)).Type = t
	(*Nk_command)(unsafe.Pointer(cmd)).Next = ((*Nk_buffer)(unsafe.Pointer((*Nk_command_buffer)(unsafe.Pointer(b)).Base)).Allocated + alignment)
	(*Nk_command_buffer)(unsafe.Pointer(b)).End = (*Nk_command)(unsafe.Pointer(cmd)).Next
	return cmd
}

var __func__50 = *(*[23]int8)(unsafe.Pointer(ts + 1184 /* "nk_command_buffe..." */)) /* nuklear.h:8819:1 */
var align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))        /* nuklear.h:8820:30 */

func Xnk_push_scissor(b uintptr, r Nk_rect) { /* nuklear.h:8850:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8853), uintptr(unsafe.Pointer(&__func__51)))
	}
	if !(b != 0) {
		return
	}

	(*Nk_command_buffer)(unsafe.Pointer(b)).Clip.X = r.X
	(*Nk_command_buffer)(unsafe.Pointer(b)).Clip.Y = r.Y
	(*Nk_command_buffer)(unsafe.Pointer(b)).Clip.W = r.W
	(*Nk_command_buffer)(unsafe.Pointer(b)).Clip.H = r.H
	cmd = nk_command_buffer_push(b, NK_COMMAND_SCISSOR, uint32(unsafe.Sizeof(Nk_command_scissor{})))

	if !(cmd != 0) {
		return
	}
	(*Nk_command_scissor)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_scissor)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_scissor)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (r.W) {
			return uint16(r.W)
		}
		return uint16(0)
	}()
	(*Nk_command_scissor)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (r.H) {
			return uint16(r.H)
		}
		return uint16(0)
	}()
}

var __func__51 = *(*[16]int8)(unsafe.Pointer(ts + 1207 /* "nk_push_scissor" */)) /* nuklear.h:8851:1 */

func Xnk_stroke_line(b uintptr, x0 float32, y0 float32, x1 float32, y1 float32, line_thickness float32, c Nk_color) { /* nuklear.h:8870:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8874), uintptr(unsafe.Pointer(&__func__52)))
	}
	if !(b != 0) || (line_thickness <= float32(0)) {
		return
	}
	cmd = nk_command_buffer_push(b, NK_COMMAND_LINE, uint32(unsafe.Sizeof(Nk_command_line{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_line)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_line)(unsafe.Pointer(cmd)).Begin.X = int16(x0)
	(*Nk_command_line)(unsafe.Pointer(cmd)).Begin.Y = int16(y0)
	(*Nk_command_line)(unsafe.Pointer(cmd)).End.X = int16(x1)
	(*Nk_command_line)(unsafe.Pointer(cmd)).End.Y = int16(y1)
	(*Nk_command_line)(unsafe.Pointer(cmd)).Color = c
}

var __func__52 = *(*[15]int8)(unsafe.Pointer(ts + 1223 /* "nk_stroke_line" */)) /* nuklear.h:8872:1 */

func Xnk_stroke_curve(b uintptr, ax float32, ay float32, ctrl0x float32, ctrl0y float32, ctrl1x float32, ctrl1y float32, bx float32, by float32, line_thickness float32, col Nk_color) { /* nuklear.h:8887:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8892), uintptr(unsafe.Pointer(&__func__53)))
	}
	if (!(b != 0) || (int32(col.A) == 0)) || (line_thickness <= float32(0)) {
		return
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_CURVE, uint32(unsafe.Sizeof(Nk_command_curve{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_curve)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_curve)(unsafe.Pointer(cmd)).Begin.X = int16(ax)
	(*Nk_command_curve)(unsafe.Pointer(cmd)).Begin.Y = int16(ay)
	(*Nk_vec2i)(unsafe.Pointer((cmd + 18 /* &.ctrl */))).X = int16(ctrl0x)
	(*Nk_vec2i)(unsafe.Pointer((cmd + 18 /* &.ctrl */))).Y = int16(ctrl0y)
	(*Nk_vec2i)(unsafe.Pointer((cmd + 18 /* &.ctrl */) + 1*4)).X = int16(ctrl1x)
	(*Nk_vec2i)(unsafe.Pointer((cmd + 18 /* &.ctrl */) + 1*4)).Y = int16(ctrl1y)
	(*Nk_command_curve)(unsafe.Pointer(cmd)).End.X = int16(bx)
	(*Nk_command_curve)(unsafe.Pointer(cmd)).End.Y = int16(by)
	(*Nk_command_curve)(unsafe.Pointer(cmd)).Color = col
}

var __func__53 = *(*[16]int8)(unsafe.Pointer(ts + 1238 /* "nk_stroke_curve" */)) /* nuklear.h:8890:1 */

func Xnk_stroke_rect(b uintptr, rect Nk_rect, rounding float32, line_thickness float32, c Nk_color) { /* nuklear.h:8910:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8914), uintptr(unsafe.Pointer(&__func__54)))
	}
	if (((!(b != 0) || (int32(c.A) == 0)) || (rect.W == float32(0))) || (rect.H == float32(0))) || (line_thickness <= float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(clip)).X < (rect.X + rect.W)) && (rect.X < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((*Nk_rect)(unsafe.Pointer(clip)).Y < (rect.Y + rect.H))) && (rect.Y < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))) {
			return
		}
	}
	cmd = nk_command_buffer_push(b, NK_COMMAND_RECT, uint32(unsafe.Sizeof(Nk_command_rect{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_rect)(unsafe.Pointer(cmd)).Rounding = uint16(rounding)
	(*Nk_command_rect)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_rect)(unsafe.Pointer(cmd)).X = int16(rect.X)
	(*Nk_command_rect)(unsafe.Pointer(cmd)).Y = int16(rect.Y)
	(*Nk_command_rect)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (rect.W) {
			return uint16(rect.W)
		}
		return uint16(0)
	}()
	(*Nk_command_rect)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (rect.H) {
			return uint16(rect.H)
		}
		return uint16(0)
	}()
	(*Nk_command_rect)(unsafe.Pointer(cmd)).Color = c
}

var __func__54 = *(*[15]int8)(unsafe.Pointer(ts + 1254 /* "nk_stroke_rect" */)) /* nuklear.h:8912:1 */

func Xnk_fill_rect(b uintptr, rect Nk_rect, rounding float32, c Nk_color) { /* nuklear.h:8933:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8937), uintptr(unsafe.Pointer(&__func__55)))
	}
	if ((!(b != 0) || (int32(c.A) == 0)) || (rect.W == float32(0))) || (rect.H == float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(clip)).X < (rect.X + rect.W)) && (rect.X < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((*Nk_rect)(unsafe.Pointer(clip)).Y < (rect.Y + rect.H))) && (rect.Y < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_RECT_FILLED, uint32(unsafe.Sizeof(Nk_command_rect_filled{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).Rounding = uint16(rounding)
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).X = int16(rect.X)
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).Y = int16(rect.Y)
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (rect.W) {
			return uint16(rect.W)
		}
		return uint16(0)
	}()
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (rect.H) {
			return uint16(rect.H)
		}
		return uint16(0)
	}()
	(*Nk_command_rect_filled)(unsafe.Pointer(cmd)).Color = c
}

var __func__55 = *(*[13]int8)(unsafe.Pointer(ts + 1269 /* "nk_fill_rect" */)) /* nuklear.h:8935:1 */

func Xnk_fill_rect_multi_color(b uintptr, rect Nk_rect, left Nk_color, top Nk_color, right Nk_color, bottom Nk_color) { /* nuklear.h:8956:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(8961), uintptr(unsafe.Pointer(&__func__56)))
	}
	if (!(b != 0) || (rect.W == float32(0))) || (rect.H == float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(clip)).X < (rect.X + rect.W)) && (rect.X < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((*Nk_rect)(unsafe.Pointer(clip)).Y < (rect.Y + rect.H))) && (rect.Y < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_RECT_MULTI_COLOR, uint32(unsafe.Sizeof(Nk_command_rect_multi_color{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).X = int16(rect.X)
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).Y = int16(rect.Y)
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (rect.W) {
			return uint16(rect.W)
		}
		return uint16(0)
	}()
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (rect.H) {
			return uint16(rect.H)
		}
		return uint16(0)
	}()
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).Left = left
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).Top = top
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).Right = right
	(*Nk_command_rect_multi_color)(unsafe.Pointer(cmd)).Bottom = bottom
}

var __func__56 = *(*[25]int8)(unsafe.Pointer(ts + 1282 /* "nk_fill_rect_mul..." */)) /* nuklear.h:8959:1 */

func Xnk_stroke_circle(b uintptr, r Nk_rect, line_thickness float32, c Nk_color) { /* nuklear.h:8982:1: */
	var cmd uintptr
	if ((!(b != 0) || (r.W == float32(0))) || (r.H == float32(0))) || (line_thickness <= float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(clip)).X < (r.X + r.W)) && (r.X < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((*Nk_rect)(unsafe.Pointer(clip)).Y < (r.Y + r.H))) && (r.Y < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_CIRCLE, uint32(unsafe.Sizeof(Nk_command_circle{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_circle)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_circle)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_circle)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_circle)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (r.W) < (float32(0)) {
			return uint16(0)
		}
		return uint16(r.W)
	}()
	(*Nk_command_circle)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (r.H) < (float32(0)) {
			return uint16(0)
		}
		return uint16(r.H)
	}()
	(*Nk_command_circle)(unsafe.Pointer(cmd)).Color = c
}

func Xnk_fill_circle(b uintptr, r Nk_rect, c Nk_color) { /* nuklear.h:9004:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9007), uintptr(unsafe.Pointer(&__func__57)))
	}
	if ((!(b != 0) || (int32(c.A) == 0)) || (r.W == float32(0))) || (r.H == float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(clip)).X < (r.X + r.W)) && (r.X < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((*Nk_rect)(unsafe.Pointer(clip)).Y < (r.Y + r.H))) && (r.Y < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_CIRCLE_FILLED, uint32(unsafe.Sizeof(Nk_command_circle_filled{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_circle_filled)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_circle_filled)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_circle_filled)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (r.W) < (float32(0)) {
			return uint16(0)
		}
		return uint16(r.W)
	}()
	(*Nk_command_circle_filled)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (r.H) < (float32(0)) {
			return uint16(0)
		}
		return uint16(r.H)
	}()
	(*Nk_command_circle_filled)(unsafe.Pointer(cmd)).Color = c
}

var __func__57 = *(*[15]int8)(unsafe.Pointer(ts + 1307 /* "nk_fill_circle" */)) /* nuklear.h:9005:1 */

func Xnk_stroke_arc(b uintptr, cx float32, cy float32, radius float32, a_min float32, a_max float32, line_thickness float32, c Nk_color) { /* nuklear.h:9025:1: */
	var cmd uintptr
	if (!(b != 0) || (int32(c.A) == 0)) || (line_thickness <= float32(0)) {
		return
	}
	cmd = nk_command_buffer_push(b, NK_COMMAND_ARC, uint32(unsafe.Sizeof(Nk_command_arc{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_arc)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_arc)(unsafe.Pointer(cmd)).Cx = int16(cx)
	(*Nk_command_arc)(unsafe.Pointer(cmd)).Cy = int16(cy)
	(*Nk_command_arc)(unsafe.Pointer(cmd)).R = uint16(radius)
	*(*float32)(unsafe.Pointer((cmd + 16 /* &.a */))) = a_min
	*(*float32)(unsafe.Pointer((cmd + 16 /* &.a */) + 1*4)) = a_max
	(*Nk_command_arc)(unsafe.Pointer(cmd)).Color = c
}

func Xnk_fill_arc(b uintptr, cx float32, cy float32, radius float32, a_min float32, a_max float32, c Nk_color) { /* nuklear.h:9042:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9046), uintptr(unsafe.Pointer(&__func__58)))
	}
	if !(b != 0) || (int32(c.A) == 0) {
		return
	}
	cmd = nk_command_buffer_push(b, NK_COMMAND_ARC_FILLED, uint32(unsafe.Sizeof(Nk_command_arc_filled{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_arc_filled)(unsafe.Pointer(cmd)).Cx = int16(cx)
	(*Nk_command_arc_filled)(unsafe.Pointer(cmd)).Cy = int16(cy)
	(*Nk_command_arc_filled)(unsafe.Pointer(cmd)).R = uint16(radius)
	*(*float32)(unsafe.Pointer((cmd + 16 /* &.a */))) = a_min
	*(*float32)(unsafe.Pointer((cmd + 16 /* &.a */) + 1*4)) = a_max
	(*Nk_command_arc_filled)(unsafe.Pointer(cmd)).Color = c
}

var __func__58 = *(*[12]int8)(unsafe.Pointer(ts + 1322 /* "nk_fill_arc" */)) /* nuklear.h:9044:1 */

func Xnk_stroke_triangle(b uintptr, x0 float32, y0 float32, x1 float32, y1 float32, x2 float32, y2 float32, line_thickness float32, c Nk_color) { /* nuklear.h:9059:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9063), uintptr(unsafe.Pointer(&__func__59)))
	}
	if (!(b != 0) || (int32(c.A) == 0)) || (line_thickness <= float32(0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if (!(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x0)) && ((x0) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y0)) && ((y0) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H)))) && !(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x1)) && ((x1) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y1)) && ((y1) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))))) && !(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x2)) && ((x2) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y2)) && ((y2) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H)))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_TRIANGLE, uint32(unsafe.Sizeof(Nk_command_triangle{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).A.X = int16(x0)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).A.Y = int16(y0)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).B.X = int16(x1)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).B.Y = int16(y1)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).C.X = int16(x2)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).C.Y = int16(y2)
	(*Nk_command_triangle)(unsafe.Pointer(cmd)).Color = c
}

var __func__59 = *(*[19]int8)(unsafe.Pointer(ts + 1334 /* "nk_stroke_triang..." */)) /* nuklear.h:9061:1 */

func Xnk_fill_triangle(b uintptr, x0 float32, y0 float32, x1 float32, y1 float32, x2 float32, y2 float32, c Nk_color) { /* nuklear.h:9086:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9090), uintptr(unsafe.Pointer(&__func__60)))
	}
	if !(b != 0) || (int32(c.A) == 0) {
		return
	}
	if !(b != 0) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var clip uintptr = (b + 4 /* &.clip */)
		if (!(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x0)) && ((x0) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y0)) && ((y0) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H)))) && !(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x1)) && ((x1) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y1)) && ((y1) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H))))) && !(((((*Nk_rect)(unsafe.Pointer(clip)).X) <= (x2)) && ((x2) < ((*Nk_rect)(unsafe.Pointer(clip)).X + (*Nk_rect)(unsafe.Pointer(clip)).W))) && ((((*Nk_rect)(unsafe.Pointer(clip)).Y) <= (y2)) && ((y2) < ((*Nk_rect)(unsafe.Pointer(clip)).Y + (*Nk_rect)(unsafe.Pointer(clip)).H)))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_TRIANGLE_FILLED, uint32(unsafe.Sizeof(Nk_command_triangle_filled{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).A.X = int16(x0)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).A.Y = int16(y0)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).B.X = int16(x1)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).B.Y = int16(y1)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).C.X = int16(x2)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).C.Y = int16(y2)
	(*Nk_command_triangle_filled)(unsafe.Pointer(cmd)).Color = c
}

var __func__60 = *(*[17]int8)(unsafe.Pointer(ts + 1353 /* "nk_fill_triangle" */)) /* nuklear.h:9088:1 */

func Xnk_stroke_polygon(b uintptr, points uintptr, point_count int32, line_thickness float32, col Nk_color) { /* nuklear.h:9113:1: */
	var i int32
	var size Nk_size = Nk_size(0)
	var cmd uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9120), uintptr(unsafe.Pointer(&__func__61)))
	}
	if (!(b != 0) || (int32(col.A) == 0)) || (line_thickness <= float32(0)) {
		return
	}
	size = (uint32(unsafe.Sizeof(Nk_command_polygon{})) + ((uint32(unsafe.Sizeof(int16(0))) * uint32(2)) * Nk_size(point_count)))
	cmd = nk_command_buffer_push(b, NK_COMMAND_POLYGON, size)
	if !(cmd != 0) {
		return
	}
	(*Nk_command_polygon)(unsafe.Pointer(cmd)).Color = col
	(*Nk_command_polygon)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	(*Nk_command_polygon)(unsafe.Pointer(cmd)).Point_count = uint16(point_count)
	for i = 0; i < point_count; i++ {
		(*Nk_vec2i)(unsafe.Pointer((cmd + 16 /* &.points */) + uintptr(i)*4)).X = int16(*(*float32)(unsafe.Pointer(points + uintptr((i*2))*4)))
		(*Nk_vec2i)(unsafe.Pointer((cmd + 16 /* &.points */) + uintptr(i)*4)).Y = int16(*(*float32)(unsafe.Pointer(points + uintptr(((i*2)+1))*4)))
	}
}

var __func__61 = *(*[18]int8)(unsafe.Pointer(ts + 1370 /* "nk_stroke_polygo..." */)) /* nuklear.h:9115:1 */

func Xnk_fill_polygon(b uintptr, points uintptr, point_count int32, col Nk_color) { /* nuklear.h:9134:1: */
	var i int32
	var size Nk_size = Nk_size(0)
	var cmd uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9141), uintptr(unsafe.Pointer(&__func__62)))
	}
	if !(b != 0) || (int32(col.A) == 0) {
		return
	}
	size = (uint32(unsafe.Sizeof(Nk_command_polygon_filled{})) + ((uint32(unsafe.Sizeof(int16(0))) * uint32(2)) * Nk_size(point_count)))
	cmd = nk_command_buffer_push(b, NK_COMMAND_POLYGON_FILLED, size)
	if !(cmd != 0) {
		return
	}
	(*Nk_command_polygon_filled)(unsafe.Pointer(cmd)).Color = col
	(*Nk_command_polygon_filled)(unsafe.Pointer(cmd)).Point_count = uint16(point_count)
	for i = 0; i < point_count; i++ {
		(*Nk_vec2i)(unsafe.Pointer((cmd + 14 /* &.points */) + uintptr(i)*4)).X = int16(*(*float32)(unsafe.Pointer(points + uintptr(((i*2)+0))*4)))
		(*Nk_vec2i)(unsafe.Pointer((cmd + 14 /* &.points */) + uintptr(i)*4)).Y = int16(*(*float32)(unsafe.Pointer(points + uintptr(((i*2)+1))*4)))
	}
}

var __func__62 = *(*[16]int8)(unsafe.Pointer(ts + 1388 /* "nk_fill_polygon" */)) /* nuklear.h:9136:1 */

func Xnk_stroke_polyline(b uintptr, points uintptr, point_count int32, line_thickness float32, col Nk_color) { /* nuklear.h:9155:1: */
	var i int32
	var size Nk_size = Nk_size(0)
	var cmd uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9162), uintptr(unsafe.Pointer(&__func__63)))
	}
	if (!(b != 0) || (int32(col.A) == 0)) || (line_thickness <= float32(0)) {
		return
	}
	size = (uint32(unsafe.Sizeof(Nk_command_polyline{})) + ((uint32(unsafe.Sizeof(int16(0))) * uint32(2)) * Nk_size(point_count)))
	cmd = nk_command_buffer_push(b, NK_COMMAND_POLYLINE, size)
	if !(cmd != 0) {
		return
	}
	(*Nk_command_polyline)(unsafe.Pointer(cmd)).Color = col
	(*Nk_command_polyline)(unsafe.Pointer(cmd)).Point_count = uint16(point_count)
	(*Nk_command_polyline)(unsafe.Pointer(cmd)).Line_thickness = uint16(line_thickness)
	for i = 0; i < point_count; i++ {
		(*Nk_vec2i)(unsafe.Pointer((cmd + 16 /* &.points */) + uintptr(i)*4)).X = int16(*(*float32)(unsafe.Pointer(points + uintptr((i*2))*4)))
		(*Nk_vec2i)(unsafe.Pointer((cmd + 16 /* &.points */) + uintptr(i)*4)).Y = int16(*(*float32)(unsafe.Pointer(points + uintptr(((i*2)+1))*4)))
	}
}

var __func__63 = *(*[19]int8)(unsafe.Pointer(ts + 1404 /* "nk_stroke_polyli..." */)) /* nuklear.h:9157:1 */

func Xnk_draw_image(b uintptr, r Nk_rect, img uintptr, col Nk_color) { /* nuklear.h:9176:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9180), uintptr(unsafe.Pointer(&__func__64)))
	}
	if !(b != 0) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var c uintptr = (b + 4 /* &.clip */)
		if (((*Nk_rect)(unsafe.Pointer(c)).W == float32(0)) || ((*Nk_rect)(unsafe.Pointer(c)).H == float32(0))) || !(((((*Nk_rect)(unsafe.Pointer(c)).X < (r.X + r.W)) && (r.X < ((*Nk_rect)(unsafe.Pointer(c)).X + (*Nk_rect)(unsafe.Pointer(c)).W))) && ((*Nk_rect)(unsafe.Pointer(c)).Y < (r.Y + r.H))) && (r.Y < ((*Nk_rect)(unsafe.Pointer(c)).Y + (*Nk_rect)(unsafe.Pointer(c)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_IMAGE, uint32(unsafe.Sizeof(Nk_command_image{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_image)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_image)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_image)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (r.W) {
			return uint16(r.W)
		}
		return uint16(0)
	}()
	(*Nk_command_image)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (r.H) {
			return uint16(r.H)
		}
		return uint16(0)
	}()
	(*Nk_command_image)(unsafe.Pointer(cmd)).Img = *(*Nk_image)(unsafe.Pointer(img))
	(*Nk_command_image)(unsafe.Pointer(cmd)).Col = col
}

var __func__64 = *(*[14]int8)(unsafe.Pointer(ts + 1423 /* "nk_draw_image" */)) /* nuklear.h:9178:1 */

func Xnk_push_custom(b uintptr, r Nk_rect, cb Nk_command_custom_callback, usr Nk_handle) { /* nuklear.h:9199:1: */
	var cmd uintptr
	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9203), uintptr(unsafe.Pointer(&__func__65)))
	}
	if !(b != 0) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var c uintptr = (b + 4 /* &.clip */)
		if (((*Nk_rect)(unsafe.Pointer(c)).W == float32(0)) || ((*Nk_rect)(unsafe.Pointer(c)).H == float32(0))) || !(((((*Nk_rect)(unsafe.Pointer(c)).X < (r.X + r.W)) && (r.X < ((*Nk_rect)(unsafe.Pointer(c)).X + (*Nk_rect)(unsafe.Pointer(c)).W))) && ((*Nk_rect)(unsafe.Pointer(c)).Y < (r.Y + r.H))) && (r.Y < ((*Nk_rect)(unsafe.Pointer(c)).Y + (*Nk_rect)(unsafe.Pointer(c)).H))) {
			return
		}
	}

	cmd = nk_command_buffer_push(b, NK_COMMAND_CUSTOM, uint32(unsafe.Sizeof(Nk_command_custom{})))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_custom)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_custom)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_custom)(unsafe.Pointer(cmd)).W = func() uint16 {
		if (float32(0)) < (r.W) {
			return uint16(r.W)
		}
		return uint16(0)
	}()
	(*Nk_command_custom)(unsafe.Pointer(cmd)).H = func() uint16 {
		if (float32(0)) < (r.H) {
			return uint16(r.H)
		}
		return uint16(0)
	}()
	(*Nk_command_custom)(unsafe.Pointer(cmd)).Callback_data = usr
	(*Nk_command_custom)(unsafe.Pointer(cmd)).Callback = cb
}

var __func__65 = *(*[15]int8)(unsafe.Pointer(ts + 1437 /* "nk_push_custom" */)) /* nuklear.h:9201:1 */

func Xnk_draw_text(b uintptr, r Nk_rect, string uintptr, length int32, font uintptr, bg Nk_color, fg Nk_color) { /* nuklear.h:9222:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var text_width float32 = float32(0)
	var cmd uintptr

	if b != 0 {
	} else {
		X__assert_fail(ts+269 /* "b" */, ts+2 /* "nuklear/nuklear...." */, uint32(9229), uintptr(unsafe.Pointer(&__func__66)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(9230), uintptr(unsafe.Pointer(&__func__66)))
	}
	if ((!(b != 0) || !(string != 0)) || !(length != 0)) || ((int32(bg.A) == 0) && (int32(fg.A) == 0)) {
		return
	}
	if (*Nk_command_buffer)(unsafe.Pointer(b)).Use_clipping != 0 {
		var c uintptr = (b + 4 /* &.clip */)
		if (((*Nk_rect)(unsafe.Pointer(c)).W == float32(0)) || ((*Nk_rect)(unsafe.Pointer(c)).H == float32(0))) || !(((((*Nk_rect)(unsafe.Pointer(c)).X < (r.X + r.W)) && (r.X < ((*Nk_rect)(unsafe.Pointer(c)).X + (*Nk_rect)(unsafe.Pointer(c)).W))) && ((*Nk_rect)(unsafe.Pointer(c)).Y < (r.Y + r.H))) && (r.Y < ((*Nk_rect)(unsafe.Pointer(c)).Y + (*Nk_rect)(unsafe.Pointer(c)).H))) {
			return
		}
	}

	// make sure text fits inside bounds
	text_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, string, length)
	if text_width > r.W {
		*(*int32)(unsafe.Pointer(bp /* glyphs */)) = 0
		*(*float32)(unsafe.Pointer(bp + 4 /* txt_width */)) = text_width
		length = nk_text_clamp(font, string, length, r.W, bp /* &glyphs */, bp+4 /* &txt_width */, uintptr(0), 0)
	}

	if !(length != 0) {
		return
	}
	cmd = nk_command_buffer_push(b, NK_COMMAND_TEXT, (uint32(unsafe.Sizeof(Nk_command_text{})) + (Nk_size(length + 1))))
	if !(cmd != 0) {
		return
	}
	(*Nk_command_text)(unsafe.Pointer(cmd)).X = int16(r.X)
	(*Nk_command_text)(unsafe.Pointer(cmd)).Y = int16(r.Y)
	(*Nk_command_text)(unsafe.Pointer(cmd)).W = uint16(r.W)
	(*Nk_command_text)(unsafe.Pointer(cmd)).H = uint16(r.H)
	(*Nk_command_text)(unsafe.Pointer(cmd)).Background = bg
	(*Nk_command_text)(unsafe.Pointer(cmd)).Foreground = fg
	(*Nk_command_text)(unsafe.Pointer(cmd)).Font = font
	(*Nk_command_text)(unsafe.Pointer(cmd)).Length = length
	(*Nk_command_text)(unsafe.Pointer(cmd)).Height = (*Nk_user_font)(unsafe.Pointer(font)).Height
	nk_memcopy(cmd+36 /* &.string */, string, Nk_size(length))
	*(*int8)(unsafe.Pointer((cmd + 36 /* &.string */) + uintptr(length))) = int8(0)
}

var __func__66 = *(*[13]int8)(unsafe.Pointer(ts + 1457 /* "nk_draw_text" */)) /* nuklear.h:9225:1 */

// ===============================================================
//
//                              VERTEX
//
// ===============================================================
func Xnk_draw_list_init(list uintptr) { /* nuklear.h:9274:1: */
	var i Nk_size = Nk_size(0)
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9277), uintptr(unsafe.Pointer(&__func__67)))
	}
	if !(list != 0) {
		return
	}
	nk_zero(list, uint32(unsafe.Sizeof(Nk_draw_list{})))
	for i = Nk_size(0); i < (uint32(unsafe.Sizeof([12]Nk_vec2{})) / uint32(unsafe.Sizeof(Nk_vec2{}))); i++ {
		var a float32 = (((float32(i) / (float32(uint32(unsafe.Sizeof([12]Nk_vec2{})) / uint32(unsafe.Sizeof(Nk_vec2{}))))) * float32(2)) * 3.141592654)
		(*Nk_vec2)(unsafe.Pointer((list + 16 /* &.circle_vtx */) + uintptr(i)*8)).X = nk_cos(a)
		(*Nk_vec2)(unsafe.Pointer((list + 16 /* &.circle_vtx */) + uintptr(i)*8)).Y = nk_sin(a)
	}
}

var __func__67 = *(*[18]int8)(unsafe.Pointer(ts + 1475 /* "nk_draw_list_ini..." */)) /* nuklear.h:9275:1 */

func Xnk_draw_list_setup(canvas uintptr, config uintptr, cmds uintptr, vertices uintptr, elements uintptr, line_aa uint32, shape_aa uint32) { /* nuklear.h:9287:1: */
	if canvas != 0 {
	} else {
		X__assert_fail(ts+1493 /* "canvas" */, ts+2 /* "nuklear/nuklear...." */, uint32(9291), uintptr(unsafe.Pointer(&__func__68)))
	}
	if config != 0 {
	} else {
		X__assert_fail(ts+1500 /* "config" */, ts+2 /* "nuklear/nuklear...." */, uint32(9292), uintptr(unsafe.Pointer(&__func__68)))
	}
	if cmds != 0 {
	} else {
		X__assert_fail(ts+1507 /* "cmds" */, ts+2 /* "nuklear/nuklear...." */, uint32(9293), uintptr(unsafe.Pointer(&__func__68)))
	}
	if vertices != 0 {
	} else {
		X__assert_fail(ts+1512 /* "vertices" */, ts+2 /* "nuklear/nuklear...." */, uint32(9294), uintptr(unsafe.Pointer(&__func__68)))
	}
	if elements != 0 {
	} else {
		X__assert_fail(ts+1521 /* "elements" */, ts+2 /* "nuklear/nuklear...." */, uint32(9295), uintptr(unsafe.Pointer(&__func__68)))
	}
	if (((!(canvas != 0) || !(config != 0)) || !(cmds != 0)) || !(vertices != 0)) || !(elements != 0) {
		return
	}

	(*Nk_draw_list)(unsafe.Pointer(canvas)).Buffer = cmds
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Config = *(*Nk_convert_config)(unsafe.Pointer(config))
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Elements = elements
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Vertices = vertices
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Line_AA = line_aa
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Shape_AA = shape_aa
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Clip_rect = nk_null_rect

	(*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_offset = Nk_size(0)
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Element_count = uint32(0)
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Vertex_count = uint32(0)
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_offset = Nk_size(0)
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_count = uint32(0)
	(*Nk_draw_list)(unsafe.Pointer(canvas)).Path_count = uint32(0)
}

var __func__68 = *(*[19]int8)(unsafe.Pointer(ts + 1530 /* "nk_draw_list_set..." */)) /* nuklear.h:9290:1 */

func Xnk__draw_list_begin(canvas uintptr, buffer uintptr) uintptr { /* nuklear.h:9314:36: */
	var memory uintptr
	var offset Nk_size
	var cmd uintptr

	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(9321), uintptr(unsafe.Pointer(&__func__69)))
	}
	if (!(buffer != 0) || !(int32((*Nk_buffer)(unsafe.Pointer(buffer)).Size) != 0)) || !(int32((*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_count) != 0) {
		return uintptr(0)
	}

	memory = (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Ptr
	offset = ((*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Size - (*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_offset)
	cmd = ((memory) + uintptr((offset)))
	return cmd
}

var __func__69 = *(*[20]int8)(unsafe.Pointer(ts + 1549 /* "nk__draw_list_be..." */)) /* nuklear.h:9316:1 */

func Xnk__draw_list_end(canvas uintptr, buffer uintptr) uintptr { /* nuklear.h:9330:36: */
	var size Nk_size
	var offset Nk_size
	var memory uintptr
	var end uintptr

	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(9338), uintptr(unsafe.Pointer(&__func__70)))
	}
	if canvas != 0 {
	} else {
		X__assert_fail(ts+1493 /* "canvas" */, ts+2 /* "nuklear/nuklear...." */, uint32(9339), uintptr(unsafe.Pointer(&__func__70)))
	}
	if !(buffer != 0) || !(canvas != 0) {
		return uintptr(0)
	}

	memory = (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Ptr
	size = (*Nk_buffer)(unsafe.Pointer(buffer)).Memory.Size
	offset = (size - (*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_offset)
	end = ((memory) + uintptr((offset)))
	end -= 24 * (uintptr((*Nk_draw_list)(unsafe.Pointer(canvas)).Cmd_count - uint32(1)))
	return end
}

var __func__70 = *(*[18]int8)(unsafe.Pointer(ts + 1569 /* "nk__draw_list_en..." */)) /* nuklear.h:9332:1 */

func Xnk__draw_list_next(cmd uintptr, buffer uintptr, canvas uintptr) uintptr { /* nuklear.h:9350:36: */
	var end uintptr
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(9355), uintptr(unsafe.Pointer(&__func__71)))
	}
	if canvas != 0 {
	} else {
		X__assert_fail(ts+1493 /* "canvas" */, ts+2 /* "nuklear/nuklear...." */, uint32(9356), uintptr(unsafe.Pointer(&__func__71)))
	}
	if (!(cmd != 0) || !(buffer != 0)) || !(canvas != 0) {
		return uintptr(0)
	}

	end = Xnk__draw_list_end(canvas, buffer)
	if cmd <= end {
		return uintptr(0)
	}
	return (cmd - uintptr(1)*24)
}

var __func__71 = *(*[19]int8)(unsafe.Pointer(ts + 1587 /* "nk__draw_list_ne..." */)) /* nuklear.h:9353:1 */

func nk_draw_list_alloc_path(list uintptr, count int32) uintptr { /* nuklear.h:9364:25: */
	var points uintptr
	points = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Buffer, NK_BUFFER_FRONT,
		(point_size * Nk_size(count)), point_align)

	if !(points != 0) {
		return uintptr(0)
	}
	if !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Path_offset) != 0) {
		var memory uintptr = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
		(*Nk_draw_list)(unsafe.Pointer(list)).Path_offset = (uint32((int32(points) - int32(memory)) / 1))
	}
	*(*uint32)(unsafe.Pointer(list + 188 /* &.path_count */)) += (uint32(count))
	return points
}

var point_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1)) /* nuklear.h:9368:30 */
var point_size Nk_size = Nk_size(unsafe.Sizeof(Nk_vec2{}))                          /* nuklear.h:9369:30 */

func nk_draw_list_path_last(list uintptr) Nk_vec2 { /* nuklear.h:9383:1: */
	var memory uintptr
	var point uintptr
	if (*Nk_draw_list)(unsafe.Pointer(list)).Path_count != 0 {
	} else {
		X__assert_fail(ts+1606 /* "list->path_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(9387), uintptr(unsafe.Pointer(&__func__72)))
	}
	memory = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
	point = ((memory) + uintptr(((*Nk_draw_list)(unsafe.Pointer(list)).Path_offset)))
	point += 8 * (uintptr((*Nk_draw_list)(unsafe.Pointer(list)).Path_count - uint32(1)))
	return *(*Nk_vec2)(unsafe.Pointer(point))
}

var __func__72 = *(*[23]int8)(unsafe.Pointer(ts + 1623 /* "nk_draw_list_pat..." */)) /* nuklear.h:9384:1 */

func nk_draw_list_push_command(list uintptr, clip Nk_rect, texture Nk_handle) uintptr { /* nuklear.h:9393:33: */
	var cmd uintptr

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9401), uintptr(unsafe.Pointer(&__func__73)))
	}
	cmd = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Buffer, NK_BUFFER_BACK, cmd_size, cmd_align)

	if !(cmd != 0) {
		return uintptr(0)
	}
	if !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count) != 0) {
		var memory uintptr = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
		var total Nk_size = Xnk_buffer_total((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
		memory = ((memory) + uintptr((total)))
		(*Nk_draw_list)(unsafe.Pointer(list)).Cmd_offset = (Nk_size((int32(memory) - int32(cmd)) / 1))
	}

	(*Nk_draw_command)(unsafe.Pointer(cmd)).Elem_count = uint32(0)
	(*Nk_draw_command)(unsafe.Pointer(cmd)).Clip_rect = clip
	(*Nk_draw_command)(unsafe.Pointer(cmd)).Texture = texture

	(*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count++
	(*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect = clip
	return cmd
}

var __func__73 = *(*[26]int8)(unsafe.Pointer(ts + 1646 /* "nk_draw_list_pus..." */)) /* nuklear.h:9396:1 */
var cmd_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))    /* nuklear.h:9397:30 */
var cmd_size Nk_size = Nk_size(unsafe.Sizeof(Nk_draw_command{}))                     /* nuklear.h:9398:30 */

func nk_draw_list_command_last(list uintptr) uintptr { /* nuklear.h:9424:33: */
	var memory uintptr
	var size Nk_size
	var cmd uintptr
	if (*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count != 0 {
	} else {
		X__assert_fail(ts+1672 /* "list->cmd_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(9430), uintptr(unsafe.Pointer(&__func__74)))
	}

	memory = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
	size = Xnk_buffer_total((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
	cmd = ((memory) + uintptr((size - (*Nk_draw_list)(unsafe.Pointer(list)).Cmd_offset)))
	return (cmd - uintptr(((*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count-uint32(1)))*24)
}

var __func__74 = *(*[26]int8)(unsafe.Pointer(ts + 1688 /* "nk_draw_list_com..." */)) /* nuklear.h:9426:1 */

func nk_draw_list_add_clip(list uintptr, rect Nk_rect) { /* nuklear.h:9438:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9440), uintptr(unsafe.Pointer(&__func__75)))
	}
	if !(list != 0) {
		return
	}
	if !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count) != 0) {
		nk_draw_list_push_command(list, rect, (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Texture)
	} else {
		var prev uintptr = nk_draw_list_command_last(list)
		if (*Nk_draw_command)(unsafe.Pointer(prev)).Elem_count == uint32(0) {
			(*Nk_draw_command)(unsafe.Pointer(prev)).Clip_rect = rect
		}
		nk_draw_list_push_command(list, rect, (*Nk_draw_command)(unsafe.Pointer(prev)).Texture)
	}
}

var __func__75 = *(*[22]int8)(unsafe.Pointer(ts + 1714 /* "nk_draw_list_add..." */)) /* nuklear.h:9439:1 */

func nk_draw_list_push_image(list uintptr, texture Nk_handle) { /* nuklear.h:9452:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_handle)(unsafe.Pointer(bp)) = texture

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9454), uintptr(unsafe.Pointer(&__func__76)))
	}
	if !(list != 0) {
		return
	}
	if !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count) != 0) {
		nk_draw_list_push_command(list, nk_null_rect, *(*Nk_handle)(unsafe.Pointer(bp /* texture */)))
	} else {
		var prev uintptr = nk_draw_list_command_last(list)
		if (*Nk_draw_command)(unsafe.Pointer(prev)).Elem_count == uint32(0) {
			(*Nk_draw_command)(unsafe.Pointer(prev)).Texture = *(*Nk_handle)(unsafe.Pointer(bp /* texture */))
		} else if *(*int32)(unsafe.Pointer(prev + 20 /* &.texture */)) != *(*int32)(unsafe.Pointer(bp /* &texture */)) {
			nk_draw_list_push_command(list, (*Nk_draw_command)(unsafe.Pointer(prev)).Clip_rect, *(*Nk_handle)(unsafe.Pointer(bp /* texture */)))
		}
	}
}

var __func__76 = *(*[24]int8)(unsafe.Pointer(ts + 1736 /* "nk_draw_list_pus..." */)) /* nuklear.h:9453:1 */

func nk_draw_list_alloc_vertices(list uintptr, count Nk_size) uintptr { /* nuklear.h:9479:15: */
	var vtx uintptr
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9483), uintptr(unsafe.Pointer(&__func__77)))
	}
	if !(list != 0) {
		return uintptr(0)
	}
	vtx = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT,
		((*Nk_draw_list)(unsafe.Pointer(list)).Config.Vertex_size * count), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Vertex_alignment)
	if !(vtx != 0) {
		return uintptr(0)
	}
	*(*uint32)(unsafe.Pointer(list + 176 /* &.vertex_count */)) += (uint32(count))

	// This assert triggers because your are drawing a lot of stuff and nuklear
	// defined `nk_draw_index` as `nk_ushort` to safe space be default.
	//
	// So you reached the maximum number of indicies or rather vertexes.
	// To solve this issue please change typdef `nk_draw_index` to `nk_uint`
	// and don't forget to specify the new element size in your drawing
	// backend (OpenGL, DirectX, ...). For example in OpenGL for `glDrawElements`
	// instead of specifing `GL_UNSIGNED_SHORT` you have to define `GL_UNSIGNED_INT`.
	// Sorry for the inconvenience.
	if uint32(unsafe.Sizeof(Nk_draw_index(0))) == uint32(2) {
		if ((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count < uint32(NK_USHORT_MAX)) && (1 != 0) {
		} else {
			X__assert_fail(ts+1760 /* "(list->vertex_co..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9499), uintptr(unsafe.Pointer(&__func__77)))
		}
	}
	return vtx
}

var __func__77 = *(*[28]int8)(unsafe.Pointer(ts + 1895 /* "nk_draw_list_all..." */)) /* nuklear.h:9481:1 */

func nk_draw_list_alloc_elements(list uintptr, count Nk_size) uintptr { /* nuklear.h:9503:24: */
	var ids uintptr
	var cmd uintptr
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9510), uintptr(unsafe.Pointer(&__func__78)))
	}
	if !(list != 0) {
		return uintptr(0)
	}

	ids = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Elements, NK_BUFFER_FRONT, (elem_size * count), elem_align)
	if !(ids != 0) {
		return uintptr(0)
	}
	cmd = nk_draw_list_command_last(list)
	*(*uint32)(unsafe.Pointer(list + 172 /* &.element_count */)) += (uint32(count))
	*(*uint32)(unsafe.Pointer(cmd /* &.elem_count */)) += (uint32(count))
	return ids
}

var __func__78 = *(*[28]int8)(unsafe.Pointer(ts + 1923 /* "nk_draw_list_all..." */)) /* nuklear.h:9505:1 */
var elem_align Nk_size = (Nk_size(((uintptr(0) + 2 /* &._h */) - uintptr(0)) / 1))   /* nuklear.h:9508:30 */
var elem_size Nk_size = Nk_size(unsafe.Sizeof(Nk_draw_index(0)))                     /* nuklear.h:9509:30 */

func nk_draw_vertex_layout_element_is_end_of_layout(element uintptr) int32 { /* nuklear.h:9522:1: */
	return (Bool32((int32((*Nk_draw_vertex_layout_element)(unsafe.Pointer(element)).Attribute) == NK_VERTEX_ATTRIBUTE_COUNT) || (int32((*Nk_draw_vertex_layout_element)(unsafe.Pointer(element)).Format) == NK_FORMAT_COUNT)))
}

func nk_draw_vertex_color(attr uintptr, vals uintptr, format uint32) { /* nuklear.h:9529:1: */
	bp := tlsAlloc(104)
	defer tlsFree(104)

	// if this triggers you tried to provide a value format for a color
	// var val [4]float32 at bp, 16

	if int32(format) >= NK_FORMAT_COLOR_BEGIN {
	} else {
		X__assert_fail(ts+1951 /* "format >= NK_FOR..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9534), uintptr(unsafe.Pointer(&__func__79)))
	}
	if int32(format) <= NK_FORMAT_COLOR_END {
	} else {
		X__assert_fail(ts+1983 /* "format <= NK_FOR..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9535), uintptr(unsafe.Pointer(&__func__79)))
	}
	if (int32(format) < NK_FORMAT_COLOR_BEGIN) || (int32(format) > NK_FORMAT_COLOR_END) {
		return
	}

	*(*float32)(unsafe.Pointer(bp /* &val[0] */)) = func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (*(*float32)(unsafe.Pointer(vals))) {
				return 1.0
			}
			return *(*float32)(unsafe.Pointer(vals))
		}()) {
			return func() float32 {
				if (1.0) < (*(*float32)(unsafe.Pointer(vals))) {
					return 1.0
				}
				return *(*float32)(unsafe.Pointer(vals))
			}()
		}
		return float32(0)
	}()
	*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)) = func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (*(*float32)(unsafe.Pointer(vals + 1*4))) {
				return 1.0
			}
			return *(*float32)(unsafe.Pointer(vals + 1*4))
		}()) {
			return func() float32 {
				if (1.0) < (*(*float32)(unsafe.Pointer(vals + 1*4))) {
					return 1.0
				}
				return *(*float32)(unsafe.Pointer(vals + 1*4))
			}()
		}
		return float32(0)
	}()
	*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)) = func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (*(*float32)(unsafe.Pointer(vals + 2*4))) {
				return 1.0
			}
			return *(*float32)(unsafe.Pointer(vals + 2*4))
		}()) {
			return func() float32 {
				if (1.0) < (*(*float32)(unsafe.Pointer(vals + 2*4))) {
					return 1.0
				}
				return *(*float32)(unsafe.Pointer(vals + 2*4))
			}()
		}
		return float32(0)
	}()
	*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 3*4)) = func() float32 {
		if (float32(0)) < (func() float32 {
			if (1.0) < (*(*float32)(unsafe.Pointer(vals + 3*4))) {
				return 1.0
			}
			return *(*float32)(unsafe.Pointer(vals + 3*4))
		}()) {
			return func() float32 {
				if (1.0) < (*(*float32)(unsafe.Pointer(vals + 3*4))) {
					return 1.0
				}
				return *(*float32)(unsafe.Pointer(vals + 3*4))
			}()
		}
		return float32(0)
	}()

	switch format {
	default:
		if (0 != 0) && (1 != 0) {
		} else {
			X__assert_fail(ts+2013 /* "0 && \"Invalid ve..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9544), uintptr(unsafe.Pointer(&__func__79)))
		}
		break
	case NK_FORMAT_R8G8B8A8:
		fallthrough
	case NK_FORMAT_R8G8B8:
		{
			*(*Nk_color)(unsafe.Pointer(bp + 16 /* col */)) = Xnk_rgba_fv(bp /* &val[0] */)
			nk_memcopy(attr, (bp + 16 /* &col */ /* &.r */), uint32(unsafe.Sizeof(Nk_color{})))

		}
		break
	case NK_FORMAT_B8G8R8A8:
		{
			var col = Xnk_rgba_fv(bp /* &val[0] */)
			*(*Nk_color)(unsafe.Pointer(bp + 20 /* bgra */)) = Xnk_rgba(int32(col.B), int32(col.G), int32(col.R), int32(col.A))
			nk_memcopy(attr, bp+20 /* &bgra */, uint32(unsafe.Sizeof(Nk_color{})))

		}
		break
	case NK_FORMAT_R16G15B16:
		{
			// var col [3]Nk_ushort at bp+24, 6

			*(*Nk_ushort)(unsafe.Pointer(bp + 24 /* &col[0] */)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */)) * float32(NK_USHORT_MAX)))
			*(*Nk_ushort)(unsafe.Pointer(bp + 24 /* &col[0] */ + 1*2)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)) * float32(NK_USHORT_MAX)))
			*(*Nk_ushort)(unsafe.Pointer(bp + 24 /* &col[0] */ + 2*2)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)) * float32(NK_USHORT_MAX)))
			nk_memcopy(attr, bp+24 /* &col[0] */, uint32(unsafe.Sizeof([3]Nk_ushort{})))

		}
		break
	case NK_FORMAT_R16G15B16A16:
		{
			// var col [4]Nk_ushort at bp+30, 8

			*(*Nk_ushort)(unsafe.Pointer(bp + 30 /* &col[0] */)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */)) * float32(NK_USHORT_MAX)))
			*(*Nk_ushort)(unsafe.Pointer(bp + 30 /* &col[0] */ + 1*2)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)) * float32(NK_USHORT_MAX)))
			*(*Nk_ushort)(unsafe.Pointer(bp + 30 /* &col[0] */ + 2*2)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)) * float32(NK_USHORT_MAX)))
			*(*Nk_ushort)(unsafe.Pointer(bp + 30 /* &col[0] */ + 3*2)) = (Nk_ushort(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 3*4)) * float32(NK_USHORT_MAX)))
			nk_memcopy(attr, bp+30 /* &col[0] */, uint32(unsafe.Sizeof([4]Nk_ushort{})))

		}
		break
	case NK_FORMAT_R32G32B32:
		{
			// var col [3]Nk_uint at bp+40, 12

			*(*Nk_uint)(unsafe.Pointer(bp + 40 /* &col[0] */)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */)) * float32(NK_UINT_MAX)))
			*(*Nk_uint)(unsafe.Pointer(bp + 40 /* &col[0] */ + 1*4)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)) * float32(NK_UINT_MAX)))
			*(*Nk_uint)(unsafe.Pointer(bp + 40 /* &col[0] */ + 2*4)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)) * float32(NK_UINT_MAX)))
			nk_memcopy(attr, bp+40 /* &col[0] */, uint32(unsafe.Sizeof([3]Nk_uint{})))

		}
		break
	case NK_FORMAT_R32G32B32A32:
		{
			// var col [4]Nk_uint at bp+52, 16

			*(*Nk_uint)(unsafe.Pointer(bp + 52 /* &col[0] */)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */)) * float32(NK_UINT_MAX)))
			*(*Nk_uint)(unsafe.Pointer(bp + 52 /* &col[0] */ + 1*4)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)) * float32(NK_UINT_MAX)))
			*(*Nk_uint)(unsafe.Pointer(bp + 52 /* &col[0] */ + 2*4)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)) * float32(NK_UINT_MAX)))
			*(*Nk_uint)(unsafe.Pointer(bp + 52 /* &col[0] */ + 3*4)) = (Nk_uint(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 3*4)) * float32(NK_UINT_MAX)))
			nk_memcopy(attr, bp+52 /* &col[0] */, uint32(unsafe.Sizeof([4]Nk_uint{})))

		}
		break
	case NK_FORMAT_R32G32B32A32_FLOAT:
		nk_memcopy(attr, bp /* &val[0] */, (uint32(unsafe.Sizeof(float32(0))) * uint32(4)))
		break
	case NK_FORMAT_R32G32B32A32_DOUBLE:
		{
			// var col [4]float64 at bp+68, 32

			*(*float64)(unsafe.Pointer(bp + 68 /* &col[0] */)) = float64(*(*float32)(unsafe.Pointer(bp /* &val[0] */)))
			*(*float64)(unsafe.Pointer(bp + 68 /* &col[0] */ + 1*8)) = float64(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 1*4)))
			*(*float64)(unsafe.Pointer(bp + 68 /* &col[0] */ + 2*8)) = float64(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 2*4)))
			*(*float64)(unsafe.Pointer(bp + 68 /* &col[0] */ + 3*8)) = float64(*(*float32)(unsafe.Pointer(bp /* &val[0] */ + 3*4)))
			nk_memcopy(attr, bp+68 /* &col[0] */, uint32(unsafe.Sizeof([4]float64{})))

		}
		break
	case NK_FORMAT_RGB32:
		fallthrough
	case NK_FORMAT_RGBA32:
		{
			var col = Xnk_rgba_fv(bp /* &val[0] */)
			*(*Nk_uint)(unsafe.Pointer(bp + 100 /* color */)) = Xnk_color_u32(col)
			nk_memcopy(attr, bp+100 /* &color */, uint32(unsafe.Sizeof(Nk_uint(0))))

		}
		break
	}
}

var __func__79 = *(*[21]int8)(unsafe.Pointer(ts + 2055 /* "nk_draw_vertex_c..." */)) /* nuklear.h:9531:1 */

func nk_draw_vertex_element(dst uintptr, values uintptr, value_count int32, format uint32) { /* nuklear.h:9604:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var value_index int32
	var attribute uintptr = dst
	// if this triggers you tried to provide a color format for a value
	if int32(format) < NK_FORMAT_COLOR_BEGIN {
	} else {
		X__assert_fail(ts+2076 /* "format < NK_FORM..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9610), uintptr(unsafe.Pointer(&__func__80)))
	}
	if (int32(format) >= NK_FORMAT_COLOR_BEGIN) && (int32(format) <= NK_FORMAT_COLOR_END) {
		return
	}
	for value_index = 0; value_index < value_count; value_index++ {
		switch format {
		default:
			if (0 != 0) && (1 != 0) {
			} else {
				X__assert_fail(ts+2107 /* "0 && \"invalid ve..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9614), uintptr(unsafe.Pointer(&__func__80)))
			}
			break
		//
		//         case NK_FORMAT_SCHAR: {
		//             char value = (char)NK_CLAMP((float)NK_SCHAR_MIN, values[value_index], (float)NK_SCHAR_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(char));
		//         } break;
		//         case NK_FORMAT_SSHORT: {
		//             nk_short value = (nk_short)NK_CLAMP((float)NK_SSHORT_MIN, values[value_index], (float)NK_SSHORT_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(value));
		//         } break;
		//         case NK_FORMAT_SINT: {
		//             nk_int value = (nk_int)NK_CLAMP((float)NK_SINT_MIN, values[value_index], (float)NK_SINT_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(nk_int));
		//         } break;
		//         case NK_FORMAT_UCHAR: {
		//             unsigned char value = (unsigned char)NK_CLAMP((float)NK_UCHAR_MIN, values[value_index], (float)NK_UCHAR_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(unsigned char));
		//         } break;
		//         case NK_FORMAT_USHORT: {
		//             nk_ushort value = (nk_ushort)NK_CLAMP((float)NK_USHORT_MIN, values[value_index], (float)NK_USHORT_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(value));
		//             } break;
		//         case NK_FORMAT_UINT: {
		//             nk_uint value = (nk_uint)NK_CLAMP((float)NK_UINT_MIN, values[value_index], (float)NK_UINT_MAX);
		//             NK_MEMCPY(attribute, &value, sizeof(value));
		//             attribute = (void*)((char*)attribute + sizeof(nk_uint));
		//         } break;
		//
		case NK_FORMAT_FLOAT:
			nk_memcopy(attribute, (values + uintptr(value_index)*4), uint32(unsafe.Sizeof(float32(0))))
			attribute = (attribute + uintptr(uint32(unsafe.Sizeof(float32(0)))))
			break
		case NK_FORMAT_DOUBLE:
			{
				*(*float64)(unsafe.Pointer(bp /* value */)) = float64(*(*float32)(unsafe.Pointer(values + uintptr(value_index)*4)))
				nk_memcopy(attribute, bp /* &value */, uint32(unsafe.Sizeof(float64(0))))
				attribute = (attribute + uintptr(uint32(unsafe.Sizeof(float64(0)))))

			}
			break
		}
	}
}

var __func__80 = *(*[23]int8)(unsafe.Pointer(ts + 2143 /* "nk_draw_vertex_e..." */)) /* nuklear.h:9606:1 */

func nk_draw_vertex(dst uintptr, config uintptr, pos Nk_vec2, uv Nk_vec2, color Nk_colorf) uintptr { /* nuklear.h:9659:15: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_vec2)(unsafe.Pointer(bp)) = pos
	*(*Nk_vec2)(unsafe.Pointer(bp + 8)) = uv
	*(*Nk_colorf)(unsafe.Pointer(bp + 16)) = color

	var result uintptr = (dst + uintptr((*Nk_convert_config)(unsafe.Pointer(config)).Vertex_size))
	var elem_iter uintptr = (*Nk_convert_config)(unsafe.Pointer(config)).Vertex_layout
	for !(nk_draw_vertex_layout_element_is_end_of_layout(elem_iter) != 0) {
		var address uintptr = (dst + uintptr((*Nk_draw_vertex_layout_element)(unsafe.Pointer(elem_iter)).Offset))
		switch (*Nk_draw_vertex_layout_element)(unsafe.Pointer(elem_iter)).Attribute {
		case NK_VERTEX_ATTRIBUTE_COUNT:
			fallthrough
		default:
			if (0 != 0) && (1 != 0) {
			} else {
				X__assert_fail(ts+2166 /* "0 && \"wrong elem..." */, ts+2 /* "nuklear/nuklear...." */, uint32(9669), uintptr(unsafe.Pointer(&__func__81)))
			}
			break
		case NK_VERTEX_POSITION:
			nk_draw_vertex_element(address, (bp /* &pos */ /* &.x */), 2, (*Nk_draw_vertex_layout_element)(unsafe.Pointer(elem_iter)).Format)
			break
		case NK_VERTEX_TEXCOORD:
			nk_draw_vertex_element(address, (bp + 8 /* &uv */ /* &.x */), 2, (*Nk_draw_vertex_layout_element)(unsafe.Pointer(elem_iter)).Format)
			break
		case NK_VERTEX_COLOR:
			nk_draw_vertex_color(address, (bp + 16 /* &color */ /* &.r */), (*Nk_draw_vertex_layout_element)(unsafe.Pointer(elem_iter)).Format)
			break
		}
		elem_iter += 12
	}
	return result
}

var __func__81 = *(*[15]int8)(unsafe.Pointer(ts + 2197 /* "nk_draw_vertex" */)) /* nuklear.h:9662:1 */

func Xnk_draw_list_stroke_poly_line(list uintptr, points uintptr, points_count uint32, color Nk_color, closed uint32, thickness float32, aliasing uint32) { /* nuklear.h:9679:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var count Nk_size
	var thick_line int32
	// var col Nk_colorf at bp, 16

	var col_trans Nk_colorf
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9687), uintptr(unsafe.Pointer(&__func__82)))
	}
	if !(list != 0) || (points_count < uint32(2)) {
		return
	}

	color.A = (Nk_byte(float32(color.A) * (*Nk_draw_list)(unsafe.Pointer(list)).Config.Global_alpha))
	count = Nk_size(points_count)
	if !(closed != 0) {
		count = (Nk_size(points_count - uint32(1)))
	}
	thick_line = (Bool32(thickness > 1.0))

	color.A = (Nk_byte(float32(color.A) * (*Nk_draw_list)(unsafe.Pointer(list)).Config.Global_alpha))
	Xnk_color_fv((bp /* &col */ /* &.r */), color)
	col_trans = *(*Nk_colorf)(unsafe.Pointer(bp /* col */))
	col_trans.A = float32(0)

	if int32(aliasing) == NK_ANTI_ALIASING_ON {
		// ANTI-ALIASED STROKE
		var AA_SIZE float32 = 1.0

		// allocate vertices and elements
		var i1 Nk_size = Nk_size(0)
		var vertex_offset Nk_size
		var index Nk_size = Nk_size((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)

		var idx_count Nk_size
		if thick_line != 0 {
			idx_count = (count * Nk_size(18))
		} else {
			idx_count = (count * Nk_size(12))
		}
		var vtx_count Nk_size
		if thick_line != 0 {
			vtx_count = (uint32(points_count * uint32(4)))
		} else {
			vtx_count = (uint32(points_count * uint32(3)))
		}

		var vtx uintptr = nk_draw_list_alloc_vertices(list, vtx_count)
		var ids uintptr = nk_draw_list_alloc_elements(list, idx_count)
		var size Nk_size
		var normals uintptr
		var temp uintptr
		if !(vtx != 0) || !(ids != 0) {
			return
		}

		// temporary allocate normals + points
		vertex_offset = (Nk_size((int32(vtx) - int32((*Nk_buffer)(unsafe.Pointer((*Nk_draw_list)(unsafe.Pointer(list)).Vertices)).Memory.Ptr)) / 1))
		Xnk_buffer_mark((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT)
		size = ((pnt_size * (func() uint32 {
			if thick_line != 0 {
				return uint32(5)
			}
			return uint32(3)
		}())) * Nk_size(points_count))
		normals = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT, size, pnt_align)
		if !(normals != 0) {
			return
		}
		temp = (normals + uintptr(points_count)*8)

		// make sure vertex pointer is still correct
		vtx = ((*Nk_buffer)(unsafe.Pointer((*Nk_draw_list)(unsafe.Pointer(list)).Vertices)).Memory.Ptr + uintptr(vertex_offset))

		// calculate normals
		for i1 = Nk_size(0); i1 < count; i1++ {
			var i2 Nk_size
			if (i1 + Nk_size(1)) == Nk_size(points_count) {
				i2 = uint32(0)
			} else {
				i2 = (i1 + Nk_size(1))
			}
			var diff = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X - (*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y - (*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).Y))
			var len float32

			// vec2 inverted length
			len = ((diff.X * diff.X) + (diff.Y * diff.Y))
			if len != 0.0 {
				len = nk_inv_sqrt(len)
			} else {
				len = 1.0
			}

			diff = Xnk_vec2((diff.X * (len)), (diff.Y * (len)))
			(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i1)*8)).X = diff.Y
			(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i1)*8)).Y = -diff.X
		}

		if !(closed != 0) {
			*(*Nk_vec2)(unsafe.Pointer(normals + uintptr((points_count-uint32(1)))*8)) = *(*Nk_vec2)(unsafe.Pointer(normals + uintptr((points_count-uint32(2)))*8))
		}

		if !(thick_line != 0) {
			var idx1 Nk_size
			var i Nk_size
			if !(closed != 0) {
				var d Nk_vec2
				var tt = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals)).X * (AA_SIZE)), ((*Nk_vec2)(unsafe.Pointer(normals)).Y * (AA_SIZE)))
				*(*Nk_vec2)(unsafe.Pointer(temp)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X + tt.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y + tt.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + 1*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X - tt.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y - tt.Y))
				d = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).X * (AA_SIZE)), ((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).Y * (AA_SIZE)))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(2))+uint32(0)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X + d.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y + d.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(2))+uint32(1)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X - d.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y - d.Y))
			}

			// fill elements
			idx1 = index
			for i1 = Nk_size(0); i1 < count; i1++ {
				var dm Nk_vec2
				var dmr2 float32
				var i2 Nk_size
				if (i1 + Nk_size(1)) == Nk_size(points_count) {
					i2 = uint32(0)
				} else {
					i2 = (i1 + Nk_size(1))
				}
				var idx2 Nk_size
				if (i1 + Nk_size(1)) == Nk_size(points_count) {
					idx2 = index
				} else {
					idx2 = (idx1 + Nk_size(3))
				}

				// average normals
				var tt = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals+uintptr(i1)*8)).X + (*Nk_vec2)(unsafe.Pointer(normals+uintptr(i2)*8)).X), ((*Nk_vec2)(unsafe.Pointer(normals+uintptr(i1)*8)).Y + (*Nk_vec2)(unsafe.Pointer(normals+uintptr(i2)*8)).Y))
				dm = Xnk_vec2((tt.X * (0.5)), (tt.Y * (0.5)))
				dmr2 = ((dm.X * dm.X) + (dm.Y * dm.Y))
				if dmr2 > 0.000001 {
					var scale float32 = (1.0 / dmr2)
					scale = func() float32 {
						if (100.0) < (scale) {
							return 100.0
						}
						return scale
					}()
					dm = Xnk_vec2((dm.X * (scale)), (dm.Y * (scale)))
				}

				dm = Xnk_vec2((dm.X * (AA_SIZE)), (dm.Y * (AA_SIZE)))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(2))+Nk_size(0)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X + dm.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y + dm.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(2))+Nk_size(1)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X - dm.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y - dm.Y))

				*(*Nk_draw_index)(unsafe.Pointer(ids)) = (Nk_draw_index(idx2 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index(idx1 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(idx1 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 3*2)) = (Nk_draw_index(idx1 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 4*2)) = (Nk_draw_index(idx2 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 5*2)) = (Nk_draw_index(idx2 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 6*2)) = (Nk_draw_index(idx2 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 7*2)) = (Nk_draw_index(idx1 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 8*2)) = (Nk_draw_index(idx1 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 9*2)) = (Nk_draw_index(idx1 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 10*2)) = (Nk_draw_index(idx2 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 11*2)) = (Nk_draw_index(idx2 + Nk_size(1)))
				ids += 2 * (uintptr(12))
				idx1 = idx2
			}

			// fill vertices
			for i = Nk_size(0); i < Nk_size(points_count); i++ {
				var uv = (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i)*8)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(2))+Nk_size(0)))*8)), uv, col_trans)
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(2))+Nk_size(1)))*8)), uv, col_trans)
			}
		} else {
			var idx1 Nk_size
			var i Nk_size
			var half_inner_thickness float32 = ((thickness - AA_SIZE) * 0.5)
			if !(closed != 0) {
				var d1 = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals)).X * (half_inner_thickness + AA_SIZE)), ((*Nk_vec2)(unsafe.Pointer(normals)).Y * (half_inner_thickness + AA_SIZE)))
				var d2 = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals)).X * (half_inner_thickness)), ((*Nk_vec2)(unsafe.Pointer(normals)).Y * (half_inner_thickness)))

				*(*Nk_vec2)(unsafe.Pointer(temp)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X + d1.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y + d1.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + 1*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X + d2.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y + d2.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + 2*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X - d2.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y - d2.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + 3*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points)).X - d1.X), ((*Nk_vec2)(unsafe.Pointer(points)).Y - d1.Y))

				d1 = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).X * (half_inner_thickness + AA_SIZE)), ((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).Y * (half_inner_thickness + AA_SIZE)))
				d2 = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).X * (half_inner_thickness)), ((*Nk_vec2)(unsafe.Pointer(normals+uintptr((points_count-uint32(1)))*8)).Y * (half_inner_thickness)))

				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(4))+uint32(0)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X + d1.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y + d1.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(4))+uint32(1)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X + d2.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y + d2.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(4))+uint32(2)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X - d2.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y - d2.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr((((points_count-uint32(1))*uint32(4))+uint32(3)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).X - d1.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr((points_count-uint32(1)))*8)).Y - d1.Y))
			}

			// add all elements
			idx1 = index
			for i1 = Nk_size(0); i1 < count; i1++ {
				var dm_out Nk_vec2
				var dm_in Nk_vec2
				var i2 Nk_size
				if (i1 + Nk_size(1)) == Nk_size(points_count) {
					i2 = uint32(0)
				} else {
					i2 = (i1 + Nk_size(1))
				}
				var idx2 Nk_size
				if (i1 + Nk_size(1)) == Nk_size(points_count) {
					idx2 = index
				} else {
					idx2 = (idx1 + Nk_size(4))
				}

				// average normals
				var tt = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(normals+uintptr(i1)*8)).X + (*Nk_vec2)(unsafe.Pointer(normals+uintptr(i2)*8)).X), ((*Nk_vec2)(unsafe.Pointer(normals+uintptr(i1)*8)).Y + (*Nk_vec2)(unsafe.Pointer(normals+uintptr(i2)*8)).Y))
				var dm = Xnk_vec2((tt.X * (0.5)), (tt.Y * (0.5)))
				var dmr2 float32 = ((dm.X * dm.X) + (dm.Y * dm.Y))
				if dmr2 > 0.000001 {
					var scale float32 = (1.0 / dmr2)
					scale = func() float32 {
						if (100.0) < (scale) {
							return 100.0
						}
						return scale
					}()
					dm = Xnk_vec2((dm.X * (scale)), (dm.Y * (scale)))
				}

				dm_out = Xnk_vec2((dm.X * ((half_inner_thickness) + AA_SIZE)), (dm.Y * ((half_inner_thickness) + AA_SIZE)))
				dm_in = Xnk_vec2((dm.X * (half_inner_thickness)), (dm.Y * (half_inner_thickness)))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(4))+Nk_size(0)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X + dm_out.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y + dm_out.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(4))+Nk_size(1)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X + dm_in.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y + dm_in.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(4))+Nk_size(2)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X - dm_in.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y - dm_in.Y))
				*(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i2*Nk_size(4))+Nk_size(3)))*8)) = Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).X - dm_out.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i2)*8)).Y - dm_out.Y))

				// add indexes
				*(*Nk_draw_index)(unsafe.Pointer(ids)) = (Nk_draw_index(idx2 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index(idx1 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(idx1 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 3*2)) = (Nk_draw_index(idx1 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 4*2)) = (Nk_draw_index(idx2 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 5*2)) = (Nk_draw_index(idx2 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 6*2)) = (Nk_draw_index(idx2 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 7*2)) = (Nk_draw_index(idx1 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 8*2)) = (Nk_draw_index(idx1 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 9*2)) = (Nk_draw_index(idx1 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 10*2)) = (Nk_draw_index(idx2 + Nk_size(0)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 11*2)) = (Nk_draw_index(idx2 + Nk_size(1)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 12*2)) = (Nk_draw_index(idx2 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 13*2)) = (Nk_draw_index(idx1 + Nk_size(2)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 14*2)) = (Nk_draw_index(idx1 + Nk_size(3)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 15*2)) = (Nk_draw_index(idx1 + Nk_size(3)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 16*2)) = (Nk_draw_index(idx2 + Nk_size(3)))
				*(*Nk_draw_index)(unsafe.Pointer(ids + 17*2)) = (Nk_draw_index(idx2 + Nk_size(2)))
				ids += 2 * (uintptr(18))
				idx1 = idx2
			}

			// add vertices
			for i = Nk_size(0); i < Nk_size(points_count); i++ {
				var uv = (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(4))+Nk_size(0)))*8)), uv, col_trans)
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(4))+Nk_size(1)))*8)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(4))+Nk_size(2)))*8)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
				vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(temp + uintptr(((i*Nk_size(4))+Nk_size(3)))*8)), uv, col_trans)
			}
		}
		// free temporary normals + points
		Xnk_buffer_reset((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT)
	} else {
		// NON ANTI-ALIASED STROKE
		var i1 Nk_size = Nk_size(0)
		var idx Nk_size = Nk_size((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)
		var idx_count Nk_size = (count * Nk_size(6))
		var vtx_count Nk_size = (count * Nk_size(4))
		var vtx uintptr = nk_draw_list_alloc_vertices(list, vtx_count)
		var ids uintptr = nk_draw_list_alloc_elements(list, idx_count)
		if !(vtx != 0) || !(ids != 0) {
			return
		}

		for i1 = Nk_size(0); i1 < count; i1++ {
			var dx float32
			var dy float32
			var uv = (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv
			var i2 Nk_size
			if (i1 + Nk_size(1)) == Nk_size(points_count) {
				i2 = uint32(0)
			} else {
				i2 = (i1 + Nk_size(1))
			}
			var p1 = *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i1)*8))
			var p2 = *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i2)*8))
			var diff = Xnk_vec2((p2.X - p1.X), (p2.Y - p1.Y))
			var len float32

			// vec2 inverted length
			len = ((diff.X * diff.X) + (diff.Y * diff.Y))
			if len != 0.0 {
				len = nk_inv_sqrt(len)
			} else {
				len = 1.0
			}
			diff = Xnk_vec2((diff.X * (len)), (diff.Y * (len)))

			// add vertices
			dx = (diff.X * (thickness * 0.5))
			dy = (diff.Y * (thickness * 0.5))

			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((p1.X+dy), (p1.Y-dx)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((p2.X+dy), (p2.Y-dx)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((p2.X-dy), (p2.Y+dx)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((p1.X-dy), (p1.Y+dx)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))

			*(*Nk_draw_index)(unsafe.Pointer(ids)) = (Nk_draw_index(idx + Nk_size(0)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index(idx + Nk_size(1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(idx + Nk_size(2)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 3*2)) = (Nk_draw_index(idx + Nk_size(0)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 4*2)) = (Nk_draw_index(idx + Nk_size(2)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 5*2)) = (Nk_draw_index(idx + Nk_size(3)))

			ids += 2 * (uintptr(6))
			idx = idx + (Nk_size(4))
		}
	}
}

var __func__82 = *(*[30]int8)(unsafe.Pointer(ts + 2212 /* "nk_draw_list_str..." */)) /* nuklear.h:9682:1 */
var pnt_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))    /* nuklear.h:9707:34 */
var pnt_size Nk_size = Nk_size(unsafe.Sizeof(Nk_vec2{}))                             /* nuklear.h:9708:34 */

func Xnk_draw_list_fill_poly_convex(list uintptr, points uintptr, points_count uint32, color Nk_color, aliasing uint32) { /* nuklear.h:9922:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var col Nk_colorf at bp, 16

	var col_trans Nk_colorf
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(9931), uintptr(unsafe.Pointer(&__func__83)))
	}
	if !(list != 0) || (points_count < uint32(3)) {
		return
	}

	color.A = (Nk_byte(float32(color.A) * (*Nk_draw_list)(unsafe.Pointer(list)).Config.Global_alpha))
	Xnk_color_fv((bp /* &col */ /* &.r */), color)
	col_trans = *(*Nk_colorf)(unsafe.Pointer(bp /* col */))
	col_trans.A = float32(0)

	if int32(aliasing) == NK_ANTI_ALIASING_ON {
		var i Nk_size = Nk_size(0)
		var i0 Nk_size = Nk_size(0)
		var i1 Nk_size = Nk_size(0)

		var AA_SIZE float32 = 1.0
		var vertex_offset Nk_size = Nk_size(0)
		var index Nk_size = Nk_size((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)

		var idx_count Nk_size = (Nk_size(((points_count - uint32(2)) * uint32(3)) + (points_count * uint32(6))))
		var vtx_count Nk_size = (Nk_size(points_count * uint32(2)))

		var vtx uintptr = nk_draw_list_alloc_vertices(list, vtx_count)
		var ids uintptr = nk_draw_list_alloc_elements(list, idx_count)

		var size Nk_size = Nk_size(0)
		var normals uintptr = uintptr(0)
		var vtx_inner_idx uint32 = (uint32(index + Nk_size(0)))
		var vtx_outer_idx uint32 = (uint32(index + Nk_size(1)))
		if !(vtx != 0) || !(ids != 0) {
			return
		}

		// temporary allocate normals
		vertex_offset = (Nk_size((int32(vtx) - int32((*Nk_buffer)(unsafe.Pointer((*Nk_draw_list)(unsafe.Pointer(list)).Vertices)).Memory.Ptr)) / 1))
		Xnk_buffer_mark((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT)
		size = (pnt_size1 * Nk_size(points_count))
		normals = nk_buffer_alloc((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT, size, pnt_align1)
		if !(normals != 0) {
			return
		}
		vtx = ((*Nk_buffer)(unsafe.Pointer((*Nk_draw_list)(unsafe.Pointer(list)).Vertices)).Memory.Ptr + uintptr(vertex_offset))

		// add elements
		for i = Nk_size(2); i < Nk_size(points_count); i++ {
			*(*Nk_draw_index)(unsafe.Pointer(ids)) = Nk_draw_index(vtx_inner_idx)
			*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index(Nk_size(vtx_inner_idx) + ((i - Nk_size(1)) << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(Nk_size(vtx_inner_idx) + (i << 1)))
			ids += 2 * (uintptr(3))
		}

		// compute normals
		i0 = (Nk_size(points_count - uint32(1)))
		i1 = Nk_size(0)
		for ; i1 < Nk_size(points_count); i0 = PostIncUint32(&i1, 1) {
			var p0 = *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i0)*8))
			var p1 = *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i1)*8))
			var diff = Xnk_vec2((p1.X - p0.X), (p1.Y - p0.Y))

			// vec2 inverted length
			var len float32 = ((diff.X * diff.X) + (diff.Y * diff.Y))
			if len != 0.0 {
				len = nk_inv_sqrt(len)
			} else {
				len = 1.0
			}
			diff = Xnk_vec2((diff.X * (len)), (diff.Y * (len)))

			(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i0)*8)).X = diff.Y
			(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i0)*8)).Y = -diff.X
		}

		// add vertices + indexes
		i0 = (Nk_size(points_count - uint32(1)))
		i1 = Nk_size(0)
		for ; i1 < Nk_size(points_count); i0 = PostIncUint32(&i1, 1) {
			var uv = (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv
			var n0 = *(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i0)*8))
			var n1 = *(*Nk_vec2)(unsafe.Pointer(normals + uintptr(i1)*8))
			var tt = Xnk_vec2((n0.X + n1.X), (n0.Y + n1.Y))
			var dm = Xnk_vec2((tt.X * (0.5)), (tt.Y * (0.5)))
			var dmr2 float32 = ((dm.X * dm.X) + (dm.Y * dm.Y))
			if dmr2 > 0.000001 {
				var scale float32 = (1.0 / dmr2)
				scale = func() float32 {
					if (scale) < (100.0) {
						return scale
					}
					return 100.0
				}()
				dm = Xnk_vec2((dm.X * (scale)), (dm.Y * (scale)))
			}
			dm = Xnk_vec2((dm.X * (AA_SIZE * 0.5)), (dm.Y * (AA_SIZE * 0.5)))

			// add vertices
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).X-dm.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).Y-dm.Y)), uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2(((*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).X+dm.X), ((*Nk_vec2)(unsafe.Pointer(points+uintptr(i1)*8)).Y+dm.Y)), uv, col_trans)

			// add indexes
			*(*Nk_draw_index)(unsafe.Pointer(ids)) = (Nk_draw_index(Nk_size(vtx_inner_idx) + (i1 << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index(Nk_size(vtx_inner_idx) + (i0 << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(Nk_size(vtx_outer_idx) + (i0 << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 3*2)) = (Nk_draw_index(Nk_size(vtx_outer_idx) + (i0 << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 4*2)) = (Nk_draw_index(Nk_size(vtx_outer_idx) + (i1 << 1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 5*2)) = (Nk_draw_index(Nk_size(vtx_inner_idx) + (i1 << 1)))
			ids += 2 * (uintptr(6))
		}
		// free temporary normals + points
		Xnk_buffer_reset((*Nk_draw_list)(unsafe.Pointer(list)).Vertices, NK_BUFFER_FRONT)
	} else {
		var i Nk_size = Nk_size(0)
		var index Nk_size = Nk_size((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)
		var idx_count Nk_size = (Nk_size((points_count - uint32(2)) * uint32(3)))
		var vtx_count Nk_size = Nk_size(points_count)
		var vtx uintptr = nk_draw_list_alloc_vertices(list, vtx_count)
		var ids uintptr = nk_draw_list_alloc_elements(list, idx_count)

		if !(vtx != 0) || !(ids != 0) {
			return
		}
		for i = Nk_size(0); i < vtx_count; i++ {
			vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), *(*Nk_vec2)(unsafe.Pointer(points + uintptr(i)*8)), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
		}
		for i = Nk_size(2); i < Nk_size(points_count); i++ {
			*(*Nk_draw_index)(unsafe.Pointer(ids)) = Nk_draw_index(index)
			*(*Nk_draw_index)(unsafe.Pointer(ids + 1*2)) = (Nk_draw_index((index + i) - Nk_size(1)))
			*(*Nk_draw_index)(unsafe.Pointer(ids + 2*2)) = (Nk_draw_index(index + i))
			ids += 2 * (uintptr(3))
		}
	}
}

var __func__83 = *(*[30]int8)(unsafe.Pointer(ts + 2242 /* "nk_draw_list_fil..." */)) /* nuklear.h:9925:1 */
var pnt_align1 Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))   /* nuklear.h:9929:30 */
var pnt_size1 Nk_size = Nk_size(unsafe.Sizeof(Nk_vec2{}))                            /* nuklear.h:9930:30 */

func Xnk_draw_list_path_clear(list uintptr) { /* nuklear.h:10047:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10049), uintptr(unsafe.Pointer(&__func__84)))
	}
	if !(list != 0) {
		return
	}
	Xnk_buffer_reset((*Nk_draw_list)(unsafe.Pointer(list)).Buffer, NK_BUFFER_FRONT)
	(*Nk_draw_list)(unsafe.Pointer(list)).Path_count = uint32(0)
	(*Nk_draw_list)(unsafe.Pointer(list)).Path_offset = uint32(0)
}

var __func__84 = *(*[24]int8)(unsafe.Pointer(ts + 2272 /* "nk_draw_list_pat..." */)) /* nuklear.h:10048:1 */

func Xnk_draw_list_path_line_to(list uintptr, pos Nk_vec2) { /* nuklear.h:10056:1: */
	var points uintptr = uintptr(0)
	var cmd uintptr = uintptr(0)
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10060), uintptr(unsafe.Pointer(&__func__85)))
	}
	if !(list != 0) {
		return
	}
	if !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Cmd_count) != 0) {
		nk_draw_list_add_clip(list, nk_null_rect)
	}

	cmd = nk_draw_list_command_last(list)
	if (cmd != 0) && (*(*uintptr)(unsafe.Pointer(cmd + 20 /* &.texture */)) != *(*uintptr)(unsafe.Pointer(list + 112 /* &.config */ + 24 /* &.null */ /* &.texture */))) {
		nk_draw_list_push_image(list, (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Texture)
	}

	points = nk_draw_list_alloc_path(list, 1)
	if !(points != 0) {
		return
	}
	*(*Nk_vec2)(unsafe.Pointer(points)) = pos
}

var __func__85 = *(*[26]int8)(unsafe.Pointer(ts + 2296 /* "nk_draw_list_pat..." */)) /* nuklear.h:10057:1 */

func Xnk_draw_list_path_arc_to_fast(list uintptr, center Nk_vec2, radius float32, a_min int32, a_max int32) { /* nuklear.h:10074:1: */
	var a int32 = 0
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10078), uintptr(unsafe.Pointer(&__func__86)))
	}
	if !(list != 0) {
		return
	}
	if a_min <= a_max {
		for a = a_min; a <= a_max; a++ {
			var c = *(*Nk_vec2)(unsafe.Pointer((list + 16 /* &.circle_vtx */) + uintptr((Nk_size(a)%(uint32(unsafe.Sizeof([12]Nk_vec2{}))/uint32(unsafe.Sizeof(Nk_vec2{})))))*8))
			var x float32 = (center.X + (c.X * radius))
			var y float32 = (center.Y + (c.Y * radius))
			Xnk_draw_list_path_line_to(list, Xnk_vec2(x, y))
		}
	}
}

var __func__86 = *(*[30]int8)(unsafe.Pointer(ts + 2322 /* "nk_draw_list_pat..." */)) /* nuklear.h:10076:1 */

func Xnk_draw_list_path_arc_to(list uintptr, center Nk_vec2, radius float32, a_min float32, a_max float32, segments uint32) { /* nuklear.h:10090:1: */
	var i uint32 = uint32(0)
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10094), uintptr(unsafe.Pointer(&__func__87)))
	}
	if !(list != 0) {
		return
	}
	if radius == 0.0 {
		return
	}

	/*  This algorithm for arc drawing relies on these two trigonometric identities[1]:
	        sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
	        cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)

	    Two coordinates (x, y) of a point on a circle centered on
	    the origin can be written in polar form as:
	        x = r * cos(a)
	        y = r * sin(a)
	    where r is the radius of the circle,
	        a is the angle between (x, y) and the origin.

	    This allows us to rotate the coordinates around the
	    origin by an angle b using the following transformation:
	        x' = r * cos(a + b) = x * cos(b) - y * sin(b)
	        y' = r * sin(a + b) = y * cos(b) + x * sin(b)

	    [1] https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities
	*/
	{
		var d_angle float32 = ((a_max - a_min) / float32(segments))
		var sin_d float32 = nk_sin(d_angle)
		var cos_d float32 = nk_cos(d_angle)

		var cx float32 = (nk_cos(a_min) * radius)
		var cy float32 = (nk_sin(a_min) * radius)
		for i = uint32(0); i <= segments; i++ {
			var new_cx float32
			var new_cy float32
			var x float32 = (center.X + cx)
			var y float32 = (center.Y + cy)
			Xnk_draw_list_path_line_to(list, Xnk_vec2(x, y))

			new_cx = ((cx * cos_d) - (cy * sin_d))
			new_cy = ((cy * cos_d) + (cx * sin_d))
			cx = new_cx
			cy = new_cy
		}
	}
}

var __func__87 = *(*[25]int8)(unsafe.Pointer(ts + 2352 /* "nk_draw_list_pat..." */)) /* nuklear.h:10092:1 */

func Xnk_draw_list_path_rect_to(list uintptr, a Nk_vec2, b Nk_vec2, rounding float32) { /* nuklear.h:10135:1: */
	var r float32
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10139), uintptr(unsafe.Pointer(&__func__88)))
	}
	if !(list != 0) {
		return
	}
	r = rounding
	r = func() float32 {
		if (r) < (func() float32 {
			if (b.X - a.X) < float32(0) {
				return -(b.X - a.X)
			}
			return (b.X - a.X)
		}()) {
			return r
		}
		return func() float32 {
			if (b.X - a.X) < float32(0) {
				return -(b.X - a.X)
			}
			return (b.X - a.X)
		}()
	}()
	r = func() float32 {
		if (r) < (func() float32 {
			if (b.Y - a.Y) < float32(0) {
				return -(b.Y - a.Y)
			}
			return (b.Y - a.Y)
		}()) {
			return r
		}
		return func() float32 {
			if (b.Y - a.Y) < float32(0) {
				return -(b.Y - a.Y)
			}
			return (b.Y - a.Y)
		}()
	}()

	if r == 0.0 {
		Xnk_draw_list_path_line_to(list, a)
		Xnk_draw_list_path_line_to(list, Xnk_vec2(b.X, a.Y))
		Xnk_draw_list_path_line_to(list, b)
		Xnk_draw_list_path_line_to(list, Xnk_vec2(a.X, b.Y))
	} else {
		Xnk_draw_list_path_arc_to_fast(list, Xnk_vec2((a.X+r), (a.Y+r)), r, 6, 9)
		Xnk_draw_list_path_arc_to_fast(list, Xnk_vec2((b.X-r), (a.Y+r)), r, 9, 12)
		Xnk_draw_list_path_arc_to_fast(list, Xnk_vec2((b.X-r), (b.Y-r)), r, 0, 3)
		Xnk_draw_list_path_arc_to_fast(list, Xnk_vec2((a.X+r), (b.Y-r)), r, 3, 6)
	}
}

var __func__88 = *(*[26]int8)(unsafe.Pointer(ts + 2377 /* "nk_draw_list_pat..." */)) /* nuklear.h:10137:1 */

func Xnk_draw_list_path_curve_to(list uintptr, p2 Nk_vec2, p3 Nk_vec2, p4 Nk_vec2, num_segments uint32) { /* nuklear.h:10158:1: */
	var t_step float32
	var i_step uint32
	var p1 Nk_vec2

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10165), uintptr(unsafe.Pointer(&__func__89)))
	}
	if (*Nk_draw_list)(unsafe.Pointer(list)).Path_count != 0 {
	} else {
		X__assert_fail(ts+1606 /* "list->path_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(10166), uintptr(unsafe.Pointer(&__func__89)))
	}
	if !(list != 0) || !(int32((*Nk_draw_list)(unsafe.Pointer(list)).Path_count) != 0) {
		return
	}
	num_segments = func() uint32 {
		if (num_segments) < (uint32(1)) {
			return uint32(1)
		}
		return num_segments
	}()

	p1 = nk_draw_list_path_last(list)
	t_step = (1.0 / float32(num_segments))
	for i_step = uint32(1); i_step <= num_segments; i_step++ {
		var t float32 = (t_step * float32(i_step))
		var u float32 = (1.0 - t)
		var w1 float32 = ((u * u) * u)
		var w2 float32 = (((float32(3) * u) * u) * t)
		var w3 float32 = (((float32(3) * u) * t) * t)
		var w4 float32 = ((t * t) * t)
		var x float32 = ((((w1 * p1.X) + (w2 * p2.X)) + (w3 * p3.X)) + (w4 * p4.X))
		var y float32 = ((((w1 * p1.Y) + (w2 * p2.Y)) + (w3 * p3.Y)) + (w4 * p4.Y))
		Xnk_draw_list_path_line_to(list, Xnk_vec2(x, y))
	}
}

var __func__89 = *(*[27]int8)(unsafe.Pointer(ts + 2403 /* "nk_draw_list_pat..." */)) /* nuklear.h:10160:1 */

func Xnk_draw_list_path_fill(list uintptr, color Nk_color) { /* nuklear.h:10185:1: */
	var points uintptr
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10188), uintptr(unsafe.Pointer(&__func__90)))
	}
	if !(list != 0) {
		return
	}
	points = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
	Xnk_draw_list_fill_poly_convex(list, points, (*Nk_draw_list)(unsafe.Pointer(list)).Path_count, color, (*Nk_draw_list)(unsafe.Pointer(list)).Config.Shape_AA)
	Xnk_draw_list_path_clear(list)
}

var __func__90 = *(*[23]int8)(unsafe.Pointer(ts + 2430 /* "nk_draw_list_pat..." */)) /* nuklear.h:10186:1 */

func Xnk_draw_list_path_stroke(list uintptr, color Nk_color, closed uint32, thickness float32) { /* nuklear.h:10195:1: */
	var points uintptr
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10199), uintptr(unsafe.Pointer(&__func__91)))
	}
	if !(list != 0) {
		return
	}
	points = Xnk_buffer_memory((*Nk_draw_list)(unsafe.Pointer(list)).Buffer)
	Xnk_draw_list_stroke_poly_line(list, points, (*Nk_draw_list)(unsafe.Pointer(list)).Path_count, color,
		closed, thickness, (*Nk_draw_list)(unsafe.Pointer(list)).Config.Line_AA)
	Xnk_draw_list_path_clear(list)
}

var __func__91 = *(*[25]int8)(unsafe.Pointer(ts + 2453 /* "nk_draw_list_pat..." */)) /* nuklear.h:10197:1 */

func Xnk_draw_list_stroke_line(list uintptr, a Nk_vec2, b Nk_vec2, col Nk_color, thickness float32) { /* nuklear.h:10207:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10210), uintptr(unsafe.Pointer(&__func__92)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	if int32((*Nk_draw_list)(unsafe.Pointer(list)).Line_AA) == NK_ANTI_ALIASING_ON {
		Xnk_draw_list_path_line_to(list, a)
		Xnk_draw_list_path_line_to(list, b)
	} else {
		var tt = Xnk_vec2(0.5, 0.5)
		Xnk_draw_list_path_line_to(list, Xnk_vec2((a.X-tt.X), (a.Y-tt.Y)))
		Xnk_draw_list_path_line_to(list, Xnk_vec2((b.X-tt.X), (b.Y-tt.Y)))
	}
	Xnk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness)
}

var __func__92 = *(*[25]int8)(unsafe.Pointer(ts + 2478 /* "nk_draw_list_str..." */)) /* nuklear.h:10209:1 */

func Xnk_draw_list_fill_rect(list uintptr, rect Nk_rect, col Nk_color, rounding float32) { /* nuklear.h:10223:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10226), uintptr(unsafe.Pointer(&__func__93)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}

	if int32((*Nk_draw_list)(unsafe.Pointer(list)).Line_AA) == NK_ANTI_ALIASING_ON {
		Xnk_draw_list_path_rect_to(list, Xnk_vec2(rect.X, rect.Y),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), rounding)
	} else {
		Xnk_draw_list_path_rect_to(list, Xnk_vec2((rect.X-0.5), (rect.Y-0.5)),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), rounding)
	}
	Xnk_draw_list_path_fill(list, col)
}

var __func__93 = *(*[23]int8)(unsafe.Pointer(ts + 2503 /* "nk_draw_list_fil..." */)) /* nuklear.h:10225:1 */

func Xnk_draw_list_stroke_rect(list uintptr, rect Nk_rect, col Nk_color, rounding float32, thickness float32) { /* nuklear.h:10238:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10241), uintptr(unsafe.Pointer(&__func__94)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	if int32((*Nk_draw_list)(unsafe.Pointer(list)).Line_AA) == NK_ANTI_ALIASING_ON {
		Xnk_draw_list_path_rect_to(list, Xnk_vec2(rect.X, rect.Y),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), rounding)
	} else {
		Xnk_draw_list_path_rect_to(list, Xnk_vec2((rect.X-0.5), (rect.Y-0.5)),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), rounding)
	}
	Xnk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness)
}

var __func__94 = *(*[25]int8)(unsafe.Pointer(ts + 2526 /* "nk_draw_list_str..." */)) /* nuklear.h:10240:1 */

func Xnk_draw_list_fill_rect_multi_color(list uintptr, rect Nk_rect, left Nk_color, top Nk_color, right Nk_color, bottom Nk_color) { /* nuklear.h:10252:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)

	var vtx uintptr
	// var col_left Nk_colorf at bp, 16

	// var col_top Nk_colorf at bp+32, 16

	// var col_right Nk_colorf at bp+16, 16

	// var col_bottom Nk_colorf at bp+48, 16

	var idx uintptr
	var index Nk_draw_index

	Xnk_color_fv((bp /* &col_left */ /* &.r */), left)
	Xnk_color_fv((bp + 16 /* &col_right */ /* &.r */), right)
	Xnk_color_fv((bp + 32 /* &col_top */ /* &.r */), top)
	Xnk_color_fv((bp + 48 /* &col_bottom */ /* &.r */), bottom)

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10267), uintptr(unsafe.Pointer(&__func__95)))
	}
	if !(list != 0) {
		return
	}

	nk_draw_list_push_image(list, (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Texture)
	index = Nk_draw_index((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)
	vtx = nk_draw_list_alloc_vertices(list, uint32(4))
	idx = nk_draw_list_alloc_elements(list, uint32(6))
	if !(vtx != 0) || !(idx != 0) {
		return
	}

	*(*Nk_draw_index)(unsafe.Pointer(idx)) = (Nk_draw_index(int32(index) + 0))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 1*2)) = (Nk_draw_index(int32(index) + 1))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 2*2)) = (Nk_draw_index(int32(index) + 2))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 3*2)) = (Nk_draw_index(int32(index) + 0))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 4*2)) = (Nk_draw_index(int32(index) + 2))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 5*2)) = (Nk_draw_index(int32(index) + 3))

	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2(rect.X, rect.Y), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv, *(*Nk_colorf)(unsafe.Pointer(bp /* col_left */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((rect.X+rect.W), rect.Y), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv, *(*Nk_colorf)(unsafe.Pointer(bp + 32 /* col_top */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv, *(*Nk_colorf)(unsafe.Pointer(bp + 16 /* col_right */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), Xnk_vec2(rect.X, (rect.Y+rect.H)), (*Nk_draw_list)(unsafe.Pointer(list)).Config.Null.Uv, *(*Nk_colorf)(unsafe.Pointer(bp + 48 /* col_bottom */)))
}

var __func__95 = *(*[35]int8)(unsafe.Pointer(ts + 2551 /* "nk_draw_list_fil..." */)) /* nuklear.h:10255:1 */

func Xnk_draw_list_fill_triangle(list uintptr, a Nk_vec2, b Nk_vec2, c Nk_vec2, col Nk_color) { /* nuklear.h:10286:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10289), uintptr(unsafe.Pointer(&__func__96)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	Xnk_draw_list_path_line_to(list, a)
	Xnk_draw_list_path_line_to(list, b)
	Xnk_draw_list_path_line_to(list, c)
	Xnk_draw_list_path_fill(list, col)
}

var __func__96 = *(*[27]int8)(unsafe.Pointer(ts + 2586 /* "nk_draw_list_fil..." */)) /* nuklear.h:10288:1 */

func Xnk_draw_list_stroke_triangle(list uintptr, a Nk_vec2, b Nk_vec2, c Nk_vec2, col Nk_color, thickness float32) { /* nuklear.h:10297:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10300), uintptr(unsafe.Pointer(&__func__97)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	Xnk_draw_list_path_line_to(list, a)
	Xnk_draw_list_path_line_to(list, b)
	Xnk_draw_list_path_line_to(list, c)
	Xnk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness)
}

var __func__97 = *(*[29]int8)(unsafe.Pointer(ts + 2613 /* "nk_draw_list_str..." */)) /* nuklear.h:10299:1 */

func Xnk_draw_list_fill_circle(list uintptr, center Nk_vec2, radius float32, col Nk_color, segs uint32) { /* nuklear.h:10308:1: */
	var a_max float32
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10312), uintptr(unsafe.Pointer(&__func__98)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	a_max = (((float32(3.141592654) * 2.0) * (float32(segs) - 1.0)) / float32(segs))
	Xnk_draw_list_path_arc_to(list, center, radius, 0.0, a_max, segs)
	Xnk_draw_list_path_fill(list, col)
}

var __func__98 = *(*[25]int8)(unsafe.Pointer(ts + 2642 /* "nk_draw_list_fil..." */)) /* nuklear.h:10310:1 */

func Xnk_draw_list_stroke_circle(list uintptr, center Nk_vec2, radius float32, col Nk_color, segs uint32, thickness float32) { /* nuklear.h:10319:1: */
	var a_max float32
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10323), uintptr(unsafe.Pointer(&__func__99)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	a_max = (((float32(3.141592654) * 2.0) * (float32(segs) - 1.0)) / float32(segs))
	Xnk_draw_list_path_arc_to(list, center, radius, 0.0, a_max, segs)
	Xnk_draw_list_path_stroke(list, col, NK_STROKE_CLOSED, thickness)
}

var __func__99 = *(*[27]int8)(unsafe.Pointer(ts + 2667 /* "nk_draw_list_str..." */)) /* nuklear.h:10321:1 */

func Xnk_draw_list_stroke_curve(list uintptr, p0 Nk_vec2, cp0 Nk_vec2, cp1 Nk_vec2, p1 Nk_vec2, col Nk_color, segments uint32, thickness float32) { /* nuklear.h:10330:1: */
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10334), uintptr(unsafe.Pointer(&__func__100)))
	}
	if !(list != 0) || !(int32(col.A) != 0) {
		return
	}
	Xnk_draw_list_path_line_to(list, p0)
	Xnk_draw_list_path_curve_to(list, cp0, cp1, p1, segments)
	Xnk_draw_list_path_stroke(list, col, NK_STROKE_OPEN, thickness)
}

var __func__100 = *(*[26]int8)(unsafe.Pointer(ts + 2694 /* "nk_draw_list_str..." */)) /* nuklear.h:10333:1 */

func nk_draw_list_push_rect_uv(list uintptr, a Nk_vec2, c Nk_vec2, uva Nk_vec2, uvc Nk_vec2, color Nk_color) { /* nuklear.h:10341:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var vtx uintptr
	var uvb Nk_vec2
	var uvd Nk_vec2
	var b Nk_vec2
	var d Nk_vec2
	// var col Nk_colorf at bp, 16

	var idx uintptr
	var index Nk_draw_index
	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10354), uintptr(unsafe.Pointer(&__func__101)))
	}
	if !(list != 0) {
		return
	}

	Xnk_color_fv((bp /* &col */ /* &.r */), color)
	uvb = Xnk_vec2(uvc.X, uva.Y)
	uvd = Xnk_vec2(uva.X, uvc.Y)
	b = Xnk_vec2(c.X, a.Y)
	d = Xnk_vec2(a.X, c.Y)

	index = Nk_draw_index((*Nk_draw_list)(unsafe.Pointer(list)).Vertex_count)
	vtx = nk_draw_list_alloc_vertices(list, uint32(4))
	idx = nk_draw_list_alloc_elements(list, uint32(6))
	if !(vtx != 0) || !(idx != 0) {
		return
	}

	*(*Nk_draw_index)(unsafe.Pointer(idx)) = (Nk_draw_index(int32(index) + 0))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 1*2)) = (Nk_draw_index(int32(index) + 1))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 2*2)) = (Nk_draw_index(int32(index) + 2))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 3*2)) = (Nk_draw_index(int32(index) + 0))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 4*2)) = (Nk_draw_index(int32(index) + 2))
	*(*Nk_draw_index)(unsafe.Pointer(idx + 5*2)) = (Nk_draw_index(int32(index) + 3))

	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), a, uva, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), b, uvb, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), c, uvc, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
	vtx = nk_draw_vertex(vtx, (list + 112 /* &.config */), d, uvd, *(*Nk_colorf)(unsafe.Pointer(bp /* col */)))
}

var __func__101 = *(*[26]int8)(unsafe.Pointer(ts + 2720 /* "nk_draw_list_pus..." */)) /* nuklear.h:10344:1 */

func Xnk_draw_list_add_image(list uintptr, texture Nk_image, rect Nk_rect, color Nk_color) { /* nuklear.h:10378:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_image)(unsafe.Pointer(bp)) = texture

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10381), uintptr(unsafe.Pointer(&__func__102)))
	}
	if !(list != 0) {
		return
	}
	// push new command with given texture
	nk_draw_list_push_image(list, (*Nk_image)(unsafe.Pointer(bp /* &texture */)).Handle)
	if Xnk_image_is_subimage(bp /* &texture */) != 0 {
		// add region inside of the texture
		// var uv [2]Nk_vec2 at bp+16, 16

		(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv */)).X = (float32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */)))) / float32((*Nk_image)(unsafe.Pointer(bp /* &texture */)).W))
		(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv */)).Y = (float32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */) + 1*2))) / float32((*Nk_image)(unsafe.Pointer(bp /* &texture */)).H))
		(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv */ + 1*8)).X = ((float32(int32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */)))) + int32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */) + 2*2))))) / float32((*Nk_image)(unsafe.Pointer(bp /* &texture */)).W))
		(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv */ + 1*8)).Y = ((float32(int32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */) + 1*2))) + int32(*(*uint16)(unsafe.Pointer((bp /* &texture */ + 8 /* &.region */) + 3*2))))) / float32((*Nk_image)(unsafe.Pointer(bp /* &texture */)).H))
		nk_draw_list_push_rect_uv(list, Xnk_vec2(rect.X, rect.Y),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)), *(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv[0] */)), *(*Nk_vec2)(unsafe.Pointer(bp + 16 /* &uv[0] */ + 1*8)), color)
	} else {
		nk_draw_list_push_rect_uv(list, Xnk_vec2(rect.X, rect.Y),
			Xnk_vec2((rect.X+rect.W), (rect.Y+rect.H)),
			Xnk_vec2(0.0, 0.0), Xnk_vec2(1.0, 1.0), color)
	}
}

var __func__102 = *(*[23]int8)(unsafe.Pointer(ts + 2746 /* "nk_draw_list_add..." */)) /* nuklear.h:10380:1 */

func Xnk_draw_list_add_text(list uintptr, font uintptr, rect Nk_rect, text uintptr, len int32, font_height float32, fg Nk_color) { /* nuklear.h:10399:1: */
	bp := tlsAlloc(44)
	defer tlsFree(44)

	var x float32 = float32(0)
	var text_len int32 = 0
	*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
	*(*Nk_rune)(unsafe.Pointer(bp + 4 /* next */)) = Nk_rune(0)
	var glyph_len int32 = 0
	var next_glyph_len int32 = 0
	// var g Nk_user_font_glyph at bp+8, 36

	if list != 0 {
	} else {
		X__assert_fail(ts+1470 /* "list" */, ts+2 /* "nuklear/nuklear...." */, uint32(10411), uintptr(unsafe.Pointer(&__func__103)))
	}
	if (!(list != 0) || !(len != 0)) || !(text != 0) {
		return
	}
	if !(((((*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.X < (rect.X + rect.W)) && (rect.X < ((*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.X + (*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.W))) && ((*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.Y < (rect.Y + rect.H))) && (rect.Y < ((*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.Y + (*Nk_draw_list)(unsafe.Pointer(list)).Clip_rect.H))) {
		return
	}

	nk_draw_list_push_image(list, (*Nk_user_font)(unsafe.Pointer(font)).Texture)
	x = rect.X
	glyph_len = Xnk_utf_decode(text, bp /* &unicode */, len)
	if !(glyph_len != 0) {
		return
	}

	// draw every glyph image
	fg.A = (Nk_byte(float32(fg.A) * (*Nk_draw_list)(unsafe.Pointer(list)).Config.Global_alpha))
	for (text_len < len) && (glyph_len != 0) {
		var gx float32
		var gy float32
		var gh float32
		var gw float32
		var char_width float32 = float32(0)
		if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune(NK_UTF_INVALID) {
			break
		}

		// query currently drawn glyph information
		next_glyph_len = Xnk_utf_decode(((text + uintptr(text_len)) + uintptr(glyph_len)), bp+4 /* &next */, (len - text_len))
		(*(*func(Nk_handle, float32, uintptr, Nk_rune, Nk_rune))(unsafe.Pointer((font + 12 /* &.query */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, font_height, bp+8 /* &g */, *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)),
			func() uint32 {
				if *(*Nk_rune)(unsafe.Pointer(bp + 4 /* next */)) == Nk_rune(NK_UTF_INVALID) {
					return uint32(0)
				}
				return *(*Nk_rune)(unsafe.Pointer(bp + 4 /* next */))
			}())

		// calculate and draw glyph drawing rectangle and image
		gx = (x + (*Nk_user_font_glyph)(unsafe.Pointer(bp+8 /* &g */)).Offset.X)
		gy = (rect.Y + (*Nk_user_font_glyph)(unsafe.Pointer(bp+8 /* &g */)).Offset.Y)
		gw = (*Nk_user_font_glyph)(unsafe.Pointer(bp + 8 /* &g */)).Width
		gh = (*Nk_user_font_glyph)(unsafe.Pointer(bp + 8 /* &g */)).Height
		char_width = (*Nk_user_font_glyph)(unsafe.Pointer(bp + 8 /* &g */)).Xadvance
		nk_draw_list_push_rect_uv(list, Xnk_vec2(gx, gy), Xnk_vec2((gx+gw), (gy+gh)),
			*(*Nk_vec2)(unsafe.Pointer((bp + 8 /* &g */ /* &.uv */))), *(*Nk_vec2)(unsafe.Pointer((bp + 8 /* &g */ /* &.uv */) + 1*8)), fg)

		// offset next glyph
		text_len = text_len + (glyph_len)
		x = x + (char_width)
		glyph_len = next_glyph_len
		*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = *(*Nk_rune)(unsafe.Pointer(bp + 4 /* next */))
	}
}

var __func__103 = *(*[22]int8)(unsafe.Pointer(ts + 2769 /* "nk_draw_list_add..." */)) /* nuklear.h:10402:1 */

func Xnk_convert(ctx uintptr, cmds uintptr, vertices uintptr, elements uintptr, config uintptr) Nk_flags { /* nuklear.h:10449:1: */
	var res Nk_flags = NK_CONVERT_SUCCESS
	var cmd uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(10455), uintptr(unsafe.Pointer(&__func__104)))
	}
	if cmds != 0 {
	} else {
		X__assert_fail(ts+1507 /* "cmds" */, ts+2 /* "nuklear/nuklear...." */, uint32(10456), uintptr(unsafe.Pointer(&__func__104)))
	}
	if vertices != 0 {
	} else {
		X__assert_fail(ts+1512 /* "vertices" */, ts+2 /* "nuklear/nuklear...." */, uint32(10457), uintptr(unsafe.Pointer(&__func__104)))
	}
	if elements != 0 {
	} else {
		X__assert_fail(ts+1521 /* "elements" */, ts+2 /* "nuklear/nuklear...." */, uint32(10458), uintptr(unsafe.Pointer(&__func__104)))
	}
	if config != 0 {
	} else {
		X__assert_fail(ts+1500 /* "config" */, ts+2 /* "nuklear/nuklear...." */, uint32(10459), uintptr(unsafe.Pointer(&__func__104)))
	}
	if (*Nk_convert_config)(unsafe.Pointer(config)).Vertex_layout != 0 {
	} else {
		X__assert_fail(ts+2795 /* "config->vertex_l..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10460), uintptr(unsafe.Pointer(&__func__104)))
	}
	if (*Nk_convert_config)(unsafe.Pointer(config)).Vertex_size != 0 {
	} else {
		X__assert_fail(ts+2817 /* "config->vertex_s..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10461), uintptr(unsafe.Pointer(&__func__104)))
	}
	if ((((!(ctx != 0) || !(cmds != 0)) || !(vertices != 0)) || !(elements != 0)) || !(config != 0)) || !(int32((*Nk_convert_config)(unsafe.Pointer(config)).Vertex_layout) != 0) {
		return NK_CONVERT_INVALID_PARAM
	}

	Xnk_draw_list_setup((ctx + 7332 /* &.draw_list */), config, cmds, vertices, elements,
		(*Nk_convert_config)(unsafe.Pointer(config)).Line_AA, (*Nk_convert_config)(unsafe.Pointer(config)).Shape_AA)
	for (cmd) = Xnk__begin(ctx); (cmd) != uintptr(0); (cmd) = Xnk__next(ctx, cmd) {
		switch (*Nk_command)(unsafe.Pointer(cmd)).Type {
		case NK_COMMAND_NOP:
			break
		case NK_COMMAND_SCISSOR:
			{
				var s uintptr = cmd
				nk_draw_list_add_clip((ctx + 7332 /* &.draw_list */), Xnk_rect(float32((*Nk_command_scissor)(unsafe.Pointer(s)).X), float32((*Nk_command_scissor)(unsafe.Pointer(s)).Y), float32((*Nk_command_scissor)(unsafe.Pointer(s)).W), float32((*Nk_command_scissor)(unsafe.Pointer(s)).H)))

			}
			break
		case NK_COMMAND_LINE:
			{
				var l uintptr = cmd
				Xnk_draw_list_stroke_line((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_line)(unsafe.Pointer(l)).Begin.X), float32((*Nk_command_line)(unsafe.Pointer(l)).Begin.Y)),
					Xnk_vec2(float32((*Nk_command_line)(unsafe.Pointer(l)).End.X), float32((*Nk_command_line)(unsafe.Pointer(l)).End.Y)), (*Nk_command_line)(unsafe.Pointer(l)).Color, float32((*Nk_command_line)(unsafe.Pointer(l)).Line_thickness))

			}
			break
		case NK_COMMAND_CURVE:
			{
				var q uintptr = cmd
				Xnk_draw_list_stroke_curve((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_curve)(unsafe.Pointer(q)).Begin.X), float32((*Nk_command_curve)(unsafe.Pointer(q)).Begin.Y)),
					Xnk_vec2(float32((*Nk_vec2i)(unsafe.Pointer((q+18 /* &.ctrl */))).X), float32((*Nk_vec2i)(unsafe.Pointer((q+18 /* &.ctrl */))).Y)), Xnk_vec2(float32((*Nk_vec2i)(unsafe.Pointer((q+18 /* &.ctrl */)+1*4)).X),
						float32((*Nk_vec2i)(unsafe.Pointer((q+18 /* &.ctrl */)+1*4)).Y)), Xnk_vec2(float32((*Nk_command_curve)(unsafe.Pointer(q)).End.X), float32((*Nk_command_curve)(unsafe.Pointer(q)).End.Y)), (*Nk_command_curve)(unsafe.Pointer(q)).Color,
					(*Nk_convert_config)(unsafe.Pointer(config)).Curve_segment_count, float32((*Nk_command_curve)(unsafe.Pointer(q)).Line_thickness))

			}
			break
		case NK_COMMAND_RECT:
			{
				var r uintptr = cmd
				Xnk_draw_list_stroke_rect((ctx + 7332 /* &.draw_list */), Xnk_rect(float32((*Nk_command_rect)(unsafe.Pointer(r)).X), float32((*Nk_command_rect)(unsafe.Pointer(r)).Y), float32((*Nk_command_rect)(unsafe.Pointer(r)).W), float32((*Nk_command_rect)(unsafe.Pointer(r)).H)),
					(*Nk_command_rect)(unsafe.Pointer(r)).Color, float32((*Nk_command_rect)(unsafe.Pointer(r)).Rounding), float32((*Nk_command_rect)(unsafe.Pointer(r)).Line_thickness))

			}
			break
		case NK_COMMAND_RECT_FILLED:
			{
				var r uintptr = cmd
				Xnk_draw_list_fill_rect((ctx + 7332 /* &.draw_list */), Xnk_rect(float32((*Nk_command_rect_filled)(unsafe.Pointer(r)).X), float32((*Nk_command_rect_filled)(unsafe.Pointer(r)).Y), float32((*Nk_command_rect_filled)(unsafe.Pointer(r)).W), float32((*Nk_command_rect_filled)(unsafe.Pointer(r)).H)),
					(*Nk_command_rect_filled)(unsafe.Pointer(r)).Color, float32((*Nk_command_rect_filled)(unsafe.Pointer(r)).Rounding))

			}
			break
		case NK_COMMAND_RECT_MULTI_COLOR:
			{
				var r uintptr = cmd
				Xnk_draw_list_fill_rect_multi_color((ctx + 7332 /* &.draw_list */), Xnk_rect(float32((*Nk_command_rect_multi_color)(unsafe.Pointer(r)).X), float32((*Nk_command_rect_multi_color)(unsafe.Pointer(r)).Y), float32((*Nk_command_rect_multi_color)(unsafe.Pointer(r)).W), float32((*Nk_command_rect_multi_color)(unsafe.Pointer(r)).H)),
					(*Nk_command_rect_multi_color)(unsafe.Pointer(r)).Left, (*Nk_command_rect_multi_color)(unsafe.Pointer(r)).Top, (*Nk_command_rect_multi_color)(unsafe.Pointer(r)).Right, (*Nk_command_rect_multi_color)(unsafe.Pointer(r)).Bottom)

			}
			break
		case NK_COMMAND_CIRCLE:
			{
				var c uintptr = cmd
				Xnk_draw_list_stroke_circle((ctx + 7332 /* &.draw_list */), Xnk_vec2((float32((*Nk_command_circle)(unsafe.Pointer(c)).X)+(float32((*Nk_command_circle)(unsafe.Pointer(c)).W)/float32(2))),
					(float32((*Nk_command_circle)(unsafe.Pointer(c)).Y)+(float32((*Nk_command_circle)(unsafe.Pointer(c)).H)/float32(2)))), (float32((*Nk_command_circle)(unsafe.Pointer(c)).W) / float32(2)), (*Nk_command_circle)(unsafe.Pointer(c)).Color,
					(*Nk_convert_config)(unsafe.Pointer(config)).Circle_segment_count, float32((*Nk_command_circle)(unsafe.Pointer(c)).Line_thickness))

			}
			break
		case NK_COMMAND_CIRCLE_FILLED:
			{
				var c uintptr = cmd
				Xnk_draw_list_fill_circle((ctx + 7332 /* &.draw_list */), Xnk_vec2((float32((*Nk_command_circle_filled)(unsafe.Pointer(c)).X)+(float32((*Nk_command_circle_filled)(unsafe.Pointer(c)).W)/float32(2))),
					(float32((*Nk_command_circle_filled)(unsafe.Pointer(c)).Y)+(float32((*Nk_command_circle_filled)(unsafe.Pointer(c)).H)/float32(2)))), (float32((*Nk_command_circle_filled)(unsafe.Pointer(c)).W) / float32(2)), (*Nk_command_circle_filled)(unsafe.Pointer(c)).Color,
					(*Nk_convert_config)(unsafe.Pointer(config)).Circle_segment_count)

			}
			break
		case NK_COMMAND_ARC:
			{
				var c uintptr = cmd
				Xnk_draw_list_path_line_to((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_arc)(unsafe.Pointer(c)).Cx), float32((*Nk_command_arc)(unsafe.Pointer(c)).Cy)))
				Xnk_draw_list_path_arc_to((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_arc)(unsafe.Pointer(c)).Cx), float32((*Nk_command_arc)(unsafe.Pointer(c)).Cy)), float32((*Nk_command_arc)(unsafe.Pointer(c)).R),
					*(*float32)(unsafe.Pointer((c + 16 /* &.a */))), *(*float32)(unsafe.Pointer((c + 16 /* &.a */) + 1*4)), (*Nk_convert_config)(unsafe.Pointer(config)).Arc_segment_count)
				Xnk_draw_list_path_stroke((ctx + 7332 /* &.draw_list */), (*Nk_command_arc)(unsafe.Pointer(c)).Color, NK_STROKE_CLOSED, float32((*Nk_command_arc)(unsafe.Pointer(c)).Line_thickness))

			}
			break
		case NK_COMMAND_ARC_FILLED:
			{
				var c uintptr = cmd
				Xnk_draw_list_path_line_to((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_arc_filled)(unsafe.Pointer(c)).Cx), float32((*Nk_command_arc_filled)(unsafe.Pointer(c)).Cy)))
				Xnk_draw_list_path_arc_to((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_arc_filled)(unsafe.Pointer(c)).Cx), float32((*Nk_command_arc_filled)(unsafe.Pointer(c)).Cy)), float32((*Nk_command_arc_filled)(unsafe.Pointer(c)).R),
					*(*float32)(unsafe.Pointer((c + 16 /* &.a */))), *(*float32)(unsafe.Pointer((c + 16 /* &.a */) + 1*4)), (*Nk_convert_config)(unsafe.Pointer(config)).Arc_segment_count)
				Xnk_draw_list_path_fill((ctx + 7332 /* &.draw_list */), (*Nk_command_arc_filled)(unsafe.Pointer(c)).Color)

			}
			break
		case NK_COMMAND_TRIANGLE:
			{
				var t uintptr = cmd
				Xnk_draw_list_stroke_triangle((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_triangle)(unsafe.Pointer(t)).A.X), float32((*Nk_command_triangle)(unsafe.Pointer(t)).A.Y)),
					Xnk_vec2(float32((*Nk_command_triangle)(unsafe.Pointer(t)).B.X), float32((*Nk_command_triangle)(unsafe.Pointer(t)).B.Y)), Xnk_vec2(float32((*Nk_command_triangle)(unsafe.Pointer(t)).C.X), float32((*Nk_command_triangle)(unsafe.Pointer(t)).C.Y)), (*Nk_command_triangle)(unsafe.Pointer(t)).Color,
					float32((*Nk_command_triangle)(unsafe.Pointer(t)).Line_thickness))

			}
			break
		case NK_COMMAND_TRIANGLE_FILLED:
			{
				var t uintptr = cmd
				Xnk_draw_list_fill_triangle((ctx + 7332 /* &.draw_list */), Xnk_vec2(float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).A.X), float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).A.Y)),
					Xnk_vec2(float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).B.X), float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).B.Y)), Xnk_vec2(float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).C.X), float32((*Nk_command_triangle_filled)(unsafe.Pointer(t)).C.Y)), (*Nk_command_triangle_filled)(unsafe.Pointer(t)).Color)

			}
			break
		case NK_COMMAND_POLYGON:
			{
				var i int32
				var p uintptr = cmd
				for i = 0; i < int32((*Nk_command_polygon)(unsafe.Pointer(p)).Point_count); i++ {
					var pnt = Xnk_vec2(float32((*Nk_vec2i)(unsafe.Pointer((p+16 /* &.points */)+uintptr(i)*4)).X), float32((*Nk_vec2i)(unsafe.Pointer((p+16 /* &.points */)+uintptr(i)*4)).Y))
					Xnk_draw_list_path_line_to((ctx + 7332 /* &.draw_list */), pnt)
				}
				Xnk_draw_list_path_stroke((ctx + 7332 /* &.draw_list */), (*Nk_command_polygon)(unsafe.Pointer(p)).Color, NK_STROKE_CLOSED, float32((*Nk_command_polygon)(unsafe.Pointer(p)).Line_thickness))

			}
			break
		case NK_COMMAND_POLYGON_FILLED:
			{
				var i int32
				var p uintptr = cmd
				for i = 0; i < int32((*Nk_command_polygon_filled)(unsafe.Pointer(p)).Point_count); i++ {
					var pnt = Xnk_vec2(float32((*Nk_vec2i)(unsafe.Pointer((p+14 /* &.points */)+uintptr(i)*4)).X), float32((*Nk_vec2i)(unsafe.Pointer((p+14 /* &.points */)+uintptr(i)*4)).Y))
					Xnk_draw_list_path_line_to((ctx + 7332 /* &.draw_list */), pnt)
				}
				Xnk_draw_list_path_fill((ctx + 7332 /* &.draw_list */), (*Nk_command_polygon_filled)(unsafe.Pointer(p)).Color)

			}
			break
		case NK_COMMAND_POLYLINE:
			{
				var i int32
				var p uintptr = cmd
				for i = 0; i < int32((*Nk_command_polyline)(unsafe.Pointer(p)).Point_count); i++ {
					var pnt = Xnk_vec2(float32((*Nk_vec2i)(unsafe.Pointer((p+16 /* &.points */)+uintptr(i)*4)).X), float32((*Nk_vec2i)(unsafe.Pointer((p+16 /* &.points */)+uintptr(i)*4)).Y))
					Xnk_draw_list_path_line_to((ctx + 7332 /* &.draw_list */), pnt)
				}
				Xnk_draw_list_path_stroke((ctx + 7332 /* &.draw_list */), (*Nk_command_polyline)(unsafe.Pointer(p)).Color, NK_STROKE_OPEN, float32((*Nk_command_polyline)(unsafe.Pointer(p)).Line_thickness))

			}
			break
		case NK_COMMAND_TEXT:
			{
				var t uintptr = cmd
				Xnk_draw_list_add_text((ctx + 7332 /* &.draw_list */), (*Nk_command_text)(unsafe.Pointer(t)).Font, Xnk_rect(float32((*Nk_command_text)(unsafe.Pointer(t)).X), float32((*Nk_command_text)(unsafe.Pointer(t)).Y), float32((*Nk_command_text)(unsafe.Pointer(t)).W), float32((*Nk_command_text)(unsafe.Pointer(t)).H)),
					t+36 /* &.string */, (*Nk_command_text)(unsafe.Pointer(t)).Length, (*Nk_command_text)(unsafe.Pointer(t)).Height, (*Nk_command_text)(unsafe.Pointer(t)).Foreground)

			}
			break
		case NK_COMMAND_IMAGE:
			{
				var i uintptr = cmd
				Xnk_draw_list_add_image((ctx + 7332 /* &.draw_list */), (*Nk_command_image)(unsafe.Pointer(i)).Img, Xnk_rect(float32((*Nk_command_image)(unsafe.Pointer(i)).X), float32((*Nk_command_image)(unsafe.Pointer(i)).Y), float32((*Nk_command_image)(unsafe.Pointer(i)).W), float32((*Nk_command_image)(unsafe.Pointer(i)).H)), (*Nk_command_image)(unsafe.Pointer(i)).Col)

			}
			break
		case NK_COMMAND_CUSTOM:
			{
				var c uintptr = cmd
				(*(*func(uintptr, int16, int16, uint16, uint16, Nk_handle))(unsafe.Pointer((c + 20 /* &.callback */))))((ctx + 7332 /* &.draw_list */), (*Nk_command_custom)(unsafe.Pointer(c)).X, (*Nk_command_custom)(unsafe.Pointer(c)).Y, (*Nk_command_custom)(unsafe.Pointer(c)).W, (*Nk_command_custom)(unsafe.Pointer(c)).H, (*Nk_command_custom)(unsafe.Pointer(c)).Callback_data)

			}
			break
		default:
			break
		}
	}
	res = res | (func() uint32 {
		if (*Nk_buffer)(unsafe.Pointer(cmds)).Needed > ((*Nk_buffer)(unsafe.Pointer(cmds)).Allocated + ((*Nk_buffer)(unsafe.Pointer(cmds)).Memory.Size - (*Nk_buffer)(unsafe.Pointer(cmds)).Size)) {
			return NK_CONVERT_COMMAND_BUFFER_FULL
		}
		return uint32(0)
	}())
	res = res | (func() uint32 {
		if (*Nk_buffer)(unsafe.Pointer(vertices)).Needed > (*Nk_buffer)(unsafe.Pointer(vertices)).Allocated {
			return NK_CONVERT_VERTEX_BUFFER_FULL
		}
		return uint32(0)
	}())
	res = res | (func() uint32 {
		if (*Nk_buffer)(unsafe.Pointer(elements)).Needed > (*Nk_buffer)(unsafe.Pointer(elements)).Allocated {
			return NK_CONVERT_ELEMENT_BUFFER_FULL
		}
		return uint32(0)
	}())
	return res
}

var __func__104 = *(*[11]int8)(unsafe.Pointer(ts + 2837 /* "nk_convert" */)) /* nuklear.h:10452:1 */

func Xnk__draw_begin(ctx uintptr, buffer uintptr) uintptr { /* nuklear.h:10590:36: */
	return Xnk__draw_list_begin((ctx + 7332 /* &.draw_list */), buffer)
}

func Xnk__draw_end(ctx uintptr, buffer uintptr) uintptr { /* nuklear.h:10596:36: */
	return Xnk__draw_list_end((ctx + 7332 /* &.draw_list */), buffer)
}

func Xnk__draw_next(cmd uintptr, buffer uintptr, ctx uintptr) uintptr { /* nuklear.h:10601:36: */
	return Xnk__draw_list_next(cmd, buffer, (ctx + 7332 /* &.draw_list */))
}

//  stb_rect_pack.h - v1.00 - public domain - rectangle packing
//  Sean Barrett 2014
//
//  Useful for e.g. packing rectangular textures into an atlas.
//  Does not do rotation.
//
//  Not necessarily the awesomest packing method, but better than
//  the totally naive one in stb_truetype (which is primarily what
//  this is meant to replace).
//
//  Has only had a few tests run, may have issues.
//
//  More docs to come.
//
//  No memory allocations; uses qsort() and assert() from stdlib.
//  Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
//  This library currently uses the Skyline Bottom-Left algorithm.
//
//  Please note: better rectangle packers are welcome! Please
//  implement them to the same API, but with a different init
//  function.
//
//  Credits
//
//   Library
//     Sean Barrett
//   Minor features
//     Martins Mozeiko
//     github:IntellectualKitty
//
//   Bugfixes / warning fixes
//     Jeremy Jaussaud
//     Fabian Giesen
//
//  Version history:
//
//      1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//      0.99  (2019-02-07)  warning fixes
//      0.11  (2017-03-03)  return packing success/fail result
//      0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//      0.09  (2016-08-27)  fix compiler warnings
//      0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//      0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//      0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//      0.05:  added STBRP_ASSERT to allow replacing assert
//      0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//      0.01:  initial release
//
//  LICENSE
//
//    See end of file for license information.

// ////////////////////////////////////////////////////////////////////////////
//
//        INCLUDE SECTION
//

type Stbrp_context1 = struct {
	Width       int32
	Height      int32
	Align       int32
	Init_mode   int32
	Heuristic   int32
	Num_nodes   int32
	Active_head uintptr
	Free_head   uintptr
	Extra       [2]Stbrp_node
} /* nuklear.h:10683:9 */

//  stb_rect_pack.h - v1.00 - public domain - rectangle packing
//  Sean Barrett 2014
//
//  Useful for e.g. packing rectangular textures into an atlas.
//  Does not do rotation.
//
//  Not necessarily the awesomest packing method, but better than
//  the totally naive one in stb_truetype (which is primarily what
//  this is meant to replace).
//
//  Has only had a few tests run, may have issues.
//
//  More docs to come.
//
//  No memory allocations; uses qsort() and assert() from stdlib.
//  Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
//  This library currently uses the Skyline Bottom-Left algorithm.
//
//  Please note: better rectangle packers are welcome! Please
//  implement them to the same API, but with a different init
//  function.
//
//  Credits
//
//   Library
//     Sean Barrett
//   Minor features
//     Martins Mozeiko
//     github:IntellectualKitty
//
//   Bugfixes / warning fixes
//     Jeremy Jaussaud
//     Fabian Giesen
//
//  Version history:
//
//      1.00  (2019-02-25)  avoid small space waste; gracefully fail too-wide rectangles
//      0.99  (2019-02-07)  warning fixes
//      0.11  (2017-03-03)  return packing success/fail result
//      0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//      0.09  (2016-08-27)  fix compiler warnings
//      0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//      0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//      0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//      0.05:  added STBRP_ASSERT to allow replacing assert
//      0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//      0.01:  initial release
//
//  LICENSE
//
//    See end of file for license information.

// ////////////////////////////////////////////////////////////////////////////
//
//        INCLUDE SECTION
//

type Stbrp_context = Stbrp_context1 /* nuklear.h:10683:30 */
type Stbrp_node1 = struct {
	X    Stbrp_coord
	Y    Stbrp_coord
	Next uintptr
} /* nuklear.h:10683:9 */

type Stbrp_node = Stbrp_node1 /* nuklear.h:10684:30 */
type Stbrp_rect1 = struct {
	Id         int32
	W          Stbrp_coord
	H          Stbrp_coord
	X          Stbrp_coord
	Y          Stbrp_coord
	Was_packed int32
} /* nuklear.h:10685:9 */

type Stbrp_rect = Stbrp_rect1 /* nuklear.h:10685:30 */

type Stbrp_coord = uint16 /* nuklear.h:10690:24 */

func Xstbrp_setup_heuristic(context uintptr, heuristic int32) { /* nuklear.h:10830:16: */
	switch (*Stbrp_context)(unsafe.Pointer(context)).Init_mode {
	case STBRP__INIT_skyline:
		if (heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) || (heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
		} else {
			X__assert_fail(ts+2848 /* "heuristic == STB..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10834), uintptr(unsafe.Pointer(&__func__105)))
		}
		(*Stbrp_context)(unsafe.Pointer(context)).Heuristic = heuristic
		break
	default:
		if 0 != 0 {
		} else {
			X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(10838), uintptr(unsafe.Pointer(&__func__105)))
		}
	}
}

var __func__105 = *(*[22]int8)(unsafe.Pointer(ts + 2955 /* "stbrp_setup_heur..." */)) /* nuklear.h:10831:1 */

func Xstbrp_setup_allow_out_of_mem(context uintptr, allow_out_of_mem int32) { /* nuklear.h:10842:16: */
	if allow_out_of_mem != 0 {
		//  if it's ok to run out of memory, then don't bother aligning them;
		//  this gives better packing, but may fail due to OOM (even though
		//  the rectangles easily fit). @TODO a smarter approach would be to only
		//  quantize once we've hit OOM, then we could get rid of this parameter.
		(*Stbrp_context)(unsafe.Pointer(context)).Align = 1
	} else {
		//  if it's not ok to run out of memory, then quantize the widths
		//  so that num_nodes is always enough nodes.
		//
		//  I.e. num_nodes * align >= width
		//                   align >= width / num_nodes
		//                   align = ceil(width/num_nodes)

		(*Stbrp_context)(unsafe.Pointer(context)).Align = ((((*Stbrp_context)(unsafe.Pointer(context)).Width + (*Stbrp_context)(unsafe.Pointer(context)).Num_nodes) - 1) / (*Stbrp_context)(unsafe.Pointer(context)).Num_nodes)
	}
}

func Xstbrp_init_target(context uintptr, width int32, height int32, nodes uintptr, num_nodes int32) { /* nuklear.h:10862:16: */
	var i int32
	if (width <= 0xffff) && (height <= 0xffff) {
	} else {
		X__assert_fail(ts+2977 /* "width <= 0xffff ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10866), uintptr(unsafe.Pointer(&__func__106)))
	}

	for i = 0; i < (num_nodes - 1); i++ {
		(*Stbrp_node)(unsafe.Pointer(nodes + uintptr(i)*8)).Next = (nodes + uintptr((i+1))*8)
	}
	(*Stbrp_node)(unsafe.Pointer(nodes + uintptr(i)*8)).Next = uintptr(0)
	(*Stbrp_context)(unsafe.Pointer(context)).Init_mode = STBRP__INIT_skyline
	(*Stbrp_context)(unsafe.Pointer(context)).Heuristic = STBRP_HEURISTIC_Skyline_default
	(*Stbrp_context)(unsafe.Pointer(context)).Free_head = (nodes)
	(*Stbrp_context)(unsafe.Pointer(context)).Active_head = (context + 32 /* &.extra */)
	(*Stbrp_context)(unsafe.Pointer(context)).Width = width
	(*Stbrp_context)(unsafe.Pointer(context)).Height = height
	(*Stbrp_context)(unsafe.Pointer(context)).Num_nodes = num_nodes
	Xstbrp_setup_allow_out_of_mem(context, 0)

	//  node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */))).X = Stbrp_coord(0)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */))).Y = Stbrp_coord(0)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */))).Next = ((context + 32 /* &.extra */) + 1*8)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */) + 1*8)).X = Stbrp_coord(width)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */) + 1*8)).Y = Stbrp_coord(65535)
	(*Stbrp_node)(unsafe.Pointer((context + 32 /* &.extra */) + 1*8)).Next = uintptr(0)
}

var __func__106 = *(*[18]int8)(unsafe.Pointer(ts + 3013 /* "stbrp_init_targe..." */)) /* nuklear.h:10863:1 */

//  find minimum y position if it starts at x1
func stbrp__skyline_find_min_y(c uintptr, first uintptr, x0 int32, width int32, pwaste uintptr) int32 { /* nuklear.h:10895:12: */
	var node uintptr = first
	var x1 int32 = (x0 + width)
	var min_y int32
	var visited_width int32
	var waste_area int32

	if int32((*Stbrp_node)(unsafe.Pointer(first)).X) <= x0 {
	} else {
		X__assert_fail(ts+3031 /* "first->x <= x0" */, ts+2 /* "nuklear/nuklear...." */, uint32(10903), uintptr(unsafe.Pointer(&__func__107)))
	}

	if int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) > x0 {
	} else {
		X__assert_fail(ts+3046 /* "node->next->x > ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10910), uintptr(unsafe.Pointer(&__func__107)))
	} //  we ended up handling this in the caller for efficiency

	if int32((*Stbrp_node)(unsafe.Pointer(node)).X) <= x0 {
	} else {
		X__assert_fail(ts+3065 /* "node->x <= x0" */, ts+2 /* "nuklear/nuklear...." */, uint32(10913), uintptr(unsafe.Pointer(&__func__107)))
	}

	min_y = 0
	waste_area = 0
	visited_width = 0
	for int32((*Stbrp_node)(unsafe.Pointer(node)).X) < x1 {
		if int32((*Stbrp_node)(unsafe.Pointer(node)).Y) > min_y {
			//  raise min_y higher.
			//  we've accounted for all waste up to min_y,
			//  but we'll now add more waste for everything we've visted
			waste_area = waste_area + (visited_width * (int32((*Stbrp_node)(unsafe.Pointer(node)).Y) - min_y))
			min_y = int32((*Stbrp_node)(unsafe.Pointer(node)).Y)
			//  the first time through, visited_width might be reduced
			if int32((*Stbrp_node)(unsafe.Pointer(node)).X) < x0 {
				visited_width = visited_width + (int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) - x0)
			} else {
				visited_width = visited_width + (int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) - int32((*Stbrp_node)(unsafe.Pointer(node)).X))
			}
		} else {
			//  add waste area
			var under_width int32 = (int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) - int32((*Stbrp_node)(unsafe.Pointer(node)).X))
			if (under_width + visited_width) > width {
				under_width = (width - visited_width)
			}
			waste_area = waste_area + (under_width * (min_y - int32((*Stbrp_node)(unsafe.Pointer(node)).Y)))
			visited_width = visited_width + (under_width)
		}
		node = (*Stbrp_node)(unsafe.Pointer(node)).Next
	}

	*(*int32)(unsafe.Pointer(pwaste)) = waste_area
	return min_y
}

var __func__107 = *(*[26]int8)(unsafe.Pointer(ts + 3079 /* "stbrp__skyline_f..." */)) /* nuklear.h:10896:1 */

type Stbrp__findresult = struct {
	X         int32
	Y         int32
	Prev_link uintptr
} /* nuklear.h:10949:3 */

func stbrp__skyline_find_best_pos(c uintptr, width int32, height int32) Stbrp__findresult { /* nuklear.h:10951:26: */
	bp := tlsAlloc(20)
	defer tlsFree(20)

	var best_waste int32 = (int32(1) << 30)
	var best_x int32
	var best_y int32 = (int32(1) << 30)
	// var fr Stbrp__findresult at bp, 12

	var prev uintptr
	var node uintptr
	var tail uintptr
	var best uintptr = uintptr(0)

	//  align to multiple of c->align
	width = ((width + (*Stbrp_context)(unsafe.Pointer(c)).Align) - 1)
	width = width - (width % (*Stbrp_context)(unsafe.Pointer(c)).Align)
	if (width % (*Stbrp_context)(unsafe.Pointer(c)).Align) == 0 {
	} else {
		X__assert_fail(ts+3105 /* "width % c->align..." */, ts+2 /* "nuklear/nuklear...." */, uint32(10960), uintptr(unsafe.Pointer(&__func__108)))
	}

	//  if it can't possibly fit, bail immediately
	if (width > (*Stbrp_context)(unsafe.Pointer(c)).Width) || (height > (*Stbrp_context)(unsafe.Pointer(c)).Height) {
		(*Stbrp__findresult)(unsafe.Pointer(bp /* &fr */)).Prev_link = uintptr(0)
		(*Stbrp__findresult)(unsafe.Pointer(bp /* &fr */)).X = AssignPtrInt32(bp /* &fr */ +4 /* &.y */, 0)
		return *(*Stbrp__findresult)(unsafe.Pointer(bp /* fr */))
	}

	node = (*Stbrp_context)(unsafe.Pointer(c)).Active_head
	prev = (c + 24 /* &.active_head */)
	for (int32((*Stbrp_node)(unsafe.Pointer(node)).X) + width) <= (*Stbrp_context)(unsafe.Pointer(c)).Width {
		var y int32
		// var waste int32 at bp+12, 4

		y = stbrp__skyline_find_min_y(c, node, int32((*Stbrp_node)(unsafe.Pointer(node)).X), width, bp+12 /* &waste */)
		if (*Stbrp_context)(unsafe.Pointer(c)).Heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight { //  actually just want to test BL
			//  bottom left
			if y < best_y {
				best_y = y
				best = prev
			}
		} else {
			//  best-fit
			if (y + height) <= (*Stbrp_context)(unsafe.Pointer(c)).Height {
				//  can only use it if it first vertically
				if (y < best_y) || ((y == best_y) && (*(*int32)(unsafe.Pointer(bp + 12 /* waste */)) < best_waste)) {
					best_y = y
					best_waste = *(*int32)(unsafe.Pointer(bp + 12 /* waste */))
					best = prev
				}
			}
		}
		prev = (node + 4 /* &.next */)
		node = (*Stbrp_node)(unsafe.Pointer(node)).Next
	}

	if best == (uintptr(0)) {
		best_x = 0
	} else {
		best_x = int32((*Stbrp_node)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(best)))).X)
	}

	//  if doing best-fit (BF), we also have to try aligning right edge to each node position
	//
	//  e.g, if fitting
	//
	//      ____________________
	//     |____________________|
	//
	//             into
	//
	//    |                         |
	//    |             ____________|
	//    |____________|
	//
	//  then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
	//
	//  This makes BF take about 2x the time

	if (*Stbrp_context)(unsafe.Pointer(c)).Heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight {
		tail = (*Stbrp_context)(unsafe.Pointer(c)).Active_head
		node = (*Stbrp_context)(unsafe.Pointer(c)).Active_head
		prev = (c + 24 /* &.active_head */)
		//  find first node that's admissible
		for int32((*Stbrp_node)(unsafe.Pointer(tail)).X) < width {
			tail = (*Stbrp_node)(unsafe.Pointer(tail)).Next
		}
		for tail != 0 {
			var xpos int32 = (int32((*Stbrp_node)(unsafe.Pointer(tail)).X) - width)
			var y int32
			// var waste int32 at bp+16, 4

			if xpos >= 0 {
			} else {
				X__assert_fail(ts+3127 /* "xpos >= 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(11024), uintptr(unsafe.Pointer(&__func__108)))
			}
			//  find the left position that matches this
			for int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) <= xpos {
				prev = (node + 4 /* &.next */)
				node = (*Stbrp_node)(unsafe.Pointer(node)).Next
			}
			if (int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(node)).Next)).X) > xpos) && (int32((*Stbrp_node)(unsafe.Pointer(node)).X) <= xpos) {
			} else {
				X__assert_fail(ts+3137 /* "node->next->x > ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(11030), uintptr(unsafe.Pointer(&__func__108)))
			}
			y = stbrp__skyline_find_min_y(c, node, xpos, width, bp+16 /* &waste */)
			if (y + height) <= (*Stbrp_context)(unsafe.Pointer(c)).Height {
				if y <= best_y {
					if ((y < best_y) || (*(*int32)(unsafe.Pointer(bp + 16 /* waste */)) < best_waste)) || ((*(*int32)(unsafe.Pointer(bp + 16 /* waste */)) == best_waste) && (xpos < best_x)) {
						best_x = xpos
						if y <= best_y {
						} else {
							X__assert_fail(ts+3177 /* "y <= best_y" */, ts+2 /* "nuklear/nuklear...." */, uint32(11036), uintptr(unsafe.Pointer(&__func__108)))
						}
						best_y = y
						best_waste = *(*int32)(unsafe.Pointer(bp + 16 /* waste */))
						best = prev
					}
				}
			}
			tail = (*Stbrp_node)(unsafe.Pointer(tail)).Next
		}
	}

	(*Stbrp__findresult)(unsafe.Pointer(bp /* &fr */)).Prev_link = best
	(*Stbrp__findresult)(unsafe.Pointer(bp /* &fr */)).X = best_x
	(*Stbrp__findresult)(unsafe.Pointer(bp /* &fr */)).Y = best_y
	return *(*Stbrp__findresult)(unsafe.Pointer(bp /* fr */))
}

var __func__108 = *(*[29]int8)(unsafe.Pointer(ts + 3189 /* "stbrp__skyline_f..." */)) /* nuklear.h:10952:1 */

func stbrp__skyline_pack_rectangle(context uintptr, width int32, height int32) Stbrp__findresult { /* nuklear.h:11053:26: */
	//  find best position according to heuristic
	var res = stbrp__skyline_find_best_pos(context, width, height)
	var node uintptr
	var cur uintptr

	//  bail if:
	//     1. it failed
	//     2. the best node doesn't fit (we don't always check this)
	//     3. we're out of memory
	if ((res.Prev_link == (uintptr(0))) || ((res.Y + height) > (*Stbrp_context)(unsafe.Pointer(context)).Height)) || ((*Stbrp_context)(unsafe.Pointer(context)).Free_head == (uintptr(0))) {
		res.Prev_link = uintptr(0)
		return res
	}

	//  on success, create new node
	node = (*Stbrp_context)(unsafe.Pointer(context)).Free_head
	(*Stbrp_node)(unsafe.Pointer(node)).X = Stbrp_coord(res.X)
	(*Stbrp_node)(unsafe.Pointer(node)).Y = (Stbrp_coord(res.Y + height))

	(*Stbrp_context)(unsafe.Pointer(context)).Free_head = (*Stbrp_node)(unsafe.Pointer(node)).Next

	//  insert the new node into the right starting point, and
	//  let 'cur' point to the remaining nodes needing to be
	//  stiched back in

	cur = *(*uintptr)(unsafe.Pointer(res.Prev_link))
	if int32((*Stbrp_node)(unsafe.Pointer(cur)).X) < res.X {
		//  preserve the existing one, so start testing with the next one
		var next uintptr = (*Stbrp_node)(unsafe.Pointer(cur)).Next
		(*Stbrp_node)(unsafe.Pointer(cur)).Next = node
		cur = next
	} else {
		*(*uintptr)(unsafe.Pointer(res.Prev_link)) = node
	}

	//  from here, traverse cur and free the nodes, until we get to one
	//  that shouldn't be freed
	for ((*Stbrp_node)(unsafe.Pointer(cur)).Next != 0) && (int32((*Stbrp_node)(unsafe.Pointer((*Stbrp_node)(unsafe.Pointer(cur)).Next)).X) <= (res.X + width)) {
		var next uintptr = (*Stbrp_node)(unsafe.Pointer(cur)).Next
		//  move the current node to the free list
		(*Stbrp_node)(unsafe.Pointer(cur)).Next = (*Stbrp_context)(unsafe.Pointer(context)).Free_head
		(*Stbrp_context)(unsafe.Pointer(context)).Free_head = cur
		cur = next
	}

	//  stitch the list back in
	(*Stbrp_node)(unsafe.Pointer(node)).Next = cur

	if int32((*Stbrp_node)(unsafe.Pointer(cur)).X) < (res.X + width) {
		(*Stbrp_node)(unsafe.Pointer(cur)).X = (Stbrp_coord(res.X + width))
	}

	return res
}

func rect_height_compare(a uintptr, b uintptr) int32 { /* nuklear.h:11132:12: */
	var p uintptr = a
	var q uintptr = b
	if int32((*Stbrp_rect)(unsafe.Pointer(p)).H) > int32((*Stbrp_rect)(unsafe.Pointer(q)).H) {
		return -1
	}
	if int32((*Stbrp_rect)(unsafe.Pointer(p)).H) < int32((*Stbrp_rect)(unsafe.Pointer(q)).H) {
		return 1
	}
	if int32((*Stbrp_rect)(unsafe.Pointer(p)).W) > int32((*Stbrp_rect)(unsafe.Pointer(q)).W) {
		return -1
	}
	return (Bool32(int32((*Stbrp_rect)(unsafe.Pointer(p)).W) < int32((*Stbrp_rect)(unsafe.Pointer(q)).W)))
}

func rect_original_order(a uintptr, b uintptr) int32 { /* nuklear.h:11143:12: */
	var p uintptr = a
	var q uintptr = b
	if (*Stbrp_rect)(unsafe.Pointer(p)).Was_packed < (*Stbrp_rect)(unsafe.Pointer(q)).Was_packed {
		return -1
	}
	return (Bool32((*Stbrp_rect)(unsafe.Pointer(p)).Was_packed > (*Stbrp_rect)(unsafe.Pointer(q)).Was_packed))
}

func Xstbrp_pack_rects(context uintptr, rects uintptr, num_rects int32) int32 { /* nuklear.h:11156:15: */
	var i int32
	var all_rects_packed int32 = 1

	//  we use the 'was_packed' field internally to allow sorting/unsorting
	for i = 0; i < num_rects; i++ {
		(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).Was_packed = i
	}

	//  sort according to heuristic
	Xqsort(rects, uint32(num_rects), uint32(unsafe.Sizeof(Stbrp_rect{})), *(*uintptr)(unsafe.Pointer(&struct{ f func(uintptr, uintptr) int32 }{rect_height_compare})))

	for i = 0; i < num_rects; i++ {
		if (int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).W) == 0) || (int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).H) == 0) {
			(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).X = AssignPtrUint16(rects+uintptr(i)*16+10 /* &.y */, Stbrp_coord(0)) //  empty rect needs no space
		} else {
			var fr = stbrp__skyline_pack_rectangle(context, int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).W), int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).H))
			if fr.Prev_link != 0 {
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).X = Stbrp_coord(fr.X)
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).Y = Stbrp_coord(fr.Y)
			} else {
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).X = AssignPtrUint16(rects+uintptr(i)*16+10 /* &.y */, Stbrp_coord(STBRP__MAXVAL))
			}
		}
	}

	//  unsort
	Xqsort(rects, uint32(num_rects), uint32(unsafe.Sizeof(Stbrp_rect{})), *(*uintptr)(unsafe.Pointer(&struct{ f func(uintptr, uintptr) int32 }{rect_original_order})))

	//  set was_packed flags and all_rects_packed status
	for i = 0; i < num_rects; i++ {
		(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(i)*16)).Was_packed = BoolInt32(!((int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).X) == STBRP__MAXVAL) && (int32((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).Y) == STBRP__MAXVAL)))
		if !((*Stbrp_rect)(unsafe.Pointer(rects+uintptr(i)*16)).Was_packed != 0) {
			all_rects_packed = 0
		}
	}

	//  return the all_rects_packed status
	return all_rects_packed
}

//
// ------------------------------------------------------------------------------
// This software is available under 2 licenses -- choose whichever you prefer.
// ------------------------------------------------------------------------------
// ALTERNATIVE A - MIT License
// Copyright (c) 2017 Sean Barrett
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ------------------------------------------------------------------------------
// ALTERNATIVE B - Public Domain (www.unlicense.org)
// This is free and unencumbered software released into the public domain.
// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
// software, either in source code form or as a compiled binary, for any purpose,
// commercial or non-commercial, and by any means.
// In jurisdictions that recognize copyright laws, the author or authors of this
// software dedicate any and all copyright interest in the software to the public
// domain. We make this dedication for the benefit of the public at large and to
// the detriment of our heirs and successors. We intend this dedication to be an
// overt act of relinquishment in perpetuity of all present and future rights to
// this software under copyright law.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ------------------------------------------------------------------------------

//  stb_truetype.h - v1.24 - public domain
//  authored from 2009-2020 by Sean Barrett / RAD Game Tools
//
//  =======================================================================
//
//     NO SECURITY GUARANTEE -- DO NOT USE THIS ON UNTRUSTED FONT FILES
//
//  This library does no range checking of the offsets found in the file,
//  meaning an attacker can use it to read arbitrary memory.
//
//  =======================================================================
//
//    This library processes TrueType files:
//         parse files
//         extract glyph metrics
//         extract glyph shapes
//         render glyphs to one-channel bitmaps with antialiasing (box filter)
//         render glyphs to one-channel SDF bitmaps (signed-distance field/function)
//
//    Todo:
//         non-MS cmaps
//         crashproof on bad data
//         hinting? (no longer patented)
//         cleartype-style AA?
//         optimize: use simple memory allocator for intermediates
//         optimize: build edge-list directly from curves
//         optimize: rasterize directly from curves?
//
//  ADDITIONAL CONTRIBUTORS
//
//    Mikko Mononen: compound shape support, more cmap formats
//    Tor Andersson: kerning, subpixel rendering
//    Dougall Johnson: OpenType / Type 2 font handling
//    Daniel Ribeiro Maciel: basic GPOS-based kerning
//
//    Misc other:
//        Ryan Gordon
//        Simon Glass
//        github:IntellectualKitty
//        Imanol Celaya
//        Daniel Ribeiro Maciel
//
//    Bug/warning reports/fixes:
//        "Zer" on mollyrocket       Fabian "ryg" Giesen   github:NiLuJe
//        Cass Everitt               Martins Mozeiko       github:aloucks
//        stoiko (Haemimont Games)   Cap Petschulat        github:oyvindjam
//        Brian Hook                 Omar Cornut           github:vassvik
//        Walter van Niftrik         Ryan Griege
//        David Gow                  Peter LaValle
//        David Given                Sergey Popov
//        Ivan-Assen Ivanov          Giumo X. Clanjor
//        Anthony Pesch              Higor Euripedes
//        Johan Duparc               Thomas Fields
//        Hou Qiming                 Derek Vinyard
//        Rob Loach                  Cort Stratton
//        Kenney Phillis Jr.         Brian Costabile
//        Ken Voskuil (kaesve)
//
//  VERSION HISTORY
//
//    1.24 (2020-02-05) fix warning
//    1.23 (2020-02-02) query SVG data for glyphs; query whole kerning table (but only kern not GPOS)
//    1.22 (2019-08-11) minimize missing-glyph duplication; fix kerning if both 'GPOS' and 'kern' are defined
//    1.21 (2019-02-25) fix warning
//    1.20 (2019-02-07) PackFontRange skips missing codepoints; GetScaleFontVMetrics()
//    1.19 (2018-02-11) GPOS kerning, STBTT_fmod
//    1.18 (2018-01-29) add missing function
//    1.17 (2017-07-23) make more arguments const; doc fix
//    1.16 (2017-07-12) SDF support
//    1.15 (2017-03-03) make more arguments const
//    1.14 (2017-01-16) num-fonts-in-TTC function
//    1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//    1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//    1.11 (2016-04-02) fix unused-variable warning
//    1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//    1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//    1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//    1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                      variant PackFontRanges to pack and render in separate phases;
//                      fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                      fixed an assert() bug in the new rasterizer
//                      replace assert() with STBTT_assert() in new rasterizer
//
//    Full history can be found at the end of this file.
//
//  LICENSE
//
//    See end of file for license information.
//
//  USAGE
//
//    Include this file in whatever places need to refer to it. In ONE C/C++
//    file, write:
//       #define STB_TRUETYPE_IMPLEMENTATION
//    before the #include of this file. This expands out the actual
//    implementation into that C/C++ file.
//
//    To make the implementation private to the file that generates the implementation,
//       #define STBTT_STATIC
//
//    Simple 3D API (don't ship this, but it's fine for tools and quick start)
//            stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//            stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//    Improved 3D API (more shippable):
//            #include "stb_rect_pack.h"           -- optional, but you really want it
//            stbtt_PackBegin()
//            stbtt_PackSetOversampling()          -- for improved quality on small fonts
//            stbtt_PackFontRanges()               -- pack and renders
//            stbtt_PackEnd()
//            stbtt_GetPackedQuad()
//
//    "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//            stbtt_InitFont()
//            stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//            stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//    Render a unicode codepoint to a bitmap
//            stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//            stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//            stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//    Character advance/positioning
//            stbtt_GetCodepointHMetrics()
//            stbtt_GetFontVMetrics()
//            stbtt_GetFontVMetricsOS2()
//            stbtt_GetCodepointKernAdvance()
//
//    Starting with version 1.06, the rasterizer was replaced with a new,
//    faster and generally-more-precise rasterizer. The new rasterizer more
//    accurately measures pixel coverage for anti-aliasing, except in the case
//    where multiple shapes overlap, in which case it overestimates the AA pixel
//    coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//    this turns out to be a problem, you can re-enable the old rasterizer with
//         #define STBTT_RASTERIZER_VERSION 1
//    which will incur about a 15% speed hit.
//
//  ADDITIONAL DOCUMENTATION
//
//    Immediately after this block comment are a series of sample programs.
//
//    After the sample programs is the "header file" section. This section
//    includes documentation for each API function.
//
//    Some important concepts to understand to use this library:
//
//       Codepoint
//          Characters are defined by unicode codepoints, e.g. 65 is
//          uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//          the hiragana for "ma".
//
//       Glyph
//          A visual character shape (every codepoint is rendered as
//          some glyph)
//
//       Glyph index
//          A font-specific integer ID representing a glyph
//
//       Baseline
//          Glyph shapes are defined relative to a baseline, which is the
//          bottom of uppercase characters. Characters extend both above
//          and below the baseline.
//
//       Current Point
//          As you draw text to the screen, you keep track of a "current point"
//          which is the origin of each character. The current point's vertical
//          position is the baseline. Even "baked fonts" use this model.
//
//       Vertical Font Metrics
//          The vertical qualities of the font, used to vertically position
//          and space the characters. See docs for stbtt_GetFontVMetrics.
//
//       Font Size in Pixels or Points
//          The preferred interface for specifying font sizes in stb_truetype
//          is to specify how tall the font's vertical extent should be in pixels.
//          If that sounds good enough, skip the next paragraph.
//
//          Most font APIs instead use "points", which are a common typographic
//          measurement for describing font size, defined as 72 points per inch.
//          stb_truetype provides a point API for compatibility. However, true
//          "per inch" conventions don't make much sense on computer displays
//          since different monitors have different number of pixels per
//          inch. For example, Windows traditionally uses a convention that
//          there are 96 pixels per inch, thus making 'inch' measurements have
//          nothing to do with inches, and thus effectively defining a point to
//          be 1.333 pixels. Additionally, the TrueType font data provides
//          an explicit scale factor to scale a given font's glyphs to points,
//          but the author has observed that this scale factor is often wrong
//          for non-commercial fonts, thus making fonts scaled in points
//          according to the TrueType spec incoherently sized in practice.
//
//  DETAILED USAGE:
//
//   Scale:
//     Select how high you want the font to be, in points or pixels.
//     Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute
//     a scale factor SF that will be used by all other functions.
//
//   Baseline:
//     You need to select a y-coordinate that is the baseline of where
//     your text will appear. Call GetFontBoundingBox to get the baseline-relative
//     bounding box for all characters. SF*-y0 will be the distance in pixels
//     that the worst-case character could extend above the baseline, so if
//     you want the top edge of characters to appear at the top of the
//     screen where y=0, then you would set the baseline to SF*-y0.
//
//   Current point:
//     Set the current point where the first character will appear. The
//     first character could extend left of the current point; this is font
//     dependent. You can either choose a current point that is the leftmost
//     point and hope, or add some padding, or check the bounding box or
//     left-side-bearing of the first character to be displayed and set
//     the current point based on that.
//
//   Displaying a character:
//     Compute the bounding box of the character. It will contain signed values
//     relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1,
//     then the character should be displayed in the rectangle from
//     <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1).
//
//   Advancing for the next character:
//     Call GlyphHMetrics, and compute 'current_point += SF * advance'.
//
//
//  ADVANCED USAGE
//
//    Quality:
//
//     - Use the functions with Subpixel at the end to allow your characters
//       to have subpixel positioning. Since the font is anti-aliased, not
//       hinted, this is very import for quality. (This is not possible with
//       baked fonts.)
//
//     - Kerning is now supported, and if you're supporting subpixel rendering
//       then kerning is worth using to give your text a polished look.
//
//    Performance:
//
//     - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//       if you don't do this, stb_truetype is forced to do the conversion on
//       every call.
//
//     - There are a lot of memory allocations. We should modify it to take
//       a temp buffer and allocate from the temp buffer (without freeing),
//       should help performance a lot.
//
//  NOTES
//
//    The system uses the raw data found in the .ttf file without changing it
//    and without building auxiliary data structures. This is a bit inefficient
//    on little-endian systems (the data is big-endian), but assuming you're
//    caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//    It appears to be very hard to programmatically determine what font a
//    given file is in a general way. I provide an API for this, but I don't
//    recommend it.
//
//
//  PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                       32-bit     64-bit
//    Previous release:  8.83 s     7.68 s
//    Pool allocations:  7.72 s     6.34 s
//    Inline sort     :  6.54 s     5.65 s
//    New rasterizer  :  5.63 s     5.00 s

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// //
// //  SAMPLE PROGRAMS
// //
//
//   Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
//
//
// ////////////////////////////////////////////////////////////////////////////
//
//  Complete program (this compiles): get a single bitmap, print as ASCII art
//
//
//  Output:
//
//      .ii.
//     @@@@@@.
//    V@Mio@@o
//    :i.  V@V
//      :oM@@M
//    :@@@MM@M
//    @@o  o@M
//   :@@.  M@M
//    @@@o@@@@
//    :M@@V:@@.
//
// ////////////////////////////////////////////////////////////////////////////
//
//  Complete program: print "Hello World!" banner, with bugs
//

// ////////////////////////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////
// //
// //   INTEGRATION WITH YOUR CODEBASE
// //
// //   The following sections allow you to supply alternate definitions
// //   of C library functions used by stb_truetype, e.g. if you don't
// //   link with the C runtime library.

//  #define your own (u)stbtt_int8/16/32 before including to override this
type Stbtt_uint8 = uint8   /* nuklear.h:11662:28 */
type Stbtt_int8 = int8     /* nuklear.h:11663:28 */
type Stbtt_uint16 = uint16 /* nuklear.h:11664:28 */
type Stbtt_int16 = int16   /* nuklear.h:11665:28 */
type Stbtt_uint32 = uint32 /* nuklear.h:11666:28 */
type Stbtt_int32 = int32   /* nuklear.h:11667:28 */

type Stbtt__check_size32 = [1]int8 /* nuklear.h:11670:17 */
type Stbtt__check_size16 = [1]int8 /* nuklear.h:11671:17 */

//  e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h
// Declarations for math functions.
//    Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X; the symbols in Annex F
//    still require that macro in C2X.

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//    Copyright (C) 2016-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//     float_t	floating-point type at least as wide as `float' used
// 		to evaluate `float' expressions
//     double_t	floating-point type at least as wide as `double' used
// 		to evaluate `double' expressions
type Float_t = float32  /* math.h:149:15 */
type Double_t = float64 /* math.h:150:16 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type X__locale_struct = struct {
	X__locales       [13]uintptr
	X__ctype_b       uintptr
	X__ctype_tolower uintptr
	X__ctype_toupper uintptr
	X__names         [13]uintptr
} /* __locale_t.h:28:1 */

type X__locale_t = uintptr /* __locale_t.h:42:32 */

type Locale_t = X__locale_t /* locale_t.h:24:20 */

// Copyright (C) 1991-2020 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.21 String handling	<string.h>

// /////////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////////
// //
// //   INTERFACE
// //
// //

//  private structure
type Stbtt__buf = struct {
	Data   uintptr
	Cursor int32
	Size   int32
} /* nuklear.h:11752:3 */

// ////////////////////////////////////////////////////////////////////////////
//
//  TEXTURE BAKING API
//
//  If you use this API, you only have to call two functions ever.
//

type Stbtt_bakedchar = struct {
	X0       uint16
	Y0       uint16
	X1       uint16
	Y1       uint16
	Xoff     float32
	Yoff     float32
	Xadvance float32
} /* nuklear.h:11765:3 */ //  you allocate this, it's num_chars long
//  if return is positive, the first unused row of the bitmap
//  if return is negative, returns the negative of the number of characters that fit
//  if return is 0, no characters fit and no rows were used
//  This uses a very crappy packing.

type Stbtt_aligned_quad = struct {
	X0 float32
	Y0 float32
	S0 float32
	T0 float32
	X1 float32
	Y1 float32
	S1 float32
	T1 float32
} /* nuklear.h:11781:3 */
//  Query the font vertical metrics without having to create a font first.

// ////////////////////////////////////////////////////////////////////////////
//
//  NEW TEXTURE BAKING API
//
//  This provides options for packing multiple fonts into one atlas, not
//  perfectly but better than nothing.

type Stbtt_packedchar = struct {
	X0       uint16
	Y0       uint16
	X1       uint16
	Y1       uint16
	Xoff     float32
	Yoff     float32
	Xadvance float32
	Xoff2    float32
	Yoff2    float32
} /* nuklear.h:11814:3 */

type Stbtt_pack_context1 = struct {
	User_allocator_context uintptr
	Pack_info              uintptr
	Width                  int32
	Height                 int32
	Stride_in_bytes        int32
	Padding                int32
	Skip_missing           int32
	H_oversample           uint32
	V_oversample           uint32
	Pixels                 uintptr
	Nodes                  uintptr
} /* nuklear.h:11816:9 */

type Stbtt_pack_context = Stbtt_pack_context1 /* nuklear.h:11816:35 */
type Stbtt_fontinfo1 = struct {
	Userdata         uintptr
	Data             uintptr
	Fontstart        int32
	NumGlyphs        int32
	Loca             int32
	Head             int32
	Glyf             int32
	Hhea             int32
	Hmtx             int32
	Kern             int32
	Gpos             int32
	Svg              int32
	Index_map        int32
	IndexToLocFormat int32
	Cff              Stbtt__buf
	Charstrings      Stbtt__buf
	Gsubrs           Stbtt__buf
	Subrs            Stbtt__buf
	Fontdicts        Stbtt__buf
	Fdselect         Stbtt__buf
} /* nuklear.h:11817:9 */

type Stbtt_fontinfo = Stbtt_fontinfo1 /* nuklear.h:11817:31 */
//  Creates character bitmaps from the font_index'th font found in fontdata (use
//  font_index=0 if you don't know what that is). It creates num_chars_in_range
//  bitmaps for characters with unicode values starting at first_unicode_char_in_range
//  and increasing. Data for how to render them is stored in chardata_for_range;
//  pass these to stbtt_GetPackedQuad to get back renderable quads.
//
//  font_size is the full height of the character from ascender to descender,
//  as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
//  by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
//  and pass that result as 'font_size':
//        ...,                  20 , ... // font max minus min y is 20 pixels tall
//        ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

type Stbtt_pack_range = struct {
	Font_size                        float32
	First_unicode_codepoint_in_range int32
	Array_of_unicode_codepoints      uintptr
	Num_chars                        int32
	Chardata_for_range               uintptr
	H_oversample                     uint8
	V_oversample                     uint8
	_                                [2]byte
} /* nuklear.h:11861:3 */
//  as above, but takes one or more glyph indices for greater efficiency

type Stbtt_kerningentry1 = struct {
	Glyph1  int32
	Glyph2  int32
	Advance int32
} /* nuklear.h:12038:9 */

//  as above, but takes one or more glyph indices for greater efficiency

type Stbtt_kerningentry = Stbtt_kerningentry1 /* nuklear.h:12043:3 */

//  (we share this with other code at RAD)
type Stbtt_vertex = struct {
	X       int16
	Y       int16
	Cx      int16
	Cy      int16
	Cx1     int16
	Cy1     int16
	Type    uint8
	Padding uint8
} /* nuklear.h:12073:6 */

//  @TODO: don't expose this structure
type Stbtt__bitmap = struct {
	W      int32
	H      int32
	Stride int32
	Pixels uintptr
} /* nuklear.h:12161:3 */

// /////////////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////////////
// //
// //   IMPLEMENTATION
// //
// //

type Stbtt__test_oversample_pow2 = [1]int32 /* nuklear.h:12349:13 */

// ////////////////////////////////////////////////////////////////////////
//
//  stbtt__buf helpers to parse data from file
//

func stbtt__buf_get8(b uintptr) Stbtt_uint8 { /* nuklear.h:12366:20: */
	if (*Stbtt__buf)(unsafe.Pointer(b)).Cursor >= (*Stbtt__buf)(unsafe.Pointer(b)).Size {
		return Stbtt_uint8(0)
	}
	return *(*uint8)(unsafe.Pointer((*Stbtt__buf)(unsafe.Pointer(b)).Data + uintptr(PostIncInt32(&(*Stbtt__buf)(unsafe.Pointer(b)).Cursor, 1))))
}

func stbtt__buf_peek8(b uintptr) Stbtt_uint8 { /* nuklear.h:12373:20: */
	if (*Stbtt__buf)(unsafe.Pointer(b)).Cursor >= (*Stbtt__buf)(unsafe.Pointer(b)).Size {
		return Stbtt_uint8(0)
	}
	return *(*uint8)(unsafe.Pointer((*Stbtt__buf)(unsafe.Pointer(b)).Data + uintptr((*Stbtt__buf)(unsafe.Pointer(b)).Cursor)))
}

func stbtt__buf_seek(b uintptr, o int32) { /* nuklear.h:12380:13: */
	if !((o > (*Stbtt__buf)(unsafe.Pointer(b)).Size) || (o < 0)) {
	} else {
		X__assert_fail(ts+3218 /* "!(o > b->size ||..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12382), uintptr(unsafe.Pointer(&__func__109)))
	}
	(*Stbtt__buf)(unsafe.Pointer(b)).Cursor = func() int32 {
		if (o > (*Stbtt__buf)(unsafe.Pointer(b)).Size) || (o < 0) {
			return (*Stbtt__buf)(unsafe.Pointer(b)).Size
		}
		return o
	}()
}

var __func__109 = *(*[16]int8)(unsafe.Pointer(ts + 3242 /* "stbtt__buf_seek" */)) /* nuklear.h:12381:1 */

func stbtt__buf_skip(b uintptr, o int32) { /* nuklear.h:12386:13: */
	stbtt__buf_seek(b, ((*Stbtt__buf)(unsafe.Pointer(b)).Cursor + o))
}

func stbtt__buf_get(b uintptr, n int32) Stbtt_uint32 { /* nuklear.h:12391:21: */
	var v Stbtt_uint32 = Stbtt_uint32(0)
	var i int32
	if (n >= 1) && (n <= 4) {
	} else {
		X__assert_fail(ts+3258 /* "n >= 1 && n <= 4" */, ts+2 /* "nuklear/nuklear...." */, uint32(12395), uintptr(unsafe.Pointer(&__func__110)))
	}
	for i = 0; i < n; i++ {
		v = ((v << 8) | Stbtt_uint32(stbtt__buf_get8(b)))
	}
	return v
}

var __func__110 = *(*[15]int8)(unsafe.Pointer(ts + 3275 /* "stbtt__buf_get" */)) /* nuklear.h:12392:1 */

func stbtt__new_buf(p uintptr, size Size_t) Stbtt__buf { /* nuklear.h:12401:19: */
	var r Stbtt__buf
	if size < Size_t(0x40000000) {
	} else {
		X__assert_fail(ts+3290 /* "size < 0x4000000..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12404), uintptr(unsafe.Pointer(&__func__111)))
	}
	r.Data = p
	r.Size = int32(size)
	r.Cursor = 0
	return r
}

var __func__111 = *(*[15]int8)(unsafe.Pointer(ts + 3308 /* "stbtt__new_buf" */)) /* nuklear.h:12402:1 */

func stbtt__buf_range(b uintptr, o int32, s int32) Stbtt__buf { /* nuklear.h:12414:19: */
	var r = stbtt__new_buf(uintptr(0), uint32(0))
	if (((o < 0) || (s < 0)) || (o > (*Stbtt__buf)(unsafe.Pointer(b)).Size)) || (s > ((*Stbtt__buf)(unsafe.Pointer(b)).Size - o)) {
		return r
	}
	r.Data = ((*Stbtt__buf)(unsafe.Pointer(b)).Data + uintptr(o))
	r.Size = s
	return r
}

func stbtt__cff_get_index(b uintptr) Stbtt__buf { /* nuklear.h:12423:19: */
	var count int32
	var start int32
	var offsize int32
	start = (*Stbtt__buf)(unsafe.Pointer(b)).Cursor
	count = int32(stbtt__buf_get(b, 2))
	if count != 0 {
		offsize = int32(stbtt__buf_get8(b))
		if (offsize >= 1) && (offsize <= 4) {
		} else {
			X__assert_fail(ts+3323 /* "offsize >= 1 && ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12430), uintptr(unsafe.Pointer(&__func__112)))
		}
		stbtt__buf_skip(b, (offsize * count))
		stbtt__buf_skip(b, (int32(stbtt__buf_get(b, offsize) - Stbtt_uint32(1))))
	}
	return stbtt__buf_range(b, start, ((*Stbtt__buf)(unsafe.Pointer(b)).Cursor - start))
}

var __func__112 = *(*[21]int8)(unsafe.Pointer(ts + 3352 /* "stbtt__cff_get_i..." */)) /* nuklear.h:12424:1 */

func stbtt__cff_int(b uintptr) Stbtt_uint32 { /* nuklear.h:12437:21: */
	var b0 int32 = int32(stbtt__buf_get8(b))
	if (b0 >= 32) && (b0 <= 246) {
		return (Stbtt_uint32(b0 - 139))
	} else if (b0 >= 247) && (b0 <= 250) {
		return (Stbtt_uint32((((b0 - 247) * 256) + int32(stbtt__buf_get8(b))) + 108))
	} else if (b0 >= 251) && (b0 <= 254) {
		return (Stbtt_uint32(((-(b0 - 251) * 256) - int32(stbtt__buf_get8(b))) - 108))
	} else if b0 == 28 {
		return stbtt__buf_get(b, 2)
	} else if b0 == 29 {
		return stbtt__buf_get(b, 4)
	}
	if 0 != 0 {
	} else {
		X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(12445), uintptr(unsafe.Pointer(&__func__113)))
	}
	return Stbtt_uint32(0)
}

var __func__113 = *(*[15]int8)(unsafe.Pointer(ts + 3373 /* "stbtt__cff_int" */)) /* nuklear.h:12438:1 */

func stbtt__cff_skip_operand(b uintptr) { /* nuklear.h:12449:13: */
	var v int32
	var b0 int32 = int32(stbtt__buf_peek8(b))
	if b0 >= 28 {
	} else {
		X__assert_fail(ts+3388 /* "b0 >= 28" */, ts+2 /* "nuklear/nuklear...." */, uint32(12451), uintptr(unsafe.Pointer(&__func__114)))
	}
	if b0 == 30 {
		stbtt__buf_skip(b, 1)
		for (*Stbtt__buf)(unsafe.Pointer(b)).Cursor < (*Stbtt__buf)(unsafe.Pointer(b)).Size {
			v = int32(stbtt__buf_get8(b))
			if ((v & 0xF) == 0xF) || ((v >> 4) == 0xF) {
				break
			}
		}
	} else {
		stbtt__cff_int(b)
	}
}

var __func__114 = *(*[24]int8)(unsafe.Pointer(ts + 3397 /* "stbtt__cff_skip_..." */)) /* nuklear.h:12449:52 */

func stbtt__dict_get(b uintptr, key int32) Stbtt__buf { /* nuklear.h:12464:19: */
	stbtt__buf_seek(b, 0)
	for (*Stbtt__buf)(unsafe.Pointer(b)).Cursor < (*Stbtt__buf)(unsafe.Pointer(b)).Size {
		var start int32 = (*Stbtt__buf)(unsafe.Pointer(b)).Cursor
		var end int32
		var op int32
		for int32(stbtt__buf_peek8(b)) >= 28 {
			stbtt__cff_skip_operand(b)
		}
		end = (*Stbtt__buf)(unsafe.Pointer(b)).Cursor
		op = int32(stbtt__buf_get8(b))
		if op == 12 {
			op = (int32(stbtt__buf_get8(b)) | 0x100)
		}
		if op == key {
			return stbtt__buf_range(b, start, (end - start))
		}
	}
	return stbtt__buf_range(b, 0, 0)
}

func stbtt__dict_get_ints(b uintptr, key int32, outcount int32, out uintptr) { /* nuklear.h:12479:13: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	var i int32
	*(*Stbtt__buf)(unsafe.Pointer(bp /* operands */)) = stbtt__dict_get(b, key)
	for i = 0; (i < outcount) && ((*Stbtt__buf)(unsafe.Pointer(bp /* &operands */)).Cursor < (*Stbtt__buf)(unsafe.Pointer(bp /* &operands */)).Size); i++ {
		*(*Stbtt_uint32)(unsafe.Pointer(out + uintptr(i)*4)) = stbtt__cff_int(bp /* &operands */)
	}
}

func stbtt__cff_index_count(b uintptr) int32 { /* nuklear.h:12487:12: */
	stbtt__buf_seek(b, 0)
	return int32(stbtt__buf_get(b, 2))
}

func stbtt__cff_index_get(b Stbtt__buf, i int32) Stbtt__buf { /* nuklear.h:12493:19: */
	bp := tlsAlloc(12)
	defer tlsFree(12)
	*(*Stbtt__buf)(unsafe.Pointer(bp)) = b

	var count int32
	var offsize int32
	var start int32
	var end int32
	stbtt__buf_seek(bp /* &b */, 0)
	count = int32(stbtt__buf_get(bp /* &b */, 2))
	offsize = int32(stbtt__buf_get8(bp /* &b */))
	if (i >= 0) && (i < count) {
	} else {
		X__assert_fail(ts+3421 /* "i >= 0 && i < co..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12499), uintptr(unsafe.Pointer(&__func__115)))
	}
	if (offsize >= 1) && (offsize <= 4) {
	} else {
		X__assert_fail(ts+3323 /* "offsize >= 1 && ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12500), uintptr(unsafe.Pointer(&__func__115)))
	}
	stbtt__buf_skip(bp /* &b */, (i * offsize))
	start = int32(stbtt__buf_get(bp /* &b */, offsize))
	end = int32(stbtt__buf_get(bp /* &b */, offsize))
	return stbtt__buf_range(bp /* &b */, ((2 + ((count + 1) * offsize)) + start), (end - start))
}

var __func__115 = *(*[21]int8)(unsafe.Pointer(ts + 3441 /* "stbtt__cff_index..." */)) /* nuklear.h:12494:1 */

// ////////////////////////////////////////////////////////////////////////
//
//  accessors to parse data from file
//

//  on platforms that don't allow misaligned reads, if we want to allow
//  truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

func ttUSHORT(p uintptr) Stbtt_uint16 { /* nuklear.h:12519:21: */
	return (Stbtt_uint16((int32(*(*Stbtt_uint8)(unsafe.Pointer(p))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 1)))))
}

func ttSHORT(p uintptr) Stbtt_int16 { /* nuklear.h:12520:20: */
	return (Stbtt_int16((int32(*(*Stbtt_uint8)(unsafe.Pointer(p))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 1)))))
}

func ttULONG(p uintptr) Stbtt_uint32 { /* nuklear.h:12521:21: */
	return (Stbtt_uint32((((int32(*(*Stbtt_uint8)(unsafe.Pointer(p))) << 24) + (int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 1))) << 16)) + (int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 2))) << 8)) + int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 3)))))
}

func ttLONG(p uintptr) Stbtt_int32 { /* nuklear.h:12522:20: */
	return ((((int32(*(*Stbtt_uint8)(unsafe.Pointer(p))) << 24) + (int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 1))) << 16)) + (int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 2))) << 8)) + int32(*(*Stbtt_uint8)(unsafe.Pointer(p + 3))))
}

func stbtt__isfont(font uintptr) int32 { /* nuklear.h:12527:12: */
	//  check the version number
	if (((int32(*(*Stbtt_uint8)(unsafe.Pointer((font)))) == ('1')) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 1))) == (0))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 2))) == (0))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 3))) == (0)) {
		return 1
	} //  TrueType 1
	if (((int32(*(*Stbtt_uint8)(unsafe.Pointer((font)))) == (int32(*(*int8)(unsafe.Pointer(ts + 3462 /* "typ1" */))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 1))) == (int32(*(*int8)(unsafe.Pointer(ts + 3462 /* "typ1" */ + 1)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 2))) == (int32(*(*int8)(unsafe.Pointer(ts + 3462 /* "typ1" */ + 2)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 3))) == (int32(*(*int8)(unsafe.Pointer(ts + 3462 /* "typ1" */ + 3))))) {
		return 1
	} //  TrueType with type 1 font -- we don't support this!
	if (((int32(*(*Stbtt_uint8)(unsafe.Pointer((font)))) == (int32(*(*int8)(unsafe.Pointer(ts + 3467 /* "OTTO" */))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 1))) == (int32(*(*int8)(unsafe.Pointer(ts + 3467 /* "OTTO" */ + 1)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 2))) == (int32(*(*int8)(unsafe.Pointer(ts + 3467 /* "OTTO" */ + 2)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 3))) == (int32(*(*int8)(unsafe.Pointer(ts + 3467 /* "OTTO" */ + 3))))) {
		return 1
	} //  OpenType with CFF
	if (((int32(*(*Stbtt_uint8)(unsafe.Pointer((font)))) == (0)) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 1))) == (1))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 2))) == (0))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 3))) == (0)) {
		return 1
	} //  OpenType 1.0
	if (((int32(*(*Stbtt_uint8)(unsafe.Pointer((font)))) == (int32(*(*int8)(unsafe.Pointer(ts + 3472 /* "true" */))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 1))) == (int32(*(*int8)(unsafe.Pointer(ts + 3472 /* "true" */ + 1)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 2))) == (int32(*(*int8)(unsafe.Pointer(ts + 3472 /* "true" */ + 2)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer((font) + 3))) == (int32(*(*int8)(unsafe.Pointer(ts + 3472 /* "true" */ + 3))))) {
		return 1
	} //  Apple specification for TrueType fonts
	return 0
}

//  @OPTIMIZE: binary search
func stbtt__find_table(data uintptr, fontstart Stbtt_uint32, tag uintptr) Stbtt_uint32 { /* nuklear.h:12539:21: */
	var num_tables Stbtt_int32 = Stbtt_int32(ttUSHORT(((data + uintptr(fontstart)) + uintptr(4))))
	var tabledir Stbtt_uint32 = (fontstart + Stbtt_uint32(12))
	var i Stbtt_int32
	for i = 0; i < num_tables; i++ {
		var loc Stbtt_uint32 = (tabledir + (Stbtt_uint32(16 * i)))
		if (((int32(*(*Stbtt_uint8)(unsafe.Pointer(((data + uintptr(loc)) + uintptr(0))))) == (int32(*(*int8)(unsafe.Pointer(tag))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer(((data + uintptr(loc)) + uintptr(0)) + 1))) == (int32(*(*int8)(unsafe.Pointer(tag + 1)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer(((data + uintptr(loc)) + uintptr(0)) + 2))) == (int32(*(*int8)(unsafe.Pointer(tag + 2)))))) && (int32(*(*Stbtt_uint8)(unsafe.Pointer(((data + uintptr(loc)) + uintptr(0)) + 3))) == (int32(*(*int8)(unsafe.Pointer(tag + 3))))) {
			return ttULONG(((data + uintptr(loc)) + uintptr(8)))
		}
	}
	return Stbtt_uint32(0)
}

func stbtt_GetFontOffsetForIndex_internal(font_collection uintptr, index int32) int32 { /* nuklear.h:12552:12: */
	//  if it's just a font, there's only one valid index
	if stbtt__isfont(font_collection) != 0 {
		if index == 0 {
			return 0
		}
		return -1
	}

	//  check if it's a TTC
	if (((int32(*(*uint8)(unsafe.Pointer((font_collection)))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 1))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 1)))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 2))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 2)))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 3))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 3))))) {
		//  version 1?
		if (ttULONG((font_collection + uintptr(4))) == Stbtt_uint32(0x00010000)) || (ttULONG((font_collection + uintptr(4))) == Stbtt_uint32(0x00020000)) {
			var n Stbtt_int32 = ttLONG((font_collection + uintptr(8)))
			if index >= n {
				return -1
			}
			return int32(ttULONG(((font_collection + uintptr(12)) + uintptr((index * 4)))))
		}
	}
	return -1
}

func stbtt_GetNumberOfFonts_internal(font_collection uintptr) int32 { /* nuklear.h:12571:12: */
	//  if it's just a font, there's only one valid font
	if stbtt__isfont(font_collection) != 0 {
		return 1
	}

	//  check if it's a TTC
	if (((int32(*(*uint8)(unsafe.Pointer((font_collection)))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 1))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 1)))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 2))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 2)))))) && (int32(*(*uint8)(unsafe.Pointer((font_collection) + 3))) == (int32(*(*int8)(unsafe.Pointer(ts + 3477 /* "ttcf" */ + 3))))) {
		//  version 1?
		if (ttULONG((font_collection + uintptr(4))) == Stbtt_uint32(0x00010000)) || (ttULONG((font_collection + uintptr(4))) == Stbtt_uint32(0x00020000)) {
			return ttLONG((font_collection + uintptr(8)))
		}
	}
	return 0
}

func stbtt__get_subrs(cff Stbtt__buf, fontdict Stbtt__buf) Stbtt__buf { /* nuklear.h:12587:19: */
	bp := tlsAlloc(48)
	defer tlsFree(48)
	*(*Stbtt__buf)(unsafe.Pointer(bp + 20)) = cff
	*(*Stbtt__buf)(unsafe.Pointer(bp)) = fontdict

	*(*Stbtt_uint32)(unsafe.Pointer(bp + 44 /* subrsoff */)) = Stbtt_uint32(0)
	*(*[2]Stbtt_uint32)(unsafe.Pointer(bp + 12 /* private_loc */)) = [2]Stbtt_uint32{Stbtt_uint32(0), Stbtt_uint32(0)}
	// var pdict Stbtt__buf at bp+32, 12

	stbtt__dict_get_ints(bp /* &fontdict */, 18, 2, bp+12 /* &private_loc[0] */)
	if !(int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 12 /* &private_loc[0] */ + 1*4))) != 0) || !(int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 12 /* &private_loc[0] */))) != 0) {
		return stbtt__new_buf(uintptr(0), uint32(0))
	}
	*(*Stbtt__buf)(unsafe.Pointer(bp + 32 /* pdict */)) = stbtt__buf_range(bp+20 /* &cff */, int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 12 /* &private_loc[0] */ + 1*4))), int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 12 /* &private_loc[0] */))))
	stbtt__dict_get_ints(bp+32 /* &pdict */, 19, 1, bp+44 /* &subrsoff */)
	if !(*(*Stbtt_uint32)(unsafe.Pointer(bp + 44 /* subrsoff */)) != 0) {
		return stbtt__new_buf(uintptr(0), uint32(0))
	}
	stbtt__buf_seek(bp+20 /* &cff */, (int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 12 /* &private_loc[0] */ + 1*4)) + *(*Stbtt_uint32)(unsafe.Pointer(bp + 44 /* subrsoff */)))))
	return stbtt__cff_get_index(bp + 20 /* &cff */)
}

//  since most people won't use this, find this table the first time it's needed
func stbtt__get_svg(info uintptr) int32 { /* nuklear.h:12601:12: */
	var t Stbtt_uint32
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg < 0 {
		t = stbtt__find_table((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data, uint32((*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontstart), ts+3482 /* "SVG " */)
		if t != 0 {
			var offset Stbtt_uint32 = ttULONG((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(t)) + uintptr(2)))
			(*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg = (int32(t + offset))
		} else {
			(*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg = 0
		}
	}
	return (*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg
}

func stbtt_InitFont_internal(info uintptr, data uintptr, fontstart int32) int32 { /* nuklear.h:12616:12: */
	bp := tlsAlloc(40)
	defer tlsFree(40)

	var cmap Stbtt_uint32
	var t Stbtt_uint32
	var i Stbtt_int32
	var numTables Stbtt_int32

	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Data = data
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontstart = fontstart
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff = stbtt__new_buf(uintptr(0), uint32(0))

	cmap = stbtt__find_table(data, uint32(fontstart), ts+3487 /* "cmap" */)                                                //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca = int32(stbtt__find_table(data, uint32(fontstart), ts+3492 /* "loca" */)) //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Head = int32(stbtt__find_table(data, uint32(fontstart), ts+3497 /* "head" */)) //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf = int32(stbtt__find_table(data, uint32(fontstart), ts+3502 /* "glyf" */)) //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea = int32(stbtt__find_table(data, uint32(fontstart), ts+3507 /* "hhea" */)) //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx = int32(stbtt__find_table(data, uint32(fontstart), ts+3512 /* "hmtx" */)) //  required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern = int32(stbtt__find_table(data, uint32(fontstart), ts+3517 /* "kern" */)) //  not required
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Gpos = int32(stbtt__find_table(data, uint32(fontstart), ts+3522 /* "GPOS" */)) //  not required

	if ((!(cmap != 0) || !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head != 0)) || !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea != 0)) || !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx != 0) {
		return 0
	}
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf != 0 {
		//  required for truetype
		if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca != 0) {
			return 0
		}
	} else {
		//  initialization for CFF / Type2 fonts (OTF)
		// var b Stbtt__buf at bp, 12

		// var topdict Stbtt__buf at bp+12, 12

		var topdictidx Stbtt__buf
		*(*Stbtt_uint32)(unsafe.Pointer(bp + 28 /* cstype */)) = Stbtt_uint32(2)
		*(*Stbtt_uint32)(unsafe.Pointer(bp + 24 /* charstrings */)) = Stbtt_uint32(0)
		*(*Stbtt_uint32)(unsafe.Pointer(bp + 32 /* fdarrayoff */)) = Stbtt_uint32(0)
		*(*Stbtt_uint32)(unsafe.Pointer(bp + 36 /* fdselectoff */)) = Stbtt_uint32(0)
		var cff Stbtt_uint32

		cff = stbtt__find_table(data, uint32(fontstart), ts+3527 /* "CFF " */)
		if !(cff != 0) {
			return 0
		}

		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontdicts = stbtt__new_buf(uintptr(0), uint32(0))
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Fdselect = stbtt__new_buf(uintptr(0), uint32(0))

		//  @TODO this should use size from table (not 512MB)
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff = stbtt__new_buf((data + uintptr(cff)), (uint32((512 * 1024) * 1024)))
		*(*Stbtt__buf)(unsafe.Pointer(bp /* b */)) = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff

		//  read the header
		stbtt__buf_skip(bp /* &b */, 2)
		stbtt__buf_seek(bp /* &b */, int32(stbtt__buf_get8(bp /* &b */))) //  hdrsize

		//  @TODO the name INDEX could list multiple fonts,
		//  but we just use the first one.
		stbtt__cff_get_index(bp /* &b */) //  name INDEX
		topdictidx = stbtt__cff_get_index(bp /* &b */)
		*(*Stbtt__buf)(unsafe.Pointer(bp + 12 /* topdict */)) = stbtt__cff_index_get(topdictidx, 0)
		stbtt__cff_get_index(bp /* &b */) //  string INDEX
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Gsubrs = stbtt__cff_get_index(bp /* &b */)

		stbtt__dict_get_ints(bp+12 /* &topdict */, 17, 1, bp+24 /* &charstrings */)
		stbtt__dict_get_ints(bp+12 /* &topdict */, (0x100 | 6), 1, bp+28 /* &cstype */)
		stbtt__dict_get_ints(bp+12 /* &topdict */, (0x100 | 36), 1, bp+32 /* &fdarrayoff */)
		stbtt__dict_get_ints(bp+12 /* &topdict */, (0x100 | 37), 1, bp+36 /* &fdselectoff */)
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Subrs = stbtt__get_subrs(*(*Stbtt__buf)(unsafe.Pointer(bp /* b */)), *(*Stbtt__buf)(unsafe.Pointer(bp + 12 /* topdict */)))

		//  we only support Type 2 charstrings
		if *(*Stbtt_uint32)(unsafe.Pointer(bp + 28 /* cstype */)) != Stbtt_uint32(2) {
			return 0
		}
		if *(*Stbtt_uint32)(unsafe.Pointer(bp + 24 /* charstrings */)) == Stbtt_uint32(0) {
			return 0
		}

		if *(*Stbtt_uint32)(unsafe.Pointer(bp + 32 /* fdarrayoff */)) != 0 {
			//  looks like a CID font
			if !(*(*Stbtt_uint32)(unsafe.Pointer(bp + 36 /* fdselectoff */)) != 0) {
				return 0
			}
			stbtt__buf_seek(bp /* &b */, int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 32 /* fdarrayoff */))))
			(*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontdicts = stbtt__cff_get_index(bp /* &b */)
			(*Stbtt_fontinfo)(unsafe.Pointer(info)).Fdselect = stbtt__buf_range(bp /* &b */, int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 36 /* fdselectoff */))), (int32(Stbtt_uint32((*Stbtt__buf)(unsafe.Pointer(bp /* &b */)).Size) - *(*Stbtt_uint32)(unsafe.Pointer(bp + 36 /* fdselectoff */)))))
		}

		stbtt__buf_seek(bp /* &b */, int32(*(*Stbtt_uint32)(unsafe.Pointer(bp + 24 /* charstrings */))))
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).Charstrings = stbtt__cff_get_index(bp /* &b */)
	}

	t = stbtt__find_table(data, uint32(fontstart), ts+3532 /* "maxp" */)
	if t != 0 {
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).NumGlyphs = int32(ttUSHORT(((data + uintptr(t)) + uintptr(4))))
	} else {
		(*Stbtt_fontinfo)(unsafe.Pointer(info)).NumGlyphs = 0xffff
	}

	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg = -1

	//  find a cmap encoding table we understand *now* to avoid searching
	//  later. (todo: could make this installable)
	//  the same regardless of glyph.
	numTables = Stbtt_int32(ttUSHORT(((data + uintptr(cmap)) + uintptr(2))))
	(*Stbtt_fontinfo)(unsafe.Pointer(info)).Index_map = 0
	for i = 0; i < numTables; i++ {
		var encoding_record Stbtt_uint32 = ((cmap + Stbtt_uint32(4)) + (Stbtt_uint32(8 * i)))
		//  find an encoding we understand:
		switch int32(ttUSHORT((data + uintptr(encoding_record)))) {
		case STBTT_PLATFORM_ID_MICROSOFT:
			switch int32(ttUSHORT(((data + uintptr(encoding_record)) + uintptr(2)))) {
			case STBTT_MS_EID_UNICODE_BMP:
				fallthrough
			case STBTT_MS_EID_UNICODE_FULL:
				//  MS/Unicode
				(*Stbtt_fontinfo)(unsafe.Pointer(info)).Index_map = (int32(cmap + ttULONG(((data + uintptr(encoding_record)) + uintptr(4)))))
				break
			}
			break
		case STBTT_PLATFORM_ID_UNICODE:
			//  Mac/iOS has these
			//  all the encodingIDs are unicode, so we don't bother to check it
			(*Stbtt_fontinfo)(unsafe.Pointer(info)).Index_map = (int32(cmap + ttULONG(((data + uintptr(encoding_record)) + uintptr(4)))))
			break
		}
	}
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Index_map == 0 {
		return 0
	}

	(*Stbtt_fontinfo)(unsafe.Pointer(info)).IndexToLocFormat = int32(ttUSHORT(((data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(50))))
	return 1
}

func Xstbtt_FindGlyphIndex(info uintptr, unicode_codepoint int32) int32 { /* nuklear.h:12729:15: */
	var data uintptr = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Data
	var index_map Stbtt_uint32 = Stbtt_uint32((*Stbtt_fontinfo)(unsafe.Pointer(info)).Index_map)

	var format Stbtt_uint16 = ttUSHORT(((data + uintptr(index_map)) + uintptr(0)))
	if int32(format) == 0 { //  apple byte encoding
		var bytes Stbtt_int32 = Stbtt_int32(ttUSHORT(((data + uintptr(index_map)) + uintptr(2))))
		if unicode_codepoint < (bytes - 6) {
			return int32(*(*Stbtt_uint8)(unsafe.Pointer((((data + uintptr(index_map)) + uintptr(6)) + uintptr(unicode_codepoint)))))
		}
		return 0
	} else if int32(format) == 6 {
		var first Stbtt_uint32 = Stbtt_uint32(ttUSHORT(((data + uintptr(index_map)) + uintptr(6))))
		var count Stbtt_uint32 = Stbtt_uint32(ttUSHORT(((data + uintptr(index_map)) + uintptr(8))))
		if (Stbtt_uint32(unicode_codepoint) >= first) && (Stbtt_uint32(unicode_codepoint) < (first + count)) {
			return int32(ttUSHORT((((data + uintptr(index_map)) + uintptr(10)) + uintptr(((Stbtt_uint32(unicode_codepoint) - first) * Stbtt_uint32(2))))))
		}
		return 0
	} else if int32(format) == 2 {
		if 0 != 0 {
		} else {
			X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(12747), uintptr(unsafe.Pointer(&__func__116)))
		} //  @TODO: high-byte mapping for japanese/chinese/korean
		return 0
	} else if int32(format) == 4 { //  standard mapping for windows fonts: binary search collection of ranges
		var segcount Stbtt_uint16 = (Stbtt_uint16(int32(ttUSHORT(((data + uintptr(index_map)) + uintptr(6)))) >> 1))
		var searchRange Stbtt_uint16 = (Stbtt_uint16(int32(ttUSHORT(((data + uintptr(index_map)) + uintptr(8)))) >> 1))
		var entrySelector Stbtt_uint16 = ttUSHORT(((data + uintptr(index_map)) + uintptr(10)))
		var rangeShift Stbtt_uint16 = (Stbtt_uint16(int32(ttUSHORT(((data + uintptr(index_map)) + uintptr(12)))) >> 1))

		//  do a binary search of the segments
		var endCount Stbtt_uint32 = (index_map + Stbtt_uint32(14))
		var search Stbtt_uint32 = endCount

		if unicode_codepoint > 0xffff {
			return 0
		}

		//  they lie from endCount .. endCount + segCount
		//  but searchRange is the nearest power of two, so...
		if unicode_codepoint >= int32(ttUSHORT(((data + uintptr(search)) + uintptr((int32(rangeShift) * 2))))) {
			search = search + (Stbtt_uint32(int32(rangeShift) * 2))
		}

		//  now decrement to bias correctly to find smallest
		search = search - (Stbtt_uint32(2))
		for entrySelector != 0 {
			var end Stbtt_uint16
			searchRange >>= 1
			end = ttUSHORT(((data + uintptr(search)) + uintptr((int32(searchRange) * 2))))
			if unicode_codepoint > int32(end) {
				search = search + (Stbtt_uint32(int32(searchRange) * 2))
			}
			entrySelector--
		}
		search = search + (Stbtt_uint32(2))

		{
			var offset Stbtt_uint16
			var start Stbtt_uint16
			var item Stbtt_uint16 = (Stbtt_uint16((search - endCount) >> 1))

			if unicode_codepoint <= int32(ttUSHORT(((data + uintptr(endCount)) + uintptr((2 * int32(item)))))) {
			} else {
				X__assert_fail(ts+3537 /* "unicode_codepoin..." */, ts+2 /* "nuklear/nuklear...." */, uint32(12783), uintptr(unsafe.Pointer(&__func__116)))
			}
			start = ttUSHORT((((((data + uintptr(index_map)) + uintptr(14)) + uintptr((int32(segcount) * 2))) + uintptr(2)) + uintptr((2 * int32(item)))))
			if unicode_codepoint < int32(start) {
				return 0
			}

			offset = ttUSHORT((((((data + uintptr(index_map)) + uintptr(14)) + uintptr((int32(segcount) * 6))) + uintptr(2)) + uintptr((2 * int32(item)))))
			if int32(offset) == 0 {
				return int32((Stbtt_uint16(unicode_codepoint + int32(ttSHORT((((((data + uintptr(index_map)) + uintptr(14)) + uintptr((int32(segcount) * 4))) + uintptr(2)) + uintptr((2 * int32(item)))))))))
			}

			return int32(ttUSHORT((((((((data + uintptr(offset)) + uintptr(((unicode_codepoint - int32(start)) * 2))) + uintptr(index_map)) + uintptr(14)) + uintptr((int32(segcount) * 6))) + uintptr(2)) + uintptr((2 * int32(item))))))

		}
	} else if (int32(format) == 12) || (int32(format) == 13) {
		var ngroups Stbtt_uint32 = ttULONG(((data + uintptr(index_map)) + uintptr(12)))
		var low Stbtt_int32
		var high Stbtt_int32
		low = 0
		high = Stbtt_int32(ngroups)
		//  Binary search the right group.
		for low < high {
			var mid Stbtt_int32 = (low + ((high - low) >> 1)) //  rounds down, so low <= mid < high
			var start_char Stbtt_uint32 = ttULONG((((data + uintptr(index_map)) + uintptr(16)) + uintptr((mid * 12))))
			var end_char Stbtt_uint32 = ttULONG(((((data + uintptr(index_map)) + uintptr(16)) + uintptr((mid * 12))) + uintptr(4)))
			if Stbtt_uint32(unicode_codepoint) < start_char {
				high = mid
			} else if Stbtt_uint32(unicode_codepoint) > end_char {
				low = (mid + 1)
			} else {
				var start_glyph Stbtt_uint32 = ttULONG(((((data + uintptr(index_map)) + uintptr(16)) + uintptr((mid * 12))) + uintptr(8)))
				if int32(format) == 12 {
					return (int32((start_glyph + Stbtt_uint32(unicode_codepoint)) - start_char))
				} else { //  format == 13
					return int32(start_glyph)
				}
			}
		}
		return 0 //  not found
	}
	//  @TODO
	if 0 != 0 {
	} else {
		X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(12818), uintptr(unsafe.Pointer(&__func__116)))
	}
	return 0
}

var __func__116 = *(*[21]int8)(unsafe.Pointer(ts + 3593 /* "stbtt_FindGlyphI..." */)) /* nuklear.h:12730:1 */

func Xstbtt_GetCodepointShape(info uintptr, unicode_codepoint int32, vertices uintptr) int32 { /* nuklear.h:12822:15: */
	return Xstbtt_GetGlyphShape(info, Xstbtt_FindGlyphIndex(info, unicode_codepoint), vertices)
}

func stbtt_setvertex(v uintptr, type1 Stbtt_uint8, x Stbtt_int32, y Stbtt_int32, cx Stbtt_int32, cy Stbtt_int32) { /* nuklear.h:12827:13: */
	(*Stbtt_vertex)(unsafe.Pointer(v)).Type = type1
	(*Stbtt_vertex)(unsafe.Pointer(v)).X = Stbtt_int16(x)
	(*Stbtt_vertex)(unsafe.Pointer(v)).Y = Stbtt_int16(y)
	(*Stbtt_vertex)(unsafe.Pointer(v)).Cx = Stbtt_int16(cx)
	(*Stbtt_vertex)(unsafe.Pointer(v)).Cy = Stbtt_int16(cy)
}

func stbtt__GetGlyfOffset(info uintptr, glyph_index int32) int32 { /* nuklear.h:12836:12: */
	var g1 int32
	var g2 int32

	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff.Size != 0) {
	} else {
		X__assert_fail(ts+3614 /* "!info->cff.size" */, ts+2 /* "nuklear/nuklear...." */, uint32(12840), uintptr(unsafe.Pointer(&__func__117)))
	}

	if glyph_index >= (*Stbtt_fontinfo)(unsafe.Pointer(info)).NumGlyphs {
		return -1
	} //  glyph index out of range
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).IndexToLocFormat >= 2 {
		return -1
	} //  unknown index->glyph map format

	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).IndexToLocFormat == 0 {
		g1 = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf + (int32(ttUSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca)) + uintptr((glyph_index * 2))))) * 2))
		g2 = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf + (int32(ttUSHORT(((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca)) + uintptr((glyph_index * 2))) + uintptr(2)))) * 2))
	} else {
		g1 = (int32(Stbtt_uint32((*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf) + ttULONG((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca)) + uintptr((glyph_index * 4))))))
		g2 = (int32(Stbtt_uint32((*Stbtt_fontinfo)(unsafe.Pointer(info)).Glyf) + ttULONG(((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Loca)) + uintptr((glyph_index * 4))) + uintptr(4)))))
	}

	if g1 == g2 {
		return -1
	}
	return g1 //  if length is 0, return -1
}

var __func__117 = *(*[21]int8)(unsafe.Pointer(ts + 3630 /* "stbtt__GetGlyfOf..." */)) /* nuklear.h:12837:1 */

func Xstbtt_GetGlyphBox(info uintptr, glyph_index int32, x0 uintptr, y0 uintptr, x1 uintptr, y1 uintptr) int32 { /* nuklear.h:12858:15: */
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff.Size != 0 {
		stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1)
	} else {
		var g int32 = stbtt__GetGlyfOffset(info, glyph_index)
		if g < 0 {
			return 0
		}

		if x0 != 0 {
			*(*int32)(unsafe.Pointer(x0)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(g)) + uintptr(2))))
		}
		if y0 != 0 {
			*(*int32)(unsafe.Pointer(y0)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(g)) + uintptr(4))))
		}
		if x1 != 0 {
			*(*int32)(unsafe.Pointer(x1)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(g)) + uintptr(6))))
		}
		if y1 != 0 {
			*(*int32)(unsafe.Pointer(y1)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(g)) + uintptr(8))))
		}
	}
	return 1
}

func Xstbtt_GetCodepointBox(info uintptr, codepoint int32, x0 uintptr, y0 uintptr, x1 uintptr, y1 uintptr) int32 { /* nuklear.h:12874:15: */
	return Xstbtt_GetGlyphBox(info, Xstbtt_FindGlyphIndex(info, codepoint), x0, y0, x1, y1)
}

func Xstbtt_IsGlyphEmpty(info uintptr, glyph_index int32) int32 { /* nuklear.h:12879:15: */
	var numberOfContours Stbtt_int16
	var g int32
	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff.Size != 0 {
		return (Bool32(stbtt__GetGlyphInfoT2(info, glyph_index, uintptr(0), uintptr(0), uintptr(0), uintptr(0)) == 0))
	}
	g = stbtt__GetGlyfOffset(info, glyph_index)
	if g < 0 {
		return 1
	}
	numberOfContours = ttSHORT(((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(g)))
	return (Bool32(int32(numberOfContours) == 0))
}

func stbtt__close_shape(vertices uintptr, num_vertices int32, was_off int32, start_off int32, sx Stbtt_int32, sy Stbtt_int32, scx Stbtt_int32, scy Stbtt_int32, cx Stbtt_int32, cy Stbtt_int32) int32 { /* nuklear.h:12891:12: */
	if start_off != 0 {
		if was_off != 0 {
			stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vcurve, ((cx + scx) >> 1), ((cy + scy) >> 1), cx, cy)
		}
		stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vcurve, sx, sy, scx, scy)
	} else {
		if was_off != 0 {
			stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vcurve, sx, sy, cx, cy)
		} else {
			stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vline, sx, sy, 0, 0)
		}
	}
	return num_vertices
}

func stbtt__GetGlyphShapeTT(info uintptr, glyph_index int32, pvertices uintptr) int32 { /* nuklear.h:12907:12: */
	bp := tlsAlloc(28)
	defer tlsFree(28)

	var numberOfContours Stbtt_int16
	var endPtsOfContours uintptr
	var data uintptr = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Data
	var vertices uintptr = uintptr(0)
	var num_vertices int32 = 0
	var g int32 = stbtt__GetGlyfOffset(info, glyph_index)

	*(*uintptr)(unsafe.Pointer(pvertices)) = uintptr(0)

	if g < 0 {
		return 0
	}

	numberOfContours = ttSHORT((data + uintptr(g)))

	if int32(numberOfContours) > 0 {
		var flags Stbtt_uint8 = Stbtt_uint8(0)
		var flagcount Stbtt_uint8
		var ins Stbtt_int32
		var i Stbtt_int32
		var j Stbtt_int32 = 0
		var m Stbtt_int32
		var n Stbtt_int32
		var next_move Stbtt_int32
		var was_off Stbtt_int32 = 0
		var off Stbtt_int32
		var start_off Stbtt_int32 = 0
		var x Stbtt_int32
		var y Stbtt_int32
		var cx Stbtt_int32
		var cy Stbtt_int32
		var sx Stbtt_int32
		var sy Stbtt_int32
		var scx Stbtt_int32
		var scy Stbtt_int32
		var points uintptr
		endPtsOfContours = ((data + uintptr(g)) + uintptr(10))
		ins = Stbtt_int32(ttUSHORT((((data + uintptr(g)) + uintptr(10)) + uintptr((int32(numberOfContours) * 2)))))
		points = (((((data + uintptr(g)) + uintptr(10)) + uintptr((int32(numberOfContours) * 2))) + uintptr(2)) + uintptr(ins))

		n = (1 + int32(ttUSHORT(((endPtsOfContours + uintptr((int32(numberOfContours) * 2))) - uintptr(2)))))

		m = (n + (2 * int32(numberOfContours))) //  a loose bound on how many vertices we might need
		vertices = nk_stbtt_malloc((uint32(m) * uint32(unsafe.Sizeof(Stbtt_vertex{}))), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		if vertices == uintptr(0) {
			return 0
		}

		next_move = 0
		flagcount = Stbtt_uint8(0)

		//  in first pass, we load uninterpreted data into the allocated array
		//  above, shifted to the end of the array so we won't overwrite it when
		//  we create our final data starting from the front

		off = (m - n) //  starting offset for uninterpreted data, regardless of how m ends up being calculated

		//  first load flags

		for i = 0; i < n; i++ {
			if int32(flagcount) == 0 {
				flags = *(*Stbtt_uint8)(unsafe.Pointer(PostIncUintptr(&points, 1)))
				if (int32(flags) & 8) != 0 {
					flagcount = *(*Stbtt_uint8)(unsafe.Pointer(PostIncUintptr(&points, 1)))
				}
			} else {
				flagcount--
			}
			(*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Type = flags
		}

		//  now load x coordinates
		x = 0
		for i = 0; i < n; i++ {
			flags = (*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Type
			if (int32(flags) & 2) != 0 {
				var dx Stbtt_int16 = Stbtt_int16(*(*Stbtt_uint8)(unsafe.Pointer(PostIncUintptr(&points, 1))))
				x = x + (func() int32 {
					if (int32(flags) & 16) != 0 {
						return int32(dx)
					}
					return -int32(dx)
				}()) //  ???
			} else {
				if !((int32(flags) & 16) != 0) {
					x = (x + Stbtt_int32((Stbtt_int16((int32(*(*Stbtt_uint8)(unsafe.Pointer(points))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(points + 1)))))))
					points += uintptr(2)
				}
			}
			(*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).X = Stbtt_int16(x)
		}

		//  now load y coordinates
		y = 0
		for i = 0; i < n; i++ {
			flags = (*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Type
			if (int32(flags) & 4) != 0 {
				var dy Stbtt_int16 = Stbtt_int16(*(*Stbtt_uint8)(unsafe.Pointer(PostIncUintptr(&points, 1))))
				y = y + (func() int32 {
					if (int32(flags) & 32) != 0 {
						return int32(dy)
					}
					return -int32(dy)
				}()) //  ???
			} else {
				if !((int32(flags) & 32) != 0) {
					y = (y + Stbtt_int32((Stbtt_int16((int32(*(*Stbtt_uint8)(unsafe.Pointer(points))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(points + 1)))))))
					points += uintptr(2)
				}
			}
			(*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Y = Stbtt_int16(y)
		}

		//  now convert them to our format
		num_vertices = 0
		sx = AssignInt32(&sy, AssignInt32(&cx, AssignInt32(&cy, AssignInt32(&scx, AssignInt32(&scy, 0)))))
		for i = 0; i < n; i++ {
			flags = (*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Type
			x = Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).X)
			y = Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr((off+i))*14)).Y)

			if next_move == i {
				if i != 0 {
					num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy)
				}

				//  now start the new one
				start_off = BoolInt32(!((int32(flags) & 1) != 0))
				if start_off != 0 {
					//  if we start off with an off-curve point, then when we need to find a point on the curve
					//  where we can start, and we need to save some state for when we wraparound.
					scx = x
					scy = y
					if !((int32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(((off+i)+1))*14)).Type) & 1) != 0) {
						//  next point is also a curve point, so interpolate an on-point curve
						sx = ((x + Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(((off+i)+1))*14)).X)) >> 1)
						sy = ((y + Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(((off+i)+1))*14)).Y)) >> 1)
					} else {
						//  otherwise just use the next point as our start point
						sx = Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(((off+i)+1))*14)).X)
						sy = Stbtt_int32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(((off+i)+1))*14)).Y)
						i++ //  we're using point i+1 as the starting point, so skip it
					}
				} else {
					sx = x
					sy = y
				}
				stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vmove, sx, sy, 0, 0)
				was_off = 0
				next_move = (1 + int32(ttUSHORT((endPtsOfContours + uintptr((j * 2))))))
				j++
			} else {
				if !((int32(flags) & 1) != 0) { //  if it's a curve
					if was_off != 0 { //  two off-curve control points in a row means interpolate an on-curve midpoint
						stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vcurve, ((cx + x) >> 1), ((cy + y) >> 1), cx, cy)
					}
					cx = x
					cy = y
					was_off = 1
				} else {
					if was_off != 0 {
						stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vcurve, x, y, cx, cy)
					} else {
						stbtt_setvertex((vertices + uintptr(PostIncInt32(&num_vertices, 1))*14), STBTT_vline, x, y, 0, 0)
					}
					was_off = 0
				}
			}
		}
		num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy)
	} else if int32(numberOfContours) < 0 {
		//  Compound shapes.
		var more int32 = 1
		var comp uintptr = ((data + uintptr(g)) + uintptr(10))
		num_vertices = 0
		vertices = uintptr(0)
		for more != 0 {
			var flags Stbtt_uint16
			var gidx Stbtt_uint16
			var comp_num_verts int32 = 0
			var i int32
			*(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)) = uintptr(0)
			var tmp uintptr = uintptr(0)
			*(*[6]float32)(unsafe.Pointer(bp /* mtx */)) = [6]float32{float32(1), float32(0), float32(0), float32(1), float32(0), float32(0)}
			var m float32
			var n float32

			flags = Stbtt_uint16(ttSHORT(comp))
			comp += uintptr(2)
			gidx = Stbtt_uint16(ttSHORT(comp))
			comp += uintptr(2)

			if (int32(flags) & 2) != 0 { //  XY values
				if (int32(flags) & 1) != 0 { //  shorts
					*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 4*4)) = float32(ttSHORT(comp))
					comp += uintptr(2)
					*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 5*4)) = float32(ttSHORT(comp))
					comp += uintptr(2)
				} else {
					*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 4*4)) = float32(*(*Stbtt_int8)(unsafe.Pointer(comp)))
					comp += uintptr(1)
					*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 5*4)) = float32(*(*Stbtt_int8)(unsafe.Pointer(comp)))
					comp += uintptr(1)
				}
			} else {
				//  @TODO handle matching point
				if 0 != 0 {
				} else {
					X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(13071), uintptr(unsafe.Pointer(&__func__118)))
				}
			}
			if (int32(flags) & (int32(1) << 3)) != 0 { //  WE_HAVE_A_SCALE
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) = AssignPtrFloat32(bp /* &mtx */ +3*4, (float32(ttSHORT(comp)) / 16384.0))
				comp += uintptr(2)
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) = AssignPtrFloat32(bp /* &mtx */ +2*4, float32(0))
			} else if (int32(flags) & (int32(1) << 6)) != 0 { //  WE_HAVE_AN_X_AND_YSCALE
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) = AssignPtrFloat32(bp /* &mtx */ +2*4, float32(0))
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
			} else if (int32(flags) & (int32(1) << 7)) != 0 { //  WE_HAVE_A_TWO_BY_TWO
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 2*4)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
				*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)) = (float32(ttSHORT(comp)) / 16384.0)
				comp += uintptr(2)
			}

			//  Find transformation scales.
			m = float32(Xsqrt((float64((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) * *(*float32)(unsafe.Pointer(bp /* &mtx[0] */))) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) * *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)))))))
			n = float32(Xsqrt((float64((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 2*4)) * *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 2*4))) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)) * *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)))))))

			//  Get indexed glyph.
			comp_num_verts = Xstbtt_GetGlyphShape(info, int32(gidx), bp+24 /* &comp_verts */)
			if comp_num_verts > 0 {
				//  Transform vertices.
				for i = 0; i < comp_num_verts; i++ {
					var v uintptr = (*(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)) + uintptr(i)*14)
					var x int16
					var y int16
					x = (*Stbtt_vertex)(unsafe.Pointer(v)).X
					y = (*Stbtt_vertex)(unsafe.Pointer(v)).Y
					(*Stbtt_vertex)(unsafe.Pointer(v)).X = (int16(m * (((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) * float32(x)) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 2*4)) * float32(y))) + *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 4*4)))))
					(*Stbtt_vertex)(unsafe.Pointer(v)).Y = (int16(n * (((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) * float32(x)) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)) * float32(y))) + *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 5*4)))))
					x = (*Stbtt_vertex)(unsafe.Pointer(v)).Cx
					y = (*Stbtt_vertex)(unsafe.Pointer(v)).Cy
					(*Stbtt_vertex)(unsafe.Pointer(v)).Cx = (int16(m * (((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */)) * float32(x)) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 2*4)) * float32(y))) + *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 4*4)))))
					(*Stbtt_vertex)(unsafe.Pointer(v)).Cy = (int16(n * (((*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 1*4)) * float32(x)) + (*(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 3*4)) * float32(y))) + *(*float32)(unsafe.Pointer(bp /* &mtx[0] */ + 5*4)))))
				}
				//  Append vertices.
				tmp = nk_stbtt_malloc(((uint32(num_vertices + comp_num_verts)) * uint32(unsafe.Sizeof(Stbtt_vertex{}))), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
				if !(tmp != 0) {
					if vertices != 0 {
						nk_stbtt_free(vertices, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
					}
					if *(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)) != 0 {
						nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
					}
					return 0
				}
				if num_vertices > 0 {
					Xmemcpy(tmp, vertices, (uint32(num_vertices) * uint32(unsafe.Sizeof(Stbtt_vertex{}))))
				}
				Xmemcpy((tmp + uintptr(num_vertices)*14), *(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)), (uint32(comp_num_verts) * uint32(unsafe.Sizeof(Stbtt_vertex{}))))
				if vertices != 0 {
					nk_stbtt_free(vertices, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
				}
				vertices = tmp
				nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp + 24 /* comp_verts */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
				num_vertices = num_vertices + (comp_num_verts)
			}
			//  More components ?
			more = (int32(flags) & (int32(1) << 5))
		}
	} else {
		//  numberOfCounters == 0, do nothing
	}

	*(*uintptr)(unsafe.Pointer(pvertices)) = vertices
	return num_vertices
}

var __func__118 = *(*[23]int8)(unsafe.Pointer(ts + 3651 /* "stbtt__GetGlyphS..." */)) /* nuklear.h:12908:1 */

type Stbtt__csctx = struct {
	Bounds       int32
	Started      int32
	First_x      float32
	First_y      float32
	X            float32
	Y            float32
	Min_x        Stbtt_int32
	Max_x        Stbtt_int32
	Min_y        Stbtt_int32
	Max_y        Stbtt_int32
	Pvertices    uintptr
	Num_vertices int32
} /* nuklear.h:13140:3 */

func stbtt__track_vertex(c uintptr, x Stbtt_int32, y Stbtt_int32) { /* nuklear.h:13144:13: */
	if (x > (*Stbtt__csctx)(unsafe.Pointer(c)).Max_x) || !((*Stbtt__csctx)(unsafe.Pointer(c)).Started != 0) {
		(*Stbtt__csctx)(unsafe.Pointer(c)).Max_x = x
	}
	if (y > (*Stbtt__csctx)(unsafe.Pointer(c)).Max_y) || !((*Stbtt__csctx)(unsafe.Pointer(c)).Started != 0) {
		(*Stbtt__csctx)(unsafe.Pointer(c)).Max_y = y
	}
	if (x < (*Stbtt__csctx)(unsafe.Pointer(c)).Min_x) || !((*Stbtt__csctx)(unsafe.Pointer(c)).Started != 0) {
		(*Stbtt__csctx)(unsafe.Pointer(c)).Min_x = x
	}
	if (y < (*Stbtt__csctx)(unsafe.Pointer(c)).Min_y) || !((*Stbtt__csctx)(unsafe.Pointer(c)).Started != 0) {
		(*Stbtt__csctx)(unsafe.Pointer(c)).Min_y = y
	}
	(*Stbtt__csctx)(unsafe.Pointer(c)).Started = 1
}

func stbtt__csctx_v(c uintptr, type1 Stbtt_uint8, x Stbtt_int32, y Stbtt_int32, cx Stbtt_int32, cy Stbtt_int32, cx1 Stbtt_int32, cy1 Stbtt_int32) { /* nuklear.h:13153:13: */
	if (*Stbtt__csctx)(unsafe.Pointer(c)).Bounds != 0 {
		stbtt__track_vertex(c, x, y)
		if int32(type1) == STBTT_vcubic {
			stbtt__track_vertex(c, cx, cy)
			stbtt__track_vertex(c, cx1, cy1)
		}
	} else {
		stbtt_setvertex(((*Stbtt__csctx)(unsafe.Pointer(c)).Pvertices + uintptr((*Stbtt__csctx)(unsafe.Pointer(c)).Num_vertices)*14), type1, x, y, cx, cy)
		(*Stbtt_vertex)(unsafe.Pointer((*Stbtt__csctx)(unsafe.Pointer(c)).Pvertices + uintptr((*Stbtt__csctx)(unsafe.Pointer(c)).Num_vertices)*14)).Cx1 = Stbtt_int16(cx1)
		(*Stbtt_vertex)(unsafe.Pointer((*Stbtt__csctx)(unsafe.Pointer(c)).Pvertices + uintptr((*Stbtt__csctx)(unsafe.Pointer(c)).Num_vertices)*14)).Cy1 = Stbtt_int16(cy1)
	}
	(*Stbtt__csctx)(unsafe.Pointer(c)).Num_vertices++
}

func stbtt__csctx_close_shape(ctx uintptr) { /* nuklear.h:13169:13: */
	if ((*Stbtt__csctx)(unsafe.Pointer(ctx)).First_x != (*Stbtt__csctx)(unsafe.Pointer(ctx)).X) || ((*Stbtt__csctx)(unsafe.Pointer(ctx)).First_y != (*Stbtt__csctx)(unsafe.Pointer(ctx)).Y) {
		stbtt__csctx_v(ctx, STBTT_vline, int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).First_x), int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).First_y), 0, 0, 0, 0)
	}
}

func stbtt__csctx_rmove_to(ctx uintptr, dx float32, dy float32) { /* nuklear.h:13175:13: */
	stbtt__csctx_close_shape(ctx)
	(*Stbtt__csctx)(unsafe.Pointer(ctx)).First_x = AssignPtrFloat32(ctx+16 /* &.x */, ((*Stbtt__csctx)(unsafe.Pointer(ctx)).X + dx))
	(*Stbtt__csctx)(unsafe.Pointer(ctx)).First_y = AssignPtrFloat32(ctx+20 /* &.y */, ((*Stbtt__csctx)(unsafe.Pointer(ctx)).Y + dy))
	stbtt__csctx_v(ctx, STBTT_vmove, int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).X), int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).Y), 0, 0, 0, 0)
}

func stbtt__csctx_rline_to(ctx uintptr, dx float32, dy float32) { /* nuklear.h:13183:13: */
	*(*float32)(unsafe.Pointer(ctx + 16 /* &.x */)) += (dx)
	*(*float32)(unsafe.Pointer(ctx + 20 /* &.y */)) += (dy)
	stbtt__csctx_v(ctx, STBTT_vline, int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).X), int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).Y), 0, 0, 0, 0)
}

func stbtt__csctx_rccurve_to(ctx uintptr, dx1 float32, dy1 float32, dx2 float32, dy2 float32, dx3 float32, dy3 float32) { /* nuklear.h:13190:13: */
	var cx1 float32 = ((*Stbtt__csctx)(unsafe.Pointer(ctx)).X + dx1)
	var cy1 float32 = ((*Stbtt__csctx)(unsafe.Pointer(ctx)).Y + dy1)
	var cx2 float32 = (cx1 + dx2)
	var cy2 float32 = (cy1 + dy2)
	(*Stbtt__csctx)(unsafe.Pointer(ctx)).X = (cx2 + dx3)
	(*Stbtt__csctx)(unsafe.Pointer(ctx)).Y = (cy2 + dy3)
	stbtt__csctx_v(ctx, STBTT_vcubic, int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).X), int32((*Stbtt__csctx)(unsafe.Pointer(ctx)).Y), int32(cx1), int32(cy1), int32(cx2), int32(cy2))
}

func stbtt__get_subr(idx Stbtt__buf, n int32) Stbtt__buf { /* nuklear.h:13201:19: */
	bp := tlsAlloc(12)
	defer tlsFree(12)
	*(*Stbtt__buf)(unsafe.Pointer(bp)) = idx

	var count int32 = stbtt__cff_index_count(bp /* &idx */)
	var bias int32 = 107
	if count >= 33900 {
		bias = 32768
	} else if count >= 1240 {
		bias = 1131
	}
	n = n + (bias)
	if (n < 0) || (n >= count) {
		return stbtt__new_buf(uintptr(0), uint32(0))
	}
	return stbtt__cff_index_get(*(*Stbtt__buf)(unsafe.Pointer(bp /* idx */)), n)
}

func stbtt__cid_get_glyph_subrs(info uintptr, glyph_index int32) Stbtt__buf { /* nuklear.h:13215:19: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	*(*Stbtt__buf)(unsafe.Pointer(bp /* fdselect */)) = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Fdselect
	var nranges int32
	var start int32
	var end int32
	var v int32
	var fmt int32
	var fdselector int32 = -1
	var i int32

	stbtt__buf_seek(bp /* &fdselect */, 0)
	fmt = int32(stbtt__buf_get8(bp /* &fdselect */))
	if fmt == 0 {
		//  untested
		stbtt__buf_skip(bp /* &fdselect */, glyph_index)
		fdselector = int32(stbtt__buf_get8(bp /* &fdselect */))
	} else if fmt == 3 {
		nranges = int32(stbtt__buf_get(bp /* &fdselect */, 2))
		start = int32(stbtt__buf_get(bp /* &fdselect */, 2))
		for i = 0; i < nranges; i++ {
			v = int32(stbtt__buf_get8(bp /* &fdselect */))
			end = int32(stbtt__buf_get(bp /* &fdselect */, 2))
			if (glyph_index >= start) && (glyph_index < end) {
				fdselector = v
				break
			}
			start = end
		}
	}
	if fdselector == -1 {
		stbtt__new_buf(uintptr(0), uint32(0))
	}
	return stbtt__get_subrs((*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff, stbtt__cff_index_get((*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontdicts, fdselector))
}

func stbtt__run_charstring(info uintptr, glyph_index int32, c uintptr) int32 { /* nuklear.h:13243:12: */
	bp := tlsAlloc(324)
	defer tlsFree(324)

	var in_header int32
	var maskbits int32
	var subr_stack_height int32
	var sp int32
	var v int32
	var i int32
	var b0 int32
	var has_subrs int32
	var clear_stack int32
	// var s [48]float32 at bp+12, 192

	// var subr_stack [10]Stbtt__buf at bp+204, 120

	var subrs Stbtt__buf
	// var b Stbtt__buf at bp, 12

	var f float32 //  two-byte escape
	var dx1 float32
	var dx2 float32
	var dx3 float32
	var dx4 float32
	var dx5 float32
	var dx6 float32
	var dy1 float32
	var dy2 float32
	var dy3 float32
	var dy4 float32
	var dy5 float32
	var dy6 float32
	var dx float32
	var dy float32
	var b1 int32
	in_header = 1
	maskbits = 0
	subr_stack_height = 0
	sp = 0
	has_subrs = 0
	subrs = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Subrs

	//  this currently ignores the initial width value, which isn't needed if we have hmtx
	*(*Stbtt__buf)(unsafe.Pointer(bp /* b */)) = stbtt__cff_index_get((*Stbtt_fontinfo)(unsafe.Pointer(info)).Charstrings, glyph_index)
__1:
	if !((*Stbtt__buf)(unsafe.Pointer(bp /* &b */)).Cursor < (*Stbtt__buf)(unsafe.Pointer(bp /* &b */)).Size) {
		goto __2
	}
	i = 0
	clear_stack = 1
	b0 = int32(stbtt__buf_get8(bp /* &b */))
	switch b0 {
	//  @TODO implement hinting
	case 0x13:
		goto __4 //  hintmask
	case 0x14:
		goto __5

	case 0x01:
		goto __6 //  hstem
	case 0x03:
		goto __7 //  vstem
	case 0x12:
		goto __8 //  hstemhm
	case 0x17:
		goto __9

	case 0x15:
		goto __10
	case 0x04:
		goto __11
	case 0x16:
		goto __12

	case 0x05:
		goto __13

	//  hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
	//  starting from a different place.

	case 0x07:
		goto __14
	case 0x06:
		goto __15

	case 0x1F:
		goto __16
	case 0x1E:
		goto __17

	case 0x08:
		goto __18

	case 0x18:
		goto __19

	case 0x19:
		goto __20

	case 0x1A:
		goto __21 //  vvcurveto
	case 0x1B:
		goto __22

	case 0x0A:
		goto __23
		//  fallthrough
	case 0x1D:
		goto __24

	case 0x0B:
		goto __25

	case 0x0E:
		goto __26

	case 0x0C:
		goto __27

	default:
		goto __28
	}
	goto __3
	//  @TODO implement hinting
__4: //  hintmask
__5: //  cntrmask
	if !(in_header != 0) {
		goto __29
	}
	maskbits = maskbits + (sp / 2)
__29:
	; //  implicit "vstem"
	in_header = 0
	stbtt__buf_skip(bp /* &b */, ((maskbits + 7) / 8))
	goto __3

__6: //  hstem
__7: //  vstem
__8: //  hstemhm
__9: //  vstemhm
	maskbits = maskbits + (sp / 2)
	goto __3

__10: //  rmoveto
	in_header = 0
	if !(sp < 2) {
		goto __30
	}
	return 0
__30:
	;
	stbtt__csctx_rmove_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((sp-2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((sp-1))*4)))
	goto __3
__11: //  vmoveto
	in_header = 0
	if !(sp < 1) {
		goto __31
	}
	return 0
__31:
	;
	stbtt__csctx_rmove_to(c, float32(0), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((sp-1))*4)))
	goto __3
__12: //  hmoveto
	in_header = 0
	if !(sp < 1) {
		goto __32
	}
	return 0
__32:
	;
	stbtt__csctx_rmove_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((sp-1))*4)), float32(0))
	goto __3

__13: //  rlineto
	if !(sp < 2) {
		goto __33
	}
	return 0
__33:
	;
__34:
	if !((i + 1) < sp) {
		goto __36
	}
	stbtt__csctx_rline_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)))
	goto __35
__35:
	i = i + (2)
	goto __34
	goto __36
__36:
	;
	goto __3

	//  hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
	//  starting from a different place.

__14: //  vlineto
	if !(sp < 1) {
		goto __37
	}
	return 0
__37:
	;
	goto vlineto
__15: //  hlineto
	if !(sp < 1) {
		goto __38
	}
	return 0
__38:
	;
__39:
	if !(i >= sp) {
		goto __42
	}
	goto __41
__42:
	;
	stbtt__csctx_rline_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), float32(0))
	i++
vlineto:
	if !(i >= sp) {
		goto __43
	}
	goto __41
__43:
	;
	stbtt__csctx_rline_to(c, float32(0), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)))
	i++
	goto __40
__40:
	goto __39
	goto __41
__41:
	;
	goto __3

__16: //  hvcurveto
	if !(sp < 4) {
		goto __44
	}
	return 0
__44:
	;
	goto hvcurveto
__17: //  vhcurveto
	if !(sp < 4) {
		goto __45
	}
	return 0
__45:
	;
__46:
	if !((i + 3) >= sp) {
		goto __49
	}
	goto __48
__49:
	;
	stbtt__csctx_rccurve_to(c, float32(0), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)), func() float32 {
		if (sp - i) == 5 {
			return *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+4))*4))
		}
		return 0.0
	}())
	i = i + (4)
hvcurveto:
	if !((i + 3) >= sp) {
		goto __50
	}
	goto __48
__50:
	;
	stbtt__csctx_rccurve_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), float32(0), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), func() float32 {
		if (sp - i) == 5 {
			return *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+4))*4))
		}
		return 0.0
	}(), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)))
	i = i + (4)
	goto __47
__47:
	goto __46
	goto __48
__48:
	;
	goto __3

__18: //  rrcurveto
	if !(sp < 6) {
		goto __51
	}
	return 0
__51:
	;
__52:
	if !((i + 5) < sp) {
		goto __54
	}
	stbtt__csctx_rccurve_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+4))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+5))*4)))
	goto __53
__53:
	i = i + (6)
	goto __52
	goto __54
__54:
	;
	goto __3

__19: //  rcurveline
	if !(sp < 8) {
		goto __55
	}
	return 0
__55:
	;
__56:
	if !((i + 5) < (sp - 2)) {
		goto __58
	}
	stbtt__csctx_rccurve_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+4))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+5))*4)))
	goto __57
__57:
	i = i + (6)
	goto __56
	goto __58
__58:
	;
	if !((i + 1) >= sp) {
		goto __59
	}
	return 0
__59:
	;
	stbtt__csctx_rline_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)))
	goto __3

__20: //  rlinecurve
	if !(sp < 8) {
		goto __60
	}
	return 0
__60:
	;
__61:
	if !((i + 1) < (sp - 6)) {
		goto __63
	}
	stbtt__csctx_rline_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)))
	goto __62
__62:
	i = i + (2)
	goto __61
	goto __63
__63:
	;
	if !((i + 5) >= sp) {
		goto __64
	}
	return 0
__64:
	;
	stbtt__csctx_rccurve_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+4))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+5))*4)))
	goto __3

__21: //  vvcurveto
__22: //  hhcurveto
	if !(sp < 4) {
		goto __65
	}
	return 0
__65:
	;
	f = 0.0
	if !((sp & 1) != 0) {
		goto __66
	}
	f = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4))
	i++
__66:
	;
__67:
	if !((i + 3) < sp) {
		goto __69
	}
	if !(b0 == 0x1B) {
		goto __70
	}
	stbtt__csctx_rccurve_to(c, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), f, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)), 0.0)
	goto __71
__70:
	stbtt__csctx_rccurve_to(c, f, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(i)*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+1))*4)), *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+2))*4)), 0.0, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr((i+3))*4)))
__71:
	;
	f = 0.0
	goto __68
__68:
	i = i + (4)
	goto __67
	goto __69
__69:
	;
	goto __3

__23: //  callsubr
	if !(!(has_subrs != 0)) {
		goto __72
	}
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Fdselect.Size != 0) {
		goto __73
	}
	subrs = stbtt__cid_get_glyph_subrs(info, glyph_index)
__73:
	;
	has_subrs = 1
__72:
	;
	//  fallthrough
__24: //  callgsubr
	if !(sp < 1) {
		goto __74
	}
	return 0
__74:
	;
	v = int32(*(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(PreDecInt32(&sp, 1))*4)))
	if !(subr_stack_height >= 10) {
		goto __75
	}
	return 0
__75:
	;
	*(*Stbtt__buf)(unsafe.Pointer(bp + 204 /* &subr_stack[0] */ + uintptr(PostIncInt32(&subr_stack_height, 1))*12)) = *(*Stbtt__buf)(unsafe.Pointer(bp /* b */))
	*(*Stbtt__buf)(unsafe.Pointer(bp /* b */)) = stbtt__get_subr(func() struct {
		Data   uintptr
		Cursor int32
		Size   int32
	} {
		if b0 == 0x0A {
			return subrs
		}
		return (*Stbtt_fontinfo)(unsafe.Pointer(info)).Gsubrs
	}(), v)
	if !((*Stbtt__buf)(unsafe.Pointer(bp /* &b */)).Size == 0) {
		goto __76
	}
	return 0
__76:
	;
	(*Stbtt__buf)(unsafe.Pointer(bp /* &b */)).Cursor = 0
	clear_stack = 0
	goto __3

__25: //  return
	if !(subr_stack_height <= 0) {
		goto __77
	}
	return 0
__77:
	;
	*(*Stbtt__buf)(unsafe.Pointer(bp /* b */)) = *(*Stbtt__buf)(unsafe.Pointer(bp + 204 /* &subr_stack[0] */ + uintptr(PreDecInt32(&subr_stack_height, 1))*12))
	clear_stack = 0
	goto __3

__26: //  endchar
	stbtt__csctx_close_shape(c)
	return 1

__27:
	b1 = int32(stbtt__buf_get8(bp /* &b */))
	switch b1 {
	//  @TODO These "flex" implementations ignore the flex-depth and resolution,
	//  and always draw beziers.
	case 0x22:
		goto __79

	case 0x23:
		goto __80

	case 0x24:
		goto __81

	case 0x25:
		goto __82

	default:
		goto __83
	}
	goto __78
	//  @TODO These "flex" implementations ignore the flex-depth and resolution,
	//  and always draw beziers.
__79: //  hflex
	if !(sp < 7) {
		goto __84
	}
	return 0
__84:
	;
	dx1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */))
	dx2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 1*4))
	dy2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 2*4))
	dx3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 3*4))
	dx4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 4*4))
	dx5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 5*4))
	dx6 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 6*4))
	stbtt__csctx_rccurve_to(c, dx1, float32(0), dx2, dy2, dx3, float32(0))
	stbtt__csctx_rccurve_to(c, dx4, float32(0), dx5, -dy2, dx6, float32(0))
	goto __78

__80: //  flex
	if !(sp < 13) {
		goto __85
	}
	return 0
__85:
	;
	dx1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */))
	dy1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 1*4))
	dx2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 2*4))
	dy2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 3*4))
	dx3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 4*4))
	dy3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 5*4))
	dx4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 6*4))
	dy4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 7*4))
	dx5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 8*4))
	dy5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 9*4))
	dx6 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 10*4))
	dy6 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 11*4))
	// fd is s[12]
	stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3)
	stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6)
	goto __78

__81: //  hflex1
	if !(sp < 9) {
		goto __86
	}
	return 0
__86:
	;
	dx1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */))
	dy1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 1*4))
	dx2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 2*4))
	dy2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 3*4))
	dx3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 4*4))
	dx4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 5*4))
	dx5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 6*4))
	dy5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 7*4))
	dx6 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 8*4))
	stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, float32(0))
	stbtt__csctx_rccurve_to(c, dx4, float32(0), dx5, dy5, dx6, -((dy1 + dy2) + dy5))
	goto __78

__82: //  flex1
	if !(sp < 11) {
		goto __87
	}
	return 0
__87:
	;
	dx1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */))
	dy1 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 1*4))
	dx2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 2*4))
	dy2 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 3*4))
	dx3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 4*4))
	dy3 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 5*4))
	dx4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 6*4))
	dy4 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 7*4))
	dx5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 8*4))
	dy5 = *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 9*4))
	dx6 = AssignFloat32(&dy6, *(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + 10*4)))
	dx = ((((dx1 + dx2) + dx3) + dx4) + dx5)
	dy = ((((dy1 + dy2) + dy3) + dy4) + dy5)
	if !(Xfabs(float64(dx)) > Xfabs(float64(dy))) {
		goto __88
	}
	dy6 = -dy
	goto __89
__88:
	dx6 = -dx
__89:
	;
	stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3)
	stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6)
	goto __78

__83:
	return 0
__78:
	;
	goto __3

__28:
	if !(((b0 != 255) && (b0 != 28)) && ((b0 < 32) || (b0 > 254))) {
		goto __90
	}
	return 0
__90:
	;

	//  push immediate
	if !(b0 == 255) {
		goto __91
	}
	f = (float32(Stbtt_int32(stbtt__buf_get(bp /* &b */, 4))) / float32(0x10000))
	goto __92
__91:
	stbtt__buf_skip(bp /* &b */, -1)
	f = float32(Stbtt_int16(stbtt__cff_int(bp /* &b */)))
__92:
	;
	if !(sp >= 48) {
		goto __93
	}
	return 0
__93:
	;
	*(*float32)(unsafe.Pointer(bp + 12 /* &s[0] */ + uintptr(PostIncInt32(&sp, 1))*4)) = f
	clear_stack = 0
	goto __3
__3:
	;
	if !(clear_stack != 0) {
		goto __94
	}
	sp = 0
__94:
	;
	goto __1
__2:
	;
	return 0

}

func stbtt__GetGlyphShapeT2(info uintptr, glyph_index int32, pvertices uintptr) int32 { /* nuklear.h:13502:12: */
	bp := tlsAlloc(96)
	defer tlsFree(96)

	//  runs the charstring twice, once to count and once to output (to avoid realloc)
	*(*Stbtt__csctx)(unsafe.Pointer(bp /* count_ctx */)) = Stbtt__csctx{Bounds: 1}
	*(*Stbtt__csctx)(unsafe.Pointer(bp + 48 /* output_ctx */)) = Stbtt__csctx{}
	if stbtt__run_charstring(info, glyph_index, bp /* &count_ctx */) != 0 {
		*(*uintptr)(unsafe.Pointer(pvertices)) = nk_stbtt_malloc((uint32((*Stbtt__csctx)(unsafe.Pointer(bp /* &count_ctx */)).Num_vertices) * uint32(unsafe.Sizeof(Stbtt_vertex{}))), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		(*Stbtt__csctx)(unsafe.Pointer(bp + 48 /* &output_ctx */)).Pvertices = *(*uintptr)(unsafe.Pointer(pvertices))
		if stbtt__run_charstring(info, glyph_index, bp+48 /* &output_ctx */) != 0 {
			if (*Stbtt__csctx)(unsafe.Pointer(bp+48 /* &output_ctx */)).Num_vertices == (*Stbtt__csctx)(unsafe.Pointer(bp /* &count_ctx */)).Num_vertices {
			} else {
				X__assert_fail(ts+3674 /* "output_ctx.num_v..." */, ts+2 /* "nuklear/nuklear...." */, uint32(13511), uintptr(unsafe.Pointer(&__func__119)))
			}
			return (*Stbtt__csctx)(unsafe.Pointer(bp + 48 /* &output_ctx */)).Num_vertices
		}
	}
	*(*uintptr)(unsafe.Pointer(pvertices)) = uintptr(0)
	return 0
}

var __func__119 = *(*[23]int8)(unsafe.Pointer(ts + 3724 /* "stbtt__GetGlyphS..." */)) /* nuklear.h:13503:1 */

func stbtt__GetGlyphInfoT2(info uintptr, glyph_index int32, x0 uintptr, y0 uintptr, x1 uintptr, y1 uintptr) int32 { /* nuklear.h:13519:12: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	*(*Stbtt__csctx)(unsafe.Pointer(bp /* c */)) = Stbtt__csctx{Bounds: 1}
	var r int32 = stbtt__run_charstring(info, glyph_index, bp /* &c */)
	if x0 != 0 {
		*(*int32)(unsafe.Pointer(x0)) = func() int32 {
			if r != 0 {
				return (*Stbtt__csctx)(unsafe.Pointer(bp /* &c */)).Min_x
			}
			return 0
		}()
	}
	if y0 != 0 {
		*(*int32)(unsafe.Pointer(y0)) = func() int32 {
			if r != 0 {
				return (*Stbtt__csctx)(unsafe.Pointer(bp /* &c */)).Min_y
			}
			return 0
		}()
	}
	if x1 != 0 {
		*(*int32)(unsafe.Pointer(x1)) = func() int32 {
			if r != 0 {
				return (*Stbtt__csctx)(unsafe.Pointer(bp /* &c */)).Max_x
			}
			return 0
		}()
	}
	if y1 != 0 {
		*(*int32)(unsafe.Pointer(y1)) = func() int32 {
			if r != 0 {
				return (*Stbtt__csctx)(unsafe.Pointer(bp /* &c */)).Max_y
			}
			return 0
		}()
	}
	if r != 0 {
		return (*Stbtt__csctx)(unsafe.Pointer(bp /* &c */)).Num_vertices
	}
	return 0
}

func Xstbtt_GetGlyphShape(info uintptr, glyph_index int32, pvertices uintptr) int32 { /* nuklear.h:13530:15: */
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Cff.Size != 0) {
		return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices)
	} else {
		return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices)
	}
	return int32(0)
}

func Xstbtt_GetGlyphHMetrics(info uintptr, glyph_index int32, advanceWidth uintptr, leftSideBearing uintptr) { /* nuklear.h:13538:16: */
	var numOfLongHorMetrics Stbtt_uint16 = ttUSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(34)))
	if glyph_index < int32(numOfLongHorMetrics) {
		if advanceWidth != 0 {
			*(*int32)(unsafe.Pointer(advanceWidth)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx)) + uintptr((4 * glyph_index)))))
		}
		if leftSideBearing != 0 {
			*(*int32)(unsafe.Pointer(leftSideBearing)) = int32(ttSHORT(((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx)) + uintptr((4 * glyph_index))) + uintptr(2))))
		}
	} else {
		if advanceWidth != 0 {
			*(*int32)(unsafe.Pointer(advanceWidth)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx)) + uintptr((4 * (int32(numOfLongHorMetrics) - 1))))))
		}
		if leftSideBearing != 0 {
			*(*int32)(unsafe.Pointer(leftSideBearing)) = int32(ttSHORT(((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hmtx)) + uintptr((4 * int32(numOfLongHorMetrics)))) + uintptr((2 * (glyph_index - int32(numOfLongHorMetrics)))))))
		}
	}
}

func Xstbtt_GetKerningTableLength(info uintptr) int32 { /* nuklear.h:13550:16: */
	var data uintptr = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern))

	//  we only look at the first table. it must be 'horizontal' and format 0.
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern != 0) {
		return 0
	}
	if int32(ttUSHORT((data + uintptr(2)))) < 1 { //  number of tables, need at least 1
		return 0
	}
	if int32(ttUSHORT((data + uintptr(8)))) != 1 { //  horizontal flag must be set in format
		return 0
	}

	return int32(ttUSHORT((data + uintptr(10))))
}

func Xstbtt_GetKerningTable(info uintptr, table uintptr, table_length int32) int32 { /* nuklear.h:13565:15: */
	var data uintptr = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern))
	var k int32
	var length int32

	//  we only look at the first table. it must be 'horizontal' and format 0.
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern != 0) {
		return 0
	}
	if int32(ttUSHORT((data + uintptr(2)))) < 1 { //  number of tables, need at least 1
		return 0
	}
	if int32(ttUSHORT((data + uintptr(8)))) != 1 { //  horizontal flag must be set in format
		return 0
	}

	length = int32(ttUSHORT((data + uintptr(10))))
	if table_length < length {
		length = table_length
	}

	for k = 0; k < length; k++ {
		(*Stbtt_kerningentry)(unsafe.Pointer(table + uintptr(k)*12)).Glyph1 = int32(ttUSHORT(((data + uintptr(18)) + uintptr((k * 6)))))
		(*Stbtt_kerningentry)(unsafe.Pointer(table + uintptr(k)*12)).Glyph2 = int32(ttUSHORT(((data + uintptr(20)) + uintptr((k * 6)))))
		(*Stbtt_kerningentry)(unsafe.Pointer(table + uintptr(k)*12)).Advance = int32(ttSHORT(((data + uintptr(22)) + uintptr((k * 6)))))
	}

	return length
}

func stbtt__GetGlyphKernInfoAdvance(info uintptr, glyph1 int32, glyph2 int32) int32 { /* nuklear.h:13592:13: */
	var data uintptr = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern))
	var needle Stbtt_uint32
	var straw Stbtt_uint32
	var l int32
	var r int32
	var m int32

	//  we only look at the first table. it must be 'horizontal' and format 0.
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern != 0) {
		return 0
	}
	if int32(ttUSHORT((data + uintptr(2)))) < 1 { //  number of tables, need at least 1
		return 0
	}
	if int32(ttUSHORT((data + uintptr(8)))) != 1 { //  horizontal flag must be set in format
		return 0
	}

	l = 0
	r = (int32(ttUSHORT((data + uintptr(10)))) - 1)
	needle = (Stbtt_uint32((glyph1 << 16) | glyph2))
	for l <= r {
		m = ((l + r) >> 1)
		straw = ttULONG(((data + uintptr(18)) + uintptr((m * 6)))) //  note: unaligned read
		if needle < straw {
			r = (m - 1)
		} else if needle > straw {
			l = (m + 1)
		} else {
			return int32(ttSHORT(((data + uintptr(22)) + uintptr((m * 6)))))
		}
	}
	return 0
}

func stbtt__GetCoverageIndex(coverageTable uintptr, glyph int32) Stbtt_int32 { /* nuklear.h:13622:21: */
	var coverageFormat Stbtt_uint16 = ttUSHORT(coverageTable)
	switch int32(coverageFormat) {
	case 1:
		{
			var glyphCount Stbtt_uint16 = ttUSHORT((coverageTable + uintptr(2)))

			//  Binary search.
			var l Stbtt_int32 = 0
			var r Stbtt_int32 = (int32(glyphCount) - 1)
			var m Stbtt_int32
			var straw int32
			var needle int32 = glyph
			for l <= r {
				var glyphArray uintptr = (coverageTable + uintptr(4))
				var glyphID Stbtt_uint16
				m = ((l + r) >> 1)
				glyphID = ttUSHORT((glyphArray + uintptr((2 * m))))
				straw = int32(glyphID)
				if needle < straw {
					r = (m - 1)
				} else if needle > straw {
					l = (m + 1)
				} else {
					return m
				}
			}

		}
		break

	case 2:
		{
			var rangeCount Stbtt_uint16 = ttUSHORT((coverageTable + uintptr(2)))
			var rangeArray uintptr = (coverageTable + uintptr(4))

			//  Binary search.
			var l Stbtt_int32 = 0
			var r Stbtt_int32 = (int32(rangeCount) - 1)
			var m Stbtt_int32
			var strawStart int32
			var strawEnd int32
			var needle int32 = glyph
			for l <= r {
				var rangeRecord uintptr
				m = ((l + r) >> 1)
				rangeRecord = (rangeArray + uintptr((6 * m)))
				strawStart = int32(ttUSHORT(rangeRecord))
				strawEnd = int32(ttUSHORT((rangeRecord + uintptr(2))))
				if needle < strawStart {
					r = (m - 1)
				} else if needle > strawEnd {
					l = (m + 1)
				} else {
					var startCoverageIndex Stbtt_uint16 = ttUSHORT((rangeRecord + uintptr(4)))
					return ((int32(startCoverageIndex) + glyph) - strawStart)
				}
			}

		}
		break

	default:
		{
			//  There are no other cases.
			if 0 != 0 {
			} else {
				X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(13674), uintptr(unsafe.Pointer(&__func__120)))
			}

		}
		break
	}

	return -1
}

var __func__120 = *(*[24]int8)(unsafe.Pointer(ts + 3747 /* "stbtt__GetCovera..." */)) /* nuklear.h:13623:1 */

func stbtt__GetGlyphClass(classDefTable uintptr, glyph int32) Stbtt_int32 { /* nuklear.h:13681:21: */
	var classDefFormat Stbtt_uint16 = ttUSHORT(classDefTable)
	switch int32(classDefFormat) {
	case 1:
		{
			var startGlyphID Stbtt_uint16 = ttUSHORT((classDefTable + uintptr(2)))
			var glyphCount Stbtt_uint16 = ttUSHORT((classDefTable + uintptr(4)))
			var classDef1ValueArray uintptr = (classDefTable + uintptr(6))

			if (glyph >= int32(startGlyphID)) && (glyph < (int32(startGlyphID) + int32(glyphCount))) {
				return Stbtt_int32(ttUSHORT((classDef1ValueArray + uintptr((2 * (glyph - int32(startGlyphID)))))))
			}

			classDefTable = (classDef1ValueArray + uintptr((2 * int32(glyphCount))))

		}
		break

	case 2:
		{
			var classRangeCount Stbtt_uint16 = ttUSHORT((classDefTable + uintptr(2)))
			var classRangeRecords uintptr = (classDefTable + uintptr(4))

			//  Binary search.
			var l Stbtt_int32 = 0
			var r Stbtt_int32 = (int32(classRangeCount) - 1)
			var m Stbtt_int32
			var strawStart int32
			var strawEnd int32
			var needle int32 = glyph
			for l <= r {
				var classRangeRecord uintptr
				m = ((l + r) >> 1)
				classRangeRecord = (classRangeRecords + uintptr((6 * m)))
				strawStart = int32(ttUSHORT(classRangeRecord))
				strawEnd = int32(ttUSHORT((classRangeRecord + uintptr(2))))
				if needle < strawStart {
					r = (m - 1)
				} else if needle > strawEnd {
					l = (m + 1)
				} else {
					return Stbtt_int32(ttUSHORT((classRangeRecord + uintptr(4))))
				}
			}

			classDefTable = (classRangeRecords + uintptr((6 * int32(classRangeCount))))

		}
		break

	default:
		{
			//  There are no other cases.
			if 0 != 0 {
			} else {
				X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(13723), uintptr(unsafe.Pointer(&__func__121)))
			}

		}
		break
	}

	return -1
}

var __func__121 = *(*[21]int8)(unsafe.Pointer(ts + 3771 /* "stbtt__GetGlyphC..." */)) /* nuklear.h:13682:1 */

//  Define to STBTT_assert(x) if you want to break on unimplemented formats.

func stbtt__GetGlyphGPOSInfoAdvance(info uintptr, glyph1 int32, glyph2 int32) Stbtt_int32 { /* nuklear.h:13733:21: */
	var lookupListOffset Stbtt_uint16
	var lookupList uintptr
	var lookupCount Stbtt_uint16
	var data uintptr
	var i Stbtt_int32

	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Gpos != 0) {
		return 0
	}

	data = ((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Gpos))

	if int32(ttUSHORT((data + uintptr(0)))) != 1 {
		return 0
	} //  Major version 1
	if int32(ttUSHORT((data + uintptr(2)))) != 0 {
		return 0
	} //  Minor version 0

	lookupListOffset = ttUSHORT((data + uintptr(8)))
	lookupList = (data + uintptr(lookupListOffset))
	lookupCount = ttUSHORT(lookupList)

	for i = 0; i < Stbtt_int32(lookupCount); i++ {
		var lookupOffset Stbtt_uint16 = ttUSHORT(((lookupList + uintptr(2)) + uintptr((2 * i))))
		var lookupTable uintptr = (lookupList + uintptr(lookupOffset))

		var lookupType Stbtt_uint16 = ttUSHORT(lookupTable)
		var subTableCount Stbtt_uint16 = ttUSHORT((lookupTable + uintptr(4)))
		var subTableOffsets uintptr = (lookupTable + uintptr(6))
		switch int32(lookupType) {
		case 2:
			{ //  Pair Adjustment Positioning Subtable
				var sti Stbtt_int32
				for sti = 0; sti < Stbtt_int32(subTableCount); sti++ {
					var subtableOffset Stbtt_uint16 = ttUSHORT((subTableOffsets + uintptr((2 * sti))))
					var table uintptr = (lookupTable + uintptr(subtableOffset))
					var posFormat Stbtt_uint16 = ttUSHORT(table)
					var coverageOffset Stbtt_uint16 = ttUSHORT((table + uintptr(2)))
					var coverageIndex Stbtt_int32 = stbtt__GetCoverageIndex((table + uintptr(coverageOffset)), glyph1)
					if coverageIndex == -1 {
						continue
					}

					switch int32(posFormat) {
					case 1:
						{
							var l Stbtt_int32
							var r Stbtt_int32
							var m Stbtt_int32
							var straw int32
							var needle int32
							var valueFormat1 Stbtt_uint16 = ttUSHORT((table + uintptr(4)))
							var valueFormat2 Stbtt_uint16 = ttUSHORT((table + uintptr(6)))
							var valueRecordPairSizeInBytes Stbtt_int32 = 2
							var pairSetCount Stbtt_uint16 = ttUSHORT((table + uintptr(8)))
							var pairPosOffset Stbtt_uint16 = ttUSHORT(((table + uintptr(10)) + uintptr((2 * coverageIndex))))
							var pairValueTable uintptr = (table + uintptr(pairPosOffset))
							var pairValueCount Stbtt_uint16 = ttUSHORT(pairValueTable)
							var pairValueArray uintptr = (pairValueTable + uintptr(2))
							//  TODO: Support more formats.

							if int32(valueFormat1) != 4 {
								return 0
							}

							if int32(valueFormat2) != 0 {
								return 0
							}

							if coverageIndex < Stbtt_int32(pairSetCount) {
							} else {
								X__assert_fail(ts+3792 /* "coverageIndex < ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(13788), uintptr(unsafe.Pointer(&__func__122)))
							}

							needle = glyph2
							r = (int32(pairValueCount) - 1)
							l = 0

							//  Binary search.
							for l <= r {
								var secondGlyph Stbtt_uint16
								var pairValue uintptr
								m = ((l + r) >> 1)
								pairValue = (pairValueArray + uintptr(((2 + valueRecordPairSizeInBytes) * m)))
								secondGlyph = ttUSHORT(pairValue)
								straw = int32(secondGlyph)
								if needle < straw {
									r = (m - 1)
								} else if needle > straw {
									l = (m + 1)
								} else {
									var xAdvance Stbtt_int16 = ttSHORT((pairValue + uintptr(2)))
									return Stbtt_int32(xAdvance)
								}
							}

						}
						break

					case 2:
						{
							var valueFormat1 Stbtt_uint16 = ttUSHORT((table + uintptr(4)))
							var valueFormat2 Stbtt_uint16 = ttUSHORT((table + uintptr(6)))

							var classDef1Offset Stbtt_uint16 = ttUSHORT((table + uintptr(8)))
							var classDef2Offset Stbtt_uint16 = ttUSHORT((table + uintptr(10)))
							var glyph1class int32 = stbtt__GetGlyphClass((table + uintptr(classDef1Offset)), glyph1)
							var glyph2class int32 = stbtt__GetGlyphClass((table + uintptr(classDef2Offset)), glyph2)

							var class1Count Stbtt_uint16 = ttUSHORT((table + uintptr(12)))
							var class2Count Stbtt_uint16 = ttUSHORT((table + uintptr(14)))
							if glyph1class < int32(class1Count) {
							} else {
								X__assert_fail(ts+3821 /* "glyph1class < cl..." */, ts+2 /* "nuklear/nuklear...." */, uint32(13825), uintptr(unsafe.Pointer(&__func__122)))
							}
							if glyph2class < int32(class2Count) {
							} else {
								X__assert_fail(ts+3847 /* "glyph2class < cl..." */, ts+2 /* "nuklear/nuklear...." */, uint32(13826), uintptr(unsafe.Pointer(&__func__122)))
							}

							//  TODO: Support more formats.

							if int32(valueFormat1) != 4 {
								return 0
							}

							if int32(valueFormat2) != 0 {
								return 0
							}

							if (((glyph1class >= 0) && (glyph1class < int32(class1Count))) && (glyph2class >= 0)) && (glyph2class < int32(class2Count)) {
								var class1Records uintptr = (table + uintptr(16))
								var class2Records uintptr = (class1Records + uintptr((2 * (glyph1class * int32(class2Count)))))
								var xAdvance Stbtt_int16 = ttSHORT((class2Records + uintptr((2 * glyph2class))))
								return Stbtt_int32(xAdvance)
							}

						}
						break

					default:
						{
							//  There are no other cases.
							if 0 != 0 {
							} else {
								X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(13844), uintptr(unsafe.Pointer(&__func__122)))
							}
							break

						}

					}
				}
				break

			}

		default:
			//  TODO: Implement other stuff.
			break
		}
	}

	return 0
}

var __func__122 = *(*[31]int8)(unsafe.Pointer(ts + 3873 /* "stbtt__GetGlyphG..." */)) /* nuklear.h:13734:1 */

func Xstbtt_GetGlyphKernAdvance(info uintptr, g1 int32, g2 int32) int32 { /* nuklear.h:13861:16: */
	var xAdvance int32 = 0

	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Gpos != 0 {
		xAdvance = xAdvance + (stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2))
	} else if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern != 0 {
		xAdvance = xAdvance + (stbtt__GetGlyphKernInfoAdvance(info, g1, g2))
	}

	return xAdvance
}

func Xstbtt_GetCodepointKernAdvance(info uintptr, ch1 int32, ch2 int32) int32 { /* nuklear.h:13873:16: */
	if !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Kern != 0) && !((*Stbtt_fontinfo)(unsafe.Pointer(info)).Gpos != 0) { //  if no kerning table, don't waste time looking up both codepoint->glyphs
		return 0
	}
	return Xstbtt_GetGlyphKernAdvance(info, Xstbtt_FindGlyphIndex(info, ch1), Xstbtt_FindGlyphIndex(info, ch2))
}

func Xstbtt_GetCodepointHMetrics(info uintptr, codepoint int32, advanceWidth uintptr, leftSideBearing uintptr) { /* nuklear.h:13880:16: */
	Xstbtt_GetGlyphHMetrics(info, Xstbtt_FindGlyphIndex(info, codepoint), advanceWidth, leftSideBearing)
}

func Xstbtt_GetFontVMetrics(info uintptr, ascent uintptr, descent uintptr, lineGap uintptr) { /* nuklear.h:13885:16: */
	if ascent != 0 {
		*(*int32)(unsafe.Pointer(ascent)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(4))))
	}
	if descent != 0 {
		*(*int32)(unsafe.Pointer(descent)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(6))))
	}
	if lineGap != 0 {
		*(*int32)(unsafe.Pointer(lineGap)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(8))))
	}
}

func Xstbtt_GetFontVMetricsOS2(info uintptr, typoAscent uintptr, typoDescent uintptr, typoLineGap uintptr) int32 { /* nuklear.h:13892:16: */
	var tab int32 = int32(stbtt__find_table((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data, uint32((*Stbtt_fontinfo)(unsafe.Pointer(info)).Fontstart), ts+3904 /* "OS/2" */))
	if !(tab != 0) {
		return 0
	}
	if typoAscent != 0 {
		*(*int32)(unsafe.Pointer(typoAscent)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(tab)) + uintptr(68))))
	}
	if typoDescent != 0 {
		*(*int32)(unsafe.Pointer(typoDescent)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(tab)) + uintptr(70))))
	}
	if typoLineGap != 0 {
		*(*int32)(unsafe.Pointer(typoLineGap)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr(tab)) + uintptr(72))))
	}
	return 1
}

func Xstbtt_GetFontBoundingBox(info uintptr, x0 uintptr, y0 uintptr, x1 uintptr, y1 uintptr) { /* nuklear.h:13903:16: */
	*(*int32)(unsafe.Pointer(x0)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(36))))
	*(*int32)(unsafe.Pointer(y0)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(38))))
	*(*int32)(unsafe.Pointer(x1)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(40))))
	*(*int32)(unsafe.Pointer(y1)) = int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(42))))
}

func Xstbtt_ScaleForPixelHeight(info uintptr, height float32) float32 { /* nuklear.h:13911:17: */
	var fheight int32 = (int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(4)))) - int32(ttSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Hhea)) + uintptr(6)))))
	return (height / float32(fheight))
}

func Xstbtt_ScaleForMappingEmToPixels(info uintptr, pixels float32) float32 { /* nuklear.h:13917:17: */
	var unitsPerEm int32 = int32(ttUSHORT((((*Stbtt_fontinfo)(unsafe.Pointer(info)).Data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Head)) + uintptr(18))))
	return (pixels / float32(unitsPerEm))
}

func Xstbtt_FreeShape(info uintptr, v uintptr) { /* nuklear.h:13923:16: */
	nk_stbtt_free(v, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
}

func Xstbtt_FindSVGDoc(info uintptr, gl int32) uintptr { /* nuklear.h:13928:23: */
	var i int32
	var data uintptr = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Data
	var svg_doc_list uintptr = (data + uintptr(stbtt__get_svg(info)))

	var numEntries int32 = int32(ttUSHORT(svg_doc_list))
	var svg_docs uintptr = (svg_doc_list + uintptr(2))

	for i = 0; i < numEntries; i++ {
		var svg_doc uintptr = (svg_docs + uintptr((12 * i)))
		if (gl >= int32(ttUSHORT(svg_doc))) && (gl <= int32(ttUSHORT((svg_doc + uintptr(2))))) {
			return svg_doc
		}
	}
	return uintptr(0)
}

func Xstbtt_GetGlyphSVG(info uintptr, gl int32, svg uintptr) int32 { /* nuklear.h:13945:15: */
	var data uintptr = (*Stbtt_fontinfo)(unsafe.Pointer(info)).Data
	var svg_doc uintptr

	if (*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg == 0 {
		return 0
	}

	svg_doc = Xstbtt_FindSVGDoc(info, gl)
	if svg_doc != (uintptr(0)) {
		*(*uintptr)(unsafe.Pointer(svg)) = ((data + uintptr((*Stbtt_fontinfo)(unsafe.Pointer(info)).Svg)) + uintptr(ttULONG((svg_doc + uintptr(4)))))
		return int32(ttULONG((svg_doc + uintptr(8))))
	} else {
		return 0
	}
	return int32(0)
}

func Xstbtt_GetCodepointSVG(info uintptr, unicode_codepoint int32, svg uintptr) int32 { /* nuklear.h:13962:15: */
	return Xstbtt_GetGlyphSVG(info, Xstbtt_FindGlyphIndex(info, unicode_codepoint), svg)
}

// ////////////////////////////////////////////////////////////////////////////
//
//  antialiasing software rasterizer
//

func Xstbtt_GetGlyphBitmapBoxSubpixel(font uintptr, glyph int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, ix0 uintptr, iy0 uintptr, ix1 uintptr, iy1 uintptr) { /* nuklear.h:13972:16: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	*(*int32)(unsafe.Pointer(bp /* x0 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 4 /* y0 */)) = 0
	// var x1 int32 at bp+8, 4

	// var y1 int32 at bp+12, 4
	//  =0 suppresses compiler warning
	if !(Xstbtt_GetGlyphBox(font, glyph, bp /* &x0 */, bp+4 /* &y0 */, bp+8 /* &x1 */, bp+12 /* &y1 */) != 0) {
		//  e.g. space character
		if ix0 != 0 {
			*(*int32)(unsafe.Pointer(ix0)) = 0
		}
		if iy0 != 0 {
			*(*int32)(unsafe.Pointer(iy0)) = 0
		}
		if ix1 != 0 {
			*(*int32)(unsafe.Pointer(ix1)) = 0
		}
		if iy1 != 0 {
			*(*int32)(unsafe.Pointer(iy1)) = 0
		}
	} else {
		//  move to integral bboxes (treating pixels as little squares, what pixels get touched)?
		if ix0 != 0 {
			*(*int32)(unsafe.Pointer(ix0)) = int32(Xfloor((float64((float32(*(*int32)(unsafe.Pointer(bp /* x0 */))) * scale_x) + shift_x))))
		}
		if iy0 != 0 {
			*(*int32)(unsafe.Pointer(iy0)) = int32(Xfloor((float64((float32(-*(*int32)(unsafe.Pointer(bp + 12 /* y1 */))) * scale_y) + shift_y))))
		}
		if ix1 != 0 {
			*(*int32)(unsafe.Pointer(ix1)) = int32(Xceil((float64((float32(*(*int32)(unsafe.Pointer(bp + 8 /* x1 */))) * scale_x) + shift_x))))
		}
		if iy1 != 0 {
			*(*int32)(unsafe.Pointer(iy1)) = int32(Xceil((float64((float32(-*(*int32)(unsafe.Pointer(bp + 4 /* y0 */))) * scale_y) + shift_y))))
		}
	}
}

func Xstbtt_GetGlyphBitmapBox(font uintptr, glyph int32, scale_x float32, scale_y float32, ix0 uintptr, iy0 uintptr, ix1 uintptr, iy1 uintptr) { /* nuklear.h:13990:16: */
	Xstbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0, 0.0, ix0, iy0, ix1, iy1)
}

func Xstbtt_GetCodepointBitmapBoxSubpixel(font uintptr, codepoint int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, ix0 uintptr, iy0 uintptr, ix1 uintptr, iy1 uintptr) { /* nuklear.h:13995:16: */
	Xstbtt_GetGlyphBitmapBoxSubpixel(font, Xstbtt_FindGlyphIndex(font, codepoint), scale_x, scale_y, shift_x, shift_y, ix0, iy0, ix1, iy1)
}

func Xstbtt_GetCodepointBitmapBox(font uintptr, codepoint int32, scale_x float32, scale_y float32, ix0 uintptr, iy0 uintptr, ix1 uintptr, iy1 uintptr) { /* nuklear.h:14000:16: */
	Xstbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, 0.0, 0.0, ix0, iy0, ix1, iy1)
}

// ////////////////////////////////////////////////////////////////////////////
//
//   Rasterizer

type Stbtt__hheap_chunk1 = struct{ Next uintptr } /* nuklear.h:14009:9 */

// ////////////////////////////////////////////////////////////////////////////
//
//   Rasterizer

type Stbtt__hheap_chunk = Stbtt__hheap_chunk1 /* nuklear.h:14012:3 */

type Stbtt__hheap1 = struct {
	Head                        uintptr
	First_free                  uintptr
	Num_remaining_in_head_chunk int32
} /* nuklear.h:14014:9 */

type Stbtt__hheap = Stbtt__hheap1 /* nuklear.h:14019:3 */

func stbtt__hheap_alloc(hh uintptr, size Size_t, userdata uintptr) uintptr { /* nuklear.h:14021:13: */
	if (*Stbtt__hheap)(unsafe.Pointer(hh)).First_free != 0 {
		var p uintptr = (*Stbtt__hheap)(unsafe.Pointer(hh)).First_free
		(*Stbtt__hheap)(unsafe.Pointer(hh)).First_free = *(*uintptr)(unsafe.Pointer(p))
		return p
	} else {
		if (*Stbtt__hheap)(unsafe.Pointer(hh)).Num_remaining_in_head_chunk == 0 {
			var count int32 = func() int32 {
				if size < Size_t(32) {
					return 2000
				}
				return func() int32 {
					if size < Size_t(128) {
						return 800
					}
					return 100
				}()
			}()
			var c uintptr = nk_stbtt_malloc((uint32(unsafe.Sizeof(Stbtt__hheap_chunk{})) + (size * Size_t(count))), userdata)
			if c == (uintptr(0)) {
				return uintptr(0)
			}
			(*Stbtt__hheap_chunk)(unsafe.Pointer(c)).Next = (*Stbtt__hheap)(unsafe.Pointer(hh)).Head
			(*Stbtt__hheap)(unsafe.Pointer(hh)).Head = c
			(*Stbtt__hheap)(unsafe.Pointer(hh)).Num_remaining_in_head_chunk = count
		}
		(*Stbtt__hheap)(unsafe.Pointer(hh)).Num_remaining_in_head_chunk--
		return ((((*Stbtt__hheap)(unsafe.Pointer(hh)).Head) + uintptr(uint32(unsafe.Sizeof(Stbtt__hheap_chunk{})))) + uintptr((size * Size_t((*Stbtt__hheap)(unsafe.Pointer(hh)).Num_remaining_in_head_chunk))))
	}
	return uintptr(0)
}

func stbtt__hheap_free(hh uintptr, p uintptr) { /* nuklear.h:14042:13: */
	*(*uintptr)(unsafe.Pointer(p)) = (*Stbtt__hheap)(unsafe.Pointer(hh)).First_free
	(*Stbtt__hheap)(unsafe.Pointer(hh)).First_free = p
}

func stbtt__hheap_cleanup(hh uintptr, userdata uintptr) { /* nuklear.h:14048:13: */
	var c uintptr = (*Stbtt__hheap)(unsafe.Pointer(hh)).Head
	for c != 0 {
		var n uintptr = (*Stbtt__hheap_chunk)(unsafe.Pointer(c)).Next
		nk_stbtt_free(c, userdata)
		c = n
	}
}

type Stbtt__edge1 = struct {
	X0     float32
	Y0     float32
	X1     float32
	Y1     float32
	Invert int32
} /* nuklear.h:14058:9 */

type Stbtt__edge = Stbtt__edge1 /* nuklear.h:14061:3 */

type Stbtt__active_edge1 = struct {
	Next      uintptr
	Fx        float32
	Fdx       float32
	Fdy       float32
	Direction float32
	Sy        float32
	Ey        float32
} /* nuklear.h:14064:9 */

type Stbtt__active_edge = Stbtt__active_edge1 /* nuklear.h:14079:3 */

func stbtt__new_active(hh uintptr, e uintptr, off_x int32, start_point float32, userdata uintptr) uintptr { /* nuklear.h:14108:27: */
	var z uintptr = stbtt__hheap_alloc(hh, uint32(unsafe.Sizeof(Stbtt__active_edge{})), userdata)
	var dxdy float32 = (((*Stbtt__edge)(unsafe.Pointer(e)).X1 - (*Stbtt__edge)(unsafe.Pointer(e)).X0) / ((*Stbtt__edge)(unsafe.Pointer(e)).Y1 - (*Stbtt__edge)(unsafe.Pointer(e)).Y0))
	if z != (uintptr(0)) {
	} else {
		X__assert_fail(ts+3909 /* "z != ((void *)0)" */, ts+2 /* "nuklear/nuklear...." */, uint32(14112), uintptr(unsafe.Pointer(&__func__123)))
	}
	// STBTT_assert(e->y0 <= start_point);
	if !(z != 0) {
		return z
	}
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Fdx = dxdy
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Fdy = func() float32 {
		if dxdy != 0.0 {
			return (1.0 / dxdy)
		}
		return 0.0
	}()
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Fx = ((*Stbtt__edge)(unsafe.Pointer(e)).X0 + (dxdy * (start_point - (*Stbtt__edge)(unsafe.Pointer(e)).Y0)))
	*(*float32)(unsafe.Pointer(z + 4 /* &.fx */)) -= (float32(off_x))
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Direction = func() float32 {
		if (*Stbtt__edge)(unsafe.Pointer(e)).Invert != 0 {
			return 1.0
		}
		return -1.0
	}()
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Sy = (*Stbtt__edge)(unsafe.Pointer(e)).Y0
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Ey = (*Stbtt__edge)(unsafe.Pointer(e)).Y1
	(*Stbtt__active_edge)(unsafe.Pointer(z)).Next = uintptr(0)
	return z
}

var __func__123 = *(*[18]int8)(unsafe.Pointer(ts + 3926 /* "stbtt__new_activ..." */)) /* nuklear.h:14109:1 */

//  the edge passed in here does not cross the vertical line at x or the vertical line at x+1
//  (i.e. it has already been clipped to those)
func stbtt__handle_clipped_edge(scanline uintptr, x int32, e uintptr, x0 float32, y0 float32, x1 float32, y1 float32) { /* nuklear.h:14279:13: */
	if y0 == y1 {
		return
	}
	if y0 < y1 {
	} else {
		X__assert_fail(ts+3944 /* "y0 < y1" */, ts+2 /* "nuklear/nuklear...." */, uint32(14282), uintptr(unsafe.Pointer(&__func__124)))
	}
	if (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy <= (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey {
	} else {
		X__assert_fail(ts+3952 /* "e->sy <= e->ey" */, ts+2 /* "nuklear/nuklear...." */, uint32(14283), uintptr(unsafe.Pointer(&__func__124)))
	}
	if y0 > (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey {
		return
	}
	if y1 < (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy {
		return
	}
	if y0 < (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy {
		x0 = x0 + (((x1 - x0) * ((*Stbtt__active_edge)(unsafe.Pointer(e)).Sy - y0)) / (y1 - y0))
		y0 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy
	}
	if y1 > (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey {
		x1 = x1 + (((x1 - x0) * ((*Stbtt__active_edge)(unsafe.Pointer(e)).Ey - y1)) / (y1 - y0))
		y1 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey
	}

	if x0 == float32(x) {
		if x1 <= (float32(x + 1)) {
		} else {
			X__assert_fail(ts+3967 /* "x1 <= x+1" */, ts+2 /* "nuklear/nuklear...." */, uint32(14296), uintptr(unsafe.Pointer(&__func__124)))
		}
	} else if x0 == (float32(x + 1)) {
		if x1 >= float32(x) {
		} else {
			X__assert_fail(ts+3977 /* "x1 >= x" */, ts+2 /* "nuklear/nuklear...." */, uint32(14298), uintptr(unsafe.Pointer(&__func__124)))
		}
	} else if x0 <= float32(x) {
		if x1 <= float32(x) {
		} else {
			X__assert_fail(ts+3985 /* "x1 <= x" */, ts+2 /* "nuklear/nuklear...." */, uint32(14300), uintptr(unsafe.Pointer(&__func__124)))
		}
	} else if x0 >= (float32(x + 1)) {
		if x1 >= (float32(x + 1)) {
		} else {
			X__assert_fail(ts+3993 /* "x1 >= x+1" */, ts+2 /* "nuklear/nuklear...." */, uint32(14302), uintptr(unsafe.Pointer(&__func__124)))
		}
	} else {
		if (x1 >= float32(x)) && (x1 <= (float32(x + 1))) {
		} else {
			X__assert_fail(ts+4003 /* "x1 >= x && x1 <=..." */, ts+2 /* "nuklear/nuklear...." */, uint32(14304), uintptr(unsafe.Pointer(&__func__124)))
		}
	}

	if (x0 <= float32(x)) && (x1 <= float32(x)) {
		*(*float32)(unsafe.Pointer(scanline + uintptr(x)*4)) += ((*Stbtt__active_edge)(unsafe.Pointer(e)).Direction * (y1 - y0))
	} else if (x0 >= (float32(x + 1))) && (x1 >= (float32(x + 1))) {
	} else {
		if (((x0 >= float32(x)) && (x0 <= (float32(x + 1)))) && (x1 >= float32(x))) && (x1 <= (float32(x + 1))) {
		} else {
			X__assert_fail(ts+4024 /* "x0 >= x && x0 <=..." */, ts+2 /* "nuklear/nuklear...." */, uint32(14311), uintptr(unsafe.Pointer(&__func__124)))
		}
		*(*float32)(unsafe.Pointer(scanline + uintptr(x)*4)) += (((*Stbtt__active_edge)(unsafe.Pointer(e)).Direction * (y1 - y0)) * (float32(1) - (((x0 - float32(x)) + (x1 - float32(x))) / float32(2)))) //  coverage = 1 - average x position
	}
}

var __func__124 = *(*[27]int8)(unsafe.Pointer(ts + 4069 /* "stbtt__handle_cl..." */)) /* nuklear.h:14280:1 */

func stbtt__fill_active_edges_new(scanline uintptr, scanline_fill uintptr, len int32, e uintptr, y_top float32) { /* nuklear.h:14316:13: */
	var y_bottom float32 = (y_top + float32(1))

	for e != 0 {
		//  brute force every pixel

		//  compute intersection points with top & bottom
		if (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey >= y_top {
		} else {
			X__assert_fail(ts+4096 /* "e->ey >= y_top" */, ts+2 /* "nuklear/nuklear...." */, uint32(14324), uintptr(unsafe.Pointer(&__func__125)))
		}

		if (*Stbtt__active_edge)(unsafe.Pointer(e)).Fdx == float32(0) {
			var x0 float32 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Fx
			if x0 < float32(len) {
				if x0 >= float32(0) {
					stbtt__handle_clipped_edge(scanline, int32(x0), e, x0, y_top, x0, y_bottom)
					stbtt__handle_clipped_edge((scanline_fill - uintptr(1)*4), (int32(x0) + 1), e, x0, y_top, x0, y_bottom)
				} else {
					stbtt__handle_clipped_edge((scanline_fill - uintptr(1)*4), 0, e, x0, y_top, x0, y_bottom)
				}
			}
		} else {
			var x0 float32 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Fx
			var dx float32 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Fdx
			var xb float32 = (x0 + dx)
			var x_top float32
			var x_bottom float32
			var sy0 float32
			var sy1 float32
			var dy float32 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Fdy
			if ((*Stbtt__active_edge)(unsafe.Pointer(e)).Sy <= y_bottom) && ((*Stbtt__active_edge)(unsafe.Pointer(e)).Ey >= y_top) {
			} else {
				X__assert_fail(ts+4111 /* "e->sy <= y_botto..." */, ts+2 /* "nuklear/nuklear...." */, uint32(14343), uintptr(unsafe.Pointer(&__func__125)))
			}

			//  compute endpoints of line segment clipped to this scanline (if the
			//  line segment starts on this scanline. x0 is the intersection of the
			//  line with y_top, but that may be off the line segment.
			if (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy > y_top {
				x_top = (x0 + (dx * ((*Stbtt__active_edge)(unsafe.Pointer(e)).Sy - y_top)))
				sy0 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Sy
			} else {
				x_top = x0
				sy0 = y_top
			}
			if (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey < y_bottom {
				x_bottom = (x0 + (dx * ((*Stbtt__active_edge)(unsafe.Pointer(e)).Ey - y_top)))
				sy1 = (*Stbtt__active_edge)(unsafe.Pointer(e)).Ey
			} else {
				x_bottom = xb
				sy1 = y_bottom
			}

			if (((x_top >= float32(0)) && (x_bottom >= float32(0))) && (x_top < float32(len))) && (x_bottom < float32(len)) {
				//  from here on, we don't have to range check x values

				if int32(x_top) == int32(x_bottom) {
					var height float32
					//  simple case, only spans one pixel
					var x int32 = int32(x_top)
					height = (sy1 - sy0)
					if (x >= 0) && (x < len) {
					} else {
						X__assert_fail(ts+4147 /* "x >= 0 && x < le..." */, ts+2 /* "nuklear/nuklear...." */, uint32(14371), uintptr(unsafe.Pointer(&__func__125)))
					}
					*(*float32)(unsafe.Pointer(scanline + uintptr(x)*4)) += (((*Stbtt__active_edge)(unsafe.Pointer(e)).Direction * (float32(1) - (((x_top - float32(x)) + (x_bottom - float32(x))) / float32(2)))) * height)
					*(*float32)(unsafe.Pointer(scanline_fill + uintptr(x)*4)) += ((*Stbtt__active_edge)(unsafe.Pointer(e)).Direction * height) //  everything right of this pixel is filled
				} else {
					var x int32
					var x1 int32
					var x2 int32
					var y_crossing float32
					var step float32
					var sign float32
					var area float32
					//  covers 2+ pixels
					if x_top > x_bottom {
						//  flip scanline vertically; signed area is the same
						var t float32
						sy0 = (y_bottom - (sy0 - y_top))
						sy1 = (y_bottom - (sy1 - y_top))
						t = sy0
						sy0 = sy1
						sy1 = t
						t = x_bottom
						x_bottom = x_top
						x_top = t
						dx = -dx
						dy = -dy
						t = x0
						x0 = xb
						xb = t
					}

					x1 = int32(x_top)
					x2 = int32(x_bottom)
					//  compute intersection with y axis at x1+1
					y_crossing = ((((float32(x1 + 1)) - x0) * dy) + y_top)

					sign = (*Stbtt__active_edge)(unsafe.Pointer(e)).Direction
					//  area of the rectangle covered from y0..y_crossing
					area = (sign * (y_crossing - sy0))
					//  area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
					*(*float32)(unsafe.Pointer(scanline + uintptr(x1)*4)) += (area * (float32(1) - (((x_top - float32(x1)) + (float32((x1 + 1) - x1))) / float32(2))))

					step = (sign * dy)
					for x = (x1 + 1); x < x2; x++ {
						*(*float32)(unsafe.Pointer(scanline + uintptr(x)*4)) += (area + (step / float32(2)))
						area = area + (step)
					}
					y_crossing = y_crossing + (dy * (float32(x2 - (x1 + 1))))

					if Xfabs(float64(area)) <= 1.01 {
					} else {
						X__assert_fail(ts+4165 /* "fabs(area) <= 1...." */, ts+2 /* "nuklear/nuklear...." */, uint32(14408), uintptr(unsafe.Pointer(&__func__125)))
					}

					*(*float32)(unsafe.Pointer(scanline + uintptr(x2)*4)) += (area + ((sign * (float32(1) - (((float32(x2 - x2)) + (x_bottom - float32(x2))) / float32(2)))) * (sy1 - y_crossing)))

					*(*float32)(unsafe.Pointer(scanline_fill + uintptr(x2)*4)) += (sign * (sy1 - sy0))
				}
			} else {
				//  if edge goes outside of box we're drawing, we require
				//  clipping logic. since this does not match the intended use
				//  of this library, we use a different, very slow brute
				//  force implementation
				var x int32
				for x = 0; x < len; x++ {
					//  cases:
					//
					//  there can be up to two intersections with the pixel. any intersection
					//  with left or right edges can be handled by splitting into two (or three)
					//  regions. intersections with top & bottom do not necessitate case-wise logic.
					//
					//  the old way of doing this found the intersections with the left & right edges,
					//  then used some simple logic to produce up to three segments in sorted order
					//  from top-to-bottom. however, this had a problem: if an x edge was epsilon
					//  across the x border, then the corresponding y position might not be distinct
					//  from the other y segment, and it might ignored as an empty segment. to avoid
					//  that, we need to explicitly produce segments based on x positions.

					//  rename variables to clearly-defined pairs
					var y0 float32 = y_top
					var x1 float32 = float32(x)
					var x2 float32 = (float32(x + 1))
					var x3 float32 = xb
					var y3 float32 = y_bottom

					//  x = e->x + e->dx * (y-y_top)
					//  (y-y_top) = (x - e->x) / e->dx
					//  y = (x - e->x) / e->dx + y_top
					var y1 float32 = (((float32(x) - x0) / dx) + y_top)
					var y2 float32 = ((((float32(x + 1)) - x0) / dx) + y_top)

					if (x0 < x1) && (x3 > x2) { //  three segments descending down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1)
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2)
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3)
					} else if (x3 < x1) && (x0 > x2) { //  three segments descending down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2)
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1)
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3)
					} else if (x0 < x1) && (x3 > x1) { //  two segments across x, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1)
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3)
					} else if (x3 < x1) && (x0 > x1) { //  two segments across x, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1)
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3)
					} else if (x0 < x2) && (x3 > x2) { //  two segments across x+1, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2)
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3)
					} else if (x3 < x2) && (x0 > x2) { //  two segments across x+1, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2)
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3)
					} else { //  one segment
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3)
					}
				}
			}
		}
		e = (*Stbtt__active_edge)(unsafe.Pointer(e)).Next
	}
}

var __func__125 = *(*[29]int8)(unsafe.Pointer(ts + 4185 /* "stbtt__fill_acti..." */)) /* nuklear.h:14317:1 */

//  directly AA rasterize edges w/o supersampling
func stbtt__rasterize_sorted_edges(result uintptr, e uintptr, n int32, vsubsample int32, off_x int32, off_y int32, userdata uintptr) { /* nuklear.h:14478:13: */
	bp := tlsAlloc(532)
	defer tlsFree(532)

	*(*Stbtt__hheap)(unsafe.Pointer(bp + 520 /* hh */)) = Stbtt__hheap{}
	*(*uintptr)(unsafe.Pointer(bp + 516 /* active */)) = uintptr(0)
	var y int32
	var j int32 = 0
	var i int32
	// var scanline_data [129]float32 at bp, 516

	var scanline uintptr
	var scanline2 uintptr

	if (*Stbtt__bitmap)(unsafe.Pointer(result)).W > 64 {
		scanline = nk_stbtt_malloc(((uint32(((*Stbtt__bitmap)(unsafe.Pointer(result)).W * 2) + 1)) * uint32(unsafe.Sizeof(float32(0)))), userdata)
	} else {
		scanline = bp /* &scanline_data[0] */
	}

	scanline2 = (scanline + uintptr((*Stbtt__bitmap)(unsafe.Pointer(result)).W)*4)

	y = off_y
	(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).Y0 = ((float32(off_y + (*Stbtt__bitmap)(unsafe.Pointer(result)).H)) + float32(1))

	for j < (*Stbtt__bitmap)(unsafe.Pointer(result)).H {
		//  find center of pixel for this scanline
		var scan_y_top float32 = (float32(y) + 0.0)
		var scan_y_bottom float32 = (float32(y) + 1.0)
		var step uintptr = bp + 516 /* &active */

		Xmemset(scanline, 0, (uint32((*Stbtt__bitmap)(unsafe.Pointer(result)).W) * uint32(unsafe.Sizeof(float32(0)))))
		Xmemset(scanline2, 0, ((uint32((*Stbtt__bitmap)(unsafe.Pointer(result)).W + 1)) * uint32(unsafe.Sizeof(float32(0)))))

		//  update all active edges;
		//  remove all active edges that terminate before the top of this scanline
		for *(*uintptr)(unsafe.Pointer(step)) != 0 {
			var z uintptr = *(*uintptr)(unsafe.Pointer(step))
			if (*Stbtt__active_edge)(unsafe.Pointer(z)).Ey <= scan_y_top {
				*(*uintptr)(unsafe.Pointer(step)) = (*Stbtt__active_edge)(unsafe.Pointer(z)).Next //  delete from list
				if (*Stbtt__active_edge)(unsafe.Pointer(z)).Direction != 0 {
				} else {
					X__assert_fail(ts+4214 /* "z->direction" */, ts+2 /* "nuklear/nuklear...." */, uint32(14512), uintptr(unsafe.Pointer(&__func__126)))
				}
				(*Stbtt__active_edge)(unsafe.Pointer(z)).Direction = float32(0)
				stbtt__hheap_free(bp+520 /* &hh */, z)
			} else {
				step = (*(*uintptr)(unsafe.Pointer(step)) /* &.next */) //  advance through list
			}
		}

		//  insert all edges that start before the bottom of this scanline
		for (*Stbtt__edge)(unsafe.Pointer(e)).Y0 <= scan_y_bottom {
			if (*Stbtt__edge)(unsafe.Pointer(e)).Y0 != (*Stbtt__edge)(unsafe.Pointer(e)).Y1 {
				var z uintptr = stbtt__new_active(bp+520 /* &hh */, e, off_x, scan_y_top, userdata)
				if z != (uintptr(0)) {
					if (j == 0) && (off_y != 0) {
						if (*Stbtt__active_edge)(unsafe.Pointer(z)).Ey < scan_y_top {
							//  this can happen due to subpixel positioning and some kind of fp rounding error i think
							(*Stbtt__active_edge)(unsafe.Pointer(z)).Ey = scan_y_top
						}
					}
					if (*Stbtt__active_edge)(unsafe.Pointer(z)).Ey >= scan_y_top {
					} else {
						X__assert_fail(ts+4227 /* "z->ey >= scan_y_..." */, ts+2 /* "nuklear/nuklear...." */, uint32(14531), uintptr(unsafe.Pointer(&__func__126)))
					} //  if we get really unlucky a tiny bit of an edge can be out of bounds
					//  insert at front
					(*Stbtt__active_edge)(unsafe.Pointer(z)).Next = *(*uintptr)(unsafe.Pointer(bp + 516 /* active */))
					*(*uintptr)(unsafe.Pointer(bp + 516 /* active */)) = z
				}
			}
			e += 20
		}

		//  now process all active edges
		if *(*uintptr)(unsafe.Pointer(bp + 516 /* active */)) != 0 {
			stbtt__fill_active_edges_new(scanline, (scanline2 + uintptr(1)*4), (*Stbtt__bitmap)(unsafe.Pointer(result)).W, *(*uintptr)(unsafe.Pointer(bp + 516 /* active */)), scan_y_top)
		}

		{
			var sum float32 = float32(0)
			for i = 0; i < (*Stbtt__bitmap)(unsafe.Pointer(result)).W; i++ {
				var k float32
				var m int32
				sum = sum + (*(*float32)(unsafe.Pointer(scanline2 + uintptr(i)*4)))
				k = (*(*float32)(unsafe.Pointer(scanline + uintptr(i)*4)) + sum)
				k = ((float32(Xfabs(float64(k))) * float32(255)) + 0.5)
				m = int32(k)
				if m > 255 {
					m = 255
				}
				*(*uint8)(unsafe.Pointer((*Stbtt__bitmap)(unsafe.Pointer(result)).Pixels + uintptr(((j * (*Stbtt__bitmap)(unsafe.Pointer(result)).Stride) + i)))) = uint8(m)
			}

		}
		//  advance all the edges
		step = bp + 516 /* &active */
		for *(*uintptr)(unsafe.Pointer(step)) != 0 {
			var z uintptr = *(*uintptr)(unsafe.Pointer(step))
			*(*float32)(unsafe.Pointer(z + 4 /* &.fx */)) += ((*Stbtt__active_edge)(unsafe.Pointer(z)).Fdx) //  advance to position for current scanline
			step = (*(*uintptr)(unsafe.Pointer(step)) /* &.next */)                                         //  advance through list
		}

		y++
		j++
	}

	stbtt__hheap_cleanup(bp+520 /* &hh */, userdata)

	if scanline != bp /* scanline_data */ {
		nk_stbtt_free(scanline, userdata)
	}
}

var __func__126 = *(*[30]int8)(unsafe.Pointer(ts + 4247 /* "stbtt__rasterize..." */)) /* nuklear.h:14479:1 */

func stbtt__sort_edges_ins_sort(p uintptr, n int32) { /* nuklear.h:14580:13: */
	bp := tlsAlloc(20)
	defer tlsFree(20)

	var i int32
	var j int32
	for i = 1; i < n; i++ {
		*(*Stbtt__edge)(unsafe.Pointer(bp /* t */)) = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(i)*20))
		var a uintptr = bp /* &t */
		j = i
		for j > 0 {
			var b uintptr = (p + uintptr((j-1))*20)
			var c int32 = (Bool32((*Stbtt__edge)(unsafe.Pointer((a))).Y0 < (*Stbtt__edge)(unsafe.Pointer((b))).Y0))
			if !(c != 0) {
				break
			}
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(j)*20)) = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr((j-1))*20))
			j--
		}
		if i != j {
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(j)*20)) = *(*Stbtt__edge)(unsafe.Pointer(bp /* t */))
		}
	}
}

func stbtt__sort_edges_quicksort(p uintptr, n int32) { /* nuklear.h:14598:13: */
	// threshold for transitioning to insertion sort
	for n > 12 {
		var t Stbtt__edge
		var c01 int32
		var c12 int32
		var c int32
		var m int32
		var i int32
		var j int32

		// compute median of three
		m = (n >> 1)
		c01 = (Bool32((*Stbtt__edge)(unsafe.Pointer((p))).Y0 < (*Stbtt__edge)(unsafe.Pointer((p + uintptr(m)*20))).Y0))
		c12 = (Bool32((*Stbtt__edge)(unsafe.Pointer((p + uintptr(m)*20))).Y0 < (*Stbtt__edge)(unsafe.Pointer((p + uintptr((n-1))*20))).Y0))
		// if 0 >= mid >= end, or 0 < mid < end, then use mid
		if c01 != c12 {
			// otherwise, we'll need to swap something else to middle
			var z int32
			c = (Bool32((*Stbtt__edge)(unsafe.Pointer((p))).Y0 < (*Stbtt__edge)(unsafe.Pointer((p + uintptr((n-1))*20))).Y0))
			// 0>mid && mid<n:  0>n => n; 0<n => 0
			// 0<mid && mid>n:  0>n => 0; 0<n => n
			if c == c12 {
				z = 0
			} else {
				z = (n - 1)
			}
			t = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(z)*20))
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(z)*20)) = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(m)*20))
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(m)*20)) = t
		}
		// now p[m] is the median-of-three
		// swap it to the beginning so it won't move around
		t = *(*Stbtt__edge)(unsafe.Pointer(p))
		*(*Stbtt__edge)(unsafe.Pointer(p)) = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(m)*20))
		*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(m)*20)) = t

		// partition loop
		i = 1
		j = (n - 1)
		for {
			// handling of equality is crucial here
			// for sentinels & efficiency with duplicates
			for ; ; i++ {
				if !((*Stbtt__edge)(unsafe.Pointer((p + uintptr(i)*20))).Y0 < (*Stbtt__edge)(unsafe.Pointer((p))).Y0) {
					break
				}
			}
			for ; ; j-- {
				if !((*Stbtt__edge)(unsafe.Pointer((p))).Y0 < (*Stbtt__edge)(unsafe.Pointer((p + uintptr(j)*20))).Y0) {
					break
				}
			}
			// make sure we haven't crossed
			if i >= j {
				break
			}
			t = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(i)*20))
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(i)*20)) = *(*Stbtt__edge)(unsafe.Pointer(p + uintptr(j)*20))
			*(*Stbtt__edge)(unsafe.Pointer(p + uintptr(j)*20)) = t

			i++
			j--
		}
		// recurse on smaller side, iterate on larger
		if j < (n - i) {
			stbtt__sort_edges_quicksort(p, j)
			p = (p + uintptr(i)*20)
			n = (n - i)
		} else {
			stbtt__sort_edges_quicksort((p + uintptr(i)*20), (n - i))
			n = j
		}
	}
}

func stbtt__sort_edges(p uintptr, n int32) { /* nuklear.h:14660:13: */
	stbtt__sort_edges_quicksort(p, n)
	stbtt__sort_edges_ins_sort(p, n)
}

type Stbtt__point = struct {
	X float32
	Y float32
} /* nuklear.h:14669:3 */

func stbtt__rasterize(result uintptr, pts uintptr, wcount uintptr, windings int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, off_x int32, off_y int32, invert int32, userdata uintptr) { /* nuklear.h:14671:13: */
	var y_scale_inv float32
	if invert != 0 {
		y_scale_inv = -scale_y
	} else {
		y_scale_inv = scale_y
	}
	var e uintptr
	var n int32
	var i int32
	var j int32
	var k int32
	var m int32
	var vsubsample int32 = 1
	//  vsubsample should divide 255 evenly; otherwise we won't reach full opacity

	//  now we have to blow out the windings into explicit edge lists
	n = 0
	for i = 0; i < windings; i++ {
		n = n + (*(*int32)(unsafe.Pointer(wcount + uintptr(i)*4)))
	}

	e = nk_stbtt_malloc((uint32(unsafe.Sizeof(Stbtt__edge{})) * (uint32(n + 1))), userdata) //  add an extra one as a sentinel
	if e == uintptr(0) {
		return
	}
	n = 0

	m = 0
	for i = 0; i < windings; i++ {
		var p uintptr = (pts + uintptr(m)*8)
		m = m + (*(*int32)(unsafe.Pointer(wcount + uintptr(i)*4)))
		j = (*(*int32)(unsafe.Pointer(wcount + uintptr(i)*4)) - 1)
		for k = 0; k < *(*int32)(unsafe.Pointer(wcount + uintptr(i)*4)); j = PostIncInt32(&k, 1) {
			var a int32 = k
			var b int32 = j
			//  skip the edge if horizontal
			if (*Stbtt__point)(unsafe.Pointer(p+uintptr(j)*8)).Y == (*Stbtt__point)(unsafe.Pointer(p+uintptr(k)*8)).Y {
				continue
			}
			//  add edge from j to k to the list
			(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).Invert = 0
			if func() int32 {
				if invert != 0 {
					return (Bool32((*Stbtt__point)(unsafe.Pointer(p+uintptr(j)*8)).Y > (*Stbtt__point)(unsafe.Pointer(p+uintptr(k)*8)).Y))
				}
				return (Bool32((*Stbtt__point)(unsafe.Pointer(p+uintptr(j)*8)).Y < (*Stbtt__point)(unsafe.Pointer(p+uintptr(k)*8)).Y))
			}() != 0 {
				(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).Invert = 1
				a = j
				b = k
			}
			(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).X0 = (((*Stbtt__point)(unsafe.Pointer(p+uintptr(a)*8)).X * scale_x) + shift_x)
			(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).Y0 = ((((*Stbtt__point)(unsafe.Pointer(p+uintptr(a)*8)).Y * y_scale_inv) + shift_y) * float32(vsubsample))
			(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).X1 = (((*Stbtt__point)(unsafe.Pointer(p+uintptr(b)*8)).X * scale_x) + shift_x)
			(*Stbtt__edge)(unsafe.Pointer(e + uintptr(n)*20)).Y1 = ((((*Stbtt__point)(unsafe.Pointer(p+uintptr(b)*8)).Y * y_scale_inv) + shift_y) * float32(vsubsample))
			n++
		}
	}

	//  now sort the edges by their highest point (should snap to integer, and then by x)
	// STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
	stbtt__sort_edges(e, n)

	//  now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
	stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata)

	nk_stbtt_free(e, userdata)
}

func stbtt__add_point(points uintptr, n int32, x float32, y float32) { /* nuklear.h:14728:13: */
	if !(points != 0) {
		return
	} //  during first pass, it's unallocated
	(*Stbtt__point)(unsafe.Pointer(points + uintptr(n)*8)).X = x
	(*Stbtt__point)(unsafe.Pointer(points + uintptr(n)*8)).Y = y
}

//  tessellate until threshold p is happy... @TODO warped to compensate for non-linear stretching
func stbtt__tesselate_curve(points uintptr, num_points uintptr, x0 float32, y0 float32, x1 float32, y1 float32, x2 float32, y2 float32, objspace_flatness_squared float32, n int32) int32 { /* nuklear.h:14736:12: */
	//  midpoint
	var mx float32 = (((x0 + (float32(2) * x1)) + x2) / float32(4))
	var my float32 = (((y0 + (float32(2) * y1)) + y2) / float32(4))
	//  versus directly drawn line
	var dx float32 = (((x0 + x2) / float32(2)) - mx)
	var dy float32 = (((y0 + y2) / float32(2)) - my)
	if n > 16 { //  65536 segments on one curve better be enough!
		return 1
	}
	if ((dx * dx) + (dy * dy)) > objspace_flatness_squared { //  half-pixel error allowed... need to be smaller if AA
		stbtt__tesselate_curve(points, num_points, x0, y0, ((x0 + x1) / 2.0), ((y0 + y1) / 2.0), mx, my, objspace_flatness_squared, (n + 1))
		stbtt__tesselate_curve(points, num_points, mx, my, ((x1 + x2) / 2.0), ((y1 + y2) / 2.0), x2, y2, objspace_flatness_squared, (n + 1))
	} else {
		stbtt__add_point(points, *(*int32)(unsafe.Pointer(num_points)), x2, y2)
		*(*int32)(unsafe.Pointer(num_points)) = (*(*int32)(unsafe.Pointer(num_points)) + 1)
	}
	return 1
}

func stbtt__tesselate_cubic(points uintptr, num_points uintptr, x0 float32, y0 float32, x1 float32, y1 float32, x2 float32, y2 float32, x3 float32, y3 float32, objspace_flatness_squared float32, n int32) { /* nuklear.h:14756:13: */
	//  @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
	var dx0 float32 = (x1 - x0)
	var dy0 float32 = (y1 - y0)
	var dx1 float32 = (x2 - x1)
	var dy1 float32 = (y2 - y1)
	var dx2 float32 = (x3 - x2)
	var dy2 float32 = (y3 - y2)
	var dx float32 = (x3 - x0)
	var dy float32 = (y3 - y0)
	var longlen float32 = (float32((Xsqrt((float64((dx0 * dx0) + (dy0 * dy0)))) + Xsqrt((float64((dx1 * dx1) + (dy1 * dy1))))) + Xsqrt((float64((dx2 * dx2) + (dy2 * dy2))))))
	var shortlen float32 = float32(Xsqrt((float64((dx * dx) + (dy * dy)))))
	var flatness_squared float32 = ((longlen * longlen) - (shortlen * shortlen))

	if n > 16 { //  65536 segments on one curve better be enough!
		return
	}

	if flatness_squared > objspace_flatness_squared {
		var x01 float32 = ((x0 + x1) / float32(2))
		var y01 float32 = ((y0 + y1) / float32(2))
		var x12 float32 = ((x1 + x2) / float32(2))
		var y12 float32 = ((y1 + y2) / float32(2))
		var x23 float32 = ((x2 + x3) / float32(2))
		var y23 float32 = ((y2 + y3) / float32(2))

		var xa float32 = ((x01 + x12) / float32(2))
		var ya float32 = ((y01 + y12) / float32(2))
		var xb float32 = ((x12 + x23) / float32(2))
		var yb float32 = ((y12 + y23) / float32(2))

		var mx float32 = ((xa + xb) / float32(2))
		var my float32 = ((ya + yb) / float32(2))

		stbtt__tesselate_cubic(points, num_points, x0, y0, x01, y01, xa, ya, mx, my, objspace_flatness_squared, (n + 1))
		stbtt__tesselate_cubic(points, num_points, mx, my, xb, yb, x23, y23, x3, y3, objspace_flatness_squared, (n + 1))
	} else {
		stbtt__add_point(points, *(*int32)(unsafe.Pointer(num_points)), x3, y3)
		*(*int32)(unsafe.Pointer(num_points)) = (*(*int32)(unsafe.Pointer(num_points)) + 1)
	}
}

//  returns number of contours
func stbtt_FlattenCurves(vertices uintptr, num_verts int32, objspace_flatness float32, contour_lengths uintptr, num_contours uintptr, userdata uintptr) uintptr { /* nuklear.h:14799:21: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var points uintptr
	// var num_points int32 at bp, 4

	var objspace_flatness_squared float32
	var i int32
	var n int32
	var start int32
	var pass int32
	var x float32
	var y float32
	points = uintptr(0)
	*(*int32)(unsafe.Pointer(bp /* num_points */)) = 0
	objspace_flatness_squared = (objspace_flatness * objspace_flatness)
	n = 0
	start = 0

	//  count how many "moves" there are to get the contour count
	i = 0
__1:
	if !(i < num_verts) {
		goto __3
	}
	if !(int32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Type) == STBTT_vmove) {
		goto __4
	}
	n++
__4:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;

	*(*int32)(unsafe.Pointer(num_contours)) = n
	if !(n == 0) {
		goto __5
	}
	return uintptr(0)
__5:
	;

	*(*uintptr)(unsafe.Pointer(contour_lengths)) = nk_stbtt_malloc((uint32(unsafe.Sizeof(int32(0))) * uint32(n)), userdata)

	if !(*(*uintptr)(unsafe.Pointer(contour_lengths)) == uintptr(0)) {
		goto __6
	}
	*(*int32)(unsafe.Pointer(num_contours)) = 0
	return uintptr(0)
__6:
	;

	//  make two passes through the points so we don't need to realloc
	pass = 0
__7:
	if !(pass < 2) {
		goto __9
	}
	x = float32(0)
	y = float32(0)
	if !(pass == 1) {
		goto __10
	}
	points = nk_stbtt_malloc((uint32(*(*int32)(unsafe.Pointer(bp /* num_points */))) * uint32(unsafe.Sizeof(Stbtt__point{}))), userdata)
	if !(points == (uintptr(0))) {
		goto __11
	}
	goto error
__11:
	;
__10:
	;
	*(*int32)(unsafe.Pointer(bp /* num_points */)) = 0
	n = -1
	i = 0
__12:
	if !(i < num_verts) {
		goto __14
	}
	switch int32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).Type) {
	case STBTT_vmove:
		goto __16
	case STBTT_vline:
		goto __17
	case STBTT_vcurve:
		goto __18
	case STBTT_vcubic:
		goto __19
	}
	goto __15
__16:
	//  start the next contour
	if !(n >= 0) {
		goto __20
	}
	*(*int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(contour_lengths))) + uintptr(n)*4)) = (*(*int32)(unsafe.Pointer(bp /* num_points */)) - start)
__20:
	;
	n++
	start = *(*int32)(unsafe.Pointer(bp /* num_points */))

	x = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).X)
	y = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).Y)
	stbtt__add_point(points, PostIncInt32(&*(*int32)(unsafe.Pointer(bp /* num_points */)), 1), x, y)
	goto __15
__17:
	x = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).X)
	y = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).Y)
	stbtt__add_point(points, PostIncInt32(&*(*int32)(unsafe.Pointer(bp /* num_points */)), 1), x, y)
	goto __15
__18:
	stbtt__tesselate_curve(points, bp /* &num_points */, x, y,
		float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cx), float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cy),
		float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).X), float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Y),
		objspace_flatness_squared, 0)
	x = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).X)
	y = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).Y)
	goto __15
__19:
	stbtt__tesselate_cubic(points, bp /* &num_points */, x, y,
		float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cx), float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cy),
		float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cx1), float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Cy1),
		float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).X), float32((*Stbtt_vertex)(unsafe.Pointer(vertices+uintptr(i)*14)).Y),
		objspace_flatness_squared, 0)
	x = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).X)
	y = float32((*Stbtt_vertex)(unsafe.Pointer(vertices + uintptr(i)*14)).Y)
	goto __15
__15:
	;
	goto __13
__13:
	i++
	goto __12
	goto __14
__14:
	;
	*(*int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(contour_lengths))) + uintptr(n)*4)) = (*(*int32)(unsafe.Pointer(bp /* num_points */)) - start)
	goto __8
__8:
	pass++
	goto __7
	goto __9
__9:
	;

	return points
error:
	nk_stbtt_free(points, userdata)
	nk_stbtt_free(*(*uintptr)(unsafe.Pointer(contour_lengths)), userdata)
	*(*uintptr)(unsafe.Pointer(contour_lengths)) = uintptr(0)
	*(*int32)(unsafe.Pointer(num_contours)) = 0
	return uintptr(0)
}

func Xstbtt_Rasterize(result uintptr, flatness_in_pixels float32, vertices uintptr, num_verts int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, x_off int32, y_off int32, invert int32, userdata uintptr) { /* nuklear.h:14876:16: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var scale float32
	if scale_x > scale_y {
		scale = scale_y
	} else {
		scale = scale_x
	}
	*(*int32)(unsafe.Pointer(bp + 4 /* winding_count */)) = 0
	*(*uintptr)(unsafe.Pointer(bp /* winding_lengths */)) = uintptr(0)
	var windings uintptr = stbtt_FlattenCurves(vertices, num_verts, (flatness_in_pixels / scale), bp /* &winding_lengths */, bp+4 /* &winding_count */, userdata)
	if windings != 0 {
		stbtt__rasterize(result, windings, *(*uintptr)(unsafe.Pointer(bp /* winding_lengths */)), *(*int32)(unsafe.Pointer(bp + 4 /* winding_count */)), scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata)
		nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp /* winding_lengths */)), userdata)
		nk_stbtt_free(windings, userdata)
	}
}

func Xstbtt_FreeBitmap(bitmap uintptr, userdata uintptr) { /* nuklear.h:14889:16: */
	nk_stbtt_free(bitmap, userdata)
}

func Xstbtt_GetGlyphBitmapSubpixel(info uintptr, scale_x float32, scale_y float32, shift_x float32, shift_y float32, glyph int32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:14894:25: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var ix0 int32 at bp+4, 4

	// var iy0 int32 at bp+8, 4

	// var ix1 int32 at bp+12, 4

	// var iy1 int32 at bp+16, 4

	// var gbm Stbtt__bitmap at bp+20, 16

	// var vertices uintptr at bp, 4

	var num_verts int32 = Xstbtt_GetGlyphShape(info, glyph, bp /* &vertices */)

	if scale_x == float32(0) {
		scale_x = scale_y
	}
	if scale_y == float32(0) {
		if scale_x == float32(0) {
			nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp /* vertices */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
			return uintptr(0)
		}
		scale_y = scale_x
	}

	Xstbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, bp+4 /* &ix0 */, bp+8 /* &iy0 */, bp+12 /* &ix1 */, bp+16 /* &iy1 */)

	//  now we get the size
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).W = (*(*int32)(unsafe.Pointer(bp + 12 /* ix1 */)) - *(*int32)(unsafe.Pointer(bp + 4 /* ix0 */)))
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).H = (*(*int32)(unsafe.Pointer(bp + 16 /* iy1 */)) - *(*int32)(unsafe.Pointer(bp + 8 /* iy0 */)))
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).Pixels = uintptr(0) //  in case we error

	if width != 0 {
		*(*int32)(unsafe.Pointer(width)) = (*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).W
	}
	if height != 0 {
		*(*int32)(unsafe.Pointer(height)) = (*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).H
	}
	if xoff != 0 {
		*(*int32)(unsafe.Pointer(xoff)) = *(*int32)(unsafe.Pointer(bp + 4 /* ix0 */))
	}
	if yoff != 0 {
		*(*int32)(unsafe.Pointer(yoff)) = *(*int32)(unsafe.Pointer(bp + 8 /* iy0 */))
	}

	if ((*Stbtt__bitmap)(unsafe.Pointer(bp+20 /* &gbm */)).W != 0) && ((*Stbtt__bitmap)(unsafe.Pointer(bp+20 /* &gbm */)).H != 0) {
		(*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).Pixels = nk_stbtt_malloc((uint32((*Stbtt__bitmap)(unsafe.Pointer(bp+20 /* &gbm */)).W * (*Stbtt__bitmap)(unsafe.Pointer(bp+20 /* &gbm */)).H)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		if (*Stbtt__bitmap)(unsafe.Pointer(bp+20 /* &gbm */)).Pixels != 0 {
			(*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).Stride = (*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).W

			Xstbtt_Rasterize(bp+20 /* &gbm */, 0.35, *(*uintptr)(unsafe.Pointer(bp /* vertices */)), num_verts, scale_x, scale_y, shift_x, shift_y, *(*int32)(unsafe.Pointer(bp + 4 /* ix0 */)), *(*int32)(unsafe.Pointer(bp + 8 /* iy0 */)), 1, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		}
	}
	nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp /* vertices */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
	return (*Stbtt__bitmap)(unsafe.Pointer(bp + 20 /* &gbm */)).Pixels
}

func Xstbtt_GetGlyphBitmap(info uintptr, scale_x float32, scale_y float32, glyph int32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:14934:25: */
	return Xstbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0, 0.0, glyph, width, height, xoff, yoff)
}

func Xstbtt_MakeGlyphBitmapSubpixel(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, glyph int32) { /* nuklear.h:14939:16: */
	bp := tlsAlloc(28)
	defer tlsFree(28)

	// var ix0 int32 at bp+4, 4

	// var iy0 int32 at bp+8, 4

	// var vertices uintptr at bp, 4

	var num_verts int32 = Xstbtt_GetGlyphShape(info, glyph, bp /* &vertices */)
	// var gbm Stbtt__bitmap at bp+12, 16

	Xstbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, bp+4 /* &ix0 */, bp+8 /* &iy0 */, uintptr(0), uintptr(0))
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 12 /* &gbm */)).Pixels = output
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 12 /* &gbm */)).W = out_w
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 12 /* &gbm */)).H = out_h
	(*Stbtt__bitmap)(unsafe.Pointer(bp + 12 /* &gbm */)).Stride = out_stride

	if ((*Stbtt__bitmap)(unsafe.Pointer(bp+12 /* &gbm */)).W != 0) && ((*Stbtt__bitmap)(unsafe.Pointer(bp+12 /* &gbm */)).H != 0) {
		Xstbtt_Rasterize(bp+12 /* &gbm */, 0.35, *(*uintptr)(unsafe.Pointer(bp /* vertices */)), num_verts, scale_x, scale_y, shift_x, shift_y, *(*int32)(unsafe.Pointer(bp + 4 /* ix0 */)), *(*int32)(unsafe.Pointer(bp + 8 /* iy0 */)), 1, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
	}

	nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp /* vertices */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
}

func Xstbtt_MakeGlyphBitmap(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, glyph int32) { /* nuklear.h:14958:16: */
	Xstbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0, 0.0, glyph)
}

func Xstbtt_GetCodepointBitmapSubpixel(info uintptr, scale_x float32, scale_y float32, shift_x float32, shift_y float32, codepoint int32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:14963:25: */
	return Xstbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, shift_x, shift_y, Xstbtt_FindGlyphIndex(info, codepoint), width, height, xoff, yoff)
}

func Xstbtt_MakeCodepointBitmapSubpixelPrefilter(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, oversample_x int32, oversample_y int32, sub_x uintptr, sub_y uintptr, codepoint int32) { /* nuklear.h:14968:16: */
	Xstbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, Xstbtt_FindGlyphIndex(info, codepoint))
}

func Xstbtt_MakeCodepointBitmapSubpixel(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, codepoint int32) { /* nuklear.h:14973:16: */
	Xstbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, Xstbtt_FindGlyphIndex(info, codepoint))
}

func Xstbtt_GetCodepointBitmap(info uintptr, scale_x float32, scale_y float32, codepoint int32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:14978:25: */
	return Xstbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0, 0.0, codepoint, width, height, xoff, yoff)
}

func Xstbtt_MakeCodepointBitmap(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, codepoint int32) { /* nuklear.h:14983:16: */
	Xstbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0, 0.0, codepoint)
}

// ////////////////////////////////////////////////////////////////////////////
//
//  bitmap baking
//
//  This is SUPER-CRAPPY packing to keep source code small

func stbtt_BakeFontBitmap_internal(data uintptr, offset int32, pixel_height float32, pixels uintptr, pw int32, ph int32, first_char int32, num_chars int32, chardata uintptr) int32 { /* nuklear.h:14994:12: */
	bp := tlsAlloc(152)
	defer tlsFree(152)

	var scale float32
	var x int32
	var y int32
	var bottom_y int32
	var i int32
	// var f Stbtt_fontinfo at bp, 128

	(*Stbtt_fontinfo)(unsafe.Pointer(bp /* &f */)).Userdata = uintptr(0)
	if !(Xstbtt_InitFont(bp /* &f */, data, offset) != 0) {
		return -1
	}
	Xmemset(pixels, 0, (uint32(pw * ph))) //  background of 0 around pixels
	x = AssignInt32(&y, 1)
	bottom_y = 1

	scale = Xstbtt_ScaleForPixelHeight(bp /* &f */, pixel_height)

	for i = 0; i < num_chars; i++ {
		// var advance int32 at bp+128, 4

		// var lsb int32 at bp+132, 4

		// var x0 int32 at bp+136, 4

		// var y0 int32 at bp+140, 4

		// var x1 int32 at bp+144, 4

		// var y1 int32 at bp+148, 4

		var gw int32
		var gh int32
		var g int32 = Xstbtt_FindGlyphIndex(bp /* &f */, (first_char + i))
		Xstbtt_GetGlyphHMetrics(bp /* &f */, g, bp+128 /* &advance */, bp+132 /* &lsb */)
		Xstbtt_GetGlyphBitmapBox(bp /* &f */, g, scale, scale, bp+136 /* &x0 */, bp+140 /* &y0 */, bp+144 /* &x1 */, bp+148 /* &y1 */)
		gw = (*(*int32)(unsafe.Pointer(bp + 144 /* x1 */)) - *(*int32)(unsafe.Pointer(bp + 136 /* x0 */)))
		gh = (*(*int32)(unsafe.Pointer(bp + 148 /* y1 */)) - *(*int32)(unsafe.Pointer(bp + 140 /* y0 */)))
		if ((x + gw) + 1) >= pw {
			y = bottom_y
			x = 1
		} //  advance to next row
		if ((y + gh) + 1) >= ph { //  check if it fits vertically AFTER potentially moving to next row
			return -i
		}
		if (x + gw) < pw {
		} else {
			X__assert_fail(ts+4277 /* "x+gw < pw" */, ts+2 /* "nuklear/nuklear...." */, uint32(15023), uintptr(unsafe.Pointer(&__func__127)))
		}
		if (y + gh) < ph {
		} else {
			X__assert_fail(ts+4287 /* "y+gh < ph" */, ts+2 /* "nuklear/nuklear...." */, uint32(15024), uintptr(unsafe.Pointer(&__func__127)))
		}
		Xstbtt_MakeGlyphBitmap(bp /* &f */, ((pixels + uintptr(x)) + uintptr((y * pw))), gw, gh, pw, scale, scale, g)
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).X0 = uint16(Stbtt_int16(x))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).Y0 = uint16(Stbtt_int16(y))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).X1 = uint16((Stbtt_int16(x + gw)))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).Y1 = uint16((Stbtt_int16(y + gh)))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).Xadvance = (scale * float32(*(*int32)(unsafe.Pointer(bp + 128 /* advance */))))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).Xoff = float32(*(*int32)(unsafe.Pointer(bp + 136 /* x0 */)))
		(*Stbtt_bakedchar)(unsafe.Pointer(chardata + uintptr(i)*20)).Yoff = float32(*(*int32)(unsafe.Pointer(bp + 140 /* y0 */)))
		x = ((x + gw) + 1)
		if ((y + gh) + 1) > bottom_y {
			bottom_y = ((y + gh) + 1)
		}
	}
	return bottom_y
}

var __func__127 = *(*[30]int8)(unsafe.Pointer(ts + 4297 /* "stbtt_BakeFontBi..." */)) /* nuklear.h:14999:1 */

func Xstbtt_GetBakedQuad(chardata uintptr, pw int32, ph int32, char_index int32, xpos uintptr, ypos uintptr, q uintptr, opengl_fillrule int32) { /* nuklear.h:15040:16: */
	var d3d_bias float32
	if opengl_fillrule != 0 {
		d3d_bias = float32(0)
	} else {
		d3d_bias = -0.5
	}
	var ipw float32 = (1.0 / float32(pw))
	var iph float32 = (1.0 / float32(ph))
	var b uintptr = (chardata + uintptr(char_index)*20)
	var round_x int32 = int32(Xfloor((float64((*(*float32)(unsafe.Pointer(xpos)) + (*Stbtt_bakedchar)(unsafe.Pointer(b)).Xoff) + 0.5))))
	var round_y int32 = int32(Xfloor((float64((*(*float32)(unsafe.Pointer(ypos)) + (*Stbtt_bakedchar)(unsafe.Pointer(b)).Yoff) + 0.5))))

	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X0 = (float32(round_x) + d3d_bias)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y0 = (float32(round_y) + d3d_bias)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X1 = ((float32((round_x + int32((*Stbtt_bakedchar)(unsafe.Pointer(b)).X1)) - int32((*Stbtt_bakedchar)(unsafe.Pointer(b)).X0))) + d3d_bias)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y1 = ((float32((round_y + int32((*Stbtt_bakedchar)(unsafe.Pointer(b)).Y1)) - int32((*Stbtt_bakedchar)(unsafe.Pointer(b)).Y0))) + d3d_bias)

	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).S0 = (float32((*Stbtt_bakedchar)(unsafe.Pointer(b)).X0) * ipw)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).T0 = (float32((*Stbtt_bakedchar)(unsafe.Pointer(b)).Y0) * iph)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).S1 = (float32((*Stbtt_bakedchar)(unsafe.Pointer(b)).X1) * ipw)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).T1 = (float32((*Stbtt_bakedchar)(unsafe.Pointer(b)).Y1) * iph)

	*(*float32)(unsafe.Pointer(xpos)) += ((*Stbtt_bakedchar)(unsafe.Pointer(b)).Xadvance)
}

// ////////////////////////////////////////////////////////////////////////////
//
//  rectangle packing replacement routines if you don't have stb_rect_pack.h
//

// ////////////////////////////////////////////////////////////////////////////
//
//  bitmap baking
//
//  This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
//  stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

func Xstbtt_PackBegin(spc uintptr, pixels uintptr, pw int32, ph int32, stride_in_bytes int32, padding int32, alloc_context uintptr) int32 { /* nuklear.h:15138:15: */
	var context uintptr = nk_stbtt_malloc(uint32(unsafe.Sizeof(Stbrp_context{})), alloc_context)
	var num_nodes int32 = (pw - padding)
	var nodes uintptr = nk_stbtt_malloc((uint32(unsafe.Sizeof(Stbrp_node{})) * uint32(num_nodes)), alloc_context)

	if (context == (uintptr(0))) || (nodes == (uintptr(0))) {
		if context != (uintptr(0)) {
			nk_stbtt_free(context, alloc_context)
		}
		if nodes != (uintptr(0)) {
			nk_stbtt_free(nodes, alloc_context)
		}
		return 0
	}

	(*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context = alloc_context
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Width = pw
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Height = ph
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Pixels = pixels
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Pack_info = context
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Nodes = nodes
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Padding = padding
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes = func() int32 {
		if stride_in_bytes != 0 {
			return stride_in_bytes
		}
		return pw
	}()
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample = uint32(1)
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample = uint32(1)
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Skip_missing = 0

	Xstbrp_init_target(context, (pw - padding), (ph - padding), nodes, num_nodes)

	if pixels != 0 {
		Xmemset(pixels, 0, (uint32(pw * ph)))
	} //  background of 0 around pixels

	return 1
}

func Xstbtt_PackEnd(spc uintptr) { /* nuklear.h:15170:16: */
	nk_stbtt_free((*Stbtt_pack_context)(unsafe.Pointer(spc)).Nodes, (*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context)
	nk_stbtt_free((*Stbtt_pack_context)(unsafe.Pointer(spc)).Pack_info, (*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context)
}

func Xstbtt_PackSetOversampling(spc uintptr, h_oversample uint32, v_oversample uint32) { /* nuklear.h:15176:16: */
	if h_oversample <= uint32(STBTT_MAX_OVERSAMPLE) {
	} else {
		X__assert_fail(ts+4327 /* "h_oversample <= ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(15178), uintptr(unsafe.Pointer(&__func__128)))
	}
	if v_oversample <= uint32(STBTT_MAX_OVERSAMPLE) {
	} else {
		X__assert_fail(ts+4345 /* "v_oversample <= ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(15179), uintptr(unsafe.Pointer(&__func__128)))
	}
	if h_oversample <= uint32(STBTT_MAX_OVERSAMPLE) {
		(*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample = h_oversample
	}
	if v_oversample <= uint32(STBTT_MAX_OVERSAMPLE) {
		(*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample = v_oversample
	}
}

var __func__128 = *(*[26]int8)(unsafe.Pointer(ts + 4363 /* "stbtt_PackSetOve..." */)) /* nuklear.h:15177:1 */

func Xstbtt_PackSetSkipMissingCodepoints(spc uintptr, skip int32) { /* nuklear.h:15186:16: */
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).Skip_missing = skip
}

func stbtt__h_prefilter(pixels uintptr, w int32, h int32, stride_in_bytes int32, kernel_width uint32) { /* nuklear.h:15193:13: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	// var buffer [8]uint8 at bp, 8

	var safe_w int32 = (int32(uint32(w) - kernel_width))
	var j int32
	Xmemset(bp /* &buffer[0] */, 0, uint32(STBTT_MAX_OVERSAMPLE)) //  suppress bogus warning from VS2013 -analyze
	for j = 0; j < h; j++ {
		var i int32
		var total uint32
		Xmemset(bp /* &buffer[0] */, 0, uint32(kernel_width))

		total = uint32(0)

		//  make kernel_width a constant in common cases so compiler can optimize out the divide
		switch kernel_width {
		case uint32(2):
			for i = 0; i <= safe_w; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr(i)))
				*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / uint32(2)))
			}
			break
		case uint32(3):
			for i = 0; i <= safe_w; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr(i)))
				*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / uint32(3)))
			}
			break
		case uint32(4):
			for i = 0; i <= safe_w; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr(i)))
				*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / uint32(4)))
			}
			break
		case uint32(5):
			for i = 0; i <= safe_w; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr(i)))
				*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / uint32(5)))
			}
			break
		default:
			for i = 0; i <= safe_w; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr(i)))
				*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / kernel_width))
			}
			break
		}

		for ; i < w; i++ {
			if int32(*(*uint8)(unsafe.Pointer(pixels + uintptr(i)))) == 0 {
			} else {
				X__assert_fail(ts+4389 /* "pixels[i] == 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(15246), uintptr(unsafe.Pointer(&__func__129)))
			}
			total = total - (uint32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1)))))))
			*(*uint8)(unsafe.Pointer(pixels + uintptr(i))) = (uint8(total / kernel_width))
		}

		pixels += uintptr(stride_in_bytes)
	}
}

var __func__129 = *(*[19]int8)(unsafe.Pointer(ts + 4404 /* "stbtt__h_prefilt..." */)) /* nuklear.h:15194:1 */

func stbtt__v_prefilter(pixels uintptr, w int32, h int32, stride_in_bytes int32, kernel_width uint32) { /* nuklear.h:15255:13: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	// var buffer [8]uint8 at bp, 8

	var safe_h int32 = (int32(uint32(h) - kernel_width))
	var j int32
	Xmemset(bp /* &buffer[0] */, 0, uint32(STBTT_MAX_OVERSAMPLE)) //  suppress bogus warning from VS2013 -analyze
	for j = 0; j < w; j++ {
		var i int32
		var total uint32
		Xmemset(bp /* &buffer[0] */, 0, uint32(kernel_width))

		total = uint32(0)

		//  make kernel_width a constant in common cases so compiler can optimize out the divide
		switch kernel_width {
		case uint32(2):
			for i = 0; i <= safe_h; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))
				*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / uint32(2)))
			}
			break
		case uint32(3):
			for i = 0; i <= safe_h; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))
				*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / uint32(3)))
			}
			break
		case uint32(4):
			for i = 0; i <= safe_h; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))
				*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / uint32(4)))
			}
			break
		case uint32(5):
			for i = 0; i <= safe_h; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))
				*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / uint32(5)))
			}
			break
		default:
			for i = 0; i <= safe_h; i++ {
				total = total + (uint32(int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) - int32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1))))))))
				*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr(((uint32(i) + kernel_width) & (uint32(STBTT_MAX_OVERSAMPLE - 1)))))) = *(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))
				*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / kernel_width))
			}
			break
		}

		for ; i < h; i++ {
			if int32(*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes))))) == 0 {
			} else {
				X__assert_fail(ts+4423 /* "pixels[i*stride_..." */, ts+2 /* "nuklear/nuklear...." */, uint32(15308), uintptr(unsafe.Pointer(&__func__130)))
			}
			total = total - (uint32(*(*uint8)(unsafe.Pointer(bp /* &buffer[0] */ + uintptr((i & (STBTT_MAX_OVERSAMPLE - 1)))))))
			*(*uint8)(unsafe.Pointer(pixels + uintptr((i * stride_in_bytes)))) = (uint8(total / kernel_width))
		}

		pixels += uintptr(1)
	}
}

var __func__130 = *(*[19]int8)(unsafe.Pointer(ts + 4454 /* "stbtt__v_prefilt..." */)) /* nuklear.h:15256:1 */

func stbtt__oversample_shift(oversample int32) float32 { /* nuklear.h:15317:14: */
	if !(oversample != 0) {
		return 0.0
	}

	//  The prefilter is a box filter of width "oversample",
	//  which shifts phase by (oversample - 1)/2 pixels in
	//  oversampled space. We want to shift in the opposite
	//  direction to counter this.
	return (float32(-(oversample - 1)) / (2.0 * float32(oversample)))
}

//  rects array must be big enough to accommodate all characters in the given ranges
func Xstbtt_PackFontRangesGatherRects(spc uintptr, info uintptr, ranges uintptr, num_ranges int32, rects uintptr) int32 { /* nuklear.h:15330:15: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var i int32
	var j int32
	var k int32
	var missing_glyph_added int32 = 0

	k = 0
	for i = 0; i < num_ranges; i++ {
		var fh float32 = (*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).Font_size
		var scale float32
		if fh > float32(0) {
			scale = Xstbtt_ScaleForPixelHeight(info, fh)
		} else {
			scale = Xstbtt_ScaleForMappingEmToPixels(info, -fh)
		}
		(*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).H_oversample = uint8((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)
		(*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).V_oversample = uint8((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)
		for j = 0; j < (*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Num_chars; j++ {
			// var x0 int32 at bp, 4

			// var y0 int32 at bp+4, 4

			// var x1 int32 at bp+8, 4

			// var y1 int32 at bp+12, 4

			var codepoint int32
			if (*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Array_of_unicode_codepoints == (uintptr(0)) {
				codepoint = ((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).First_unicode_codepoint_in_range + j)
			} else {
				codepoint = *(*int32)(unsafe.Pointer((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Array_of_unicode_codepoints + uintptr(j)*4))
			}
			var glyph int32 = Xstbtt_FindGlyphIndex(info, codepoint)
			if (glyph == 0) && (((*Stbtt_pack_context)(unsafe.Pointer(spc)).Skip_missing != 0) || (missing_glyph_added != 0)) {
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(k)*16)).W = AssignPtrUint16(rects+uintptr(k)*16+6 /* &.h */, Stbrp_coord(0))
			} else {
				Xstbtt_GetGlyphBitmapBoxSubpixel(info, glyph,
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)),
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)),
					float32(0), float32(0),
					bp /* &x0 */, bp+4 /* &y0 */, bp+8 /* &x1 */, bp+12 /* &y1 */)
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(k)*16)).W = (Stbrp_coord(((uint32((*(*int32)(unsafe.Pointer(bp + 8 /* x1 */)) - *(*int32)(unsafe.Pointer(bp /* x0 */))) + (*Stbtt_pack_context)(unsafe.Pointer(spc)).Padding)) + (*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample) - uint32(1)))
				(*Stbrp_rect)(unsafe.Pointer(rects + uintptr(k)*16)).H = (Stbrp_coord(((uint32((*(*int32)(unsafe.Pointer(bp + 12 /* y1 */)) - *(*int32)(unsafe.Pointer(bp + 4 /* y0 */))) + (*Stbtt_pack_context)(unsafe.Pointer(spc)).Padding)) + (*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample) - uint32(1)))
				if glyph == 0 {
					missing_glyph_added = 1
				}
			}
			k++
		}
	}

	return k
}

func Xstbtt_MakeGlyphBitmapSubpixelPrefilter(info uintptr, output uintptr, out_w int32, out_h int32, out_stride int32, scale_x float32, scale_y float32, shift_x float32, shift_y float32, prefilter_x int32, prefilter_y int32, sub_x uintptr, sub_y uintptr, glyph int32) { /* nuklear.h:15365:16: */
	Xstbtt_MakeGlyphBitmapSubpixel(info,
		output,
		(out_w - (prefilter_x - 1)),
		(out_h - (prefilter_y - 1)),
		out_stride,
		scale_x,
		scale_y,
		shift_x,
		shift_y,
		glyph)

	if prefilter_x > 1 {
		stbtt__h_prefilter(output, out_w, out_h, out_stride, uint32(prefilter_x))
	}

	if prefilter_y > 1 {
		stbtt__v_prefilter(output, out_w, out_h, out_stride, uint32(prefilter_y))
	}

	*(*float32)(unsafe.Pointer(sub_x)) = stbtt__oversample_shift(prefilter_x)
	*(*float32)(unsafe.Pointer(sub_y)) = stbtt__oversample_shift(prefilter_y)
}

//  rects array must be big enough to accommodate all characters in the given ranges
func Xstbtt_PackFontRangesRenderIntoRects(spc uintptr, info uintptr, ranges uintptr, num_ranges int32, rects uintptr) int32 { /* nuklear.h:15389:15: */
	bp := tlsAlloc(24)
	defer tlsFree(24)

	var i int32
	var j int32
	var k int32
	var missing_glyph int32 = -1
	var return_value int32 = 1

	//  save current values
	var old_h_over int32 = int32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)
	var old_v_over int32 = int32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)

	k = 0
	for i = 0; i < num_ranges; i++ {
		var fh float32 = (*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).Font_size
		var scale float32
		if fh > float32(0) {
			scale = Xstbtt_ScaleForPixelHeight(info, fh)
		} else {
			scale = Xstbtt_ScaleForMappingEmToPixels(info, -fh)
		}
		var recip_h float32
		var recip_v float32
		var sub_x float32
		var sub_y float32
		(*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample = uint32((*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).H_oversample)
		(*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample = uint32((*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).V_oversample)
		recip_h = (1.0 / float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample))
		recip_v = (1.0 / float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample))
		sub_x = stbtt__oversample_shift(int32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample))
		sub_y = stbtt__oversample_shift(int32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample))
		for j = 0; j < (*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Num_chars; j++ {
			var r uintptr = (rects + uintptr(k)*16)
			if (((*Stbrp_rect)(unsafe.Pointer(r)).Was_packed != 0) && (int32((*Stbrp_rect)(unsafe.Pointer(r)).W) != 0)) && (int32((*Stbrp_rect)(unsafe.Pointer(r)).H) != 0) {
				var bc uintptr = ((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range + uintptr(j)*28)
				// var advance int32 at bp, 4

				// var lsb int32 at bp+4, 4

				// var x0 int32 at bp+8, 4

				// var y0 int32 at bp+12, 4

				// var x1 int32 at bp+16, 4

				// var y1 int32 at bp+20, 4

				var codepoint int32
				if (*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Array_of_unicode_codepoints == (uintptr(0)) {
					codepoint = ((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).First_unicode_codepoint_in_range + j)
				} else {
					codepoint = *(*int32)(unsafe.Pointer((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Array_of_unicode_codepoints + uintptr(j)*4))
				}
				var glyph int32 = Xstbtt_FindGlyphIndex(info, codepoint)
				var pad Stbrp_coord = Stbrp_coord((*Stbtt_pack_context)(unsafe.Pointer(spc)).Padding)

				//  pad on left and top
				*(*Stbrp_coord)(unsafe.Pointer(r + 8 /* &.x */)) += Stbrp_coord((int32(pad)))
				*(*Stbrp_coord)(unsafe.Pointer(r + 10 /* &.y */)) += Stbrp_coord((int32(pad)))
				*(*Stbrp_coord)(unsafe.Pointer(r + 4 /* &.w */)) -= Stbrp_coord((int32(pad)))
				*(*Stbrp_coord)(unsafe.Pointer(r + 6 /* &.h */)) -= Stbrp_coord((int32(pad)))
				Xstbtt_GetGlyphHMetrics(info, glyph, bp /* &advance */, bp+4 /* &lsb */)
				Xstbtt_GetGlyphBitmapBox(info, glyph,
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)),
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)),
					bp+8 /* &x0 */, bp+12 /* &y0 */, bp+16 /* &x1 */, bp+20 /* &y1 */)
				Xstbtt_MakeGlyphBitmapSubpixel(info,
					(((*Stbtt_pack_context)(unsafe.Pointer(spc)).Pixels + uintptr((*Stbrp_rect)(unsafe.Pointer(r)).X)) + uintptr((int32((*Stbrp_rect)(unsafe.Pointer(r)).Y) * (*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes))),
					(int32((uint32((*Stbrp_rect)(unsafe.Pointer(r)).W) - (*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample) + uint32(1))),
					(int32((uint32((*Stbrp_rect)(unsafe.Pointer(r)).H) - (*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample) + uint32(1))),
					(*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes,
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)),
					(scale * float32((*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)),
					float32(0), float32(0),
					glyph)

				if (*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample > uint32(1) {
					stbtt__h_prefilter((((*Stbtt_pack_context)(unsafe.Pointer(spc)).Pixels + uintptr((*Stbrp_rect)(unsafe.Pointer(r)).X)) + uintptr((int32((*Stbrp_rect)(unsafe.Pointer(r)).Y) * (*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes))),
						int32((*Stbrp_rect)(unsafe.Pointer(r)).W), int32((*Stbrp_rect)(unsafe.Pointer(r)).H), (*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes,
						(*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample)
				}

				if (*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample > uint32(1) {
					stbtt__v_prefilter((((*Stbtt_pack_context)(unsafe.Pointer(spc)).Pixels + uintptr((*Stbrp_rect)(unsafe.Pointer(r)).X)) + uintptr((int32((*Stbrp_rect)(unsafe.Pointer(r)).Y) * (*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes))),
						int32((*Stbrp_rect)(unsafe.Pointer(r)).W), int32((*Stbrp_rect)(unsafe.Pointer(r)).H), (*Stbtt_pack_context)(unsafe.Pointer(spc)).Stride_in_bytes,
						(*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample)
				}

				(*Stbtt_packedchar)(unsafe.Pointer(bc)).X0 = uint16(Stbtt_int16((*Stbrp_rect)(unsafe.Pointer(r)).X))
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Y0 = uint16(Stbtt_int16((*Stbrp_rect)(unsafe.Pointer(r)).Y))
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).X1 = uint16((Stbtt_int16(int32((*Stbrp_rect)(unsafe.Pointer(r)).X) + int32((*Stbrp_rect)(unsafe.Pointer(r)).W))))
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Y1 = uint16((Stbtt_int16(int32((*Stbrp_rect)(unsafe.Pointer(r)).Y) + int32((*Stbrp_rect)(unsafe.Pointer(r)).H))))
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Xadvance = (scale * float32(*(*int32)(unsafe.Pointer(bp /* advance */))))
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Xoff = ((float32(*(*int32)(unsafe.Pointer(bp + 8 /* x0 */))) * recip_h) + sub_x)
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Yoff = ((float32(*(*int32)(unsafe.Pointer(bp + 12 /* y0 */))) * recip_v) + sub_y)
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Xoff2 = (((float32(*(*int32)(unsafe.Pointer(bp + 8 /* x0 */)) + int32((*Stbrp_rect)(unsafe.Pointer(r)).W))) * recip_h) + sub_x)
				(*Stbtt_packedchar)(unsafe.Pointer(bc)).Yoff2 = (((float32(*(*int32)(unsafe.Pointer(bp + 12 /* y0 */)) + int32((*Stbrp_rect)(unsafe.Pointer(r)).H))) * recip_v) + sub_y)

				if glyph == 0 {
					missing_glyph = j
				}
			} else if (*Stbtt_pack_context)(unsafe.Pointer(spc)).Skip_missing != 0 {
				return_value = 0
			} else if ((((*Stbrp_rect)(unsafe.Pointer(r)).Was_packed != 0) && (int32((*Stbrp_rect)(unsafe.Pointer(r)).W) == 0)) && (int32((*Stbrp_rect)(unsafe.Pointer(r)).H) == 0)) && (missing_glyph >= 0) {
				*(*Stbtt_packedchar)(unsafe.Pointer((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range + uintptr(j)*28)) = *(*Stbtt_packedchar)(unsafe.Pointer((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range + uintptr(missing_glyph)*28))
			} else {
				return_value = 0 //  if any fail, report failure
			}

			k++
		}
	}

	//  restore original values
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).H_oversample = uint32(old_h_over)
	(*Stbtt_pack_context)(unsafe.Pointer(spc)).V_oversample = uint32(old_v_over)

	return return_value
}

func Xstbtt_PackFontRangesPackRects(spc uintptr, rects uintptr, num_rects int32) { /* nuklear.h:15478:16: */
	Xstbrp_pack_rects((*Stbtt_pack_context)(unsafe.Pointer(spc)).Pack_info, rects, num_rects)
}

func Xstbtt_PackFontRanges(spc uintptr, fontdata uintptr, font_index int32, ranges uintptr, num_ranges int32) int32 { /* nuklear.h:15483:15: */
	bp := tlsAlloc(128)
	defer tlsFree(128)

	// var info Stbtt_fontinfo at bp, 128

	var i int32
	var j int32
	var n int32
	var return_value int32 = 1
	// stbrp_context *context = (stbrp_context *) spc->pack_info;
	var rects uintptr

	//  flag all characters as NOT packed
	for i = 0; i < num_ranges; i++ {
		for j = 0; j < (*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Num_chars; j++ {
			(*Stbtt_packedchar)(unsafe.Pointer((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range + uintptr(j)*28)).X0 = AssignPtrUint16((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range+uintptr(j)*28+2 /* &.y0 */, AssignPtrUint16((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range+uintptr(j)*28+4 /* &.x1 */, AssignPtrUint16((*Stbtt_pack_range)(unsafe.Pointer(ranges+uintptr(i)*24)).Chardata_for_range+uintptr(j)*28+6 /* &.y1 */, uint16(0))))
		}
	}

	n = 0
	for i = 0; i < num_ranges; i++ {
		n = n + ((*Stbtt_pack_range)(unsafe.Pointer(ranges + uintptr(i)*24)).Num_chars)
	}

	rects = nk_stbtt_malloc((uint32(unsafe.Sizeof(Stbrp_rect{})) * uint32(n)), (*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context)
	if rects == (uintptr(0)) {
		return 0
	}

	(*Stbtt_fontinfo)(unsafe.Pointer(bp /* &info */)).Userdata = (*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context
	Xstbtt_InitFont(bp /* &info */, fontdata, Xstbtt_GetFontOffsetForIndex(fontdata, font_index))

	n = Xstbtt_PackFontRangesGatherRects(spc, bp /* &info */, ranges, num_ranges, rects)

	Xstbtt_PackFontRangesPackRects(spc, rects, n)

	return_value = Xstbtt_PackFontRangesRenderIntoRects(spc, bp /* &info */, ranges, num_ranges, rects)

	nk_stbtt_free(rects, (*Stbtt_pack_context)(unsafe.Pointer(spc)).User_allocator_context)
	return return_value
}

func Xstbtt_PackFontRange(spc uintptr, fontdata uintptr, font_index int32, font_size float32, first_unicode_codepoint_in_range int32, num_chars_in_range int32, chardata_for_range uintptr) int32 { /* nuklear.h:15519:15: */
	bp := tlsAlloc(24)
	defer tlsFree(24)

	// var range1 Stbtt_pack_range at bp, 24

	(*Stbtt_pack_range)(unsafe.Pointer(bp /* &range1 */)).First_unicode_codepoint_in_range = first_unicode_codepoint_in_range
	(*Stbtt_pack_range)(unsafe.Pointer(bp /* &range1 */)).Array_of_unicode_codepoints = uintptr(0)
	(*Stbtt_pack_range)(unsafe.Pointer(bp /* &range1 */)).Num_chars = num_chars_in_range
	(*Stbtt_pack_range)(unsafe.Pointer(bp /* &range1 */)).Chardata_for_range = chardata_for_range
	(*Stbtt_pack_range)(unsafe.Pointer(bp /* &range1 */)).Font_size = font_size
	return Xstbtt_PackFontRanges(spc, fontdata, font_index, bp /* &range1 */, 1)
}

func Xstbtt_GetScaledFontVMetrics(fontdata uintptr, index int32, size float32, ascent uintptr, descent uintptr, lineGap uintptr) { /* nuklear.h:15531:16: */
	bp := tlsAlloc(140)
	defer tlsFree(140)

	// var i_ascent int32 at bp+128, 4

	// var i_descent int32 at bp+132, 4

	// var i_lineGap int32 at bp+136, 4

	var scale float32
	// var info Stbtt_fontinfo at bp, 128

	Xstbtt_InitFont(bp /* &info */, fontdata, Xstbtt_GetFontOffsetForIndex(fontdata, index))
	if size > float32(0) {
		scale = Xstbtt_ScaleForPixelHeight(bp /* &info */, size)
	} else {
		scale = Xstbtt_ScaleForMappingEmToPixels(bp /* &info */, -size)
	}
	Xstbtt_GetFontVMetrics(bp /* &info */, bp+128 /* &i_ascent */, bp+132 /* &i_descent */, bp+136 /* &i_lineGap */)
	*(*float32)(unsafe.Pointer(ascent)) = (float32(*(*int32)(unsafe.Pointer(bp + 128 /* i_ascent */))) * scale)
	*(*float32)(unsafe.Pointer(descent)) = (float32(*(*int32)(unsafe.Pointer(bp + 132 /* i_descent */))) * scale)
	*(*float32)(unsafe.Pointer(lineGap)) = (float32(*(*int32)(unsafe.Pointer(bp + 136 /* i_lineGap */))) * scale)
}

func Xstbtt_GetPackedQuad(chardata uintptr, pw int32, ph int32, char_index int32, xpos uintptr, ypos uintptr, q uintptr, align_to_integer int32) { /* nuklear.h:15544:16: */
	var ipw float32 = (1.0 / float32(pw))
	var iph float32 = (1.0 / float32(ph))
	var b uintptr = (chardata + uintptr(char_index)*28)

	if align_to_integer != 0 {
		var x float32 = float32(int32(Xfloor((float64((*(*float32)(unsafe.Pointer(xpos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Xoff) + 0.5)))))
		var y float32 = float32(int32(Xfloor((float64((*(*float32)(unsafe.Pointer(ypos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Yoff) + 0.5)))))
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X0 = x
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y0 = y
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X1 = ((x + (*Stbtt_packedchar)(unsafe.Pointer(b)).Xoff2) - (*Stbtt_packedchar)(unsafe.Pointer(b)).Xoff)
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y1 = ((y + (*Stbtt_packedchar)(unsafe.Pointer(b)).Yoff2) - (*Stbtt_packedchar)(unsafe.Pointer(b)).Yoff)
	} else {
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X0 = (*(*float32)(unsafe.Pointer(xpos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Xoff)
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y0 = (*(*float32)(unsafe.Pointer(ypos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Yoff)
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).X1 = (*(*float32)(unsafe.Pointer(xpos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Xoff2)
		(*Stbtt_aligned_quad)(unsafe.Pointer(q)).Y1 = (*(*float32)(unsafe.Pointer(ypos)) + (*Stbtt_packedchar)(unsafe.Pointer(b)).Yoff2)
	}

	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).S0 = (float32((*Stbtt_packedchar)(unsafe.Pointer(b)).X0) * ipw)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).T0 = (float32((*Stbtt_packedchar)(unsafe.Pointer(b)).Y0) * iph)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).S1 = (float32((*Stbtt_packedchar)(unsafe.Pointer(b)).X1) * ipw)
	(*Stbtt_aligned_quad)(unsafe.Pointer(q)).T1 = (float32((*Stbtt_packedchar)(unsafe.Pointer(b)).Y1) * iph)

	*(*float32)(unsafe.Pointer(xpos)) += ((*Stbtt_packedchar)(unsafe.Pointer(b)).Xadvance)
}

// ////////////////////////////////////////////////////////////////////////////
//
//  sdf computation
//

func stbtt__ray_intersect_bezier(orig uintptr, ray uintptr, q0 uintptr, q1 uintptr, q2 uintptr, hits uintptr) int32 { /* nuklear.h:15579:12: */
	var q0perp float32 = ((*(*float32)(unsafe.Pointer(q0 + 1*4)) * *(*float32)(unsafe.Pointer(ray))) - (*(*float32)(unsafe.Pointer(q0)) * *(*float32)(unsafe.Pointer(ray + 1*4))))
	var q1perp float32 = ((*(*float32)(unsafe.Pointer(q1 + 1*4)) * *(*float32)(unsafe.Pointer(ray))) - (*(*float32)(unsafe.Pointer(q1)) * *(*float32)(unsafe.Pointer(ray + 1*4))))
	var q2perp float32 = ((*(*float32)(unsafe.Pointer(q2 + 1*4)) * *(*float32)(unsafe.Pointer(ray))) - (*(*float32)(unsafe.Pointer(q2)) * *(*float32)(unsafe.Pointer(ray + 1*4))))
	var roperp float32 = ((*(*float32)(unsafe.Pointer(orig + 1*4)) * *(*float32)(unsafe.Pointer(ray))) - (*(*float32)(unsafe.Pointer(orig)) * *(*float32)(unsafe.Pointer(ray + 1*4))))

	var a float32 = ((q0perp - (float32(2) * q1perp)) + q2perp)
	var b float32 = (q1perp - q0perp)
	var c float32 = (q0perp - roperp)

	var s0 float32 = 0.
	var s1 float32 = 0.
	var num_s int32 = 0

	if float64(a) != 0.0 {
		var discr float32 = ((b * b) - (a * c))
		if float64(discr) > 0.0 {
			var rcpna float32 = (float32(-1) / a)
			var d float32 = float32(Xsqrt(float64(discr)))
			s0 = ((b + d) * rcpna)
			s1 = ((b - d) * rcpna)
			if (float64(s0) >= 0.0) && (float64(s0) <= 1.0) {
				num_s = 1
			}
			if ((float64(d) > 0.0) && (float64(s1) >= 0.0)) && (float64(s1) <= 1.0) {
				if num_s == 0 {
					s0 = s1
				}
				num_s++
			}
		}
	} else {
		//  2*b*s + c = 0
		//  s = -c / (2*b)
		s0 = (c / (float32(-2) * b))
		if (float64(s0) >= 0.0) && (float64(s0) <= 1.0) {
			num_s = 1
		}
	}

	if num_s == 0 {
		return 0
	} else {
		var rcp_len2 float32 = (float32(1) / ((*(*float32)(unsafe.Pointer(ray)) * *(*float32)(unsafe.Pointer(ray))) + (*(*float32)(unsafe.Pointer(ray + 1*4)) * *(*float32)(unsafe.Pointer(ray + 1*4)))))
		var rayn_x float32 = (*(*float32)(unsafe.Pointer(ray)) * rcp_len2)
		var rayn_y float32 = (*(*float32)(unsafe.Pointer(ray + 1*4)) * rcp_len2)

		var q0d float32 = ((*(*float32)(unsafe.Pointer(q0)) * rayn_x) + (*(*float32)(unsafe.Pointer(q0 + 1*4)) * rayn_y))
		var q1d float32 = ((*(*float32)(unsafe.Pointer(q1)) * rayn_x) + (*(*float32)(unsafe.Pointer(q1 + 1*4)) * rayn_y))
		var q2d float32 = ((*(*float32)(unsafe.Pointer(q2)) * rayn_x) + (*(*float32)(unsafe.Pointer(q2 + 1*4)) * rayn_y))
		var rod float32 = ((*(*float32)(unsafe.Pointer(orig)) * rayn_x) + (*(*float32)(unsafe.Pointer(orig + 1*4)) * rayn_y))

		var q10d float32 = (q1d - q0d)
		var q20d float32 = (q2d - q0d)
		var q0rd float32 = (q0d - rod)

		*(*float32)(unsafe.Pointer((hits))) = ((q0rd + ((s0 * (2.0 - (2.0 * s0))) * q10d)) + ((s0 * s0) * q20d))
		*(*float32)(unsafe.Pointer((hits) + 1*4)) = ((a * s0) + b)

		if num_s > 1 {
			*(*float32)(unsafe.Pointer((hits + 1*8))) = ((q0rd + ((s1 * (2.0 - (2.0 * s1))) * q10d)) + ((s1 * s1) * q20d))
			*(*float32)(unsafe.Pointer((hits + 1*8) + 1*4)) = ((a * s1) + b)
			return 2
		} else {
			return 1
		}
	}
	return int32(0)
}

func equal(a uintptr, b uintptr) int32 { /* nuklear.h:15643:12: */
	return (Bool32((*(*float32)(unsafe.Pointer(a)) == *(*float32)(unsafe.Pointer(b))) && (*(*float32)(unsafe.Pointer(a + 1*4)) == *(*float32)(unsafe.Pointer(b + 1*4)))))
}

func stbtt__compute_crossings_x(x float32, y float32, nverts int32, verts uintptr) int32 { /* nuklear.h:15648:12: */
	bp := tlsAlloc(56)
	defer tlsFree(56)

	var i int32
	// var orig [2]float32 at bp, 8

	*(*[2]float32)(unsafe.Pointer(bp + 32 /* ray */)) = [2]float32{float32(1), float32(0)}
	var y_frac float32
	var winding int32 = 0

	*(*float32)(unsafe.Pointer(bp /* &orig[0] */)) = x
	*(*float32)(unsafe.Pointer(bp /* &orig[0] */ + 1*4)) = y

	//  make sure y never passes through a vertex of the shape
	y_frac = float32(Xfmod(float64(y), 1.0))
	if y_frac < 0.01 {
		y = y + (0.01)
	} else if y_frac > 0.99 {
		y = y - (0.01)
	}
	*(*float32)(unsafe.Pointer(bp /* &orig[0] */ + 1*4)) = y

	//  test a ray from (-infinity,y) to (x,y)
	for i = 0; i < nverts; i++ {
		if int32((*Stbtt_vertex)(unsafe.Pointer(verts+uintptr(i)*14)).Type) == STBTT_vline {
			var x0 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).X)
			var y0 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).Y)
			var x1 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).X)
			var y1 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).Y)
			if ((y > (func() float32 {
				if (y0) < (y1) {
					return float32(y0)
				}
				return float32(y1)
			}())) && (y < (func() float32 {
				if (y0) < (y1) {
					return float32(y1)
				}
				return float32(y0)
			}()))) && (x > (func() float32 {
				if (x0) < (x1) {
					return float32(x0)
				}
				return float32(x1)
			}())) {
				var x_inter float32 = ((((y - float32(y0)) / (float32(y1 - y0))) * (float32(x1 - x0))) + float32(x0))
				if x_inter < x {
					winding = winding + (func() int32 {
						if y0 < y1 {
							return 1
						}
						return -1
					}())
				}
			}
		}
		if int32((*Stbtt_vertex)(unsafe.Pointer(verts+uintptr(i)*14)).Type) == STBTT_vcurve {
			var x0 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).X)
			var y0 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).Y)
			var x1 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).Cx)
			var y1 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).Cy)
			var x2 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).X)
			var y2 int32 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).Y)
			var ax int32 = func() int32 {
				if (x0) < (func() int32 {
					if (x1) < (x2) {
						return x1
					}
					return x2
				}()) {
					return x0
				}
				return func() int32 {
					if (x1) < (x2) {
						return x1
					}
					return x2
				}()
			}()
			var ay int32 = func() int32 {
				if (y0) < (func() int32 {
					if (y1) < (y2) {
						return y1
					}
					return y2
				}()) {
					return y0
				}
				return func() int32 {
					if (y1) < (y2) {
						return y1
					}
					return y2
				}()
			}()
			var by int32 = func() int32 {
				if (y0) < (func() int32 {
					if (y1) < (y2) {
						return y2
					}
					return y1
				}()) {
					return func() int32 {
						if (y1) < (y2) {
							return y2
						}
						return y1
					}()
				}
				return y0
			}()
			if ((y > float32(ay)) && (y < float32(by))) && (x > float32(ax)) {
				// var q0 [2]float32 at bp+8, 8

				// var q1 [2]float32 at bp+16, 8

				// var q2 [2]float32 at bp+24, 8

				// var hits [2][2]float32 at bp+40, 16

				*(*float32)(unsafe.Pointer(bp + 8 /* &q0[0] */)) = float32(x0)
				*(*float32)(unsafe.Pointer(bp + 8 /* &q0[0] */ + 1*4)) = float32(y0)
				*(*float32)(unsafe.Pointer(bp + 16 /* &q1[0] */)) = float32(x1)
				*(*float32)(unsafe.Pointer(bp + 16 /* &q1[0] */ + 1*4)) = float32(y1)
				*(*float32)(unsafe.Pointer(bp + 24 /* &q2[0] */)) = float32(x2)
				*(*float32)(unsafe.Pointer(bp + 24 /* &q2[0] */ + 1*4)) = float32(y2)
				if (equal(bp+8 /* &q0[0] */, bp+16 /* &q1[0] */) != 0) || (equal(bp+16 /* &q1[0] */, bp+24 /* &q2[0] */) != 0) {
					x0 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).X)
					y0 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr((i-1))*14)).Y)
					x1 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).X)
					y1 = int32((*Stbtt_vertex)(unsafe.Pointer(verts + uintptr(i)*14)).Y)
					if ((y > (func() float32 {
						if (y0) < (y1) {
							return float32(y0)
						}
						return float32(y1)
					}())) && (y < (func() float32 {
						if (y0) < (y1) {
							return float32(y1)
						}
						return float32(y0)
					}()))) && (x > (func() float32 {
						if (x0) < (x1) {
							return float32(x0)
						}
						return float32(x1)
					}())) {
						var x_inter float32 = ((((y - float32(y0)) / (float32(y1 - y0))) * (float32(x1 - x0))) + float32(x0))
						if x_inter < x {
							winding = winding + (func() int32 {
								if y0 < y1 {
									return 1
								}
								return -1
							}())
						}
					}
				} else {
					var num_hits int32 = stbtt__ray_intersect_bezier(bp /* &orig[0] */, bp+32 /* &ray[0] */, bp+8 /* &q0[0] */, bp+16 /* &q1[0] */, bp+24 /* &q2[0] */, bp+40 /* &hits[0] */)
					if num_hits >= 1 {
						if *(*float32)(unsafe.Pointer((bp + 40 /* &hits[0] */))) < float32(0) {
							winding = winding + (func() int32 {
								if *(*float32)(unsafe.Pointer((bp + 40 /* &hits[0] */) + 1*4)) < float32(0) {
									return -1
								}
								return 1
							}())
						}
					}
					if num_hits >= 2 {
						if *(*float32)(unsafe.Pointer((bp + 40 /* &hits[0] */ + 1*8))) < float32(0) {
							winding = winding + (func() int32 {
								if *(*float32)(unsafe.Pointer((bp + 40 /* &hits[0] */ + 1*8) + 1*4)) < float32(0) {
									return -1
								}
								return 1
							}())
						}
					}
				}
			}
		}
	}
	return winding
}

func stbtt__cuberoot(x float32) float32 { /* nuklear.h:15717:14: */
	if x < float32(0) {
		return -float32(Xpow(float64(-x), (float64(float32(1.0) / 3.0))))
	} else {
		return float32(Xpow(float64(x), (float64(float32(1.0) / 3.0))))
	}
	return float32(0)
}

//  x^3 + c*x^2 + b*x + a = 0
func stbtt__solve_cubic(a float32, b float32, c float32, r uintptr) int32 { /* nuklear.h:15726:12: */
	var s float32 = (-a / float32(3))
	var p float32 = (b - ((a * a) / float32(3)))
	var q float32 = (((a * (((float32(2) * a) * a) - (float32(9) * b))) / float32(27)) + c)
	var p3 float32 = ((p * p) * p)
	var d float32 = ((q * q) + ((float32(4) * p3) / float32(27)))
	if d >= float32(0) {
		var z float32 = float32(Xsqrt(float64(d)))
		var u float32 = ((-q + z) / float32(2))
		var v float32 = ((-q - z) / float32(2))
		u = stbtt__cuberoot(u)
		v = stbtt__cuberoot(v)
		*(*float32)(unsafe.Pointer(r)) = ((s + u) + v)
		return 1
	} else {
		var u float32 = float32(Xsqrt((float64(-p / float32(3)))))
		var v float32 = (float32(Xacos(((-Xsqrt((float64(float32(-27) / p3))) * float64(q)) / float64(2)))) / float32(3)) //  p3 must be negative, since d is negative
		var m float32 = float32(Xcos(float64(v)))
		var n float32 = (float32(Xcos((float64(v) - (float64(3.141592) / float64(2))))) * 1.732050808)
		*(*float32)(unsafe.Pointer(r)) = (s + ((u * float32(2)) * m))
		*(*float32)(unsafe.Pointer(r + 1*4)) = (s - (u * (m + n)))
		*(*float32)(unsafe.Pointer(r + 2*4)) = (s - (u * (m - n)))

		// STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe?
		// STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f);
		// STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f);
		return 3
	}
	return int32(0)
}

func Xstbtt_GetGlyphSDF(info uintptr, scale float32, glyph int32, padding int32, onedge_value uint8, pixel_dist_scale float32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:15757:25: */
	bp := tlsAlloc(32)
	defer tlsFree(32)

	var scale_x float32 = scale
	var scale_y float32 = scale
	// var ix0 int32 at bp, 4

	// var iy0 int32 at bp+4, 4

	// var ix1 int32 at bp+8, 4

	// var iy1 int32 at bp+12, 4

	var w int32
	var h int32
	var data uintptr

	if scale == float32(0) {
		return uintptr(0)
	}

	Xstbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0, 0.0, bp /* &ix0 */, bp+4 /* &iy0 */, bp+8 /* &ix1 */, bp+12 /* &iy1 */)

	//  if empty, return NULL
	if (*(*int32)(unsafe.Pointer(bp /* ix0 */)) == *(*int32)(unsafe.Pointer(bp + 8 /* ix1 */))) || (*(*int32)(unsafe.Pointer(bp + 4 /* iy0 */)) == *(*int32)(unsafe.Pointer(bp + 12 /* iy1 */))) {
		return uintptr(0)
	}

	*(*int32)(unsafe.Pointer(bp /* ix0 */)) -= padding
	*(*int32)(unsafe.Pointer(bp + 4 /* iy0 */)) -= padding
	*(*int32)(unsafe.Pointer(bp + 8 /* ix1 */)) += padding
	*(*int32)(unsafe.Pointer(bp + 12 /* iy1 */)) += padding

	w = (*(*int32)(unsafe.Pointer(bp + 8 /* ix1 */)) - *(*int32)(unsafe.Pointer(bp /* ix0 */)))
	h = (*(*int32)(unsafe.Pointer(bp + 12 /* iy1 */)) - *(*int32)(unsafe.Pointer(bp + 4 /* iy0 */)))

	if width != 0 {
		*(*int32)(unsafe.Pointer(width)) = w
	}
	if height != 0 {
		*(*int32)(unsafe.Pointer(height)) = h
	}
	if xoff != 0 {
		*(*int32)(unsafe.Pointer(xoff)) = *(*int32)(unsafe.Pointer(bp /* ix0 */))
	}
	if yoff != 0 {
		*(*int32)(unsafe.Pointer(yoff)) = *(*int32)(unsafe.Pointer(bp + 4 /* iy0 */))
	}

	//  invert for y-downwards bitmaps
	scale_y = -scale_y

	{
		var x int32
		var y int32
		var i int32
		var j int32
		var precompute uintptr
		// var verts uintptr at bp+16, 4

		var num_verts int32 = Xstbtt_GetGlyphShape(info, glyph, bp+16 /* &verts */)
		data = nk_stbtt_malloc((uint32(w * h)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		precompute = nk_stbtt_malloc((uint32(num_verts) * uint32(unsafe.Sizeof(float32(0)))), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)

		i = 0
		j = (num_verts - 1)
		for ; i < num_verts; j = PostIncInt32(&i, 1) {
			if int32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Type) == STBTT_vline {
				var x0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).X) * scale_x)
				var y0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Y) * scale_y)
				var x1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(j)*14)).X) * scale_x)
				var y1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(j)*14)).Y) * scale_y)
				var dist float32 = float32(Xsqrt((float64(((x1 - x0) * (x1 - x0)) + ((y1 - y0) * (y1 - y0))))))
				*(*float32)(unsafe.Pointer(precompute + uintptr(i)*4)) = func() float32 {
					if dist == float32(0) {
						return 0.0
					}
					return (1.0 / dist)
				}()
			} else if int32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Type) == STBTT_vcurve {
				var x2 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(j)*14)).X) * scale_x)
				var y2 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(j)*14)).Y) * scale_y)
				var x1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Cx) * scale_x)
				var y1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Cy) * scale_y)
				var x0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).X) * scale_x)
				var y0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Y) * scale_y)
				var bx float32 = ((x0 - (float32(2) * x1)) + x2)
				var by float32 = ((y0 - (float32(2) * y1)) + y2)
				var len2 float32 = ((bx * bx) + (by * by))
				if len2 != 0.0 {
					*(*float32)(unsafe.Pointer(precompute + uintptr(i)*4)) = (1.0 / ((bx * bx) + (by * by)))
				} else {
					*(*float32)(unsafe.Pointer(precompute + uintptr(i)*4)) = 0.0
				}
			} else {
				*(*float32)(unsafe.Pointer(precompute + uintptr(i)*4)) = 0.0
			}
		}

		for y = *(*int32)(unsafe.Pointer(bp + 4 /* iy0 */)); y < *(*int32)(unsafe.Pointer(bp + 12 /* iy1 */)); y++ {
			for x = *(*int32)(unsafe.Pointer(bp /* ix0 */)); x < *(*int32)(unsafe.Pointer(bp + 8 /* ix1 */)); x++ {
				var val float32
				var min_dist float32 = 999999.0
				var sx float32 = (float32(x) + 0.5)
				var sy float32 = (float32(y) + 0.5)
				var x_gspace float32 = (sx / scale_x)
				var y_gspace float32 = (sy / scale_y)

				var winding int32 = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, *(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))) //  @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path

				for i = 0; i < num_verts; i++ {
					var x0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).X) * scale_x)
					var y0 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Y) * scale_y)

					//  check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve
					var dist2 float32 = (((x0 - sx) * (x0 - sx)) + ((y0 - sy) * (y0 - sy)))
					if dist2 < (min_dist * min_dist) {
						min_dist = float32(Xsqrt(float64(dist2)))
					}

					if int32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Type) == STBTT_vline {
						var x1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr((i-1))*14)).X) * scale_x)
						var y1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr((i-1))*14)).Y) * scale_y)

						//  coarse culling against bbox
						// if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist &&
						//     sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist)
						var dist float32 = (float32(Xfabs((float64(((x1 - x0) * (y0 - sy)) - ((y1 - y0) * (x0 - sx)))))) * *(*float32)(unsafe.Pointer(precompute + uintptr(i)*4)))
						if i != 0 {
						} else {
							X__assert_fail(ts+4473 /* "i != 0" */, ts+2 /* "nuklear/nuklear...." */, uint32(15842), uintptr(unsafe.Pointer(&__func__131)))
						}
						if dist < min_dist {
							//  check position along line
							//  x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0)
							//  minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy)
							var dx float32 = (x1 - x0)
							var dy float32 = (y1 - y0)
							var px float32 = (x0 - sx)
							var py float32 = (y0 - sy)
							//  minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy
							//  derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve
							var t float32 = (-((px * dx) + (py * dy)) / ((dx * dx) + (dy * dy)))
							if (t >= 0.0) && (t <= 1.0) {
								min_dist = dist
							}
						}
					} else if int32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Type) == STBTT_vcurve {
						var x2 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr((i-1))*14)).X) * scale_x)
						var y2 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr((i-1))*14)).Y) * scale_y)
						var x1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Cx) * scale_x)
						var y1 float32 = (float32((*Stbtt_vertex)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */))+uintptr(i)*14)).Cy) * scale_y)
						var box_x0 float32 = func() float32 {
							if (func() float32 {
								if (x0) < (x1) {
									return x0
								}
								return x1
							}()) < (x2) {
								return func() float32 {
									if (x0) < (x1) {
										return x0
									}
									return x1
								}()
							}
							return x2
						}()
						var box_y0 float32 = func() float32 {
							if (func() float32 {
								if (y0) < (y1) {
									return y0
								}
								return y1
							}()) < (y2) {
								return func() float32 {
									if (y0) < (y1) {
										return y0
									}
									return y1
								}()
							}
							return y2
						}()
						var box_x1 float32 = func() float32 {
							if (func() float32 {
								if (x0) < (x1) {
									return x1
								}
								return x0
							}()) < (x2) {
								return x2
							}
							return func() float32 {
								if (x0) < (x1) {
									return x1
								}
								return x0
							}()
						}()
						var box_y1 float32 = func() float32 {
							if (func() float32 {
								if (y0) < (y1) {
									return y1
								}
								return y0
							}()) < (y2) {
								return y2
							}
							return func() float32 {
								if (y0) < (y1) {
									return y1
								}
								return y0
							}()
						}()
						//  coarse culling against bbox to avoid computing cubic unnecessarily
						if (((sx > (box_x0 - min_dist)) && (sx < (box_x1 + min_dist))) && (sy > (box_y0 - min_dist))) && (sy < (box_y1 + min_dist)) {
							var num int32 = 0
							var ax float32 = (x1 - x0)
							var ay float32 = (y1 - y0)
							var bx float32 = ((x0 - (float32(2) * x1)) + x2)
							var by float32 = ((y0 - (float32(2) * y1)) + y2)
							var mx float32 = (x0 - sx)
							var my float32 = (y0 - sy)
							// var res [3]float32 at bp+20, 12

							var px float32
							var py float32
							var t float32
							var it float32
							var a_inv float32 = *(*float32)(unsafe.Pointer(precompute + uintptr(i)*4))
							if float64(a_inv) == 0.0 { //  if a_inv is 0, it's 2nd degree so use quadratic formula
								var a float32 = (float32(3) * ((ax * bx) + (ay * by)))
								var b float32 = ((float32(2) * ((ax * ax) + (ay * ay))) + ((mx * bx) + (my * by)))
								var c float32 = ((mx * ax) + (my * ay))
								if float64(a) == 0.0 { //  if a is 0, it's linear
									if float64(b) != 0.0 {
										*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + uintptr(PostIncInt32(&num, 1))*4)) = (-c / b)
									}
								} else {
									var discriminant float32 = ((b * b) - ((float32(4) * a) * c))
									if discriminant < float32(0) {
										num = 0
									} else {
										var root float32 = float32(Xsqrt(float64(discriminant)))
										*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */)) = ((-b - root) / (float32(2) * a))
										*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 1*4)) = ((-b + root) / (float32(2) * a))
										num = 2 //  don't bother distinguishing 1-solution case, as code below will still work
									}
								}
							} else {
								var b float32 = ((float32(3) * ((ax * bx) + (ay * by))) * a_inv) //  could precompute this as it doesn't depend on sample point
								var c float32 = (((float32(2) * ((ax * ax) + (ay * ay))) + ((mx * bx) + (my * by))) * a_inv)
								var d float32 = (((mx * ax) + (my * ay)) * a_inv)
								num = stbtt__solve_cubic(b, c, d, bp+20 /* &res[0] */)
							}
							if ((num >= 1) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */)) >= 0.0)) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */)) <= 1.0) {
								t = *(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */))
								it = (1.0 - t)
								px = ((((it * it) * x0) + (((float32(2) * t) * it) * x1)) + ((t * t) * x2))
								py = ((((it * it) * y0) + (((float32(2) * t) * it) * y1)) + ((t * t) * y2))
								dist2 = (((px - sx) * (px - sx)) + ((py - sy) * (py - sy)))
								if dist2 < (min_dist * min_dist) {
									min_dist = float32(Xsqrt(float64(dist2)))
								}
							}
							if ((num >= 2) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 1*4)) >= 0.0)) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 1*4)) <= 1.0) {
								t = *(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 1*4))
								it = (1.0 - t)
								px = ((((it * it) * x0) + (((float32(2) * t) * it) * x1)) + ((t * t) * x2))
								py = ((((it * it) * y0) + (((float32(2) * t) * it) * y1)) + ((t * t) * y2))
								dist2 = (((px - sx) * (px - sx)) + ((py - sy) * (py - sy)))
								if dist2 < (min_dist * min_dist) {
									min_dist = float32(Xsqrt(float64(dist2)))
								}
							}
							if ((num >= 3) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 2*4)) >= 0.0)) && (*(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 2*4)) <= 1.0) {
								t = *(*float32)(unsafe.Pointer(bp + 20 /* &res[0] */ + 2*4))
								it = (1.0 - t)
								px = ((((it * it) * x0) + (((float32(2) * t) * it) * x1)) + ((t * t) * x2))
								py = ((((it * it) * y0) + (((float32(2) * t) * it) * y1)) + ((t * t) * y2))
								dist2 = (((px - sx) * (px - sx)) + ((py - sy) * (py - sy)))
								if dist2 < (min_dist * min_dist) {
									min_dist = float32(Xsqrt(float64(dist2)))
								}
							}
						}
					}
				}
				if winding == 0 {
					min_dist = -min_dist
				} //  if outside the shape, value is negative
				val = (float32(onedge_value) + (pixel_dist_scale * min_dist))
				if val < float32(0) {
					val = float32(0)
				} else if val > float32(255) {
					val = float32(255)
				}
				*(*uint8)(unsafe.Pointer(data + uintptr((((y - *(*int32)(unsafe.Pointer(bp + 4 /* iy0 */))) * w) + (x - *(*int32)(unsafe.Pointer(bp /* ix0 */))))))) = uint8(val)
			}
		}
		nk_stbtt_free(precompute, (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)
		nk_stbtt_free(*(*uintptr)(unsafe.Pointer(bp + 16 /* verts */)), (*Stbtt_fontinfo)(unsafe.Pointer(info)).Userdata)

	}
	return data
}

var __func__131 = *(*[18]int8)(unsafe.Pointer(ts + 4480 /* "stbtt_GetGlyphSD..." */)) /* nuklear.h:15758:1 */

func Xstbtt_GetCodepointSDF(info uintptr, scale float32, codepoint int32, padding int32, onedge_value uint8, pixel_dist_scale float32, width uintptr, height uintptr, xoff uintptr, yoff uintptr) uintptr { /* nuklear.h:15938:25: */
	return Xstbtt_GetGlyphSDF(info, scale, Xstbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff)
}

func Xstbtt_FreeSDF(bitmap uintptr, userdata uintptr) { /* nuklear.h:15943:16: */
	nk_stbtt_free(bitmap, userdata)
}

// ////////////////////////////////////////////////////////////////////////////
//
//  font name matching -- recommended not to use this
//

//  check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
func stbtt__CompareUTF8toUTF16_bigendian_prefix(s1 uintptr, len1 Stbtt_int32, s2 uintptr, len2 Stbtt_int32) Stbtt_int32 { /* nuklear.h:15954:20: */
	var i Stbtt_int32 = 0

	//  convert utf16 to utf8 and compare the results while converting
	for len2 != 0 {
		var ch Stbtt_uint16 = (Stbtt_uint16((int32(*(*Stbtt_uint8)(unsafe.Pointer(s2))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(s2 + 1)))))
		if int32(ch) < 0x80 {
			if i >= len1 {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != int32(ch) {
				return -1
			}
		} else if int32(ch) < 0x800 {
			if (i + 1) >= len1 {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (0xc0 + (int32(ch) >> 6)) {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (0x80 + (int32(ch) & 0x3f)) {
				return -1
			}
		} else if (int32(ch) >= 0xd800) && (int32(ch) < 0xdc00) {
			var c Stbtt_uint32
			var ch2 Stbtt_uint16 = (Stbtt_uint16((int32(*(*Stbtt_uint8)(unsafe.Pointer(s2 + 2))) * 256) + int32(*(*Stbtt_uint8)(unsafe.Pointer(s2 + 3)))))
			if (i + 3) >= len1 {
				return -1
			}
			c = (Stbtt_uint32((((int32(ch) - 0xd800) << 10) + (int32(ch2) - 0xdc00)) + 0x10000))
			if Stbtt_uint32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (Stbtt_uint32(0xf0) + (c >> 18)) {
				return -1
			}
			if Stbtt_uint32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (Stbtt_uint32(0x80) + ((c >> 12) & Stbtt_uint32(0x3f))) {
				return -1
			}
			if Stbtt_uint32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (Stbtt_uint32(0x80) + ((c >> 6) & Stbtt_uint32(0x3f))) {
				return -1
			}
			if Stbtt_uint32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (Stbtt_uint32(0x80) + ((c) & Stbtt_uint32(0x3f))) {
				return -1
			}
			s2 += uintptr(2) //  plus another 2 below
			len2 = len2 - (2)
		} else if (int32(ch) >= 0xdc00) && (int32(ch) < 0xe000) {
			return -1
		} else {
			if (i + 2) >= len1 {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (0xe0 + (int32(ch) >> 12)) {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (0x80 + ((int32(ch) >> 6) & 0x3f)) {
				return -1
			}
			if int32(*(*Stbtt_uint8)(unsafe.Pointer(s1 + uintptr(PostIncInt32(&i, 1))))) != (0x80 + ((int32(ch)) & 0x3f)) {
				return -1
			}
		}
		s2 += uintptr(2)
		len2 = len2 - (2)
	}
	return i
}

func stbtt_CompareUTF8toUTF16_bigendian_internal(s1 uintptr, len1 int32, s2 uintptr, len2 int32) int32 { /* nuklear.h:15993:12: */
	return (Bool32(len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix(s1, len1, s2, len2)))
}

//  returns results in whatever encoding you request... but note that 2-byte encodings
//  will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
func Xstbtt_GetFontNameString(font uintptr, length uintptr, platformID int32, encodingID int32, languageID int32, nameID int32) uintptr { /* nuklear.h:16000:22: */
	var i Stbtt_int32
	var count Stbtt_int32
	var stringOffset Stbtt_int32
	var fc uintptr = (*Stbtt_fontinfo)(unsafe.Pointer(font)).Data
	var offset Stbtt_uint32 = Stbtt_uint32((*Stbtt_fontinfo)(unsafe.Pointer(font)).Fontstart)
	var nm Stbtt_uint32 = stbtt__find_table(fc, offset, ts+4498 /* "name" */)
	if !(nm != 0) {
		return uintptr(0)
	}

	count = Stbtt_int32(ttUSHORT(((fc + uintptr(nm)) + uintptr(2))))
	stringOffset = (Stbtt_int32(nm + Stbtt_uint32(ttUSHORT(((fc + uintptr(nm)) + uintptr(4))))))
	for i = 0; i < count; i++ {
		var loc Stbtt_uint32 = ((nm + Stbtt_uint32(6)) + (Stbtt_uint32(12 * i)))
		if (((platformID == int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(0))))) && (encodingID == int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(2)))))) &&
			(languageID == int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(4)))))) && (nameID == int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(6))))) {
			*(*int32)(unsafe.Pointer(length)) = int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(8))))
			return ((fc + uintptr(stringOffset)) + uintptr(ttUSHORT(((fc + uintptr(loc)) + uintptr(10)))))
		}
	}
	return uintptr(0)
}

func stbtt__matchpair(fc uintptr, nm Stbtt_uint32, name uintptr, nlen Stbtt_int32, target_id Stbtt_int32, next_id Stbtt_int32) int32 { /* nuklear.h:16021:12: */
	var i Stbtt_int32
	var count Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(nm)) + uintptr(2))))
	var stringOffset Stbtt_int32 = (Stbtt_int32(nm + Stbtt_uint32(ttUSHORT(((fc + uintptr(nm)) + uintptr(4))))))

	for i = 0; i < count; i++ {
		var loc Stbtt_uint32 = ((nm + Stbtt_uint32(6)) + (Stbtt_uint32(12 * i)))
		var id Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(6))))
		if id == target_id {
			//  find the encoding
			var platform Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(0))))
			var encoding Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(2))))
			var language Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(4))))

			//  is this a Unicode encoding?
			if ((platform == 0) || ((platform == 3) && (encoding == 1))) || ((platform == 3) && (encoding == 10)) {
				var slen Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(8))))
				var off Stbtt_int32 = Stbtt_int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(10))))

				//  check if there's a prefix match
				var matchlen Stbtt_int32 = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, ((fc + uintptr(stringOffset)) + uintptr(off)), slen)
				if matchlen >= 0 {
					//  check for target_id+1 immediately following, with same encoding & language
					if (((((i + 1) < count) && (int32(ttUSHORT((((fc + uintptr(loc)) + uintptr(12)) + uintptr(6)))) == next_id)) && (int32(ttUSHORT(((fc + uintptr(loc)) + uintptr(12)))) == platform)) && (int32(ttUSHORT((((fc + uintptr(loc)) + uintptr(12)) + uintptr(2)))) == encoding)) && (int32(ttUSHORT((((fc + uintptr(loc)) + uintptr(12)) + uintptr(4)))) == language) {
						slen = Stbtt_int32(ttUSHORT((((fc + uintptr(loc)) + uintptr(12)) + uintptr(8))))
						off = Stbtt_int32(ttUSHORT((((fc + uintptr(loc)) + uintptr(12)) + uintptr(10))))
						if slen == 0 {
							if matchlen == nlen {
								return 1
							}
						} else if (matchlen < nlen) && (int32(*(*Stbtt_uint8)(unsafe.Pointer(name + uintptr(matchlen)))) == ' ') {
							matchlen++
							if stbtt_CompareUTF8toUTF16_bigendian_internal((name+uintptr(matchlen)), (nlen-matchlen), ((fc+uintptr(stringOffset))+uintptr(off)), slen) != 0 {
								return 1
							}
						}
					} else {
						//  if nothing immediately following
						if matchlen == nlen {
							return 1
						}
					}
				}
			}

			//  @TODO handle other encodings
		}
	}
	return 0
}

func stbtt__matches(fc uintptr, offset Stbtt_uint32, name uintptr, flags Stbtt_int32) int32 { /* nuklear.h:16068:12: */
	var nlen Stbtt_int32 = Stbtt_int32(Xstrlen(name))
	var nm Stbtt_uint32
	var hd Stbtt_uint32
	if !(stbtt__isfont((fc + uintptr(offset))) != 0) {
		return 0
	}

	//  check italics/bold/underline flags in macStyle...
	if flags != 0 {
		hd = stbtt__find_table(fc, offset, ts+3497 /* "head" */)
		if (int32(ttUSHORT(((fc + uintptr(hd)) + uintptr(44)))) & 7) != (flags & 7) {
			return 0
		}
	}

	nm = stbtt__find_table(fc, offset, ts+4498 /* "name" */)
	if !(nm != 0) {
		return 0
	}

	if flags != 0 {
		//  if we checked the macStyle flags, then just check the family and ignore the subfamily
		if stbtt__matchpair(fc, nm, name, nlen, 16, -1) != 0 {
			return 1
		}
		if stbtt__matchpair(fc, nm, name, nlen, 1, -1) != 0 {
			return 1
		}
		if stbtt__matchpair(fc, nm, name, nlen, 3, -1) != 0 {
			return 1
		}
	} else {
		if stbtt__matchpair(fc, nm, name, nlen, 16, 17) != 0 {
			return 1
		}
		if stbtt__matchpair(fc, nm, name, nlen, 1, 2) != 0 {
			return 1
		}
		if stbtt__matchpair(fc, nm, name, nlen, 3, -1) != 0 {
			return 1
		}
	}

	return 0
}

func stbtt_FindMatchingFont_internal(font_collection uintptr, name_utf8 uintptr, flags Stbtt_int32) int32 { /* nuklear.h:16097:12: */
	var i Stbtt_int32
	for i = 0; ; i++ {
		var off Stbtt_int32 = Xstbtt_GetFontOffsetForIndex(font_collection, i)
		if off < 0 {
			return off
		}
		if stbtt__matches(font_collection, uint32(off), name_utf8, flags) != 0 {
			return off
		}
	}
	return int32(0)
}

func Xstbtt_BakeFontBitmap(data uintptr, offset int32, pixel_height float32, pixels uintptr, pw int32, ph int32, first_char int32, num_chars int32, chardata uintptr) int32 { /* nuklear.h:16113:15: */
	return stbtt_BakeFontBitmap_internal(data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata)
}

func Xstbtt_GetFontOffsetForIndex(data uintptr, index int32) int32 { /* nuklear.h:16120:15: */
	return stbtt_GetFontOffsetForIndex_internal(data, index)
}

func Xstbtt_GetNumberOfFonts(data uintptr) int32 { /* nuklear.h:16125:15: */
	return stbtt_GetNumberOfFonts_internal(data)
}

func Xstbtt_InitFont(info uintptr, data uintptr, offset int32) int32 { /* nuklear.h:16130:15: */
	return stbtt_InitFont_internal(info, data, offset)
}

func Xstbtt_FindMatchingFont(fontdata uintptr, name uintptr, flags int32) int32 { /* nuklear.h:16135:15: */
	return stbtt_FindMatchingFont_internal(fontdata, name, flags)
}

func Xstbtt_CompareUTF8toUTF16_bigendian(s1 uintptr, len1 int32, s2 uintptr, len2 int32) int32 { /* nuklear.h:16140:15: */
	return stbtt_CompareUTF8toUTF16_bigendian_internal(s1, len1, s2, len2)
}

//  FULL VERSION HISTORY
//
//    1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod
//    1.18 (2018-01-29) add missing function
//    1.17 (2017-07-23) make more arguments const; doc fix
//    1.16 (2017-07-12) SDF support
//    1.15 (2017-03-03) make more arguments const
//    1.14 (2017-01-16) num-fonts-in-TTC function
//    1.13 (2017-01-02) support OpenType fonts, certain Apple fonts
//    1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//    1.11 (2016-04-02) fix unused-variable warning
//    1.10 (2016-04-02) allow user-defined fabs() replacement
//                      fix memory leak if fontsize=0.0
//                      fix warning from duplicate typedef
//    1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//    1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//    1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                      allow PackFontRanges to pack and render in separate phases;
//                      fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                      fixed an assert() bug in the new rasterizer
//                      replace assert() with STBTT_assert() in new rasterizer
//    1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                      also more precise AA rasterizer, except if shapes overlap
//                      remove need for STBTT_sort
//    1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//    1.04 (2015-04-15) typo in example
//    1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//    1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//    1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                         non-oversampled; STBTT_POINT_SIZE for packed case only
//    1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//    0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//    0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//    0.8b (2014-07-07) fix a warning
//    0.8  (2014-05-25) fix a few more warnings
//    0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//    0.6c (2012-07-24) improve documentation
//    0.6b (2012-07-20) fix a few more warnings
//    0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                         stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//    0.5  (2011-12-09) bugfixes:
//                         subpixel glyph renderer computed wrong bounding box
//                         first vertex of shape can be off-curve (FreeSans)
//    0.4b (2011-12-03) fixed an error in the font baking example
//    0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                     bugfixes for:
//                         codepoint-to-glyph conversion using table fmt=12
//                         codepoint-to-glyph conversion using table fmt=4
//                         stbtt_GetBakedQuad with non-square texture (Zer)
//                     updated Hello World! sample to use kerning and subpixel
//                     fixed some warnings
//    0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                     userdata, malloc-from-userdata, non-zero fill (stb)
//    0.2  (2009-03-11) Fix unsigned/signed char warnings
//    0.1  (2009-03-09) First public release
//

//
// ------------------------------------------------------------------------------
// This software is available under 2 licenses -- choose whichever you prefer.
// ------------------------------------------------------------------------------
// ALTERNATIVE A - MIT License
// Copyright (c) 2017 Sean Barrett
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// ------------------------------------------------------------------------------
// ALTERNATIVE B - Public Domain (www.unlicense.org)
// This is free and unencumbered software released into the public domain.
// Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
// software, either in source code form or as a compiled binary, for any purpose,
// commercial or non-commercial, and by any means.
// In jurisdictions that recognize copyright laws, the author or authors of this
// software dedicate any and all copyright interest in the software to the public
// domain. We make this dedication for the benefit of the public at large and to
// the detriment of our heirs and successors. We intend this dedication to be an
// overt act of relinquishment in perpetuity of all present and future rights to
// this software under copyright law.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ------------------------------------------------------------------------------

// -------------------------------------------------------------
//
//                          RECT PACK
//
// --------------------------------------------------------------

// ==============================================================
//
//                          TRUETYPE
//
// ===============================================================

// -------------------------------------------------------------
//
//                          FONT BAKING
//
// --------------------------------------------------------------
type Nk_font_bake_data = struct {
	Info struct {
		Userdata         uintptr
		Data             uintptr
		Fontstart        int32
		NumGlyphs        int32
		Loca             int32
		Head             int32
		Glyf             int32
		Hhea             int32
		Hmtx             int32
		Kern             int32
		Gpos             int32
		Svg              int32
		Index_map        int32
		IndexToLocFormat int32
		Cff              Stbtt__buf
		Charstrings      Stbtt__buf
		Gsubrs           Stbtt__buf
		Subrs            Stbtt__buf
		Fontdicts        Stbtt__buf
		Fdselect         Stbtt__buf
	}
	Rects       uintptr
	Ranges      uintptr
	Range_count Nk_rune
} /* nuklear.h:16278:1 */

type Nk_font_baker = struct {
	Alloc struct {
		Userdata Nk_handle
		Alloc    Nk_plugin_alloc
		Free     Nk_plugin_free
	}
	Spc struct {
		User_allocator_context uintptr
		Pack_info              uintptr
		Width                  int32
		Height                 int32
		Stride_in_bytes        int32
		Padding                int32
		Skip_missing           int32
		H_oversample           uint32
		V_oversample           uint32
		Pixels                 uintptr
		Nodes                  uintptr
	}
	Build        uintptr
	Packed_chars uintptr
	Rects        uintptr
	Ranges       uintptr
} /* nuklear.h:16285:1 */

var nk_rect_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))  /* nuklear.h:16294:25 */
var nk_range_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1)) /* nuklear.h:16295:25 */
var nk_char_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))  /* nuklear.h:16296:25 */
var nk_build_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1)) /* nuklear.h:16297:25 */
var nk_baker_align Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1)) /* nuklear.h:16298:25 */

func nk_range_count(range1 uintptr) int32 { /* nuklear.h:16301:1: */
	var iter uintptr = range1
	if range1 != 0 {
	} else {
		X__assert_fail(ts+4503 /* "range" */, ts+2 /* "nuklear/nuklear...." */, uint32(16304), uintptr(unsafe.Pointer(&__func__132)))
	}
	if !(range1 != 0) {
		return 0
	}
	for *(*Nk_rune)(unsafe.Pointer(PostIncUintptr(&iter, 4))) != Nk_rune(0) {
	}
	if iter == range1 {
		return 0
	}
	return (int32(((int32(iter) - int32(range1)) / 4) / 2))
}

var __func__132 = *(*[15]int8)(unsafe.Pointer(ts + 4509 /* "nk_range_count" */)) /* nuklear.h:16302:1 */

func nk_range_glyph_count(range1 uintptr, count int32) int32 { /* nuklear.h:16310:1: */
	var i int32 = 0
	var total_glyphs int32 = 0
	for i = 0; i < count; i++ {
		var diff int32
		var f Nk_rune = *(*Nk_rune)(unsafe.Pointer(range1 + uintptr(((i*2)+0))*4))
		var t Nk_rune = *(*Nk_rune)(unsafe.Pointer(range1 + uintptr(((i*2)+1))*4))
		if t >= f {
		} else {
			X__assert_fail(ts+4524 /* "t >= f" */, ts+2 /* "nuklear/nuklear...." */, uint32(16318), uintptr(unsafe.Pointer(&__func__133)))
		}
		diff = (int32((t - f) + Nk_rune(1)))
		total_glyphs = total_glyphs + (diff)
	}
	return total_glyphs
}

var __func__133 = *(*[21]int8)(unsafe.Pointer(ts + 4531 /* "nk_range_glyph_c..." */)) /* nuklear.h:16311:1 */

func Xnk_font_default_glyph_ranges() uintptr { /* nuklear.h:16324:21: */
	return uintptr(unsafe.Pointer(&ranges))
}

var ranges = [3]Nk_rune{Nk_rune(0x0020), Nk_rune(0x00FF), Nk_rune(0)} /* nuklear.h:16327:30 */

func Xnk_font_chinese_glyph_ranges() uintptr { /* nuklear.h:16330:21: */
	return uintptr(unsafe.Pointer(&ranges1))
}

var ranges1 = [11]Nk_rune{
	Nk_rune(0x0020), Nk_rune(0x00FF),
	Nk_rune(0x3000), Nk_rune(0x30FF),
	Nk_rune(0x31F0), Nk_rune(0x31FF),
	Nk_rune(0xFF00), Nk_rune(0xFFEF),
	Nk_rune(0x4e00), Nk_rune(0x9FAF),
	Nk_rune(0),
} /* nuklear.h:16333:30 */

func Xnk_font_cyrillic_glyph_ranges() uintptr { /* nuklear.h:16343:21: */
	return uintptr(unsafe.Pointer(&ranges2))
}

var ranges2 = [9]Nk_rune{
	Nk_rune(0x0020), Nk_rune(0x00FF),
	Nk_rune(0x0400), Nk_rune(0x052F),
	Nk_rune(0x2DE0), Nk_rune(0x2DFF),
	Nk_rune(0xA640), Nk_rune(0xA69F),
	Nk_rune(0),
} /* nuklear.h:16346:30 */

func Xnk_font_korean_glyph_ranges() uintptr { /* nuklear.h:16355:21: */
	return uintptr(unsafe.Pointer(&ranges3))
}

var ranges3 = [7]Nk_rune{
	Nk_rune(0x0020), Nk_rune(0x00FF),
	Nk_rune(0x3131), Nk_rune(0x3163),
	Nk_rune(0xAC00), Nk_rune(0xD79D),
	Nk_rune(0),
} /* nuklear.h:16358:30 */

func nk_font_baker_memory(temp uintptr, glyph_count uintptr, config_list uintptr, count int32) { /* nuklear.h:16367:1: */
	var range_count int32 = 0
	var total_range_count int32 = 0
	var iter uintptr
	var i uintptr

	if config_list != 0 {
	} else {
		X__assert_fail(ts+4552 /* "config_list" */, ts+2 /* "nuklear/nuklear...." */, uint32(16374), uintptr(unsafe.Pointer(&__func__134)))
	}
	if glyph_count != 0 {
	} else {
		X__assert_fail(ts+4564 /* "glyph_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(16375), uintptr(unsafe.Pointer(&__func__134)))
	}
	if !(config_list != 0) {
		*(*Nk_size)(unsafe.Pointer(temp)) = Nk_size(0)
		*(*int32)(unsafe.Pointer(glyph_count)) = 0
		return
	}
	*(*int32)(unsafe.Pointer(glyph_count)) = 0
	for iter = config_list; iter != 0; iter = (*Nk_font_config)(unsafe.Pointer(iter)).Next {
		i = iter
		for ok := true; ok; ok = ((AssignUintptr(&i, (*Nk_font_config)(unsafe.Pointer(i)).N)) != iter) {
			if !(int32((*Nk_font_config)(unsafe.Pointer(i)).Range) != 0) {
				(*Nk_font_config)(unsafe.Pointer(iter)).Range = Xnk_font_default_glyph_ranges()
			}
			range_count = nk_range_count((*Nk_font_config)(unsafe.Pointer(i)).Range)
			total_range_count = total_range_count + (range_count)
			*(*int32)(unsafe.Pointer(glyph_count)) += (nk_range_glyph_count((*Nk_font_config)(unsafe.Pointer(i)).Range, range_count))
		}
	}
	*(*Nk_size)(unsafe.Pointer(temp)) = (Nk_size(*(*int32)(unsafe.Pointer(glyph_count))) * Nk_size(unsafe.Sizeof(Stbrp_rect1{})))
	*(*Nk_size)(unsafe.Pointer(temp)) += (Nk_size(total_range_count) * Nk_size(unsafe.Sizeof(Stbtt_pack_range{})))
	*(*Nk_size)(unsafe.Pointer(temp)) += (Nk_size(*(*int32)(unsafe.Pointer(glyph_count))) * Nk_size(unsafe.Sizeof(Stbtt_packedchar{})))
	*(*Nk_size)(unsafe.Pointer(temp)) += (Nk_size(count) * Nk_size(unsafe.Sizeof(Nk_font_bake_data{})))
	*(*Nk_size)(unsafe.Pointer(temp)) += (Nk_size(unsafe.Sizeof(Nk_font_baker{})))
	*(*Nk_size)(unsafe.Pointer(temp)) += ((nk_rect_align + nk_range_align) + nk_char_align)
	*(*Nk_size)(unsafe.Pointer(temp)) += (nk_build_align + nk_baker_align)
}

var __func__134 = *(*[21]int8)(unsafe.Pointer(ts + 4576 /* "nk_font_baker_me..." */)) /* nuklear.h:16369:1 */

func nk_font_baker(memory uintptr, glyph_count int32, count int32, alloc uintptr) uintptr { /* nuklear.h:16398:31: */
	var baker uintptr
	if !(memory != 0) {
		return uintptr(0)
	}
	// setup baker inside a memory block
	baker = uintptr((int32((Nk_size(((memory) + uintptr((nk_baker_align - Nk_size(1)))))) & ^(nk_baker_align - Nk_size(1)))))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Build = uintptr((int32((Nk_size(((baker + uintptr(1)*72) + uintptr((nk_build_align - Nk_size(1)))))) & ^(nk_build_align - Nk_size(1)))))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Packed_chars = uintptr((int32((Nk_size((((*Nk_font_baker)(unsafe.Pointer(baker)).Build + uintptr(count)*140) + uintptr((nk_char_align - Nk_size(1)))))) & ^(nk_char_align - Nk_size(1)))))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Rects = uintptr((int32((Nk_size((((*Nk_font_baker)(unsafe.Pointer(baker)).Packed_chars + uintptr(glyph_count)*28) + uintptr((nk_rect_align - Nk_size(1)))))) & ^(nk_rect_align - Nk_size(1)))))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Ranges = uintptr((int32((Nk_size((((*Nk_font_baker)(unsafe.Pointer(baker)).Rects + uintptr(glyph_count)*16) + uintptr((nk_range_align - Nk_size(1)))))) & ^(nk_range_align - Nk_size(1)))))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Alloc = *(*Nk_allocator)(unsafe.Pointer(alloc))
	return baker
}

func nk_font_bake_pack(baker uintptr, image_memory uintptr, width uintptr, height uintptr, custom uintptr, config_list uintptr, count int32, alloc uintptr) int32 { /* nuklear.h:16413:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var config_iter uintptr
	var it uintptr
	var total_glyph_count int32 = 0
	var total_range_count int32 = 0
	var range_count int32 = 0
	var i int32 = 0

	if image_memory != 0 {
	} else {
		X__assert_fail(ts+4597 /* "image_memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(16425), uintptr(unsafe.Pointer(&__func__135)))
	}
	if width != 0 {
	} else {
		X__assert_fail(ts+4610 /* "width" */, ts+2 /* "nuklear/nuklear...." */, uint32(16426), uintptr(unsafe.Pointer(&__func__135)))
	}
	if height != 0 {
	} else {
		X__assert_fail(ts+4616 /* "height" */, ts+2 /* "nuklear/nuklear...." */, uint32(16427), uintptr(unsafe.Pointer(&__func__135)))
	}
	if config_list != 0 {
	} else {
		X__assert_fail(ts+4552 /* "config_list" */, ts+2 /* "nuklear/nuklear...." */, uint32(16428), uintptr(unsafe.Pointer(&__func__135)))
	}
	if count != 0 {
	} else {
		X__assert_fail(ts+4623 /* "count" */, ts+2 /* "nuklear/nuklear...." */, uint32(16429), uintptr(unsafe.Pointer(&__func__135)))
	}
	if alloc != 0 {
	} else {
		X__assert_fail(ts+4629 /* "alloc" */, ts+2 /* "nuklear/nuklear...." */, uint32(16430), uintptr(unsafe.Pointer(&__func__135)))
	}

	if (((!(image_memory != 0) || !(width != 0)) || !(height != 0)) || !(config_list != 0)) || !(count != 0) {
		return Nk_false
	}
	for config_iter = config_list; config_iter != 0; config_iter = (*Nk_font_config)(unsafe.Pointer(config_iter)).Next {
		it = config_iter
		for ok := true; ok; ok = ((AssignUintptr(&it, (*Nk_font_config)(unsafe.Pointer(it)).N)) != config_iter) {
			range_count = nk_range_count((*Nk_font_config)(unsafe.Pointer(it)).Range)
			total_range_count = total_range_count + (range_count)
			total_glyph_count = total_glyph_count + (nk_range_glyph_count((*Nk_font_config)(unsafe.Pointer(it)).Range, range_count))
		}
	}
	// setup font baker from temporary memory
	for config_iter = config_list; config_iter != 0; config_iter = (*Nk_font_config)(unsafe.Pointer(config_iter)).Next {
		it = config_iter
		var font_info uintptr = ((*Nk_font_baker)(unsafe.Pointer(baker)).Build + uintptr(PostIncInt32(&i, 1))*140 /* &.info */)
		(*Stbtt_fontinfo1)(unsafe.Pointer(font_info)).Userdata = alloc
		for ok1 := true; ok1; ok1 = ((AssignUintptr(&it, (*Nk_font_config)(unsafe.Pointer(it)).N)) != config_iter) {
			if !(Xstbtt_InitFont(font_info, (*Nk_font_config)(unsafe.Pointer(it)).Ttf_blob, 0) != 0) {
				return Nk_false
			}
		}
	}
	*(*int32)(unsafe.Pointer(height)) = 0
	*(*int32)(unsafe.Pointer(width)) = func() int32 {
		if total_glyph_count > 1000 {
			return 1024
		}
		return 512
	}()
	Xstbtt_PackBegin((baker + 12 /* &.spc */), uintptr(0), *(*int32)(unsafe.Pointer(width)), int32(max_height), 0, 1, alloc)
	{
		var input_i int32 = 0
		var range_n int32 = 0
		var rect_n int32 = 0
		var char_n int32 = 0

		if custom != 0 {
			// pack custom user data first so it will be in the upper left corner
			// var custom_space Stbrp_rect1 at bp, 16

			nk_zero(bp /* &custom_space */, uint32(unsafe.Sizeof(Stbrp_rect1{})))
			(*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).W = Stbrp_coord((*Nk_recti)(unsafe.Pointer(custom)).W)
			(*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).H = Stbrp_coord((*Nk_recti)(unsafe.Pointer(custom)).H)

			Xstbtt_PackSetOversampling((baker + 12 /* &.spc */), uint32(1), uint32(1))
			Xstbrp_pack_rects((*Nk_font_baker)(unsafe.Pointer(baker)).Spc.Pack_info, bp /* &custom_space */, 1)
			*(*int32)(unsafe.Pointer(height)) = func() int32 {
				if (*(*int32)(unsafe.Pointer(height))) < (int32((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).Y) + int32((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).H)) {
					return (int32((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).Y) + int32((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).H))
				}
				return *(*int32)(unsafe.Pointer(height))
			}()

			(*Nk_recti)(unsafe.Pointer(custom)).X = int16((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).X)
			(*Nk_recti)(unsafe.Pointer(custom)).Y = int16((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).Y)
			(*Nk_recti)(unsafe.Pointer(custom)).W = int16((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).W)
			(*Nk_recti)(unsafe.Pointer(custom)).H = int16((*Stbrp_rect1)(unsafe.Pointer(bp /* &custom_space */)).H)
		}

		// first font pass: pack all glyphs
		input_i = 0
		config_iter = config_list
		for ; (input_i < count) && (config_iter != 0); config_iter = (*Nk_font_config)(unsafe.Pointer(config_iter)).Next {
			it = config_iter
			for ok2 := true; ok2; ok2 = ((AssignUintptr(&it, (*Nk_font_config)(unsafe.Pointer(it)).N)) != config_iter) {
				var n int32 = 0
				var glyph_count int32
				var in_range uintptr
				var cfg uintptr = it
				var tmp uintptr = ((*Nk_font_baker)(unsafe.Pointer(baker)).Build + uintptr(PostIncInt32(&input_i, 1))*140)

				// count glyphs + ranges in current font
				glyph_count = 0
				range_count = 0
				for in_range = (*Nk_font_config)(unsafe.Pointer(cfg)).Range; (*(*Nk_rune)(unsafe.Pointer(in_range)) != 0) && (*(*Nk_rune)(unsafe.Pointer(in_range + 1*4)) != 0); in_range += 4 * (uintptr(2)) {
					glyph_count = glyph_count + ((int32(*(*Nk_rune)(unsafe.Pointer(in_range + 1*4)) - *(*Nk_rune)(unsafe.Pointer(in_range)))) + 1)
					range_count++
				}

				// setup ranges
				(*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges = ((*Nk_font_baker)(unsafe.Pointer(baker)).Ranges + uintptr(range_n)*24)
				(*Nk_font_bake_data)(unsafe.Pointer(tmp)).Range_count = Nk_rune(range_count)
				range_n = range_n + (range_count)
				for i = 0; i < range_count; i++ {
					in_range = ((*Nk_font_config)(unsafe.Pointer(cfg)).Range + uintptr((i*2))*4)
					(*Stbtt_pack_range)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)).Font_size = (*Nk_font_config)(unsafe.Pointer(cfg)).Size
					(*Stbtt_pack_range)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)).First_unicode_codepoint_in_range = int32(*(*Nk_rune)(unsafe.Pointer(in_range)))
					(*Stbtt_pack_range)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)).Num_chars = ((int32(*(*Nk_rune)(unsafe.Pointer(in_range + 1*4)) - *(*Nk_rune)(unsafe.Pointer(in_range)))) + 1)
					(*Stbtt_pack_range)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)).Chardata_for_range = ((*Nk_font_baker)(unsafe.Pointer(baker)).Packed_chars + uintptr(char_n)*28)
					char_n = char_n + ((*Stbtt_pack_range)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)).Num_chars)
				}

				// pack
				(*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects = ((*Nk_font_baker)(unsafe.Pointer(baker)).Rects + uintptr(rect_n)*16)
				rect_n = rect_n + (glyph_count)
				Xstbtt_PackSetOversampling((baker + 12 /* &.spc */), uint32((*Nk_font_config)(unsafe.Pointer(cfg)).Oversample_h), uint32((*Nk_font_config)(unsafe.Pointer(cfg)).Oversample_v))
				n = Xstbtt_PackFontRangesGatherRects((baker + 12 /* &.spc */), (tmp /* &.info */),
					(*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges, int32((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Range_count), (*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects)
				Xstbrp_pack_rects((*Nk_font_baker)(unsafe.Pointer(baker)).Spc.Pack_info, (*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects, n)

				// texture height
				for i = 0; i < n; i++ {
					if (*Stbrp_rect1)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects+uintptr(i)*16)).Was_packed != 0 {
						*(*int32)(unsafe.Pointer(height)) = func() int32 {
							if (*(*int32)(unsafe.Pointer(height))) < (int32((*Stbrp_rect1)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects+uintptr(i)*16)).Y) + int32((*Stbrp_rect1)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects+uintptr(i)*16)).H)) {
								return (int32((*Stbrp_rect1)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects+uintptr(i)*16)).Y) + int32((*Stbrp_rect1)(unsafe.Pointer((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects+uintptr(i)*16)).H))
							}
							return *(*int32)(unsafe.Pointer(height))
						}()
					}
				}
			}
		}
		if rect_n == total_glyph_count {
		} else {
			X__assert_fail(ts+4635 /* "rect_n == total_..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16520), uintptr(unsafe.Pointer(&__func__135)))
		}
		if char_n == total_glyph_count {
		} else {
			X__assert_fail(ts+4663 /* "char_n == total_..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16521), uintptr(unsafe.Pointer(&__func__135)))
		}
		if range_n == total_range_count {
		} else {
			X__assert_fail(ts+4691 /* "range_n == total..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16522), uintptr(unsafe.Pointer(&__func__135)))
		}

	}
	*(*int32)(unsafe.Pointer(height)) = int32(nk_round_up_pow2(Nk_uint(*(*int32)(unsafe.Pointer(height)))))
	*(*Nk_size)(unsafe.Pointer(image_memory)) = ((Nk_size(*(*int32)(unsafe.Pointer(width)))) * (Nk_size(*(*int32)(unsafe.Pointer(height)))))
	return Nk_true
}

var __func__135 = *(*[18]int8)(unsafe.Pointer(ts + 4720 /* "nk_font_bake_pac..." */)) /* nuklear.h:16417:1 */
var max_height Nk_size = (Nk_size(1024 * 32))                                         /* nuklear.h:16418:30 */

func nk_font_bake(baker uintptr, image_memory uintptr, width int32, height int32, glyphs uintptr, glyphs_count int32, config_list uintptr, font_count int32) { /* nuklear.h:16529:1: */
	bp := tlsAlloc(52)
	defer tlsFree(52)

	var input_i int32 = 0
	var glyph_n Nk_rune = Nk_rune(0)
	var config_iter uintptr
	var it uintptr

	if image_memory != 0 {
	} else {
		X__assert_fail(ts+4597 /* "image_memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(16538), uintptr(unsafe.Pointer(&__func__136)))
	}
	if width != 0 {
	} else {
		X__assert_fail(ts+4610 /* "width" */, ts+2 /* "nuklear/nuklear...." */, uint32(16539), uintptr(unsafe.Pointer(&__func__136)))
	}
	if height != 0 {
	} else {
		X__assert_fail(ts+4616 /* "height" */, ts+2 /* "nuklear/nuklear...." */, uint32(16540), uintptr(unsafe.Pointer(&__func__136)))
	}
	if config_list != 0 {
	} else {
		X__assert_fail(ts+4552 /* "config_list" */, ts+2 /* "nuklear/nuklear...." */, uint32(16541), uintptr(unsafe.Pointer(&__func__136)))
	}
	if baker != 0 {
	} else {
		X__assert_fail(ts+4738 /* "baker" */, ts+2 /* "nuklear/nuklear...." */, uint32(16542), uintptr(unsafe.Pointer(&__func__136)))
	}
	if font_count != 0 {
	} else {
		X__assert_fail(ts+4744 /* "font_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(16543), uintptr(unsafe.Pointer(&__func__136)))
	}
	if glyphs_count != 0 {
	} else {
		X__assert_fail(ts+4755 /* "glyphs_count" */, ts+2 /* "nuklear/nuklear...." */, uint32(16544), uintptr(unsafe.Pointer(&__func__136)))
	}
	if (((((!(image_memory != 0) || !(width != 0)) || !(height != 0)) || !(config_list != 0)) || !(font_count != 0)) || !(glyphs != 0)) || !(glyphs_count != 0) {
		return
	}

	// second font pass: render glyphs
	nk_zero(image_memory, (Nk_size(width) * Nk_size(height)))
	(*Nk_font_baker)(unsafe.Pointer(baker)).Spc.Pixels = image_memory
	(*Nk_font_baker)(unsafe.Pointer(baker)).Spc.Height = height
	input_i = 0
	config_iter = config_list
	for ; (input_i < font_count) && (config_iter != 0); config_iter = (*Nk_font_config)(unsafe.Pointer(config_iter)).Next {
		it = config_iter
		for ok := true; ok; ok = ((AssignUintptr(&it, (*Nk_font_config)(unsafe.Pointer(it)).N)) != config_iter) {
			var cfg uintptr = it
			var tmp uintptr = ((*Nk_font_baker)(unsafe.Pointer(baker)).Build + uintptr(PostIncInt32(&input_i, 1))*140)
			Xstbtt_PackSetOversampling((baker + 12 /* &.spc */), uint32((*Nk_font_config)(unsafe.Pointer(cfg)).Oversample_h), uint32((*Nk_font_config)(unsafe.Pointer(cfg)).Oversample_v))
			Xstbtt_PackFontRangesRenderIntoRects((baker + 12 /* &.spc */), (tmp /* &.info */), (*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges, int32((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Range_count), (*Nk_font_bake_data)(unsafe.Pointer(tmp)).Rects)
		}
	}
	Xstbtt_PackEnd((baker + 12 /* &.spc */))

	// third pass: setup font and glyphs
	input_i = 0
	config_iter = config_list
	for ; (input_i < font_count) && (config_iter != 0); config_iter = (*Nk_font_config)(unsafe.Pointer(config_iter)).Next {
		it = config_iter
		for ok1 := true; ok1; ok1 = ((AssignUintptr(&it, (*Nk_font_config)(unsafe.Pointer(it)).N)) != config_iter) {
			var i Nk_size = Nk_size(0)
			var char_idx int32 = 0
			var glyph_count Nk_rune = Nk_rune(0)
			var cfg uintptr = it
			var tmp uintptr = ((*Nk_font_baker)(unsafe.Pointer(baker)).Build + uintptr(PostIncInt32(&input_i, 1))*140)
			var dst_font uintptr = (*Nk_font_config)(unsafe.Pointer(cfg)).Font

			var font_scale float32 = Xstbtt_ScaleForPixelHeight((tmp /* &.info */), (*Nk_font_config)(unsafe.Pointer(cfg)).Size)
			// var unscaled_ascent int32 at bp, 4

			// var unscaled_descent int32 at bp+4, 4

			// var unscaled_line_gap int32 at bp+8, 4

			Xstbtt_GetFontVMetrics((tmp /* &.info */), bp /* &unscaled_ascent */, bp+4, /* &unscaled_descent */
				bp+8 /* &unscaled_line_gap */)

			// fill baked font
			if !(int32((*Nk_font_config)(unsafe.Pointer(cfg)).Merge_mode) != 0) {
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Ranges = (*Nk_font_config)(unsafe.Pointer(cfg)).Range
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Height = (*Nk_font_config)(unsafe.Pointer(cfg)).Size
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Ascent = (float32(*(*int32)(unsafe.Pointer(bp /* unscaled_ascent */))) * font_scale)
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Descent = (float32(*(*int32)(unsafe.Pointer(bp + 4 /* unscaled_descent */))) * font_scale)
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Glyph_offset = glyph_n
				// Need to zero this, or it will carry over from a previous
				// bake, and cause a segfault when accessing glyphs[].
				(*Nk_baked_font)(unsafe.Pointer(dst_font)).Glyph_count = Nk_rune(0)
			}

			// fill own baked font glyph array
			for i = Nk_size(0); i < Nk_size((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Range_count); i++ {
				var range1 uintptr = ((*Nk_font_bake_data)(unsafe.Pointer(tmp)).Ranges + uintptr(i)*24)
				for char_idx = 0; char_idx < (*Stbtt_pack_range)(unsafe.Pointer(range1)).Num_chars; char_idx++ {
					var codepoint Nk_rune = Nk_rune(0)
					*(*float32)(unsafe.Pointer(bp + 12 /* dummy_x */)) = float32(0)
					*(*float32)(unsafe.Pointer(bp + 16 /* dummy_y */)) = float32(0)
					// var q Stbtt_aligned_quad at bp+20, 32

					var glyph uintptr

					// query glyph bounds from stb_truetype
					var pc uintptr = ((*Stbtt_pack_range)(unsafe.Pointer(range1)).Chardata_for_range + uintptr(char_idx)*28)
					if ((!(int32((*Stbtt_packedchar)(unsafe.Pointer(pc)).X0) != 0) && !(int32((*Stbtt_packedchar)(unsafe.Pointer(pc)).X1) != 0)) && !(int32((*Stbtt_packedchar)(unsafe.Pointer(pc)).Y0) != 0)) && !(int32((*Stbtt_packedchar)(unsafe.Pointer(pc)).Y1) != 0) {
						continue
					}
					codepoint = (Nk_rune((*Stbtt_pack_range)(unsafe.Pointer(range1)).First_unicode_codepoint_in_range + char_idx))
					Xstbtt_GetPackedQuad((*Stbtt_pack_range)(unsafe.Pointer(range1)).Chardata_for_range, width,
						height, char_idx, bp+12 /* &dummy_x */, bp+16 /* &dummy_y */, bp+20 /* &q */, 0)

					// fill own glyph type with data
					glyph = (glyphs + uintptr((((*Nk_baked_font)(unsafe.Pointer(dst_font)).Glyph_offset+(*Nk_baked_font)(unsafe.Pointer(dst_font)).Glyph_count)+glyph_count))*48)
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).Codepoint = codepoint
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).X0 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).X0
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).Y0 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).Y0
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).X1 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).X1
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).Y1 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).Y1
					*(*float32)(unsafe.Pointer(glyph + 12 /* &.y0 */)) += ((*Nk_baked_font)(unsafe.Pointer(dst_font)).Ascent + 0.5)
					*(*float32)(unsafe.Pointer(glyph + 20 /* &.y1 */)) += ((*Nk_baked_font)(unsafe.Pointer(dst_font)).Ascent + 0.5)
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).W = (((*Nk_font_glyph)(unsafe.Pointer(glyph)).X1 - (*Nk_font_glyph)(unsafe.Pointer(glyph)).X0) + 0.5)
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).H = ((*Nk_font_glyph)(unsafe.Pointer(glyph)).Y1 - (*Nk_font_glyph)(unsafe.Pointer(glyph)).Y0)

					if int32((*Nk_font_config)(unsafe.Pointer(cfg)).Coord_type) == NK_COORD_PIXEL {
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).U0 = ((*Stbtt_aligned_quad)(unsafe.Pointer(bp+20 /* &q */)).S0 * float32(width))
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).V0 = ((*Stbtt_aligned_quad)(unsafe.Pointer(bp+20 /* &q */)).T0 * float32(height))
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).U1 = ((*Stbtt_aligned_quad)(unsafe.Pointer(bp+20 /* &q */)).S1 * float32(width))
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).V1 = ((*Stbtt_aligned_quad)(unsafe.Pointer(bp+20 /* &q */)).T1 * float32(height))
					} else {
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).U0 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).S0
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).V0 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).T0
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).U1 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).S1
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).V1 = (*Stbtt_aligned_quad)(unsafe.Pointer(bp + 20 /* &q */)).T1
					}
					(*Nk_font_glyph)(unsafe.Pointer(glyph)).Xadvance = ((*Stbtt_packedchar)(unsafe.Pointer(pc)).Xadvance + (*Nk_font_config)(unsafe.Pointer(cfg)).Spacing.X)
					if (*Nk_font_config)(unsafe.Pointer(cfg)).Pixel_snap != 0 {
						(*Nk_font_glyph)(unsafe.Pointer(glyph)).Xadvance = float32((int32((*Nk_font_glyph)(unsafe.Pointer(glyph)).Xadvance + 0.5)))
					}
					glyph_count++
				}
			}
			*(*Nk_rune)(unsafe.Pointer(dst_font + 16 /* &.glyph_count */)) += (glyph_count)
			glyph_n = glyph_n + (glyph_count)
		}
	}
}

var __func__136 = *(*[13]int8)(unsafe.Pointer(ts + 4768 /* "nk_font_bake" */)) /* nuklear.h:16532:1 */

func nk_font_bake_custom_data(img_memory uintptr, img_width int32, img_height int32, img_dst Nk_recti, texture_data_mask uintptr, tex_width int32, tex_height int32, white int8, black int8) { /* nuklear.h:16641:1: */
	var pixels uintptr
	var y int32 = 0
	var x int32 = 0
	var n int32 = 0

	if img_memory != 0 {
	} else {
		X__assert_fail(ts+4781 /* "img_memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(16650), uintptr(unsafe.Pointer(&__func__137)))
	}
	if img_width != 0 {
	} else {
		X__assert_fail(ts+4792 /* "img_width" */, ts+2 /* "nuklear/nuklear...." */, uint32(16651), uintptr(unsafe.Pointer(&__func__137)))
	}
	if img_height != 0 {
	} else {
		X__assert_fail(ts+4802 /* "img_height" */, ts+2 /* "nuklear/nuklear...." */, uint32(16652), uintptr(unsafe.Pointer(&__func__137)))
	}
	if texture_data_mask != 0 {
	} else {
		X__assert_fail(ts+4813 /* "texture_data_mas..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16653), uintptr(unsafe.Pointer(&__func__137)))
	}
	_ = tex_height
	if ((!(img_memory != 0) || !(img_width != 0)) || !(img_height != 0)) || !(texture_data_mask != 0) {
		return
	}

	pixels = img_memory
	y = 0
	n = 0
	for ; y < tex_height; y++ {
		x = 0
	__1:
		if !(x < tex_width) {
			goto __3
		}
		{
			var off0 int32 = ((int32(img_dst.X) + x) + ((int32(img_dst.Y) + y) * img_width))
			var off1 int32 = ((off0 + 1) + tex_width)
			*(*Nk_byte)(unsafe.Pointer(pixels + uintptr(off0))) = func() uint8 {
				if int32(*(*int8)(unsafe.Pointer(texture_data_mask + uintptr(n)))) == int32(white) {
					return uint8(0xFF)
				}
				return uint8(0x00)
			}()
			*(*Nk_byte)(unsafe.Pointer(pixels + uintptr(off1))) = func() uint8 {
				if int32(*(*int8)(unsafe.Pointer(texture_data_mask + uintptr(n)))) == int32(black) {
					return uint8(0xFF)
				}
				return uint8(0x00)
			}()

		}
		goto __2
	__2:
		x++
		n++
		goto __1
		goto __3
	__3:
	}
}

var __func__137 = *(*[25]int8)(unsafe.Pointer(ts + 4831 /* "nk_font_bake_cus..." */)) /* nuklear.h:16644:1 */

func nk_font_bake_convert(out_memory uintptr, img_width int32, img_height int32, in_memory uintptr) { /* nuklear.h:16669:1: */
	var n int32 = 0
	var dst uintptr
	var src uintptr

	if out_memory != 0 {
	} else {
		X__assert_fail(ts+4856 /* "out_memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(16676), uintptr(unsafe.Pointer(&__func__138)))
	}
	if in_memory != 0 {
	} else {
		X__assert_fail(ts+4867 /* "in_memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(16677), uintptr(unsafe.Pointer(&__func__138)))
	}
	if img_width != 0 {
	} else {
		X__assert_fail(ts+4792 /* "img_width" */, ts+2 /* "nuklear/nuklear...." */, uint32(16678), uintptr(unsafe.Pointer(&__func__138)))
	}
	if img_height != 0 {
	} else {
		X__assert_fail(ts+4802 /* "img_height" */, ts+2 /* "nuklear/nuklear...." */, uint32(16679), uintptr(unsafe.Pointer(&__func__138)))
	}
	if ((!(out_memory != 0) || !(in_memory != 0)) || !(img_height != 0)) || !(img_width != 0) {
		return
	}

	dst = out_memory
	src = in_memory
	for n = (img_width * img_height); n > 0; n-- {
		*(*Nk_rune)(unsafe.Pointer(PostIncUintptr(&dst, 4))) = (((Nk_rune(*(*Nk_byte)(unsafe.Pointer(PostIncUintptr(&src, 1))))) << 24) | Nk_rune(0x00FFFFFF))
	}
}

var __func__138 = *(*[21]int8)(unsafe.Pointer(ts + 4877 /* "nk_font_bake_con..." */)) /* nuklear.h:16671:1 */

// -------------------------------------------------------------
//
//                          FONT
//
// --------------------------------------------------------------
func nk_font_text_width(handle Nk_handle, height float32, text uintptr, len int32) float32 { /* nuklear.h:16694:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)
	*(*Nk_handle)(unsafe.Pointer(bp)) = handle

	// var unicode Nk_rune at bp+4, 4

	var text_len int32 = 0
	var text_width float32 = float32(0)
	var glyph_len int32 = 0
	var scale float32 = float32(0)

	var font uintptr = *(*uintptr)(unsafe.Pointer(bp /* &handle */))
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(16703), uintptr(unsafe.Pointer(&__func__139)))
	}
	if (*Nk_font)(unsafe.Pointer(font)).Glyphs != 0 {
	} else {
		X__assert_fail(ts+4898 /* "font->glyphs" */, ts+2 /* "nuklear/nuklear...." */, uint32(16704), uintptr(unsafe.Pointer(&__func__139)))
	}
	if (!(font != 0) || !(text != 0)) || !(len != 0) {
		return float32(0)
	}

	scale = (height / (*Nk_font)(unsafe.Pointer(font)).Info.Height)
	glyph_len = AssignInt32(&text_len, Xnk_utf_decode(text, bp+4 /* &unicode */, len))
	if !(glyph_len != 0) {
		return float32(0)
	}
	for (text_len <= len) && (glyph_len != 0) {
		var g uintptr
		if *(*Nk_rune)(unsafe.Pointer(bp + 4 /* unicode */)) == Nk_rune(NK_UTF_INVALID) {
			break
		}

		// query currently drawn glyph information
		g = Xnk_font_find_glyph(font, *(*Nk_rune)(unsafe.Pointer(bp + 4 /* unicode */)))
		text_width = text_width + ((*Nk_font_glyph)(unsafe.Pointer(g)).Xadvance * scale)

		// offset next glyph
		glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp+4 /* &unicode */, (len - text_len))
		text_len = text_len + (glyph_len)
	}
	return text_width
}

var __func__139 = *(*[19]int8)(unsafe.Pointer(ts + 4911 /* "nk_font_text_wid..." */)) /* nuklear.h:16695:1 */

func nk_font_query_font_glyph(handle Nk_handle, height float32, glyph uintptr, codepoint Nk_rune, next_codepoint Nk_rune) { /* nuklear.h:16727:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_handle)(unsafe.Pointer(bp)) = handle

	var scale float32
	var g uintptr
	var font uintptr

	if glyph != 0 {
	} else {
		X__assert_fail(ts+4930 /* "glyph" */, ts+2 /* "nuklear/nuklear...." */, uint32(16734), uintptr(unsafe.Pointer(&__func__140)))
	}
	_ = next_codepoint

	font = *(*uintptr)(unsafe.Pointer(bp /* &handle */))
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(16738), uintptr(unsafe.Pointer(&__func__140)))
	}
	if (*Nk_font)(unsafe.Pointer(font)).Glyphs != 0 {
	} else {
		X__assert_fail(ts+4898 /* "font->glyphs" */, ts+2 /* "nuklear/nuklear...." */, uint32(16739), uintptr(unsafe.Pointer(&__func__140)))
	}
	if !(font != 0) || !(glyph != 0) {
		return
	}

	scale = (height / (*Nk_font)(unsafe.Pointer(font)).Info.Height)
	g = Xnk_font_find_glyph(font, codepoint)
	(*Nk_user_font_glyph)(unsafe.Pointer(glyph)).Width = (((*Nk_font_glyph)(unsafe.Pointer(g)).X1 - (*Nk_font_glyph)(unsafe.Pointer(g)).X0) * scale)
	(*Nk_user_font_glyph)(unsafe.Pointer(glyph)).Height = (((*Nk_font_glyph)(unsafe.Pointer(g)).Y1 - (*Nk_font_glyph)(unsafe.Pointer(g)).Y0) * scale)
	(*Nk_user_font_glyph)(unsafe.Pointer(glyph)).Offset = Xnk_vec2(((*Nk_font_glyph)(unsafe.Pointer(g)).X0 * scale), ((*Nk_font_glyph)(unsafe.Pointer(g)).Y0 * scale))
	(*Nk_user_font_glyph)(unsafe.Pointer(glyph)).Xadvance = ((*Nk_font_glyph)(unsafe.Pointer(g)).Xadvance * scale)
	*(*Nk_vec2)(unsafe.Pointer((glyph /* &.uv */))) = Xnk_vec2((*Nk_font_glyph)(unsafe.Pointer(g)).U0, (*Nk_font_glyph)(unsafe.Pointer(g)).V0)
	*(*Nk_vec2)(unsafe.Pointer((glyph /* &.uv */) + 1*8)) = Xnk_vec2((*Nk_font_glyph)(unsafe.Pointer(g)).U1, (*Nk_font_glyph)(unsafe.Pointer(g)).V1)
}

var __func__140 = *(*[25]int8)(unsafe.Pointer(ts + 4936 /* "nk_font_query_fo..." */)) /* nuklear.h:16729:1 */

func Xnk_font_find_glyph(font uintptr, unicode Nk_rune) uintptr { /* nuklear.h:16753:34: */
	var i int32 = 0
	var count int32
	var total_glyphs int32 = 0
	var glyph uintptr = uintptr(0)
	var iter uintptr = uintptr(0)

	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(16762), uintptr(unsafe.Pointer(&__func__141)))
	}
	if (*Nk_font)(unsafe.Pointer(font)).Glyphs != 0 {
	} else {
		X__assert_fail(ts+4898 /* "font->glyphs" */, ts+2 /* "nuklear/nuklear...." */, uint32(16763), uintptr(unsafe.Pointer(&__func__141)))
	}
	if (*Nk_font)(unsafe.Pointer(font)).Info.Ranges != 0 {
	} else {
		X__assert_fail(ts+4961 /* "font->info.range..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16764), uintptr(unsafe.Pointer(&__func__141)))
	}
	if !(font != 0) || !(int32((*Nk_font)(unsafe.Pointer(font)).Glyphs) != 0) {
		return uintptr(0)
	}

	glyph = (*Nk_font)(unsafe.Pointer(font)).Fallback
	iter = (*Nk_font)(unsafe.Pointer(font)).Config
	for ok := true; ok; ok = ((AssignUintptr(&iter, (*Nk_font_config)(unsafe.Pointer(iter)).N)) != (*Nk_font)(unsafe.Pointer(font)).Config) {
		count = nk_range_count((*Nk_font_config)(unsafe.Pointer(iter)).Range)
		for i = 0; i < count; i++ {
			var f Nk_rune = *(*Nk_rune)(unsafe.Pointer((*Nk_font_config)(unsafe.Pointer(iter)).Range + uintptr(((i*2)+0))*4))
			var t Nk_rune = *(*Nk_rune)(unsafe.Pointer((*Nk_font_config)(unsafe.Pointer(iter)).Range + uintptr(((i*2)+1))*4))
			var diff int32 = (int32((t - f) + Nk_rune(1)))
			if (unicode >= f) && (unicode <= t) {
				return ((*Nk_font)(unsafe.Pointer(font)).Glyphs + uintptr((Nk_rune(total_glyphs)+(unicode-f)))*48)
			}
			total_glyphs = total_glyphs + (diff)
		}
	}
	return glyph
}

var __func__141 = *(*[19]int8)(unsafe.Pointer(ts + 4979 /* "nk_font_find_gly..." */)) /* nuklear.h:16755:1 */

func nk_font_init(font uintptr, pixel_height float32, fallback_codepoint Nk_rune, glyphs uintptr, baked_font uintptr, atlas Nk_handle) { /* nuklear.h:16782:1: */
	var baked Nk_baked_font
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(16787), uintptr(unsafe.Pointer(&__func__142)))
	}
	if glyphs != 0 {
	} else {
		X__assert_fail(ts+4998 /* "glyphs" */, ts+2 /* "nuklear/nuklear...." */, uint32(16788), uintptr(unsafe.Pointer(&__func__142)))
	}
	if baked_font != 0 {
	} else {
		X__assert_fail(ts+5005 /* "baked_font" */, ts+2 /* "nuklear/nuklear...." */, uint32(16789), uintptr(unsafe.Pointer(&__func__142)))
	}
	if (!(font != 0) || !(glyphs != 0)) || !(baked_font != 0) {
		return
	}

	baked = *(*Nk_baked_font)(unsafe.Pointer(baked_font))
	(*Nk_font)(unsafe.Pointer(font)).Fallback = uintptr(0)
	(*Nk_font)(unsafe.Pointer(font)).Info = baked
	(*Nk_font)(unsafe.Pointer(font)).Scale = (pixel_height / (*Nk_font)(unsafe.Pointer(font)).Info.Height)
	(*Nk_font)(unsafe.Pointer(font)).Glyphs = (glyphs + uintptr((*Nk_baked_font)(unsafe.Pointer(baked_font)).Glyph_offset)*48)
	(*Nk_font)(unsafe.Pointer(font)).Texture = atlas
	(*Nk_font)(unsafe.Pointer(font)).Fallback_codepoint = fallback_codepoint
	(*Nk_font)(unsafe.Pointer(font)).Fallback = Xnk_font_find_glyph(font, fallback_codepoint)

	(*Nk_font)(unsafe.Pointer(font)).Handle.Height = ((*Nk_font)(unsafe.Pointer(font)).Info.Height * (*Nk_font)(unsafe.Pointer(font)).Scale)
	(*Nk_font)(unsafe.Pointer(font)).Handle.Width = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, float32, uintptr, int32) float32
	}{nk_font_text_width}))
	*(*uintptr)(unsafe.Pointer(font + 4 /* &.handle */ /* &.userdata */)) = font
	(*Nk_font)(unsafe.Pointer(font)).Handle.Query = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, float32, uintptr, Nk_rune, Nk_rune)
	}{nk_font_query_font_glyph}))
	(*Nk_font)(unsafe.Pointer(font)).Handle.Texture = (*Nk_font)(unsafe.Pointer(font)).Texture
}

var __func__142 = *(*[13]int8)(unsafe.Pointer(ts + 5016 /* "nk_font_init" */)) /* nuklear.h:16785:1 */

// ---------------------------------------------------------------------------
//
//                          DEFAULT FONT
//
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------

var nk_proggy_clean_ttf_compressed_data_base85 = *(*[11981]int8)(unsafe.Pointer(ts + 5029 /* "7])#######hV0qs'..." */)) /* nuklear.h:16830:22 */

var nk_custom_cursor_data = *(*[2431]int8)(unsafe.Pointer(ts + 17010 /* "..-         -XXX..." */)) /* nuklear.h:16922:22 */

var nk__barrier uintptr  /* nuklear.h:16959:25: */
var nk__barrier2 uintptr /* nuklear.h:16960:25: */
var nk__barrier3 uintptr /* nuklear.h:16961:25: */
var nk__barrier4 uintptr /* nuklear.h:16962:25: */
var nk__dout uintptr     /* nuklear.h:16963:25: */

func nk_decompress_length(input uintptr) uint32 { /* nuklear.h:16966:1: */
	return (uint32((((int32(*(*uint8)(unsafe.Pointer(input + 8))) << 24) + (int32(*(*uint8)(unsafe.Pointer(input + 9))) << 16)) + (int32(*(*uint8)(unsafe.Pointer(input + 10))) << 8)) + int32(*(*uint8)(unsafe.Pointer(input + 11)))))
}

func nk__match(data uintptr, length uint32) { /* nuklear.h:16971:1: */
	// INVERSE of memmove... write each byte before copying the next...
	if (nk__dout + uintptr(length)) <= nk__barrier {
	} else {
		X__assert_fail(ts+19441 /* "nk__dout + lengt..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16974), uintptr(unsafe.Pointer(&__func__143)))
	}
	if (nk__dout + uintptr(length)) > nk__barrier {
		nk__dout += uintptr(length)
		return
	}
	if data < nk__barrier4 {
		nk__dout = (nk__barrier + uintptr(1))
		return
	}
	for PostDecUint32(&length, 1) != 0 {
		*(*uint8)(unsafe.Pointer(PostIncUintptr(&nk__dout, 1))) = *(*uint8)(unsafe.Pointer(PostIncUintptr(&data, 1)))
	}
}

var __func__143 = *(*[10]int8)(unsafe.Pointer(ts + 19474 /* "nk__match" */)) /* nuklear.h:16972:1 */

func nk__lit(data uintptr, length uint32) { /* nuklear.h:16980:1: */
	if (nk__dout + uintptr(length)) <= nk__barrier {
	} else {
		X__assert_fail(ts+19441 /* "nk__dout + lengt..." */, ts+2 /* "nuklear/nuklear...." */, uint32(16982), uintptr(unsafe.Pointer(&__func__144)))
	}
	if (nk__dout + uintptr(length)) > nk__barrier {
		nk__dout += uintptr(length)
		return
	}
	if data < nk__barrier2 {
		nk__dout = (nk__barrier + uintptr(1))
		return
	}
	nk_memcopy(nk__dout, data, uint32(length))
	nk__dout += uintptr(length)
}

var __func__144 = *(*[8]int8)(unsafe.Pointer(ts + 19484 /* "nk__lit" */)) /* nuklear.h:16981:1 */

func nk_decompress_token(i uintptr) uintptr { /* nuklear.h:16988:24: */

	if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x20 { // use fewer if's for cases that expand small
		if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x80 {
			nk__match(((nk__dout - uintptr(*(*uint8)(unsafe.Pointer(i + 1)))) - uintptr(1)), ((uint32(*(*uint8)(unsafe.Pointer(i))) - uint32(0x80)) + uint32(1)))
			i += uintptr(2)
		} else if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x40 {
			nk__match((nk__dout - uintptr(((((int32(*(*uint8)(unsafe.Pointer(i))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 1)))) - 0x4000) + 1))), (uint32(*(*uint8)(unsafe.Pointer(i + 2))) + uint32(1)))
			i += uintptr(3)
		} else { /* *i >= 0x20 */
			nk__lit((i + uintptr(1)), ((uint32(*(*uint8)(unsafe.Pointer(i))) - uint32(0x20)) + uint32(1)))
			i += (uintptr(1 + ((int32(*(*uint8)(unsafe.Pointer(i))) - 0x20) + 1)))
		}
	} else { // more ifs for cases that expand large, since overhead is amortized
		if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x18 {
			nk__match((nk__dout - uintptr((uint32((((int32(*(*uint8)(unsafe.Pointer(i))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 2))))) - 0x180000) + 1)))), (uint32(*(*uint8)(unsafe.Pointer(i + 3))) + uint32(1)))
			i += uintptr(4)
		} else if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x10 {
			nk__match((nk__dout - uintptr((uint32((((int32(*(*uint8)(unsafe.Pointer(i))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 2))))) - 0x100000) + 1)))), ((uint32((int32(*(*uint8)(unsafe.Pointer(i + 3))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 4))))) + uint32(1)))
			i += uintptr(5)
		} else if int32(*(*uint8)(unsafe.Pointer(i))) >= 0x08 {
			nk__lit((i + uintptr(2)), (((uint32((int32(*(*uint8)(unsafe.Pointer(i))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 1))))) - uint32(0x0800)) + uint32(1)))
			i += (uintptr(2 + ((((int32(*(*uint8)(unsafe.Pointer(i))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 1)))) - 0x0800) + 1)))
		} else if int32(*(*uint8)(unsafe.Pointer(i))) == 0x07 {
			nk__lit((i + uintptr(3)), ((uint32((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 2))))) + uint32(1)))
			i += (uintptr(3 + (((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 2)))) + 1)))
		} else if int32(*(*uint8)(unsafe.Pointer(i))) == 0x06 {
			nk__match((nk__dout - uintptr((uint32(((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 2))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 3))))) + 1)))), (uint32(*(*uint8)(unsafe.Pointer(i + 4))) + 1))
			i += uintptr(5)
		} else if int32(*(*uint8)(unsafe.Pointer(i))) == 0x04 {
			nk__match((nk__dout - uintptr((uint32(((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 2))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 3))))) + 1)))), ((uint32((int32(*(*uint8)(unsafe.Pointer(i + 4))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 5))))) + 1))
			i += uintptr(6)
		}
	}
	return i
}

func nk_adler32(adler32 uint32, buffer uintptr, buflen uint32) uint32 { /* nuklear.h:17010:1: */
	var ADLER_MOD uint32 = uint32(65521)
	var s1 uint32 = (uint32(adler32 & uint32(0xffff)))
	var s2 uint32 = (uint32(adler32 >> 16))
	var blocklen uint32
	var i uint32

	blocklen = (uint32(buflen % uint32(5552)))
	for buflen != 0 {
		for i = uint32(0); (i + uint32(7)) < blocklen; i = i + (uint32(8)) {
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 1))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 2))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 3))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 4))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 5))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 6))))
			s2 = s2 + (s1)
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(buffer + 7))))
			s2 = s2 + (s1)
			buffer += uintptr(8)
		}
		for ; i < blocklen; i++ {
			s1 = s1 + (uint32(*(*uint8)(unsafe.Pointer(PostIncUintptr(&buffer, 1)))))
			s2 = s2 + (s1)
		}

		s1 = s1 % (ADLER_MOD)
		s2 = s2 % (ADLER_MOD)
		buflen = buflen - (uint32(blocklen))
		blocklen = uint32(5552)
	}
	return ((uint32(s2 << 16)) + uint32(s1))
}

func nk_decompress(output uintptr, i uintptr, length uint32) uint32 { /* nuklear.h:17040:1: */
	var olen uint32
	if ((int32(*(*uint8)(unsafe.Pointer(i))) << 24) + ((int32(*(*uint8)(unsafe.Pointer(i + 1))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 2))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 3)))))) != 0x57bC0000 {
		return uint32(0)
	}
	if ((int32(*(*uint8)(unsafe.Pointer(i + 4))) << 24) + ((int32(*(*uint8)(unsafe.Pointer(i + 5))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 6))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 7)))))) != 0 {
		return uint32(0)
	} // error! stream is > 4GB
	olen = nk_decompress_length(i)
	nk__barrier2 = i
	nk__barrier3 = (i + uintptr(length))
	nk__barrier = (output + uintptr(olen))
	nk__barrier4 = output
	i += uintptr(16)

	nk__dout = output
	for {
		var old_i uintptr = i
		i = nk_decompress_token(i)
		if i == old_i {
			if (int32(*(*uint8)(unsafe.Pointer(i))) == 0x05) && (int32(*(*uint8)(unsafe.Pointer(i + 1))) == 0xfa) {
				if nk__dout == (output + uintptr(olen)) {
				} else {
					X__assert_fail(ts+19492 /* "nk__dout == outp..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17058), uintptr(unsafe.Pointer(&__func__145)))
				}
				if nk__dout != (output + uintptr(olen)) {
					return uint32(0)
				}
				if nk_adler32(uint32(1), output, olen) != (uint32((int32(*(*uint8)(unsafe.Pointer(i + 2))) << 24) + ((int32(*(*uint8)(unsafe.Pointer(i + 3))) << 16) + ((int32(*(*uint8)(unsafe.Pointer(i + 4))) << 8) + int32(*(*uint8)(unsafe.Pointer(i + 5))))))) {
					return uint32(0)
				}
				return olen
			} else {
				if 0 != 0 {
				} else {
					X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(17064), uintptr(unsafe.Pointer(&__func__145)))
				} // NOTREACHED
				return uint32(0)
			}
		}
		if nk__dout <= (output + uintptr(olen)) {
		} else {
			X__assert_fail(ts+19518 /* "nk__dout <= outp..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17068), uintptr(unsafe.Pointer(&__func__145)))
		}
		if nk__dout > (output + uintptr(olen)) {
			return uint32(0)
		}
	}
	return uint32(0)
}

var __func__145 = *(*[14]int8)(unsafe.Pointer(ts + 19544 /* "nk_decompress" */)) /* nuklear.h:17041:1 */

func nk_decode_85_byte(c int8) uint32 { /* nuklear.h:17074:1: */
	return func() uint32 {
		if int32(c) >= '\\' {
			return (uint32(int32(c) - 36))
		}
		return (uint32(int32(c) - 35))
	}()
}

func nk_decode_85(dst uintptr, src uintptr) { /* nuklear.h:17079:1: */
	for *(*uint8)(unsafe.Pointer(src)) != 0 {
		var tmp uint32 = (nk_decode_85_byte(int8(*(*uint8)(unsafe.Pointer(src)))) + (uint32(85) * (nk_decode_85_byte(int8(*(*uint8)(unsafe.Pointer(src + 1)))) + (uint32(85) * (nk_decode_85_byte(int8(*(*uint8)(unsafe.Pointer(src + 2)))) + (uint32(85) * (nk_decode_85_byte(int8(*(*uint8)(unsafe.Pointer(src + 3)))) + (uint32(85) * nk_decode_85_byte(int8(*(*uint8)(unsafe.Pointer(src + 4))))))))))))

		// we can't assume little-endianess.
		*(*uint8)(unsafe.Pointer(dst)) = (uint8((tmp >> 0) & uint32(0xFF)))
		*(*uint8)(unsafe.Pointer(dst + 1)) = (uint8((tmp >> 8) & uint32(0xFF)))
		*(*uint8)(unsafe.Pointer(dst + 2)) = (uint8((tmp >> 16) & uint32(0xFF)))
		*(*uint8)(unsafe.Pointer(dst + 3)) = (uint8((tmp >> 24) & uint32(0xFF)))

		src += uintptr(5)
		dst += uintptr(4)
	}
}

// -------------------------------------------------------------
//
//                          FONT ATLAS
//
// --------------------------------------------------------------
func Xnk_font_config(pixel_height float32) Nk_font_config { /* nuklear.h:17107:1: */
	bp := tlsAlloc(56)
	defer tlsFree(56)

	// var cfg Nk_font_config at bp, 56

	nk_zero(bp /* &cfg */, uint32(unsafe.Sizeof(Nk_font_config{})))
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_blob = uintptr(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_size = Nk_size(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_data_owned_by_atlas = uint8(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Size = pixel_height
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Oversample_h = uint8(3)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Oversample_v = uint8(1)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Pixel_snap = uint8(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Coord_type = NK_COORD_UV
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Spacing = Xnk_vec2(float32(0), float32(0))
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Range = Xnk_font_default_glyph_ranges()
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Merge_mode = uint8(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Fallback_glyph = Nk_rune('?')
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Font = uintptr(0)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).N = uintptr(0)
	return *(*Nk_font_config)(unsafe.Pointer(bp /* cfg */))
}

func Xnk_font_atlas_init_default(atlas uintptr) { /* nuklear.h:17129:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17131), uintptr(unsafe.Pointer(&__func__146)))
	}
	if !(atlas != 0) {
		return
	}
	nk_zero(atlas, uint32(unsafe.Sizeof(Nk_font_atlas{})))
	*(*uintptr)(unsafe.Pointer(atlas + 24 /* &.temporary */ /* &.userdata */)) = uintptr(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, uintptr, Nk_size) uintptr
	}{nk_malloc}))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free = *(*uintptr)(unsafe.Pointer(&struct{ f func(Nk_handle, uintptr) }{nk_mfree}))
	*(*uintptr)(unsafe.Pointer(atlas + 12 /* &.permanent */ /* &.userdata */)) = uintptr(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, uintptr, Nk_size) uintptr
	}{nk_malloc}))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free = *(*uintptr)(unsafe.Pointer(&struct{ f func(Nk_handle, uintptr) }{nk_mfree}))
}

var __func__146 = *(*[27]int8)(unsafe.Pointer(ts + 19564 /* "nk_font_atlas_in..." */)) /* nuklear.h:17130:1 */

func Xnk_font_atlas_init(atlas uintptr, alloc uintptr) { /* nuklear.h:17143:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17145), uintptr(unsafe.Pointer(&__func__147)))
	}
	if alloc != 0 {
	} else {
		X__assert_fail(ts+4629 /* "alloc" */, ts+2 /* "nuklear/nuklear...." */, uint32(17146), uintptr(unsafe.Pointer(&__func__147)))
	}
	if !(atlas != 0) || !(alloc != 0) {
		return
	}
	nk_zero(atlas, uint32(unsafe.Sizeof(Nk_font_atlas{})))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent = *(*Nk_allocator)(unsafe.Pointer(alloc))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary = *(*Nk_allocator)(unsafe.Pointer(alloc))
}

var __func__147 = *(*[19]int8)(unsafe.Pointer(ts + 19591 /* "nk_font_atlas_in..." */)) /* nuklear.h:17144:1 */

func Xnk_font_atlas_init_custom(atlas uintptr, permanent uintptr, temporary uintptr) { /* nuklear.h:17153:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17156), uintptr(unsafe.Pointer(&__func__148)))
	}
	if permanent != 0 {
	} else {
		X__assert_fail(ts+19610 /* "permanent" */, ts+2 /* "nuklear/nuklear...." */, uint32(17157), uintptr(unsafe.Pointer(&__func__148)))
	}
	if temporary != 0 {
	} else {
		X__assert_fail(ts+19620 /* "temporary" */, ts+2 /* "nuklear/nuklear...." */, uint32(17158), uintptr(unsafe.Pointer(&__func__148)))
	}
	if (!(atlas != 0) || !(permanent != 0)) || !(temporary != 0) {
		return
	}
	nk_zero(atlas, uint32(unsafe.Sizeof(Nk_font_atlas{})))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent = *(*Nk_allocator)(unsafe.Pointer(permanent))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary = *(*Nk_allocator)(unsafe.Pointer(temporary))
}

var __func__148 = *(*[26]int8)(unsafe.Pointer(ts + 19630 /* "nk_font_atlas_in..." */)) /* nuklear.h:17155:1 */

func Xnk_font_atlas_begin(atlas uintptr) { /* nuklear.h:17165:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17167), uintptr(unsafe.Pointer(&__func__149)))
	}
	if ((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0) && ((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0) {
	} else {
		X__assert_fail(ts+19656 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17168), uintptr(unsafe.Pointer(&__func__149)))
	}
	if ((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0) && ((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0) {
	} else {
		X__assert_fail(ts+19704 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17169), uintptr(unsafe.Pointer(&__func__149)))
	}
	if (((!(atlas != 0) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0) {
		return
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs != 0 {
		(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs)
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs = uintptr(0)
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel != 0 {
		(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel)
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel = uintptr(0)
	}
}

var __func__149 = *(*[20]int8)(unsafe.Pointer(ts + 19752 /* "nk_font_atlas_be..." */)) /* nuklear.h:17166:1 */

func Xnk_font_atlas_add(atlas uintptr, config uintptr) uintptr { /* nuklear.h:17181:22: */
	var font uintptr = uintptr(0)
	var cfg uintptr

	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17187), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17188), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17189), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17190), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17191), uintptr(unsafe.Pointer(&__func__150)))
	}

	if config != 0 {
	} else {
		X__assert_fail(ts+1500 /* "config" */, ts+2 /* "nuklear/nuklear...." */, uint32(17193), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_config)(unsafe.Pointer(config)).Ttf_blob != 0 {
	} else {
		X__assert_fail(ts+19862 /* "config->ttf_blob" */, ts+2 /* "nuklear/nuklear...." */, uint32(17194), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_config)(unsafe.Pointer(config)).Ttf_size != 0 {
	} else {
		X__assert_fail(ts+19879 /* "config->ttf_size" */, ts+2 /* "nuklear/nuklear...." */, uint32(17195), uintptr(unsafe.Pointer(&__func__150)))
	}
	if (*Nk_font_config)(unsafe.Pointer(config)).Size > 0.0 {
	} else {
		X__assert_fail(ts+19896 /* "config->size > 0..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17196), uintptr(unsafe.Pointer(&__func__150)))
	}

	if (((((((!(atlas != 0) || !(config != 0)) || !(int32((*Nk_font_config)(unsafe.Pointer(config)).Ttf_blob) != 0)) || !(int32((*Nk_font_config)(unsafe.Pointer(config)).Ttf_size) != 0)) || ((*Nk_font_config)(unsafe.Pointer(config)).Size <= 0.0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0) {
		return uintptr(0)
	}

	// allocate font config
	cfg = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 12 /* &.permanent */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, uintptr(0), uint32(unsafe.Sizeof(Nk_font_config{})))
	nk_memcopy(cfg, config, uint32(unsafe.Sizeof(Nk_font_config{})))
	(*Nk_font_config)(unsafe.Pointer(cfg)).N = cfg
	(*Nk_font_config)(unsafe.Pointer(cfg)).P = cfg

	if !(int32((*Nk_font_config)(unsafe.Pointer(config)).Merge_mode) != 0) {
		// insert font config into list
		if !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Config) != 0) {
			(*Nk_font_atlas)(unsafe.Pointer(atlas)).Config = cfg
			(*Nk_font_config)(unsafe.Pointer(cfg)).Next = uintptr(0)
		} else {
			var i uintptr = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config
			for (*Nk_font_config)(unsafe.Pointer(i)).Next != 0 {
				i = (*Nk_font_config)(unsafe.Pointer(i)).Next
			}
			(*Nk_font_config)(unsafe.Pointer(i)).Next = cfg
			(*Nk_font_config)(unsafe.Pointer(cfg)).Next = uintptr(0)
		}
		// allocate new font
		font = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 12 /* &.permanent */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, uintptr(0), uint32(unsafe.Sizeof(Nk_font{})))
		if font != 0 {
		} else {
			X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(17224), uintptr(unsafe.Pointer(&__func__150)))
		}
		nk_zero(font, uint32(unsafe.Sizeof(Nk_font{})))
		if !(font != 0) {
			return uintptr(0)
		}
		(*Nk_font)(unsafe.Pointer(font)).Config = cfg

		// insert font into list
		if !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts) != 0) {
			(*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts = font
			(*Nk_font)(unsafe.Pointer(font)).Next = uintptr(0)
		} else {
			var i uintptr = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts
			for (*Nk_font)(unsafe.Pointer(i)).Next != 0 {
				i = (*Nk_font)(unsafe.Pointer(i)).Next
			}
			(*Nk_font)(unsafe.Pointer(i)).Next = font
			(*Nk_font)(unsafe.Pointer(font)).Next = uintptr(0)
		}
		(*Nk_font_config)(unsafe.Pointer(cfg)).Font = (font + 24 /* &.info */)
	} else {
		// extend previously added font
		var f uintptr = uintptr(0)
		var c uintptr = uintptr(0)
		if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num != 0 {
		} else {
			X__assert_fail(ts+19916 /* "atlas->font_num" */, ts+2 /* "nuklear/nuklear...." */, uint32(17244), uintptr(unsafe.Pointer(&__func__150)))
		}
		f = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts
		c = (*Nk_font)(unsafe.Pointer(f)).Config
		(*Nk_font_config)(unsafe.Pointer(cfg)).Font = (f + 24 /* &.info */)

		(*Nk_font_config)(unsafe.Pointer(cfg)).N = c
		(*Nk_font_config)(unsafe.Pointer(cfg)).P = (*Nk_font_config)(unsafe.Pointer(c)).P
		(*Nk_font_config)(unsafe.Pointer((*Nk_font_config)(unsafe.Pointer(c)).P)).N = cfg
		(*Nk_font_config)(unsafe.Pointer(c)).P = cfg
	}
	// create own copy of .TTF font blob
	if !(int32((*Nk_font_config)(unsafe.Pointer(config)).Ttf_data_owned_by_atlas) != 0) {
		(*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_blob = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 12 /* &.permanent */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, uintptr(0), (*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_size)
		if (*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_blob != 0 {
		} else {
			X__assert_fail(ts+19932 /* "cfg->ttf_blob" */, ts+2 /* "nuklear/nuklear...." */, uint32(17257), uintptr(unsafe.Pointer(&__func__150)))
		}
		if !(int32((*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_blob) != 0) {
			(*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num++
			return uintptr(0)
		}
		nk_memcopy((*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_blob, (*Nk_font_config)(unsafe.Pointer(config)).Ttf_blob, (*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_size)
		(*Nk_font_config)(unsafe.Pointer(cfg)).Ttf_data_owned_by_atlas = uint8(1)
	}
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num++
	return font
}

var __func__150 = *(*[18]int8)(unsafe.Pointer(ts + 19946 /* "nk_font_atlas_ad..." */)) /* nuklear.h:17183:1 */

func Xnk_font_atlas_add_from_memory(atlas uintptr, memory uintptr, size Nk_size, height float32, config uintptr) uintptr { /* nuklear.h:17268:22: */
	bp := tlsAlloc(56)
	defer tlsFree(56)

	// var cfg Nk_font_config at bp, 56

	if memory != 0 {
	} else {
		X__assert_fail(ts+19964 /* "memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(17273), uintptr(unsafe.Pointer(&__func__151)))
	}
	if size != 0 {
	} else {
		X__assert_fail(ts+301 /* "size" */, ts+2 /* "nuklear/nuklear...." */, uint32(17274), uintptr(unsafe.Pointer(&__func__151)))
	}

	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17276), uintptr(unsafe.Pointer(&__func__151)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17277), uintptr(unsafe.Pointer(&__func__151)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17278), uintptr(unsafe.Pointer(&__func__151)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17279), uintptr(unsafe.Pointer(&__func__151)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17280), uintptr(unsafe.Pointer(&__func__151)))
	}
	if (((((!(atlas != 0) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0)) || !(memory != 0)) || !(size != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0) {
		return uintptr(0)
	}

	if config != 0 {
		*(*Nk_font_config)(unsafe.Pointer(bp /* cfg */)) = *(*Nk_font_config)(unsafe.Pointer(config))
	} else {
		*(*Nk_font_config)(unsafe.Pointer(bp /* cfg */)) = Xnk_font_config(height)
	}
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_blob = memory
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_size = size
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Size = height
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_data_owned_by_atlas = uint8(0)
	return Xnk_font_atlas_add(atlas, bp /* &cfg */)
}

var __func__151 = *(*[30]int8)(unsafe.Pointer(ts + 19971 /* "nk_font_atlas_ad..." */)) /* nuklear.h:17271:1 */

func Xnk_font_atlas_add_compressed(atlas uintptr, compressed_data uintptr, compressed_size Nk_size, height float32, config uintptr) uintptr { /* nuklear.h:17319:22: */
	bp := tlsAlloc(56)
	defer tlsFree(56)

	var decompressed_size uint32
	var decompressed_data uintptr
	// var cfg Nk_font_config at bp, 56

	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17328), uintptr(unsafe.Pointer(&__func__152)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17329), uintptr(unsafe.Pointer(&__func__152)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17330), uintptr(unsafe.Pointer(&__func__152)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17331), uintptr(unsafe.Pointer(&__func__152)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17332), uintptr(unsafe.Pointer(&__func__152)))
	}

	if compressed_data != 0 {
	} else {
		X__assert_fail(ts+20001 /* "compressed_data" */, ts+2 /* "nuklear/nuklear...." */, uint32(17334), uintptr(unsafe.Pointer(&__func__152)))
	}
	if compressed_size != 0 {
	} else {
		X__assert_fail(ts+20017 /* "compressed_size" */, ts+2 /* "nuklear/nuklear...." */, uint32(17335), uintptr(unsafe.Pointer(&__func__152)))
	}
	if ((((!(atlas != 0) || !(compressed_data != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0) {
		return uintptr(0)
	}

	decompressed_size = nk_decompress_length(compressed_data)
	decompressed_data = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 12 /* &.permanent */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, uintptr(0), uint32(decompressed_size))
	if decompressed_data != 0 {
	} else {
		X__assert_fail(ts+20033 /* "decompressed_dat..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17342), uintptr(unsafe.Pointer(&__func__152)))
	}
	if !(decompressed_data != 0) {
		return uintptr(0)
	}
	nk_decompress(decompressed_data, compressed_data,
		uint32(compressed_size))

	if config != 0 {
		*(*Nk_font_config)(unsafe.Pointer(bp /* cfg */)) = *(*Nk_font_config)(unsafe.Pointer(config))
	} else {
		*(*Nk_font_config)(unsafe.Pointer(bp /* cfg */)) = Xnk_font_config(height)
	}
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_blob = decompressed_data
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_size = Nk_size(decompressed_size)
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Size = height
	(*Nk_font_config)(unsafe.Pointer(bp /* &cfg */)).Ttf_data_owned_by_atlas = uint8(1)
	return Xnk_font_atlas_add(atlas, bp /* &cfg */)
}

var __func__152 = *(*[29]int8)(unsafe.Pointer(ts + 20051 /* "nk_font_atlas_ad..." */)) /* nuklear.h:17323:1 */

func Xnk_font_atlas_add_compressed_base85(atlas uintptr, data_base85 uintptr, height float32, config uintptr) uintptr { /* nuklear.h:17354:22: */
	var compressed_size int32
	var compressed_data uintptr
	var font uintptr

	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17362), uintptr(unsafe.Pointer(&__func__153)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17363), uintptr(unsafe.Pointer(&__func__153)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17364), uintptr(unsafe.Pointer(&__func__153)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17365), uintptr(unsafe.Pointer(&__func__153)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17366), uintptr(unsafe.Pointer(&__func__153)))
	}

	if data_base85 != 0 {
	} else {
		X__assert_fail(ts+20080 /* "data_base85" */, ts+2 /* "nuklear/nuklear...." */, uint32(17368), uintptr(unsafe.Pointer(&__func__153)))
	}
	if ((((!(atlas != 0) || !(data_base85 != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0) {
		return uintptr(0)
	}

	compressed_size = (((Xnk_strlen(data_base85) + 4) / 5) * 4)
	compressed_data = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 24 /* &.temporary */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, uintptr(0), Nk_size(compressed_size))
	if compressed_data != 0 {
	} else {
		X__assert_fail(ts+20001 /* "compressed_data" */, ts+2 /* "nuklear/nuklear...." */, uint32(17375), uintptr(unsafe.Pointer(&__func__153)))
	}
	if !(compressed_data != 0) {
		return uintptr(0)
	}
	nk_decode_85(compressed_data, data_base85)
	font = Xnk_font_atlas_add_compressed(atlas, compressed_data,
		Nk_size(compressed_size), height, config)
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, compressed_data)
	return font
}

var __func__153 = *(*[36]int8)(unsafe.Pointer(ts + 20092 /* "nk_font_atlas_ad..." */)) /* nuklear.h:17357:1 */

func Xnk_font_atlas_add_default(atlas uintptr, pixel_height float32, config uintptr) uintptr { /* nuklear.h:17385:22: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17389), uintptr(unsafe.Pointer(&__func__154)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17390), uintptr(unsafe.Pointer(&__func__154)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17391), uintptr(unsafe.Pointer(&__func__154)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17392), uintptr(unsafe.Pointer(&__func__154)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17393), uintptr(unsafe.Pointer(&__func__154)))
	}
	return Xnk_font_atlas_add_compressed_base85(atlas,
		uintptr(unsafe.Pointer(&nk_proggy_clean_ttf_compressed_data_base85)), pixel_height, config)
}

var __func__154 = *(*[26]int8)(unsafe.Pointer(ts + 20128 /* "nk_font_atlas_ad..." */)) /* nuklear.h:17388:1 */

func Xnk_font_atlas_bake(atlas uintptr, width uintptr, height uintptr, fmt uint32) uintptr { /* nuklear.h:17398:18: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	var i int32
	var tmp uintptr
	// var tmp_size Nk_size at bp, 4

	// var img_size Nk_size at bp+4, 4

	var font_iter uintptr
	var baker uintptr
	// convert alpha8 image into rgba32 image
	var img_rgba uintptr
	var font uintptr
	var config uintptr
	var cursor uintptr
	i = 0
	tmp = uintptr(0)

	if !(atlas != 0) {
		goto __1
	}
	goto __2
__1:
	X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17408), uintptr(unsafe.Pointer(&__func__155)))
__2:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0) {
		goto __3
	}
	goto __4
__3:
	X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17409), uintptr(unsafe.Pointer(&__func__155)))
__4:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0) {
		goto __5
	}
	goto __6
__5:
	X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17410), uintptr(unsafe.Pointer(&__func__155)))
__6:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0) {
		goto __7
	}
	goto __8
__7:
	X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17411), uintptr(unsafe.Pointer(&__func__155)))
__8:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0) {
		goto __9
	}
	goto __10
__9:
	X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17412), uintptr(unsafe.Pointer(&__func__155)))
__10:
	;

	if !(width != 0) {
		goto __11
	}
	goto __12
__11:
	X__assert_fail(ts+4610 /* "width" */, ts+2 /* "nuklear/nuklear...." */, uint32(17414), uintptr(unsafe.Pointer(&__func__155)))
__12:
	;
	if !(height != 0) {
		goto __13
	}
	goto __14
__13:
	X__assert_fail(ts+4616 /* "height" */, ts+2 /* "nuklear/nuklear...." */, uint32(17415), uintptr(unsafe.Pointer(&__func__155)))
__14:
	;
	if !((((((!(atlas != 0) || !(width != 0)) || !(height != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0)) {
		goto __15
	}
	return uintptr(0)
__15:
	;

	// no font added so just use default font
	if !(!((*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num != 0)) {
		goto __16
	}
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Default_font = Xnk_font_atlas_add_default(atlas, 13.0, uintptr(0))
__16:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num != 0) {
		goto __17
	}
	goto __18
__17:
	X__assert_fail(ts+19916 /* "atlas->font_num" */, ts+2 /* "nuklear/nuklear...." */, uint32(17426), uintptr(unsafe.Pointer(&__func__155)))
__18:
	;
	if !(!((*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num != 0)) {
		goto __19
	}
	return uintptr(0)
__19:
	;

	// allocate temporary baker memory required for the baking process
	nk_font_baker_memory(bp /* &tmp_size */, (atlas + 268 /* &.glyph_count */), (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num)
	tmp = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 24 /* &.temporary */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, uintptr(0), *(*Nk_size)(unsafe.Pointer(bp /* tmp_size */)))
	if !(tmp != 0) {
		goto __20
	}
	goto __21
__20:
	X__assert_fail(ts+20154 /* "tmp" */, ts+2 /* "nuklear/nuklear...." */, uint32(17432), uintptr(unsafe.Pointer(&__func__155)))
__21:
	;
	if !(!(tmp != 0)) {
		goto __22
	}
	goto failed
__22:
	;
	Xmemset(tmp, 0, *(*Nk_size)(unsafe.Pointer(bp /* tmp_size */)))

	// allocate glyph memory for all fonts
	baker = nk_font_baker(tmp, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyph_count, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num, (atlas + 24 /* &.temporary */))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 12 /* &.permanent */ + 4 /* &.alloc */))))(
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, uintptr(0), (uint32(unsafe.Sizeof(Nk_font_glyph{})) * Nk_size((*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyph_count)))
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs != 0) {
		goto __23
	}
	goto __24
__23:
	X__assert_fail(ts+20158 /* "atlas->glyphs" */, ts+2 /* "nuklear/nuklear...." */, uint32(17440), uintptr(unsafe.Pointer(&__func__155)))
__24:
	;
	if !(!(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs) != 0)) {
		goto __25
	}
	goto failed
__25:
	;

	// pack all glyphs into a tight fit space
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.W = (int16((NK_CURSOR_DATA_W * 2) + 1))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.H = (int16(NK_CURSOR_DATA_H + 1))
	if !(!(nk_font_bake_pack(baker, bp+4 /* &img_size */, width, height, (atlas+36 /* &.custom */),
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Config, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num, (atlas+24 /* &.temporary */)) != 0)) {
		goto __26
	}
	goto failed
__26:
	;

	// allocate memory for the baked image font atlas
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 24 /* &.temporary */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, uintptr(0), *(*Nk_size)(unsafe.Pointer(bp + 4 /* img_size */)))
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel != 0) {
		goto __27
	}
	goto __28
__27:
	X__assert_fail(ts+20172 /* "atlas->pixel" */, ts+2 /* "nuklear/nuklear...." */, uint32(17453), uintptr(unsafe.Pointer(&__func__155)))
__28:
	;
	if !(!(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel) != 0)) {
		goto __29
	}
	goto failed
__29:
	;

	// bake glyphs and custom white pixel into image
	nk_font_bake(baker, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel, *(*int32)(unsafe.Pointer(width)), *(*int32)(unsafe.Pointer(height)),
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyph_count, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Font_num)
	nk_font_bake_custom_data((*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel, *(*int32)(unsafe.Pointer(width)), *(*int32)(unsafe.Pointer(height)), (*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom,
		uintptr(unsafe.Pointer(&nk_custom_cursor_data)), NK_CURSOR_DATA_W, NK_CURSOR_DATA_H, int8('.'), int8('X'))

	if !(int32(fmt) == NK_FONT_ATLAS_RGBA32) {
		goto __30
	}
	// convert alpha8 image into rgba32 image
	img_rgba = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((atlas + 24 /* &.temporary */ + 4 /* &.alloc */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, uintptr(0),
		(Nk_size((*(*int32)(unsafe.Pointer(width)) * *(*int32)(unsafe.Pointer(height))) * 4)))
	if !(img_rgba != 0) {
		goto __31
	}
	goto __32
__31:
	X__assert_fail(ts+20185 /* "img_rgba" */, ts+2 /* "nuklear/nuklear...." */, uint32(17467), uintptr(unsafe.Pointer(&__func__155)))
__32:
	;
	if !(!(img_rgba != 0)) {
		goto __33
	}
	goto failed
__33:
	;
	nk_font_bake_convert(img_rgba, *(*int32)(unsafe.Pointer(width)), *(*int32)(unsafe.Pointer(height)), (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel)
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel = img_rgba
__30:
	;
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_width = *(*int32)(unsafe.Pointer(width))
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_height = *(*int32)(unsafe.Pointer(height))

	// initialize each font
	font_iter = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts
__34:
	if !(font_iter != 0) {
		goto __36
	}
	font = font_iter
	config = (*Nk_font)(unsafe.Pointer(font)).Config
	nk_font_init(font, (*Nk_font_config)(unsafe.Pointer(config)).Size, (*Nk_font_config)(unsafe.Pointer(config)).Fallback_glyph, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs,
		(*Nk_font_config)(unsafe.Pointer(config)).Font, Xnk_handle_ptr(uintptr(0)))
	goto __35
__35:
	font_iter = (*Nk_font)(unsafe.Pointer(font_iter)).Next
	goto __34
	goto __36
__36:
	;

	/* initialize each cursor */

	i = 0
__37:
	if !(i < NK_CURSOR_COUNT) {
		goto __39
	}
	cursor = ((atlas + 44 /* &.cursors */) + uintptr(i)*32)
	(*Nk_cursor)(unsafe.Pointer(cursor)).Img.W = uint16(*(*int32)(unsafe.Pointer(width)))
	(*Nk_cursor)(unsafe.Pointer(cursor)).Img.H = uint16(*(*int32)(unsafe.Pointer(height)))
	*(*uint16)(unsafe.Pointer((cursor /* &.img */ + 8 /* &.region */))) = (uint16(float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.X) + (*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24))).X))
	*(*uint16)(unsafe.Pointer((cursor /* &.img */ + 8 /* &.region */) + 1*2)) = (uint16(float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.Y) + (*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24))).Y))
	*(*uint16)(unsafe.Pointer((cursor /* &.img */ + 8 /* &.region */) + 2*2)) = uint16((*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24) + 1*8)).X)
	*(*uint16)(unsafe.Pointer((cursor /* &.img */ + 8 /* &.region */) + 3*2)) = uint16((*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24) + 1*8)).Y)
	(*Nk_cursor)(unsafe.Pointer(cursor)).Size = *(*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24) + 1*8))
	(*Nk_cursor)(unsafe.Pointer(cursor)).Offset = *(*Nk_vec2)(unsafe.Pointer((uintptr(unsafe.Pointer(&nk_cursor_data)) + uintptr(i)*24) + 2*8))
	goto __38
__38:
	i++
	goto __37
	goto __39
__39:
	;

	// free temporary memory
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, tmp)
	return (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel

failed:
	// error so cleanup all memory
	if !(tmp != 0) {
		goto __40
	}
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, tmp)
__40:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs != 0) {
		goto __41
	}
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs = uintptr(0)
__41:
	;
	if !((*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel != 0) {
		goto __42
	}
	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel = uintptr(0)
__42:
	;
	return uintptr(0)
}

var __func__155 = *(*[19]int8)(unsafe.Pointer(ts + 20194 /* "nk_font_atlas_ba..." */)) /* nuklear.h:17401:1 */
var nk_cursor_data = [7][3]Nk_vec2{[3]Nk_vec2{
	// Pos      Size        Offset
	Nk_vec2{Y: float32(3)}, Nk_vec2{X: float32(12), Y: float32(19)}, Nk_vec2{}},
	[3]Nk_vec2{Nk_vec2{X: float32(13)}, Nk_vec2{X: float32(7), Y: float32(16)}, Nk_vec2{X: float32(4), Y: float32(8)}},
	[3]Nk_vec2{Nk_vec2{X: float32(31)}, Nk_vec2{X: float32(23), Y: float32(23)}, Nk_vec2{X: float32(11), Y: float32(11)}},
	[3]Nk_vec2{Nk_vec2{X: float32(21)}, Nk_vec2{X: float32(9), Y: float32(23)}, Nk_vec2{X: float32(5), Y: float32(11)}},
	[3]Nk_vec2{Nk_vec2{X: float32(55), Y: float32(18)}, Nk_vec2{X: float32(23), Y: float32(9)}, Nk_vec2{X: float32(11), Y: float32(5)}},
	[3]Nk_vec2{Nk_vec2{X: float32(73)}, Nk_vec2{X: float32(17), Y: float32(17)}, Nk_vec2{X: float32(9), Y: float32(9)}},
	[3]Nk_vec2{Nk_vec2{X: float32(55)}, Nk_vec2{X: float32(17), Y: float32(17)}, Nk_vec2{X: float32(9), Y: float32(9)}}} /* nuklear.h:17485:38 */

func Xnk_font_atlas_end(atlas uintptr, texture Nk_handle, null uintptr) { /* nuklear.h:17524:1: */
	var i int32 = 0
	var font_iter uintptr
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17529), uintptr(unsafe.Pointer(&__func__156)))
	}
	if !(atlas != 0) {
		if !(null != 0) {
			return
		}
		(*Nk_draw_null_texture)(unsafe.Pointer(null)).Texture = texture
		(*Nk_draw_null_texture)(unsafe.Pointer(null)).Uv = Xnk_vec2(0.5, 0.5)
	}
	if null != 0 {
		(*Nk_draw_null_texture)(unsafe.Pointer(null)).Texture = texture
		(*Nk_draw_null_texture)(unsafe.Pointer(null)).Uv.X = ((float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.X) + 0.5) / float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_width))
		(*Nk_draw_null_texture)(unsafe.Pointer(null)).Uv.Y = ((float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.Y) + 0.5) / float32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_height))
	}
	for font_iter = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts; font_iter != 0; font_iter = (*Nk_font)(unsafe.Pointer(font_iter)).Next {
		(*Nk_font)(unsafe.Pointer(font_iter)).Texture = texture
		(*Nk_font)(unsafe.Pointer(font_iter)).Handle.Texture = texture
	}
	for i = 0; i < NK_CURSOR_COUNT; i++ {
		(*Nk_cursor)(unsafe.Pointer((atlas + 44 /* &.cursors */) + uintptr(i)*32)).Img.Handle = texture
	}

	(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 24 /* &.temporary */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Pixel = uintptr(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_width = 0
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Tex_height = 0
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.X = int16(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.Y = int16(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.W = int16(0)
	(*Nk_font_atlas)(unsafe.Pointer(atlas)).Custom.H = int16(0)
}

var __func__156 = *(*[18]int8)(unsafe.Pointer(ts + 20213 /* "nk_font_atlas_en..." */)) /* nuklear.h:17526:1 */

func Xnk_font_atlas_cleanup(atlas uintptr) { /* nuklear.h:17559:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17561), uintptr(unsafe.Pointer(&__func__157)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17562), uintptr(unsafe.Pointer(&__func__157)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17563), uintptr(unsafe.Pointer(&__func__157)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17564), uintptr(unsafe.Pointer(&__func__157)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17565), uintptr(unsafe.Pointer(&__func__157)))
	}
	if (!(atlas != 0) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0) {
		return
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config != 0 {
		var iter uintptr
		for iter = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config; iter != 0; iter = (*Nk_font_config)(unsafe.Pointer(iter)).Next {
			var i uintptr
			for i = (*Nk_font_config)(unsafe.Pointer(iter)).N; i != iter; i = (*Nk_font_config)(unsafe.Pointer(i)).N {
				(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_config)(unsafe.Pointer(i)).Ttf_blob)
				(*Nk_font_config)(unsafe.Pointer(i)).Ttf_blob = uintptr(0)
			}
			(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_config)(unsafe.Pointer(iter)).Ttf_blob)
			(*Nk_font_config)(unsafe.Pointer(iter)).Ttf_blob = uintptr(0)
		}
	}
}

var __func__157 = *(*[22]int8)(unsafe.Pointer(ts + 20231 /* "nk_font_atlas_cl..." */)) /* nuklear.h:17560:1 */

func Xnk_font_atlas_clear(atlas uintptr) { /* nuklear.h:17581:1: */
	if atlas != 0 {
	} else {
		X__assert_fail(ts+19558 /* "atlas" */, ts+2 /* "nuklear/nuklear...." */, uint32(17583), uintptr(unsafe.Pointer(&__func__158)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Alloc != 0 {
	} else {
		X__assert_fail(ts+19817 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17584), uintptr(unsafe.Pointer(&__func__158)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Temporary.Free != 0 {
	} else {
		X__assert_fail(ts+19840 /* "atlas->temporary..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17585), uintptr(unsafe.Pointer(&__func__158)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc != 0 {
	} else {
		X__assert_fail(ts+19772 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17586), uintptr(unsafe.Pointer(&__func__158)))
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free != 0 {
	} else {
		X__assert_fail(ts+19795 /* "atlas->permanent..." */, ts+2 /* "nuklear/nuklear...." */, uint32(17587), uintptr(unsafe.Pointer(&__func__158)))
	}
	if (!(atlas != 0) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Alloc) != 0)) || !(int32((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Free) != 0) {
		return
	}

	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config != 0 {
		var iter uintptr
		var next uintptr
		for iter = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Config; iter != 0; iter = next {
			var i uintptr
			var n uintptr
			for i = (*Nk_font_config)(unsafe.Pointer(iter)).N; i != iter; i = n {
				n = (*Nk_font_config)(unsafe.Pointer(i)).N
				if (*Nk_font_config)(unsafe.Pointer(i)).Ttf_blob != 0 {
					(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_config)(unsafe.Pointer(i)).Ttf_blob)
				}
				(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, i)
			}
			next = (*Nk_font_config)(unsafe.Pointer(iter)).Next
			if (*Nk_font_config)(unsafe.Pointer(i)).Ttf_blob != 0 {
				(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_config)(unsafe.Pointer(iter)).Ttf_blob)
			}
			(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, iter)
		}
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Config = uintptr(0)
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts != 0 {
		var iter uintptr
		var next uintptr
		for iter = (*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts; iter != 0; iter = next {
			next = (*Nk_font)(unsafe.Pointer(iter)).Next
			(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, iter)
		}
		(*Nk_font_atlas)(unsafe.Pointer(atlas)).Fonts = uintptr(0)
	}
	if (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs != 0 {
		(*(*func(Nk_handle, uintptr))(unsafe.Pointer((atlas + 12 /* &.permanent */ + 8 /* &.free */))))((*Nk_font_atlas)(unsafe.Pointer(atlas)).Permanent.Userdata, (*Nk_font_atlas)(unsafe.Pointer(atlas)).Glyphs)
	}
	nk_zero(atlas, uint32(unsafe.Sizeof(Nk_font_atlas{})))
}

var __func__158 = *(*[20]int8)(unsafe.Pointer(ts + 20253 /* "nk_font_atlas_cl..." */)) /* nuklear.h:17582:1 */

// ===============================================================
//
//                          INPUT
//
// ===============================================================
func Xnk_input_begin(ctx uintptr) { /* nuklear.h:17631:1: */
	var i int32
	var in uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17635), uintptr(unsafe.Pointer(&__func__159)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)
	for i = 0; i < NK_BUTTON_MAX; i++ {
		(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */) + uintptr(i)*16)).Clicked = uint32(0)
	}

	(*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len = 0
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta = Xnk_vec2(float32(0), float32(0))
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Prev.X = (*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Prev.Y = (*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X = float32(0)
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y = float32(0)
	for i = 0; i < NK_KEY_MAX; i++ {
		(*Nk_key)(unsafe.Pointer((in /* &.keyboard */ /* &.keys */) + uintptr(i)*8)).Clicked = uint32(0)
	}
}

var __func__159 = *(*[15]int8)(unsafe.Pointer(ts + 20273 /* "nk_input_begin" */)) /* nuklear.h:17632:1 */

func Xnk_input_end(ctx uintptr) { /* nuklear.h:17651:1: */
	var in uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17654), uintptr(unsafe.Pointer(&__func__160)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)
	if (*Nk_input)(unsafe.Pointer(in)).Mouse.Grab != 0 {
		(*Nk_input)(unsafe.Pointer(in)).Mouse.Grab = uint8(0)
	}
	if (*Nk_input)(unsafe.Pointer(in)).Mouse.Ungrab != 0 {
		(*Nk_input)(unsafe.Pointer(in)).Mouse.Grabbed = uint8(0)
		(*Nk_input)(unsafe.Pointer(in)).Mouse.Ungrab = uint8(0)
		(*Nk_input)(unsafe.Pointer(in)).Mouse.Grab = uint8(0)
	}
}

var __func__160 = *(*[13]int8)(unsafe.Pointer(ts + 20288 /* "nk_input_end" */)) /* nuklear.h:17652:1 */

func Xnk_input_motion(ctx uintptr, x int32, y int32) { /* nuklear.h:17666:1: */
	var in uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17669), uintptr(unsafe.Pointer(&__func__161)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X = float32(x)
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y = float32(y)
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X = ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - (*Nk_input)(unsafe.Pointer(in)).Mouse.Prev.X)
	(*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y = ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_input)(unsafe.Pointer(in)).Mouse.Prev.Y)
}

var __func__161 = *(*[16]int8)(unsafe.Pointer(ts + 20301 /* "nk_input_motion" */)) /* nuklear.h:17667:1 */

func Xnk_input_key(ctx uintptr, key uint32, down Nk_bool) { /* nuklear.h:17678:1: */
	var in uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17681), uintptr(unsafe.Pointer(&__func__162)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)
	(*Nk_key)(unsafe.Pointer((in /* &.keyboard */ /* &.keys */)+uintptr(key)*8)).Clicked++
	(*Nk_key)(unsafe.Pointer((in /* &.keyboard */ /* &.keys */) + uintptr(key)*8)).Down = down
}

var __func__162 = *(*[13]int8)(unsafe.Pointer(ts + 20317 /* "nk_input_key" */)) /* nuklear.h:17679:1 */

func Xnk_input_button(ctx uintptr, id uint32, x int32, y int32, down Nk_bool) { /* nuklear.h:17693:1: */
	var btn uintptr
	var in uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17697), uintptr(unsafe.Pointer(&__func__163)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)
	if (*Nk_mouse_button)(unsafe.Pointer((in+260 /* &.mouse */ /* &.buttons */)+uintptr(id)*16)).Down == down {
		return
	}

	btn = ((in + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	(*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.X = float32(x)
	(*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.Y = float32(y)
	(*Nk_mouse_button)(unsafe.Pointer(btn)).Down = down
	(*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked++
}

var __func__163 = *(*[16]int8)(unsafe.Pointer(ts + 20330 /* "nk_input_button" */)) /* nuklear.h:17694:1 */

func Xnk_input_scroll(ctx uintptr, val Nk_vec2) { /* nuklear.h:17709:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17711), uintptr(unsafe.Pointer(&__func__164)))
	}
	if !(ctx != 0) {
		return
	}
	*(*float32)(unsafe.Pointer(ctx /* &.input */ + 260 /* &.mouse */ + 88 /* &.scroll_delta */ /* &.x */)) += (val.X)
	*(*float32)(unsafe.Pointer(ctx /* &.input */ + 260 /* &.mouse */ + 88 /* &.scroll_delta */ + 4 /* &.y */)) += (val.Y)
}

var __func__164 = *(*[16]int8)(unsafe.Pointer(ts + 20346 /* "nk_input_scroll" */)) /* nuklear.h:17710:1 */

func Xnk_input_glyph(ctx uintptr, glyph uintptr) { /* nuklear.h:17717:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var len int32 = 0
	// var unicode Nk_rune at bp, 4

	var in uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17723), uintptr(unsafe.Pointer(&__func__165)))
	}
	if !(ctx != 0) {
		return
	}
	in = (ctx /* &.input */)

	len = Xnk_utf_decode(glyph, bp /* &unicode */, NK_UTF_SIZE)
	if (len != 0) && (((*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len + len) < NK_INPUT_MAX) {
		Xnk_utf_encode(*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)), ((in /* &.keyboard */ + 240 /* &.text */) + uintptr((*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len)),
			(NK_INPUT_MAX - (*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len))
		*(*int32)(unsafe.Pointer(in /* &.keyboard */ + 256 /* &.text_len */)) += (len)
	}
}

var __func__165 = *(*[15]int8)(unsafe.Pointer(ts + 20362 /* "nk_input_glyph" */)) /* nuklear.h:17718:1 */

func Xnk_input_char(ctx uintptr, c int8) { /* nuklear.h:17735:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var glyph Nk_glyph at bp, 4

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17738), uintptr(unsafe.Pointer(&__func__166)))
	}
	if !(ctx != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(bp /* &glyph[0] */)) = c
	Xnk_input_glyph(ctx, bp /* &glyph[0] */)
}

var __func__166 = *(*[14]int8)(unsafe.Pointer(ts + 20377 /* "nk_input_char" */)) /* nuklear.h:17736:1 */

func Xnk_input_unicode(ctx uintptr, unicode Nk_rune) { /* nuklear.h:17744:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var rune Nk_glyph at bp, 4

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17747), uintptr(unsafe.Pointer(&__func__167)))
	}
	if !(ctx != 0) {
		return
	}
	Xnk_utf_encode(unicode, bp /* &rune[0] */, NK_UTF_SIZE)
	Xnk_input_glyph(ctx, bp /* &rune[0] */)
}

var __func__167 = *(*[17]int8)(unsafe.Pointer(ts + 20391 /* "nk_input_unicode" */)) /* nuklear.h:17745:1 */

func Xnk_input_has_mouse_click(i uintptr, id uint32) Nk_bool { /* nuklear.h:17753:1: */
	var btn uintptr
	if !(i != 0) {
		return Nk_false
	}
	btn = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	if ((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked != 0) && ((*Nk_mouse_button)(unsafe.Pointer(btn)).Down == Nk_false) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_has_mouse_click_in_rect(i uintptr, id uint32, b Nk_rect) Nk_bool { /* nuklear.h:17761:1: */
	var btn uintptr
	if !(i != 0) {
		return Nk_false
	}
	btn = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	if !((((b.X) <= ((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.X)) && (((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.X) < (b.X + b.W))) && (((b.Y) <= ((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.Y)) && (((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked_pos.Y) < (b.Y + b.H)))) {
		return Nk_false
	}
	return Nk_true
}

func Xnk_input_has_mouse_click_down_in_rect(i uintptr, id uint32, b Nk_rect, down Nk_bool) Nk_bool { /* nuklear.h:17772:1: */
	var btn uintptr
	if !(i != 0) {
		return Nk_false
	}
	btn = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	return (Bool32((Xnk_input_has_mouse_click_in_rect(i, id, b) != 0) && ((*Nk_mouse_button)(unsafe.Pointer(btn)).Down == down)))
}

func Xnk_input_is_mouse_click_in_rect(i uintptr, id uint32, b Nk_rect) Nk_bool { /* nuklear.h:17781:1: */
	var btn uintptr
	if !(i != 0) {
		return Nk_false
	}
	btn = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	if (Xnk_input_has_mouse_click_down_in_rect(i, id, b, Nk_false) != 0) && ((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked != 0) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_is_mouse_click_down_in_rect(i uintptr, id uint32, b Nk_rect, down Nk_bool) Nk_bool { /* nuklear.h:17791:1: */
	var btn uintptr
	if !(i != 0) {
		return Nk_false
	}
	btn = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	if (Xnk_input_has_mouse_click_down_in_rect(i, id, b, down) != 0) && ((*Nk_mouse_button)(unsafe.Pointer(btn)).Clicked != 0) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_any_mouse_click_in_rect(in uintptr, b Nk_rect) Nk_bool { /* nuklear.h:17801:1: */
	var i int32
	var down int32 = 0
	for i = 0; i < NK_BUTTON_MAX; i++ {
		down = (Bool32((down != 0) || (Xnk_input_is_mouse_click_in_rect(in, uint32(i), b) != 0)))
	}
	return down
}

func Xnk_input_is_mouse_hovering_rect(i uintptr, rect Nk_rect) Nk_bool { /* nuklear.h:17809:1: */
	if !(i != 0) {
		return Nk_false
	}
	return (Bool32((((rect.X) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.X)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.X) < (rect.X + rect.W))) && (((rect.Y) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.Y)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.Y) < (rect.Y + rect.H)))))
}

func Xnk_input_is_mouse_prev_hovering_rect(i uintptr, rect Nk_rect) Nk_bool { /* nuklear.h:17815:1: */
	if !(i != 0) {
		return Nk_false
	}
	return (Bool32((((rect.X) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Prev.X)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Prev.X) < (rect.X + rect.W))) && (((rect.Y) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Prev.Y)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Prev.Y) < (rect.Y + rect.H)))))
}

func Xnk_input_mouse_clicked(i uintptr, id uint32, rect Nk_rect) Nk_bool { /* nuklear.h:17821:1: */
	if !(i != 0) {
		return Nk_false
	}
	if !(Xnk_input_is_mouse_hovering_rect(i, rect) != 0) {
		return Nk_false
	}
	return Xnk_input_is_mouse_click_in_rect(i, id, rect)
}

func Xnk_input_is_mouse_down(i uintptr, id uint32) Nk_bool { /* nuklear.h:17828:1: */
	if !(i != 0) {
		return Nk_false
	}
	return (*Nk_mouse_button)(unsafe.Pointer((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)).Down
}

func Xnk_input_is_mouse_pressed(i uintptr, id uint32) Nk_bool { /* nuklear.h:17834:1: */
	var b uintptr
	if !(i != 0) {
		return Nk_false
	}
	b = ((i + 260 /* &.mouse */ /* &.buttons */) + uintptr(id)*16)
	if ((*Nk_mouse_button)(unsafe.Pointer(b)).Down != 0) && ((*Nk_mouse_button)(unsafe.Pointer(b)).Clicked != 0) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_is_mouse_released(i uintptr, id uint32) Nk_bool { /* nuklear.h:17844:1: */
	if !(i != 0) {
		return Nk_false
	}
	return (Bool32(!((*Nk_mouse_button)(unsafe.Pointer((i+260 /* &.mouse */ /* &.buttons */)+uintptr(id)*16)).Down != 0) && ((*Nk_mouse_button)(unsafe.Pointer((i+260 /* &.mouse */ /* &.buttons */)+uintptr(id)*16)).Clicked != 0)))
}

func Xnk_input_is_key_pressed(i uintptr, key uint32) Nk_bool { /* nuklear.h:17850:1: */
	var k uintptr
	if !(i != 0) {
		return Nk_false
	}
	k = ((i /* &.keyboard */ /* &.keys */) + uintptr(key)*8)
	if (((*Nk_key)(unsafe.Pointer(k)).Down != 0) && ((*Nk_key)(unsafe.Pointer(k)).Clicked != 0)) || (!((*Nk_key)(unsafe.Pointer(k)).Down != 0) && ((*Nk_key)(unsafe.Pointer(k)).Clicked >= uint32(2))) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_is_key_released(i uintptr, key uint32) Nk_bool { /* nuklear.h:17860:1: */
	var k uintptr
	if !(i != 0) {
		return Nk_false
	}
	k = ((i /* &.keyboard */ /* &.keys */) + uintptr(key)*8)
	if (!((*Nk_key)(unsafe.Pointer(k)).Down != 0) && ((*Nk_key)(unsafe.Pointer(k)).Clicked != 0)) || (((*Nk_key)(unsafe.Pointer(k)).Down != 0) && ((*Nk_key)(unsafe.Pointer(k)).Clicked >= uint32(2))) {
		return Nk_true
	}
	return Nk_false
}

func Xnk_input_is_key_down(i uintptr, key uint32) Nk_bool { /* nuklear.h:17870:1: */
	var k uintptr
	if !(i != 0) {
		return Nk_false
	}
	k = ((i /* &.keyboard */ /* &.keys */) + uintptr(key)*8)
	if (*Nk_key)(unsafe.Pointer(k)).Down != 0 {
		return Nk_true
	}
	return Nk_false
}

// ===============================================================
//
//                              STYLE
//
// ===============================================================
func Xnk_style_default(ctx uintptr) { /* nuklear.h:17888:13: */
	Xnk_style_from_table(ctx, uintptr(0))
}

var nk_default_color_style = [28]Nk_color{
	Nk_color{R: Nk_byte(175), G: Nk_byte(175), B: Nk_byte(175), A: Nk_byte(255)}, Nk_color{R: Nk_byte(45), G: Nk_byte(45), B: Nk_byte(45), A: Nk_byte(255)}, Nk_color{R: Nk_byte(40), G: Nk_byte(40), B: Nk_byte(40), A: Nk_byte(255)}, Nk_color{R: Nk_byte(65), G: Nk_byte(65), B: Nk_byte(65), A: Nk_byte(255)}, Nk_color{R: Nk_byte(50), G: Nk_byte(50), B: Nk_byte(50), A: Nk_byte(255)}, Nk_color{R: Nk_byte(40), G: Nk_byte(40), B: Nk_byte(40), A: Nk_byte(255)}, Nk_color{R: Nk_byte(35), G: Nk_byte(35), B: Nk_byte(35), A: Nk_byte(255)}, Nk_color{R: Nk_byte(100), G: Nk_byte(100), B: Nk_byte(100), A: Nk_byte(255)}, Nk_color{R: Nk_byte(120), G: Nk_byte(120), B: Nk_byte(120), A: Nk_byte(255)}, Nk_color{R: Nk_byte(45), G: Nk_byte(45), B: Nk_byte(45), A: Nk_byte(255)}, Nk_color{R: Nk_byte(45), G: Nk_byte(45), B: Nk_byte(45), A: Nk_byte(255)}, Nk_color{R: Nk_byte(35), G: Nk_byte(35), B: Nk_byte(35), A: Nk_byte(255)}, Nk_color{R: Nk_byte(38), G: Nk_byte(38), B: Nk_byte(38), A: Nk_byte(255)}, Nk_color{R: Nk_byte(100), G: Nk_byte(100), B: Nk_byte(100), A: Nk_byte(255)}, Nk_color{R: Nk_byte(120), G: Nk_byte(120), B: Nk_byte(120), A: Nk_byte(255)}, Nk_color{R: Nk_byte(150), G: Nk_byte(150), B: Nk_byte(150), A: Nk_byte(255)}, Nk_color{R: Nk_byte(38), G: Nk_byte(38), B: Nk_byte(38), A: Nk_byte(255)}, Nk_color{R: Nk_byte(38), G: Nk_byte(38), B: Nk_byte(38), A: Nk_byte(255)}, Nk_color{R: Nk_byte(175), G: Nk_byte(175), B: Nk_byte(175), A: Nk_byte(255)}, Nk_color{R: Nk_byte(45), G: Nk_byte(45), B: Nk_byte(45), A: Nk_byte(255)}, Nk_color{R: Nk_byte(120), G: Nk_byte(120), B: Nk_byte(120), A: Nk_byte(255)}, Nk_color{R: Nk_byte(45), G: Nk_byte(45), B: Nk_byte(45), A: Nk_byte(255)}, Nk_color{R: Nk_byte(255), A: Nk_byte(255)}, Nk_color{R: Nk_byte(40), G: Nk_byte(40), B: Nk_byte(40), A: Nk_byte(255)}, Nk_color{R: Nk_byte(100), G: Nk_byte(100), B: Nk_byte(100), A: Nk_byte(255)}, Nk_color{R: Nk_byte(120), G: Nk_byte(120), B: Nk_byte(120), A: Nk_byte(255)}, Nk_color{R: Nk_byte(150), G: Nk_byte(150), B: Nk_byte(150), A: Nk_byte(255)}, Nk_color{R: Nk_byte(40), G: Nk_byte(40), B: Nk_byte(40), A: Nk_byte(255)},
} /* nuklear.h:17920:1 */
var nk_color_names = [28]uintptr{
	ts + 20408 /* "NK_COLOR_TEXT" */, ts + 20422 /* "NK_COLOR_WINDOW" */, ts + 20438 /* "NK_COLOR_HEADER" */, ts + 20454 /* "NK_COLOR_BORDER" */, ts + 20470 /* "NK_COLOR_BUTTON" */, ts + 20486 /* "NK_COLOR_BUTTON_..." */, ts + 20508 /* "NK_COLOR_BUTTON_..." */, ts + 20531 /* "NK_COLOR_TOGGLE" */, ts + 20547 /* "NK_COLOR_TOGGLE_..." */, ts + 20569 /* "NK_COLOR_TOGGLE_..." */, ts + 20592 /* "NK_COLOR_SELECT" */, ts + 20608 /* "NK_COLOR_SELECT_..." */, ts + 20631 /* "NK_COLOR_SLIDER" */, ts + 20647 /* "NK_COLOR_SLIDER_..." */, ts + 20670 /* "NK_COLOR_SLIDER_..." */, ts + 20699 /* "NK_COLOR_SLIDER_..." */, ts + 20729 /* "NK_COLOR_PROPERT..." */, ts + 20747 /* "NK_COLOR_EDIT" */, ts + 20761 /* "NK_COLOR_EDIT_CU..." */, ts + 20782 /* "NK_COLOR_COMBO" */, ts + 20797 /* "NK_COLOR_CHART" */, ts + 20812 /* "NK_COLOR_CHART_C..." */, ts + 20833 /* "NK_COLOR_CHART_C..." */, ts + 20864 /* "NK_COLOR_SCROLLB..." */, ts + 20883 /* "NK_COLOR_SCROLLB..." */, ts + 20909 /* "NK_COLOR_SCROLLB..." */, ts + 20941 /* "NK_COLOR_SCROLLB..." */, ts + 20974, /* "NK_COLOR_TAB_HEA..." */
} /* nuklear.h:17925:22 */

func Xnk_style_get_color_by_name(c uint32) uintptr { /* nuklear.h:17931:18: */
	return nk_color_names[c]
}

func Xnk_style_item_image(img Nk_image) Nk_style_item { /* nuklear.h:17937:1: */
	bp := tlsAlloc(20)
	defer tlsFree(20)

	// var i Nk_style_item at bp, 20

	(*Nk_style_item)(unsafe.Pointer(bp /* &i */)).Type = NK_STYLE_ITEM_IMAGE
	*(*Nk_image)(unsafe.Pointer(bp /* &i */ + 4 /* &.data */)) = img
	return *(*Nk_style_item)(unsafe.Pointer(bp /* i */))
}

func Xnk_style_item_color(col Nk_color) Nk_style_item { /* nuklear.h:17945:1: */
	bp := tlsAlloc(20)
	defer tlsFree(20)

	// var i Nk_style_item at bp, 20

	(*Nk_style_item)(unsafe.Pointer(bp /* &i */)).Type = NK_STYLE_ITEM_COLOR
	*(*Nk_color)(unsafe.Pointer(bp /* &i */ + 4 /* &.data */)) = col
	return *(*Nk_style_item)(unsafe.Pointer(bp /* i */))
}

func Xnk_style_item_hide() Nk_style_item { /* nuklear.h:17953:1: */
	bp := tlsAlloc(20)
	defer tlsFree(20)

	// var i Nk_style_item at bp, 20

	(*Nk_style_item)(unsafe.Pointer(bp /* &i */)).Type = NK_STYLE_ITEM_COLOR
	*(*Nk_color)(unsafe.Pointer(bp /* &i */ + 4 /* &.data */)) = Xnk_rgba(0, 0, 0, 0)
	return *(*Nk_style_item)(unsafe.Pointer(bp /* i */))
}

func Xnk_style_from_table(ctx uintptr, table uintptr) { /* nuklear.h:17961:1: */
	var style uintptr
	var text uintptr
	var button uintptr
	var toggle uintptr
	var select1 uintptr
	var slider uintptr
	var prog uintptr
	var scroll uintptr
	var edit uintptr
	var property uintptr
	var combo uintptr
	var chart uintptr
	var tab uintptr
	var win uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(17978), uintptr(unsafe.Pointer(&__func__168)))
	}
	if !(ctx != 0) {
		return
	}
	style = (ctx + 360 /* &.style */)
	table = func() uintptr {
		if !(table != 0) {
			return uintptr(unsafe.Pointer(&nk_default_color_style))
		}
		return table
	}()

	// default text
	text = (style + 44 /* &.text */)
	(*Nk_style_text)(unsafe.Pointer(text)).Color = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_text)(unsafe.Pointer(text)).Padding = Xnk_vec2(float32(0), float32(0))

	// default button
	button = (style + 56 /* &.button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 4*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 5*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 6*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 4*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Image_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 1.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 4.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// contextual button
	button = (style + 184 /* &.contextual_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 5*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 6*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// menu button
	button = (style + 312 /* &.menu_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 1.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// checkbox toggle
	toggle = (style + 600 /* &.checkbox */)
	nk_zero(toggle, uint32(unsafe.Sizeof(Nk_style_toggle{})))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 7*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 8*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 8*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Cursor_normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 9*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Cursor_hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 9*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Touch_padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Border = 0.0
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Spacing = float32(4)

	// option toggle
	toggle = (style + 440 /* &.option */)
	nk_zero(toggle, uint32(unsafe.Sizeof(Nk_style_toggle{})))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 7*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 8*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 8*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Cursor_normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 9*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Cursor_hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 9*4)))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Padding = Xnk_vec2(3.0, 3.0)
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Touch_padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Border = 0.0
	(*Nk_style_toggle)(unsafe.Pointer(toggle)).Spacing = float32(4)

	// selectable
	select1 = (style + 760 /* &.selectable */)
	nk_zero(select1, uint32(unsafe.Sizeof(Nk_style_selectable{})))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 10*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 10*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Pressed = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 10*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Normal_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 11*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Hover_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 11*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Pressed_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 11*4)))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_pressed = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_normal_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_hover_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Text_pressed_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Image_padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Touch_padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Rounding = 0.0
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Draw_begin = uintptr(0)
	(*Nk_style_selectable)(unsafe.Pointer(select1)).Draw_end = uintptr(0)

	// slider
	slider = (style + 952 /* &.slider */)
	nk_zero(slider, uint32(unsafe.Sizeof(Nk_style_slider{})))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Normal = Xnk_style_item_hide()
	(*Nk_style_slider)(unsafe.Pointer(slider)).Hover = Xnk_style_item_hide()
	(*Nk_style_slider)(unsafe.Pointer(slider)).Active = Xnk_style_item_hide()
	(*Nk_style_slider)(unsafe.Pointer(slider)).Bar_normal = *(*Nk_color)(unsafe.Pointer(table + 12*4))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Bar_hover = *(*Nk_color)(unsafe.Pointer(table + 12*4))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Bar_active = *(*Nk_color)(unsafe.Pointer(table + 12*4))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Bar_filled = *(*Nk_color)(unsafe.Pointer(table + 13*4))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Cursor_normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 13*4)))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Cursor_hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 14*4)))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Cursor_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 15*4)))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Inc_symbol = NK_SYMBOL_TRIANGLE_RIGHT
	(*Nk_style_slider)(unsafe.Pointer(slider)).Dec_symbol = NK_SYMBOL_TRIANGLE_LEFT
	(*Nk_style_slider)(unsafe.Pointer(slider)).Cursor_size = Xnk_vec2(float32(16), float32(16))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Padding = Xnk_vec2(float32(2), float32(2))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Spacing = Xnk_vec2(float32(2), float32(2))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_slider)(unsafe.Pointer(slider)).Show_buttons = Nk_false
	(*Nk_style_slider)(unsafe.Pointer(slider)).Bar_height = float32(8)
	(*Nk_style_slider)(unsafe.Pointer(slider)).Rounding = float32(0)
	(*Nk_style_slider)(unsafe.Pointer(slider)).Draw_begin = uintptr(0)
	(*Nk_style_slider)(unsafe.Pointer(slider)).Draw_end = uintptr(0)

	// slider buttons
	button = (style + 952 /* &.slider */ + 180 /* &.inc_button */)
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(Xnk_rgb(40, 40, 40))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(Xnk_rgb(42, 42, 42))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(Xnk_rgb(44, 44, 44))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgb(65, 65, 65)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = Xnk_rgb(40, 40, 40)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(8.0, 8.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 1.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Slider.Dec_button = (*Nk_style)(unsafe.Pointer(style)).Slider.Inc_button

	// progressbar
	prog = (style + 1408 /* &.progress */)
	nk_zero(prog, uint32(unsafe.Sizeof(Nk_style_progress{})))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 12*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 12*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 12*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 13*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 14*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 15*4)))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_progress)(unsafe.Pointer(prog)).Rounding = float32(0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Border = float32(0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_rounding = float32(0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Cursor_border = float32(0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Draw_begin = uintptr(0)
	(*Nk_style_progress)(unsafe.Pointer(prog)).Draw_end = uintptr(0)

	// scrollbars
	scroll = (style + 3132 /* &.scrollh */)
	nk_zero(scroll, uint32(unsafe.Sizeof(Nk_style_scrollbar{})))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 23*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 23*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 23*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Cursor_normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 24*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Cursor_hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 25*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Cursor_active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 26*4)))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Dec_symbol = NK_SYMBOL_CIRCLE_SOLID
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Inc_symbol = NK_SYMBOL_CIRCLE_SOLID
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 23*4))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Cursor_border_color = *(*Nk_color)(unsafe.Pointer(table + 23*4))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Show_buttons = Nk_false
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Border = float32(0)
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Rounding = float32(0)
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Border_cursor = float32(0)
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Rounding_cursor = float32(0)
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Draw_begin = uintptr(0)
	(*Nk_style_scrollbar)(unsafe.Pointer(scroll)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Scrollv = (*Nk_style)(unsafe.Pointer(style)).Scrollh

	// scrollbars buttons
	button = (style + 3132 /* &.scrollh */ + 156 /* &.inc_button */)
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(Xnk_rgb(40, 40, 40))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(Xnk_rgb(42, 42, 42))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(Xnk_rgb(44, 44, 44))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgb(65, 65, 65)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = Xnk_rgb(40, 40, 40)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = Xnk_rgb(175, 175, 175)
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(4.0, 4.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 1.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Scrollh.Dec_button = (*Nk_style)(unsafe.Pointer(style)).Scrollh.Inc_button
	(*Nk_style)(unsafe.Pointer(style)).Scrollv.Inc_button = (*Nk_style)(unsafe.Pointer(style)).Scrollh.Inc_button
	(*Nk_style)(unsafe.Pointer(style)).Scrollv.Dec_button = (*Nk_style)(unsafe.Pointer(style)).Scrollh.Inc_button

	// edit
	edit = (style + 2512 /* &.edit */)
	nk_zero(edit, uint32(unsafe.Sizeof(Nk_style_edit{})))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 17*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 17*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 17*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_text_normal = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_text_hover = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_text_normal = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_text_hover = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Scrollbar_size = Xnk_vec2(float32(10), float32(10))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Scrollbar = (*Nk_style)(unsafe.Pointer(style)).Scrollv
	(*Nk_style_edit)(unsafe.Pointer(edit)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Row_padding = float32(2)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_size = float32(4)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Border = float32(1)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Rounding = float32(0)

	// property
	property = (style + 1572 /* &.property */)
	nk_zero(property, uint32(unsafe.Sizeof(Nk_style_property{})))
	(*Nk_style_property)(unsafe.Pointer(property)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_property)(unsafe.Pointer(property)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_property)(unsafe.Pointer(property)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_property)(unsafe.Pointer(property)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_property)(unsafe.Pointer(property)).Label_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_property)(unsafe.Pointer(property)).Label_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_property)(unsafe.Pointer(property)).Label_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_property)(unsafe.Pointer(property)).Sym_left = NK_SYMBOL_TRIANGLE_LEFT
	(*Nk_style_property)(unsafe.Pointer(property)).Sym_right = NK_SYMBOL_TRIANGLE_RIGHT
	(*Nk_style_property)(unsafe.Pointer(property)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_property)(unsafe.Pointer(property)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_property)(unsafe.Pointer(property)).Border = float32(1)
	(*Nk_style_property)(unsafe.Pointer(property)).Rounding = float32(10)
	(*Nk_style_property)(unsafe.Pointer(property)).Draw_begin = uintptr(0)
	(*Nk_style_property)(unsafe.Pointer(property)).Draw_end = uintptr(0)

	// property buttons
	button = (style + 1572 /* &.property */ + 800 /* &.dec_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 16*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Property.Inc_button = (*Nk_style)(unsafe.Pointer(style)).Property.Dec_button

	// property edit
	edit = (style + 1572 /* &.property */ + 100 /* &.edit */)
	nk_zero(edit, uint32(unsafe.Sizeof(Nk_style_edit{})))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 16*4)))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_text_normal = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_text_hover = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_text_normal = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Selected_text_hover = *(*Nk_color)(unsafe.Pointer(table + 17*4))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_style_edit)(unsafe.Pointer(edit)).Cursor_size = float32(8)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Border = float32(0)
	(*Nk_style_edit)(unsafe.Pointer(edit)).Rounding = float32(0)

	// chart
	chart = (style + 3084 /* &.chart */)
	nk_zero(chart, uint32(unsafe.Sizeof(Nk_style_chart{})))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Background = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 20*4)))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Selected_color = *(*Nk_color)(unsafe.Pointer(table + 22*4))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Color = *(*Nk_color)(unsafe.Pointer(table + 21*4))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_chart)(unsafe.Pointer(chart)).Border = float32(0)
	(*Nk_style_chart)(unsafe.Pointer(chart)).Rounding = float32(0)

	// combo
	combo = (style + 4572 /* &.combo */)
	(*Nk_style_combo)(unsafe.Pointer(combo)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Label_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Label_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Label_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Sym_normal = NK_SYMBOL_TRIANGLE_DOWN
	(*Nk_style_combo)(unsafe.Pointer(combo)).Sym_hover = NK_SYMBOL_TRIANGLE_DOWN
	(*Nk_style_combo)(unsafe.Pointer(combo)).Sym_active = NK_SYMBOL_TRIANGLE_DOWN
	(*Nk_style_combo)(unsafe.Pointer(combo)).Content_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Button_padding = Xnk_vec2(float32(0), float32(4))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Spacing = Xnk_vec2(float32(4), float32(0))
	(*Nk_style_combo)(unsafe.Pointer(combo)).Border = float32(1)
	(*Nk_style_combo)(unsafe.Pointer(combo)).Rounding = float32(0)

	// combo button
	button = (style + 4572 /* &.combo */ + 88 /* &.button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 19*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 19*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// tab
	tab = (style + 3996 /* &.tab */)
	(*Nk_style_tab)(unsafe.Pointer(tab)).Background = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 27*4)))
	(*Nk_style_tab)(unsafe.Pointer(tab)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_tab)(unsafe.Pointer(tab)).Text = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_tab)(unsafe.Pointer(tab)).Sym_minimize = NK_SYMBOL_TRIANGLE_RIGHT
	(*Nk_style_tab)(unsafe.Pointer(tab)).Sym_maximize = NK_SYMBOL_TRIANGLE_DOWN
	(*Nk_style_tab)(unsafe.Pointer(tab)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_tab)(unsafe.Pointer(tab)).Spacing = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_tab)(unsafe.Pointer(tab)).Indent = 10.0
	(*Nk_style_tab)(unsafe.Pointer(tab)).Border = float32(1)
	(*Nk_style_tab)(unsafe.Pointer(tab)).Rounding = float32(0)

	// tab button
	button = (style + 3996 /* &.tab */ + 156 /* &.tab_minimize_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 27*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 27*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 27*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 27*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Tab.Tab_maximize_button = *(*Nk_style_button)(unsafe.Pointer(button))

	// node button
	button = (style + 3996 /* &.tab */ + 412 /* &.node_minimize_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 27*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(2.0, 2.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)
	(*Nk_style)(unsafe.Pointer(style)).Tab.Node_maximize_button = *(*Nk_style_button)(unsafe.Pointer(button))

	// window header
	win = (style + 4832 /* &.window */)
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Align = NK_HEADER_RIGHT
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Close_symbol = NK_SYMBOL_X
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Minimize_symbol = NK_SYMBOL_MINUS
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Maximize_symbol = NK_SYMBOL_PLUS
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Label_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Label_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Label_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Label_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Header.Spacing = Xnk_vec2(float32(0), float32(0))

	// window header close button
	button = (style + 4832 /* &.window */ /* &.header */ + 60 /* &.close_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 2*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// window header minimize button
	button = (style + 4832 /* &.window */ /* &.header */ + 188 /* &.minimize_button */)
	nk_zero(button, uint32(unsafe.Sizeof(Nk_style_button{})))
	(*Nk_style_button)(unsafe.Pointer(button)).Normal = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Hover = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Active = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 2*4)))
	(*Nk_style_button)(unsafe.Pointer(button)).Border_color = Xnk_rgba(0, 0, 0, 0)
	(*Nk_style_button)(unsafe.Pointer(button)).Text_background = *(*Nk_color)(unsafe.Pointer(table + 2*4))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_normal = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_hover = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_active = *(*Nk_color)(unsafe.Pointer(table))
	(*Nk_style_button)(unsafe.Pointer(button)).Padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Touch_padding = Xnk_vec2(0.0, 0.0)
	(*Nk_style_button)(unsafe.Pointer(button)).Userdata = Xnk_handle_ptr(uintptr(0))
	(*Nk_style_button)(unsafe.Pointer(button)).Text_alignment = NK_TEXT_CENTERED
	(*Nk_style_button)(unsafe.Pointer(button)).Border = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Rounding = 0.0
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_begin = uintptr(0)
	(*Nk_style_button)(unsafe.Pointer(button)).Draw_end = uintptr(0)

	// window
	(*Nk_style_window)(unsafe.Pointer(win)).Background = *(*Nk_color)(unsafe.Pointer(table + 1*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Fixed_background = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table + 1*4)))
	(*Nk_style_window)(unsafe.Pointer(win)).Border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Popup_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Combo_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Contextual_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Menu_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Group_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Tooltip_border_color = *(*Nk_color)(unsafe.Pointer(table + 3*4))
	(*Nk_style_window)(unsafe.Pointer(win)).Scaler = Xnk_style_item_color(*(*Nk_color)(unsafe.Pointer(table)))

	(*Nk_style_window)(unsafe.Pointer(win)).Rounding = 0.0
	(*Nk_style_window)(unsafe.Pointer(win)).Spacing = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Scrollbar_size = Xnk_vec2(float32(10), float32(10))
	(*Nk_style_window)(unsafe.Pointer(win)).Min_size = Xnk_vec2(float32(64), float32(64))

	(*Nk_style_window)(unsafe.Pointer(win)).Combo_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Contextual_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Menu_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Group_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Tooltip_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Popup_border = 1.0
	(*Nk_style_window)(unsafe.Pointer(win)).Border = 2.0
	(*Nk_style_window)(unsafe.Pointer(win)).Min_row_height_padding = float32(8)

	(*Nk_style_window)(unsafe.Pointer(win)).Padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Group_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Popup_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Combo_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Contextual_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Menu_padding = Xnk_vec2(float32(4), float32(4))
	(*Nk_style_window)(unsafe.Pointer(win)).Tooltip_padding = Xnk_vec2(float32(4), float32(4))
}

var __func__168 = *(*[20]int8)(unsafe.Pointer(ts + 20994 /* "nk_style_from_ta..." */)) /* nuklear.h:17962:1 */

func Xnk_style_set_font(ctx uintptr, font uintptr) { /* nuklear.h:18505:1: */
	var style uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18508), uintptr(unsafe.Pointer(&__func__169)))
	}

	if !(ctx != 0) {
		return
	}
	style = (ctx + 360 /* &.style */)
	(*Nk_style)(unsafe.Pointer(style)).Font = font
	(*Nk_context)(unsafe.Pointer(ctx)).Stacks.Fonts.Head = 0
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
		Xnk_layout_reset_min_row_height(ctx)
	}
}

var __func__169 = *(*[18]int8)(unsafe.Pointer(ts + 21014 /* "nk_style_set_fon..." */)) /* nuklear.h:18506:1 */

func Xnk_style_push_font(ctx uintptr, font uintptr) Nk_bool { /* nuklear.h:18518:1: */
	var font_stack uintptr
	var element uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18523), uintptr(unsafe.Pointer(&__func__170)))
	}
	if !(ctx != 0) {
		return 0
	}

	font_stack = (ctx + 5828 /* &.stacks */ + 1364 /* &.fonts */)
	if (*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head < (int32(uint32(unsafe.Sizeof([8]Nk_config_stack_user_font_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_user_font_element{})))) {
	} else {
		X__assert_fail(ts+21032 /* "font_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18527), uintptr(unsafe.Pointer(&__func__170)))
	}
	if (*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head >= (int32(uint32(unsafe.Sizeof([8]Nk_config_stack_user_font_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_user_font_element{})))) {
		return 0
	}

	element = ((font_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head, 1))*8)
	(*Nk_config_stack_user_font_element)(unsafe.Pointer(element)).Address = (ctx + 360 /* &.style */ /* &.font */)
	(*Nk_config_stack_user_font_element)(unsafe.Pointer(element)).Old_value = (*Nk_context)(unsafe.Pointer(ctx)).Style.Font
	(*Nk_context)(unsafe.Pointer(ctx)).Style.Font = font
	return 1
}

var __func__170 = *(*[19]int8)(unsafe.Pointer(ts + 21119 /* "nk_style_push_fo..." */)) /* nuklear.h:18519:1 */

func Xnk_style_pop_font(ctx uintptr) Nk_bool { /* nuklear.h:18538:1: */
	var font_stack uintptr
	var element uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18543), uintptr(unsafe.Pointer(&__func__171)))
	}
	if !(ctx != 0) {
		return 0
	}

	font_stack = (ctx + 5828 /* &.stacks */ + 1364 /* &.fonts */)
	if (*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21138 /* "font_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18547), uintptr(unsafe.Pointer(&__func__171)))
	}
	if (*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head < 1 {
		return 0
	}

	element = ((font_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_user_font)(unsafe.Pointer(font_stack)).Head, 1))*8)
	*(*uintptr)(unsafe.Pointer((*Nk_config_stack_user_font_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_user_font_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__171 = *(*[18]int8)(unsafe.Pointer(ts + 21159 /* "nk_style_pop_fon..." */)) /* nuklear.h:18539:1 */

func Xnk_style_push_style_item(ctx uintptr, address uintptr, value Nk_style_item) Nk_bool { /* nuklear.h:18587:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18587), uintptr(unsafe.Pointer(&__func__172)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ /* &.style_items */)
	if (*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head < (int32(uint32(unsafe.Sizeof([16]Nk_config_stack_style_item_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_style_item_element{})))) {
	} else {
		X__assert_fail(ts+21177 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18587), uintptr(unsafe.Pointer(&__func__172)))
	}
	if (*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head >= (int32(uint32(unsafe.Sizeof([16]Nk_config_stack_style_item_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_style_item_element{})))) {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head, 1))*24)
	(*Nk_config_stack_style_item_element)(unsafe.Pointer(element)).Address = address
	(*Nk_config_stack_style_item_element)(unsafe.Pointer(element)).Old_value = *(*Nk_style_item)(unsafe.Pointer(address))
	*(*Nk_style_item)(unsafe.Pointer(address)) = value
	return 1
}

var __func__172 = *(*[25]int8)(unsafe.Pointer(ts + 21264 /* "nk_style_push_st..." */)) /* nuklear.h:18587:16 */

func Xnk_style_push_float(ctx uintptr, address uintptr, value float32) Nk_bool { /* nuklear.h:18588:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18588), uintptr(unsafe.Pointer(&__func__173)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 388 /* &.floats */)
	if (*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head < (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_float_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_float_element{})))) {
	} else {
		X__assert_fail(ts+21177 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18588), uintptr(unsafe.Pointer(&__func__173)))
	}
	if (*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head >= (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_float_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_float_element{})))) {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head, 1))*8)
	(*Nk_config_stack_float_element)(unsafe.Pointer(element)).Address = address
	(*Nk_config_stack_float_element)(unsafe.Pointer(element)).Old_value = *(*float32)(unsafe.Pointer(address))
	*(*float32)(unsafe.Pointer(address)) = value
	return 1
}

var __func__173 = *(*[20]int8)(unsafe.Pointer(ts + 21289 /* "nk_style_push_fl..." */)) /* nuklear.h:18588:16 */

func Xnk_style_push_vec2(ctx uintptr, address uintptr, value Nk_vec2) Nk_bool { /* nuklear.h:18589:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18589), uintptr(unsafe.Pointer(&__func__174)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 648 /* &.vectors */)
	if (*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head < (int32(uint32(unsafe.Sizeof([16]Nk_config_stack_vec2_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_vec2_element{})))) {
	} else {
		X__assert_fail(ts+21177 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18589), uintptr(unsafe.Pointer(&__func__174)))
	}
	if (*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head >= (int32(uint32(unsafe.Sizeof([16]Nk_config_stack_vec2_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_vec2_element{})))) {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head, 1))*12)
	(*Nk_config_stack_vec2_element)(unsafe.Pointer(element)).Address = address
	(*Nk_config_stack_vec2_element)(unsafe.Pointer(element)).Old_value = *(*Nk_vec2)(unsafe.Pointer(address))
	*(*Nk_vec2)(unsafe.Pointer(address)) = value
	return 1
}

var __func__174 = *(*[19]int8)(unsafe.Pointer(ts + 21309 /* "nk_style_push_ve..." */)) /* nuklear.h:18589:16 */

func Xnk_style_push_flags(ctx uintptr, address uintptr, value Nk_flags) Nk_bool { /* nuklear.h:18590:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18590), uintptr(unsafe.Pointer(&__func__175)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 844 /* &.flags */)
	if (*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head < (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_flags_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_flags_element{})))) {
	} else {
		X__assert_fail(ts+21177 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18590), uintptr(unsafe.Pointer(&__func__175)))
	}
	if (*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head >= (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_flags_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_flags_element{})))) {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head, 1))*8)
	(*Nk_config_stack_flags_element)(unsafe.Pointer(element)).Address = address
	(*Nk_config_stack_flags_element)(unsafe.Pointer(element)).Old_value = *(*Nk_flags)(unsafe.Pointer(address))
	*(*Nk_flags)(unsafe.Pointer(address)) = value
	return 1
}

var __func__175 = *(*[20]int8)(unsafe.Pointer(ts + 21328 /* "nk_style_push_fl..." */)) /* nuklear.h:18590:16 */

func Xnk_style_push_color(ctx uintptr, address uintptr, value Nk_color) Nk_bool { /* nuklear.h:18591:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18591), uintptr(unsafe.Pointer(&__func__176)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 1104 /* &.colors */)
	if (*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head < (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_color_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_color_element{})))) {
	} else {
		X__assert_fail(ts+21177 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18591), uintptr(unsafe.Pointer(&__func__176)))
	}
	if (*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head >= (int32(uint32(unsafe.Sizeof([32]Nk_config_stack_color_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_color_element{})))) {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head, 1))*8)
	(*Nk_config_stack_color_element)(unsafe.Pointer(element)).Address = address
	(*Nk_config_stack_color_element)(unsafe.Pointer(element)).Old_value = *(*Nk_color)(unsafe.Pointer(address))
	*(*Nk_color)(unsafe.Pointer(address)) = value
	return 1
}

var __func__176 = *(*[20]int8)(unsafe.Pointer(ts + 21348 /* "nk_style_push_co..." */)) /* nuklear.h:18591:16 */

func Xnk_style_pop_style_item(ctx uintptr) Nk_bool { /* nuklear.h:18593:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18593), uintptr(unsafe.Pointer(&__func__177)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ /* &.style_items */)
	if (*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21368 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18593), uintptr(unsafe.Pointer(&__func__177)))
	}
	if (*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head < 1 {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_style_item)(unsafe.Pointer(type_stack)).Head, 1))*24)
	*(*Nk_style_item)(unsafe.Pointer((*Nk_config_stack_style_item_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_style_item_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__177 = *(*[24]int8)(unsafe.Pointer(ts + 21389 /* "nk_style_pop_sty..." */)) /* nuklear.h:18593:16 */

func Xnk_style_pop_float(ctx uintptr) Nk_bool { /* nuklear.h:18594:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18594), uintptr(unsafe.Pointer(&__func__178)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 388 /* &.floats */)
	if (*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21368 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18594), uintptr(unsafe.Pointer(&__func__178)))
	}
	if (*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head < 1 {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_float)(unsafe.Pointer(type_stack)).Head, 1))*8)
	*(*float32)(unsafe.Pointer((*Nk_config_stack_float_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_float_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__178 = *(*[19]int8)(unsafe.Pointer(ts + 21413 /* "nk_style_pop_flo..." */)) /* nuklear.h:18594:16 */

func Xnk_style_pop_vec2(ctx uintptr) Nk_bool { /* nuklear.h:18595:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18595), uintptr(unsafe.Pointer(&__func__179)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 648 /* &.vectors */)
	if (*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21368 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18595), uintptr(unsafe.Pointer(&__func__179)))
	}
	if (*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head < 1 {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_vec2)(unsafe.Pointer(type_stack)).Head, 1))*12)
	*(*Nk_vec2)(unsafe.Pointer((*Nk_config_stack_vec2_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_vec2_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__179 = *(*[18]int8)(unsafe.Pointer(ts + 21432 /* "nk_style_pop_vec..." */)) /* nuklear.h:18595:16 */

func Xnk_style_pop_flags(ctx uintptr) Nk_bool { /* nuklear.h:18596:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18596), uintptr(unsafe.Pointer(&__func__180)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 844 /* &.flags */)
	if (*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21368 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18596), uintptr(unsafe.Pointer(&__func__180)))
	}
	if (*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head < 1 {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_flags)(unsafe.Pointer(type_stack)).Head, 1))*8)
	*(*Nk_flags)(unsafe.Pointer((*Nk_config_stack_flags_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_flags_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__180 = *(*[19]int8)(unsafe.Pointer(ts + 21450 /* "nk_style_pop_fla..." */)) /* nuklear.h:18596:16 */

func Xnk_style_pop_color(ctx uintptr) Nk_bool { /* nuklear.h:18597:16: */
	var type_stack uintptr
	var element uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18597), uintptr(unsafe.Pointer(&__func__181)))
	}
	if !(ctx != 0) {
		return 0
	}
	type_stack = (ctx + 5828 /* &.stacks */ + 1104 /* &.colors */)
	if (*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+21368 /* "type_stack->head..." */, ts+2 /* "nuklear/nuklear...." */, uint32(18597), uintptr(unsafe.Pointer(&__func__181)))
	}
	if (*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head < 1 {
		return 0
	}
	element = ((type_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_color)(unsafe.Pointer(type_stack)).Head, 1))*8)
	*(*Nk_color)(unsafe.Pointer((*Nk_config_stack_color_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_color_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__181 = *(*[19]int8)(unsafe.Pointer(ts + 21469 /* "nk_style_pop_col..." */)) /* nuklear.h:18597:16 */

func Xnk_style_set_cursor(ctx uintptr, c uint32) Nk_bool { /* nuklear.h:18600:1: */
	var style uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18603), uintptr(unsafe.Pointer(&__func__182)))
	}
	if !(ctx != 0) {
		return 0
	}
	style = (ctx + 360 /* &.style */)
	if *(*uintptr)(unsafe.Pointer((style + 4 /* &.cursors */) + uintptr(c)*4)) != 0 {
		(*Nk_style)(unsafe.Pointer(style)).Cursor_active = *(*uintptr)(unsafe.Pointer((style + 4 /* &.cursors */) + uintptr(c)*4))
		return 1
	}
	return 0
}

var __func__182 = *(*[20]int8)(unsafe.Pointer(ts + 21488 /* "nk_style_set_cur..." */)) /* nuklear.h:18601:1 */

func Xnk_style_show_cursor(ctx uintptr) { /* nuklear.h:18613:1: */
	(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_visible = Nk_true
}

func Xnk_style_hide_cursor(ctx uintptr) { /* nuklear.h:18618:1: */
	(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_visible = Nk_false
}

func Xnk_style_load_cursor(ctx uintptr, cursor uint32, c uintptr) { /* nuklear.h:18623:1: */
	var style uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18627), uintptr(unsafe.Pointer(&__func__183)))
	}
	if !(ctx != 0) {
		return
	}
	style = (ctx + 360 /* &.style */)
	*(*uintptr)(unsafe.Pointer((style + 4 /* &.cursors */) + uintptr(cursor)*4)) = c
}

var __func__183 = *(*[21]int8)(unsafe.Pointer(ts + 21508 /* "nk_style_load_cu..." */)) /* nuklear.h:18625:1 */

func Xnk_style_load_all_cursors(ctx uintptr, cursors uintptr) { /* nuklear.h:18633:1: */
	var i int32 = 0
	var style uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18637), uintptr(unsafe.Pointer(&__func__184)))
	}
	if !(ctx != 0) {
		return
	}
	style = (ctx + 360 /* &.style */)
	for i = 0; i < NK_CURSOR_COUNT; i++ {
		*(*uintptr)(unsafe.Pointer((style + 4 /* &.cursors */) + uintptr(i)*4)) = (cursors + uintptr(i)*32)
	}
	(*Nk_style)(unsafe.Pointer(style)).Cursor_visible = Nk_true
}

var __func__184 = *(*[26]int8)(unsafe.Pointer(ts + 21529 /* "nk_style_load_al..." */)) /* nuklear.h:18634:1 */

// ==============================================================
//
//                          CONTEXT
//
// ===============================================================
func nk_setup(ctx uintptr, font uintptr) { /* nuklear.h:18655:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18657), uintptr(unsafe.Pointer(&__func__185)))
	}
	if !(ctx != 0) {
		return
	}
	nk_zero(ctx, uint32(unsafe.Sizeof(Nk_context{})))
	Xnk_style_default(ctx)
	(*Nk_context)(unsafe.Pointer(ctx)).Seq = uint32(1)
	if font != 0 {
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Font = font
	}
	Xnk_draw_list_init((ctx + 7332 /* &.draw_list */))
}

var __func__185 = *(*[9]int8)(unsafe.Pointer(ts + 21555 /* "nk_setup" */)) /* nuklear.h:18656:1 */

func Xnk_init_default(ctx uintptr, font uintptr) Nk_bool { /* nuklear.h:18669:1: */
	bp := tlsAlloc(12)
	defer tlsFree(12)

	// var alloc Nk_allocator at bp, 12

	*(*uintptr)(unsafe.Pointer(bp /* &alloc */ /* &.userdata */)) = uintptr(0)
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Alloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(Nk_handle, uintptr, Nk_size) uintptr
	}{nk_malloc}))
	(*Nk_allocator)(unsafe.Pointer(bp /* &alloc */)).Free = *(*uintptr)(unsafe.Pointer(&struct{ f func(Nk_handle, uintptr) }{nk_mfree}))
	return Xnk_init(ctx, bp /* &alloc */, font)
}

func Xnk_init_fixed(ctx uintptr, memory uintptr, size Nk_size, font uintptr) Nk_bool { /* nuklear.h:18679:1: */
	if memory != 0 {
	} else {
		X__assert_fail(ts+19964 /* "memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(18682), uintptr(unsafe.Pointer(&__func__186)))
	}
	if !(memory != 0) {
		return 0
	}
	nk_setup(ctx, font)
	Xnk_buffer_init_fixed((ctx + 5748 /* &.memory */), memory, size)
	(*Nk_context)(unsafe.Pointer(ctx)).Use_pool = Nk_false
	return 1
}

var __func__186 = *(*[14]int8)(unsafe.Pointer(ts + 21564 /* "nk_init_fixed" */)) /* nuklear.h:18681:1 */

func Xnk_init_custom(ctx uintptr, cmds uintptr, pool uintptr, font uintptr) Nk_bool { /* nuklear.h:18690:1: */
	if cmds != 0 {
	} else {
		X__assert_fail(ts+1507 /* "cmds" */, ts+2 /* "nuklear/nuklear...." */, uint32(18693), uintptr(unsafe.Pointer(&__func__187)))
	}
	if pool != 0 {
	} else {
		X__assert_fail(ts+21578 /* "pool" */, ts+2 /* "nuklear/nuklear...." */, uint32(18694), uintptr(unsafe.Pointer(&__func__187)))
	}
	if !(cmds != 0) || !(pool != 0) {
		return 0
	}

	nk_setup(ctx, font)
	(*Nk_context)(unsafe.Pointer(ctx)).Memory = *(*Nk_buffer)(unsafe.Pointer(cmds))
	if int32((*Nk_buffer)(unsafe.Pointer(pool)).Type) == NK_BUFFER_FIXED {
		// take memory from buffer and alloc fixed pool
		nk_pool_init_fixed((ctx + 12888 /* &.pool */), (*Nk_buffer)(unsafe.Pointer(pool)).Memory.Ptr, (*Nk_buffer)(unsafe.Pointer(pool)).Memory.Size)
	} else {
		// create dynamic pool from buffer allocator
		var alloc uintptr = (pool + 16 /* &.pool */)
		nk_pool_init((ctx + 12888 /* &.pool */), alloc, uint32(NK_POOL_DEFAULT_CAPACITY))
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Use_pool = Nk_true
	return 1
}

var __func__187 = *(*[15]int8)(unsafe.Pointer(ts + 21583 /* "nk_init_custom" */)) /* nuklear.h:18692:1 */

func Xnk_init(ctx uintptr, alloc uintptr, font uintptr) Nk_bool { /* nuklear.h:18711:1: */
	if alloc != 0 {
	} else {
		X__assert_fail(ts+4629 /* "alloc" */, ts+2 /* "nuklear/nuklear...." */, uint32(18714), uintptr(unsafe.Pointer(&__func__188)))
	}
	if !(alloc != 0) {
		return 0
	}
	nk_setup(ctx, font)
	Xnk_buffer_init((ctx + 5748 /* &.memory */), alloc, (uint32(4 * 1024)))
	nk_pool_init((ctx + 12888 /* &.pool */), alloc, uint32(NK_POOL_DEFAULT_CAPACITY))
	(*Nk_context)(unsafe.Pointer(ctx)).Use_pool = Nk_true
	return 1
}

var __func__188 = *(*[8]int8)(unsafe.Pointer(ts + 21598 /* "nk_init" */)) /* nuklear.h:18713:1 */

func Xnk_free(ctx uintptr) { /* nuklear.h:18733:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18735), uintptr(unsafe.Pointer(&__func__189)))
	}
	if !(ctx != 0) {
		return
	}
	Xnk_buffer_free((ctx + 5748 /* &.memory */))
	if (*Nk_context)(unsafe.Pointer(ctx)).Use_pool != 0 {
		nk_pool_free((ctx + 12888 /* &.pool */))
	}

	nk_zero((ctx /* &.input */), uint32(unsafe.Sizeof(Nk_input{})))
	nk_zero((ctx + 360 /* &.style */), uint32(unsafe.Sizeof(Nk_style{})))
	nk_zero((ctx + 5748 /* &.memory */), uint32(unsafe.Sizeof(Nk_buffer{})))

	(*Nk_context)(unsafe.Pointer(ctx)).Seq = uint32(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Build = 0
	(*Nk_context)(unsafe.Pointer(ctx)).Begin = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).End = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Active = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Freelist = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Count = uint32(0)
}

var __func__189 = *(*[8]int8)(unsafe.Pointer(ts + 21606 /* "nk_free" */)) /* nuklear.h:18734:1 */

func Xnk_clear(ctx uintptr) { /* nuklear.h:18755:1: */
	var iter uintptr
	var next uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18759), uintptr(unsafe.Pointer(&__func__190)))
	}

	if !(ctx != 0) {
		return
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Use_pool != 0 {
		Xnk_buffer_clear((ctx + 5748 /* &.memory */))
	} else {
		Xnk_buffer_reset((ctx + 5748 /* &.memory */), NK_BUFFER_FRONT)
	}

	(*Nk_context)(unsafe.Pointer(ctx)).Build = 0
	(*Nk_context)(unsafe.Pointer(ctx)).Memory.Calls = Nk_size(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state = Nk_flags(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active = *(*uintptr)(unsafe.Pointer((ctx + 360 /* &.style */ + 4 /* &.cursors */)))
	nk_memset((ctx + 12840 /* &.overlay */), 0, uint32(unsafe.Sizeof(Nk_command_buffer{})))

	// garbage collector
	iter = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	for iter != 0 {
		// make sure valid minimized windows do not get removed
		if ((((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_MINIMIZED) != 0) && !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_CLOSED) != 0)) && ((*Nk_window)(unsafe.Pointer(iter)).Seq == (*Nk_context)(unsafe.Pointer(ctx)).Seq) {
			iter = (*Nk_window)(unsafe.Pointer(iter)).Next
			continue
		}
		// remove hotness from hidden or closed windows
		if ((((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0) || (((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_CLOSED) != 0)) && (iter == (*Nk_context)(unsafe.Pointer(ctx)).Active) {
			(*Nk_context)(unsafe.Pointer(ctx)).Active = (*Nk_window)(unsafe.Pointer(iter)).Prev
			(*Nk_context)(unsafe.Pointer(ctx)).End = (*Nk_window)(unsafe.Pointer(iter)).Prev
			if !(int32((*Nk_context)(unsafe.Pointer(ctx)).End) != 0) {
				(*Nk_context)(unsafe.Pointer(ctx)).Begin = uintptr(0)
			}
			if (*Nk_context)(unsafe.Pointer(ctx)).Active != 0 {
				*(*Nk_flags)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Active + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
			}
		}
		// free unused popup windows
		if ((*Nk_window)(unsafe.Pointer(iter)).Popup.Win != 0) && ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq) {
			nk_free_window(ctx, (*Nk_window)(unsafe.Pointer(iter)).Popup.Win)
			(*Nk_window)(unsafe.Pointer(iter)).Popup.Win = uintptr(0)
		}
		/* remove unused window state tables */
		{
			var n uintptr
			var it uintptr = (*Nk_window)(unsafe.Pointer(iter)).Tables
			for it != 0 {
				n = (*Nk_table)(unsafe.Pointer(it)).Next
				if (*Nk_table)(unsafe.Pointer(it)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq {
					nk_remove_table(iter, it)
					nk_zero(it, uint32(unsafe.Sizeof(Nk_page_data{})))
					nk_free_table(ctx, it)
					if it == (*Nk_window)(unsafe.Pointer(iter)).Tables {
						(*Nk_window)(unsafe.Pointer(iter)).Tables = n
					}
				}
				it = n
			}
		}
		// window itself is not used anymore so free
		if ((*Nk_window)(unsafe.Pointer(iter)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq) || (((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_CLOSED) != 0) {
			next = (*Nk_window)(unsafe.Pointer(iter)).Next
			nk_remove_window(ctx, iter)
			nk_free_window(ctx, iter)
			iter = next
		} else {
			iter = (*Nk_window)(unsafe.Pointer(iter)).Next
		}
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Seq++
}

var __func__190 = *(*[9]int8)(unsafe.Pointer(ts + 21614 /* "nk_clear" */)) /* nuklear.h:18756:1 */

func nk_start_buffer(ctx uintptr, buffer uintptr) { /* nuklear.h:18821:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18823), uintptr(unsafe.Pointer(&__func__191)))
	}
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(18824), uintptr(unsafe.Pointer(&__func__191)))
	}
	if !(ctx != 0) || !(buffer != 0) {
		return
	}
	(*Nk_command_buffer)(unsafe.Pointer(buffer)).Begin = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated
	(*Nk_command_buffer)(unsafe.Pointer(buffer)).End = (*Nk_command_buffer)(unsafe.Pointer(buffer)).Begin
	(*Nk_command_buffer)(unsafe.Pointer(buffer)).Last = (*Nk_command_buffer)(unsafe.Pointer(buffer)).Begin
	(*Nk_command_buffer)(unsafe.Pointer(buffer)).Clip = nk_null_rect
}

var __func__191 = *(*[16]int8)(unsafe.Pointer(ts + 21623 /* "nk_start_buffer" */)) /* nuklear.h:18822:1 */

func nk_start(ctx uintptr, win uintptr) { /* nuklear.h:18832:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18834), uintptr(unsafe.Pointer(&__func__192)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(18835), uintptr(unsafe.Pointer(&__func__192)))
	}
	nk_start_buffer(ctx, (win + 100 /* &.buffer */))
}

var __func__192 = *(*[9]int8)(unsafe.Pointer(ts + 21643 /* "nk_start" */)) /* nuklear.h:18833:1 */

func nk_start_popup(ctx uintptr, win uintptr) { /* nuklear.h:18839:1: */
	var buf uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18842), uintptr(unsafe.Pointer(&__func__193)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(18843), uintptr(unsafe.Pointer(&__func__193)))
	}
	if !(ctx != 0) || !(win != 0) {
		return
	}

	// save buffer fill state for popup
	buf = (win + 252 /* &.popup */ + 8 /* &.buf */)
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Begin = (*Nk_window)(unsafe.Pointer(win)).Buffer.End
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).End = (*Nk_window)(unsafe.Pointer(win)).Buffer.End
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Parent = (*Nk_window)(unsafe.Pointer(win)).Buffer.Last
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Last = (*Nk_popup_buffer)(unsafe.Pointer(buf)).Begin
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Active = Nk_true
}

var __func__193 = *(*[15]int8)(unsafe.Pointer(ts + 21652 /* "nk_start_popup" */)) /* nuklear.h:18840:1 */

func nk_finish_popup(ctx uintptr, win uintptr) { /* nuklear.h:18855:1: */
	var buf uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18858), uintptr(unsafe.Pointer(&__func__194)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(18859), uintptr(unsafe.Pointer(&__func__194)))
	}
	if !(ctx != 0) || !(win != 0) {
		return
	}

	buf = (win + 252 /* &.popup */ + 8 /* &.buf */)
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Last = (*Nk_window)(unsafe.Pointer(win)).Buffer.Last
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).End = (*Nk_window)(unsafe.Pointer(win)).Buffer.End
}

var __func__194 = *(*[16]int8)(unsafe.Pointer(ts + 21667 /* "nk_finish_popup" */)) /* nuklear.h:18856:1 */

func nk_finish_buffer(ctx uintptr, buffer uintptr) { /* nuklear.h:18867:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18869), uintptr(unsafe.Pointer(&__func__195)))
	}
	if buffer != 0 {
	} else {
		X__assert_fail(ts+240 /* "buffer" */, ts+2 /* "nuklear/nuklear...." */, uint32(18870), uintptr(unsafe.Pointer(&__func__195)))
	}
	if !(ctx != 0) || !(buffer != 0) {
		return
	}
	(*Nk_command_buffer)(unsafe.Pointer(buffer)).End = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated
}

var __func__195 = *(*[17]int8)(unsafe.Pointer(ts + 21683 /* "nk_finish_buffer" */)) /* nuklear.h:18868:1 */

func nk_finish(ctx uintptr, win uintptr) { /* nuklear.h:18875:1: */
	var buf uintptr
	var parent_last uintptr
	var memory uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18881), uintptr(unsafe.Pointer(&__func__196)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(18882), uintptr(unsafe.Pointer(&__func__196)))
	}
	if !(ctx != 0) || !(win != 0) {
		return
	}
	nk_finish_buffer(ctx, (win + 100 /* &.buffer */))
	if !((*Nk_window)(unsafe.Pointer(win)).Popup.Buf.Active != 0) {
		return
	}

	buf = (win + 252 /* &.popup */ + 8 /* &.buf */)
	memory = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Memory.Ptr
	parent_last = ((memory) + uintptr(((*Nk_popup_buffer)(unsafe.Pointer(buf)).Parent)))
	(*Nk_command)(unsafe.Pointer(parent_last)).Next = (*Nk_popup_buffer)(unsafe.Pointer(buf)).End
}

var __func__196 = *(*[10]int8)(unsafe.Pointer(ts + 21700 /* "nk_finish" */)) /* nuklear.h:18876:1 */

func nk_build(ctx uintptr) { /* nuklear.h:18893:1: */
	var it uintptr
	var cmd uintptr
	var buffer uintptr
	var mouse_bounds Nk_rect
	var cursor uintptr
	var next uintptr
	var next1 uintptr
	var buf uintptr
	it = uintptr(0)
	cmd = uintptr(0)
	buffer = uintptr(0)

	// draw cursor overlay
	if !(!(int32((*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active) != 0)) {
		goto __1
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active = *(*uintptr)(unsafe.Pointer((ctx + 360 /* &.style */ + 4 /* &.cursors */)))
__1:
	;
	if !((((*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active != 0) && !(int32((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Grabbed) != 0)) && ((*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_visible != 0)) {
		goto __2
	}
	cursor = (*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active
	nk_command_buffer_init((ctx + 12840 /* &.overlay */), (ctx + 5748 /* &.memory */), NK_CLIPPING_OFF)
	nk_start_buffer(ctx, (ctx + 12840 /* &.overlay */))

	mouse_bounds.X = ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.X - (*Nk_cursor)(unsafe.Pointer(cursor)).Offset.X)
	mouse_bounds.Y = ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.Y - (*Nk_cursor)(unsafe.Pointer(cursor)).Offset.Y)
	mouse_bounds.W = (*Nk_cursor)(unsafe.Pointer(cursor)).Size.X
	mouse_bounds.H = (*Nk_cursor)(unsafe.Pointer(cursor)).Size.Y

	Xnk_draw_image((ctx + 12840 /* &.overlay */), mouse_bounds, (cursor /* &.img */), nk_white)
	nk_finish_buffer(ctx, (ctx + 12840 /* &.overlay */))
__2:
	;
	// build one big draw command list out of all window buffers
	it = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	buffer = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Memory.Ptr
__3:
	if !(it != uintptr(0)) {
		goto __4
	}
	next = (*Nk_window)(unsafe.Pointer(it)).Next
	if !((((*Nk_window)(unsafe.Pointer(it)).Buffer.Last == (*Nk_window)(unsafe.Pointer(it)).Buffer.Begin) || (((*Nk_window)(unsafe.Pointer(it)).Flags & NK_WINDOW_HIDDEN) != 0)) || ((*Nk_window)(unsafe.Pointer(it)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq)) {
		goto __5
	}
	goto cont
__5:
	;

	cmd = ((buffer) + uintptr(((*Nk_window)(unsafe.Pointer(it)).Buffer.Last)))
__6:
	if !((next != 0) && ((((*Nk_window)(unsafe.Pointer(next)).Buffer.Last == (*Nk_window)(unsafe.Pointer(next)).Buffer.Begin) || (((*Nk_window)(unsafe.Pointer(next)).Flags & NK_WINDOW_HIDDEN) != 0)) || ((*Nk_window)(unsafe.Pointer(next)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq))) {
		goto __7
	}
	next = (*Nk_window)(unsafe.Pointer(next)).Next
	goto __6
__7:
	; // skip empty command buffers

	if !(next != 0) {
		goto __8
	}
	(*Nk_command)(unsafe.Pointer(cmd)).Next = (*Nk_window)(unsafe.Pointer(next)).Buffer.Begin
__8:
	;
cont:
	it = next
	goto __3
__4:
	;
	// append all popup draw commands into lists
	it = (*Nk_context)(unsafe.Pointer(ctx)).Begin
__9:
	if !(it != uintptr(0)) {
		goto __10
	}
	next1 = (*Nk_window)(unsafe.Pointer(it)).Next
	if !(!((*Nk_window)(unsafe.Pointer(it)).Popup.Buf.Active != 0)) {
		goto __11
	}
	goto skip
__11:
	;

	buf = (it + 252 /* &.popup */ + 8 /* &.buf */)
	(*Nk_command)(unsafe.Pointer(cmd)).Next = (*Nk_popup_buffer)(unsafe.Pointer(buf)).Begin
	cmd = ((buffer) + uintptr(((*Nk_popup_buffer)(unsafe.Pointer(buf)).Last)))
	(*Nk_popup_buffer)(unsafe.Pointer(buf)).Active = Nk_false
skip:
	it = next1
	goto __9
__10:
	;
	if !(cmd != 0) {
		goto __12
	}
	// append overlay commands
	if !((*Nk_context)(unsafe.Pointer(ctx)).Overlay.End != (*Nk_context)(unsafe.Pointer(ctx)).Overlay.Begin) {
		goto __13
	}
	(*Nk_command)(unsafe.Pointer(cmd)).Next = (*Nk_context)(unsafe.Pointer(ctx)).Overlay.Begin
	goto __14
__13:
	(*Nk_command)(unsafe.Pointer(cmd)).Next = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated
__14:
	;
__12:
	;
}

func Xnk__begin(ctx uintptr) uintptr { /* nuklear.h:18954:31: */
	var iter uintptr
	var buffer uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18959), uintptr(unsafe.Pointer(&__func__197)))
	}
	if !(ctx != 0) {
		return uintptr(0)
	}
	if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Count) != 0) {
		return uintptr(0)
	}

	buffer = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Memory.Ptr
	if !((*Nk_context)(unsafe.Pointer(ctx)).Build != 0) {
		nk_build(ctx)
		(*Nk_context)(unsafe.Pointer(ctx)).Build = Nk_true
	}
	iter = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	for (iter != 0) && ((((*Nk_window)(unsafe.Pointer(iter)).Buffer.Begin == (*Nk_window)(unsafe.Pointer(iter)).Buffer.End) || (((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0)) || ((*Nk_window)(unsafe.Pointer(iter)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq)) {
		iter = (*Nk_window)(unsafe.Pointer(iter)).Next
	}
	if !(iter != 0) {
		return uintptr(0)
	}
	return ((buffer) + uintptr(((*Nk_window)(unsafe.Pointer(iter)).Buffer.Begin)))
}

var __func__197 = *(*[10]int8)(unsafe.Pointer(ts + 21710 /* "nk__begin" */)) /* nuklear.h:18956:1 */

func Xnk__next(ctx uintptr, cmd uintptr) uintptr { /* nuklear.h:18976:31: */
	var buffer uintptr
	var next uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(18981), uintptr(unsafe.Pointer(&__func__198)))
	}
	if (!(ctx != 0) || !(cmd != 0)) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Count) != 0) {
		return uintptr(0)
	}
	if (*Nk_command)(unsafe.Pointer(cmd)).Next >= (*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated {
		return uintptr(0)
	}
	buffer = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Memory.Ptr
	next = ((buffer) + uintptr(((*Nk_command)(unsafe.Pointer(cmd)).Next)))
	return next
}

var __func__198 = *(*[9]int8)(unsafe.Pointer(ts + 21720 /* "nk__next" */)) /* nuklear.h:18978:1 */

// ===============================================================
//
//                              POOL
//
// ===============================================================
func nk_pool_init(pool uintptr, alloc uintptr, capacity uint32) { /* nuklear.h:19000:1: */
	if capacity >= uint32(1) {
	} else {
		X__assert_fail(ts+21729 /* "capacity >= 1" */, ts+2 /* "nuklear/nuklear...." */, uint32(19003), uintptr(unsafe.Pointer(&__func__199)))
	}
	nk_zero(pool, uint32(unsafe.Sizeof(Nk_pool{})))
	(*Nk_pool)(unsafe.Pointer(pool)).Alloc = *(*Nk_allocator)(unsafe.Pointer(alloc))
	(*Nk_pool)(unsafe.Pointer(pool)).Capacity = capacity
	(*Nk_pool)(unsafe.Pointer(pool)).Type = NK_BUFFER_DYNAMIC
	(*Nk_pool)(unsafe.Pointer(pool)).Pages = uintptr(0)
}

var __func__199 = *(*[13]int8)(unsafe.Pointer(ts + 21743 /* "nk_pool_init" */)) /* nuklear.h:19002:1 */

func nk_pool_free(pool uintptr) { /* nuklear.h:19011:1: */
	var iter uintptr
	if !(pool != 0) {
		return
	}
	iter = (*Nk_pool)(unsafe.Pointer(pool)).Pages
	if int32((*Nk_pool)(unsafe.Pointer(pool)).Type) == NK_BUFFER_FIXED {
		return
	}
	for iter != 0 {
		var next uintptr = (*Nk_page)(unsafe.Pointer(iter)).Next
		(*(*func(Nk_handle, uintptr))(unsafe.Pointer((pool /* &.alloc */ + 8 /* &.free */))))((*Nk_pool)(unsafe.Pointer(pool)).Alloc.Userdata, iter)
		iter = next
	}
}

func nk_pool_init_fixed(pool uintptr, memory uintptr, size Nk_size) { /* nuklear.h:19024:1: */
	nk_zero(pool, uint32(unsafe.Sizeof(Nk_pool{})))
	if (size >= Nk_size(unsafe.Sizeof(Nk_page{}))) {
	} else {
		X__assert_fail(ts+21756 /* "size >= sizeof(s..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19027), uintptr(unsafe.Pointer(&__func__200)))
	}
	if (size < Nk_size(unsafe.Sizeof(Nk_page{}))) {
		return
	}
	// first nk_page_element is embedded in nk_page, additional elements follow in adjacent space
	(*Nk_pool)(unsafe.Pointer(pool)).Capacity = (uint32(uint32(1) + (uint32((uint32(size - Nk_size(unsafe.Sizeof(Nk_page{}))))) / uint32(unsafe.Sizeof(Nk_page_element{})))))
	(*Nk_pool)(unsafe.Pointer(pool)).Pages = memory
	(*Nk_pool)(unsafe.Pointer(pool)).Type = NK_BUFFER_FIXED
	(*Nk_pool)(unsafe.Pointer(pool)).Size = size
}

var __func__200 = *(*[19]int8)(unsafe.Pointer(ts + 21787 /* "nk_pool_init_fix..." */)) /* nuklear.h:19025:1 */

func nk_pool_alloc(pool uintptr) uintptr { /* nuklear.h:19035:30: */
	if !(int32((*Nk_pool)(unsafe.Pointer(pool)).Pages) != 0) || ((*Nk_page)(unsafe.Pointer((*Nk_pool)(unsafe.Pointer(pool)).Pages)).Size >= (*Nk_pool)(unsafe.Pointer(pool)).Capacity) {
		// allocate new page
		var page uintptr
		if int32((*Nk_pool)(unsafe.Pointer(pool)).Type) == NK_BUFFER_FIXED {
			if (*Nk_pool)(unsafe.Pointer(pool)).Pages != 0 {
			} else {
				X__assert_fail(ts+21806 /* "pool->pages" */, ts+2 /* "nuklear/nuklear...." */, uint32(19042), uintptr(unsafe.Pointer(&__func__201)))
			}
			if !(int32((*Nk_pool)(unsafe.Pointer(pool)).Pages) != 0) {
				return uintptr(0)
			}
			if (*Nk_page)(unsafe.Pointer((*Nk_pool)(unsafe.Pointer(pool)).Pages)).Size < (*Nk_pool)(unsafe.Pointer(pool)).Capacity {
			} else {
				X__assert_fail(ts+21818 /* "pool->pages->siz..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19044), uintptr(unsafe.Pointer(&__func__201)))
			}
			return uintptr(0)
		} else {
			var size Nk_size = Nk_size(unsafe.Sizeof(Nk_page{}))
			size = size + ((uint32((*Nk_pool)(unsafe.Pointer(pool)).Capacity - uint32(1))) * uint32(unsafe.Sizeof(Nk_page_element{})))
			page = (*(*func(Nk_handle, uintptr, Nk_size) uintptr)(unsafe.Pointer((pool /* &.alloc */ + 4 /* &.alloc */))))((*Nk_pool)(unsafe.Pointer(pool)).Alloc.Userdata, uintptr(0), size)
			(*Nk_page)(unsafe.Pointer(page)).Next = (*Nk_pool)(unsafe.Pointer(pool)).Pages
			(*Nk_pool)(unsafe.Pointer(pool)).Pages = page
			(*Nk_page)(unsafe.Pointer(page)).Size = uint32(0)
		}
	}
	return (((*Nk_pool)(unsafe.Pointer(pool)).Pages + 8 /* &.win */) + uintptr(PostIncUint32(&(*Nk_page)(unsafe.Pointer((*Nk_pool)(unsafe.Pointer(pool)).Pages)).Size, 1))*432)
}

var __func__201 = *(*[14]int8)(unsafe.Pointer(ts + 21853 /* "nk_pool_alloc" */)) /* nuklear.h:19037:1 */

// ===============================================================
//
//                          PAGE ELEMENT
//
// ===============================================================
func nk_create_page_element(ctx uintptr) uintptr { /* nuklear.h:19066:30: */
	var elem uintptr
	if (*Nk_context)(unsafe.Pointer(ctx)).Freelist != 0 {
		// unlink page element from free list
		elem = (*Nk_context)(unsafe.Pointer(ctx)).Freelist
		(*Nk_context)(unsafe.Pointer(ctx)).Freelist = (*Nk_page_element)(unsafe.Pointer(elem)).Next
	} else if (*Nk_context)(unsafe.Pointer(ctx)).Use_pool != 0 {
		// allocate page element from memory pool
		elem = nk_pool_alloc((ctx + 12888 /* &.pool */))
		if elem != 0 {
		} else {
			X__assert_fail(ts+21867 /* "elem" */, ts+2 /* "nuklear/nuklear...." */, uint32(19077), uintptr(unsafe.Pointer(&__func__202)))
		}
		if !(elem != 0) {
			return uintptr(0)
		}
	} else {
		elem = nk_buffer_alloc((ctx + 5748 /* &.memory */), NK_BUFFER_BACK, size, align1)
		if elem != 0 {
		} else {
			X__assert_fail(ts+21867 /* "elem" */, ts+2 /* "nuklear/nuklear...." */, uint32(19084), uintptr(unsafe.Pointer(&__func__202)))
		}
		if !(elem != 0) {
			return uintptr(0)
		}
	}
	nk_zero(elem, uint32(unsafe.Sizeof(Nk_page_element{})))
	(*Nk_page_element)(unsafe.Pointer(elem)).Next = uintptr(0)
	(*Nk_page_element)(unsafe.Pointer(elem)).Prev = uintptr(0)
	return elem
}

var __func__202 = *(*[23]int8)(unsafe.Pointer(ts + 21872 /* "nk_create_page_e..." */)) /* nuklear.h:19068:1 */
var size Nk_size = Nk_size(unsafe.Sizeof(Nk_page_element{}))                           /* nuklear.h:19081:34 */
var align1 Nk_size = (Nk_size(((uintptr(0) + 4 /* &._h */) - uintptr(0)) / 1))         /* nuklear.h:19082:34 */

func nk_link_page_element_into_freelist(ctx uintptr, elem uintptr) { /* nuklear.h:19093:1: */
	// link table into freelist
	if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Freelist) != 0) {
		(*Nk_context)(unsafe.Pointer(ctx)).Freelist = elem
	} else {
		(*Nk_page_element)(unsafe.Pointer(elem)).Next = (*Nk_context)(unsafe.Pointer(ctx)).Freelist
		(*Nk_context)(unsafe.Pointer(ctx)).Freelist = elem
	}
}

func nk_free_page_element(ctx uintptr, elem uintptr) { /* nuklear.h:19105:1: */
	// we have a pool so just add to free list
	if (*Nk_context)(unsafe.Pointer(ctx)).Use_pool != 0 {
		nk_link_page_element_into_freelist(ctx, elem)
		return
	}
	/* if possible remove last element from back of fixed memory buffer */
	{
		var elem_end uintptr = (elem + uintptr(1)*432)
		var buffer_end uintptr = ((*Nk_context)(unsafe.Pointer(ctx)).Memory.Memory.Ptr + uintptr((*Nk_context)(unsafe.Pointer(ctx)).Memory.Size))
		if elem_end == buffer_end {
			*(*Nk_size)(unsafe.Pointer(ctx + 5748 /* &.memory */ + 56 /* &.size */)) -= (Nk_size(unsafe.Sizeof(Nk_page_element{})))
		} else {
			nk_link_page_element_into_freelist(ctx, elem)
		}
	}
}

// ===============================================================
//
//                              TABLE
//
// ===============================================================
func nk_create_table(ctx uintptr) uintptr { /* nuklear.h:19129:23: */
	var elem uintptr
	elem = nk_create_page_element(ctx)
	if !(elem != 0) {
		return uintptr(0)
	}
	nk_zero(elem, uint32(unsafe.Sizeof(Nk_page_element{})))
	return (elem /* &.data */ /* &.tbl */)
}

func nk_free_table(ctx uintptr, tbl uintptr) { /* nuklear.h:19139:1: */
	var pd uintptr = ((func() uintptr {
		if 1 != 0 {
			return tbl
		}
		return (uintptr(0) /* &.tbl */)
	}()) - uintptr((Nk_ptr((uintptr(0) /* &.tbl */)))))
	var pe uintptr = ((func() uintptr {
		if 1 != 0 {
			return pd
		}
		return (uintptr(0) /* &.data */)
	}()) - uintptr((Nk_ptr((uintptr(0) /* &.data */)))))
	nk_free_page_element(ctx, pe)
}

func nk_push_table(win uintptr, tbl uintptr) { /* nuklear.h:19146:1: */
	if !(int32((*Nk_window)(unsafe.Pointer(win)).Tables) != 0) {
		(*Nk_window)(unsafe.Pointer(win)).Tables = tbl
		(*Nk_table)(unsafe.Pointer(tbl)).Next = uintptr(0)
		(*Nk_table)(unsafe.Pointer(tbl)).Prev = uintptr(0)
		(*Nk_table)(unsafe.Pointer(tbl)).Size = uint32(0)
		(*Nk_window)(unsafe.Pointer(win)).Table_count = uint32(1)
		return
	}
	(*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Prev = tbl
	(*Nk_table)(unsafe.Pointer(tbl)).Next = (*Nk_window)(unsafe.Pointer(win)).Tables
	(*Nk_table)(unsafe.Pointer(tbl)).Prev = uintptr(0)
	(*Nk_table)(unsafe.Pointer(tbl)).Size = uint32(0)
	(*Nk_window)(unsafe.Pointer(win)).Tables = tbl
	(*Nk_window)(unsafe.Pointer(win)).Table_count++
}

func nk_remove_table(win uintptr, tbl uintptr) { /* nuklear.h:19164:1: */
	if (*Nk_window)(unsafe.Pointer(win)).Tables == tbl {
		(*Nk_window)(unsafe.Pointer(win)).Tables = (*Nk_table)(unsafe.Pointer(tbl)).Next
	}
	if (*Nk_table)(unsafe.Pointer(tbl)).Next != 0 {
		(*Nk_table)(unsafe.Pointer((*Nk_table)(unsafe.Pointer(tbl)).Next)).Prev = (*Nk_table)(unsafe.Pointer(tbl)).Prev
	}
	if (*Nk_table)(unsafe.Pointer(tbl)).Prev != 0 {
		(*Nk_table)(unsafe.Pointer((*Nk_table)(unsafe.Pointer(tbl)).Prev)).Next = (*Nk_table)(unsafe.Pointer(tbl)).Next
	}
	(*Nk_table)(unsafe.Pointer(tbl)).Next = uintptr(0)
	(*Nk_table)(unsafe.Pointer(tbl)).Prev = uintptr(0)
}

func nk_add_value(ctx uintptr, win uintptr, name Nk_hash, value Nk_uint) uintptr { /* nuklear.h:19175:15: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(19179), uintptr(unsafe.Pointer(&__func__203)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(19180), uintptr(unsafe.Pointer(&__func__203)))
	}
	if !(win != 0) || !(ctx != 0) {
		return uintptr(0)
	}
	if !(int32((*Nk_window)(unsafe.Pointer(win)).Tables) != 0) || (uint32((*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Size) >= (((func() uint32 {
		if (uint32(unsafe.Sizeof(Nk_window{}))) < (uint32(unsafe.Sizeof(Nk_panel{}))) {
			return uint32(unsafe.Sizeof(Nk_panel{}))
		}
		return uint32(unsafe.Sizeof(Nk_window{}))
	}()) / uint32(unsafe.Sizeof(Nk_uint(0)))) / uint32(2))) {
		var tbl uintptr = nk_create_table(ctx)
		if tbl != 0 {
		} else {
			X__assert_fail(ts+21895 /* "tbl" */, ts+2 /* "nuklear/nuklear...." */, uint32(19184), uintptr(unsafe.Pointer(&__func__203)))
		}
		if !(tbl != 0) {
			return uintptr(0)
		}
		nk_push_table(win, tbl)
	}
	(*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Seq = (*Nk_window)(unsafe.Pointer(win)).Seq
	*(*Nk_hash)(unsafe.Pointer(((*Nk_window)(unsafe.Pointer(win)).Tables + 8 /* &.keys */) + uintptr((*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Size)*4)) = name
	*(*Nk_uint)(unsafe.Pointer(((*Nk_window)(unsafe.Pointer(win)).Tables + 212 /* &.values */) + uintptr((*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Size)*4)) = value
	return (((*Nk_window)(unsafe.Pointer(win)).Tables + 212 /* &.values */) + uintptr(PostIncUint32(&(*Nk_table)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Tables)).Size, 1))*4)
}

var __func__203 = *(*[13]int8)(unsafe.Pointer(ts + 21899 /* "nk_add_value" */)) /* nuklear.h:19178:1 */

func nk_find_value(win uintptr, name Nk_hash) uintptr { /* nuklear.h:19193:15: */
	var iter uintptr = (*Nk_window)(unsafe.Pointer(win)).Tables
	for iter != 0 {
		var i uint32 = uint32(0)
		var size uint32 = (*Nk_table)(unsafe.Pointer(iter)).Size
		for i = uint32(0); i < size; i++ {
			if *(*Nk_hash)(unsafe.Pointer((iter + 8 /* &.keys */) + uintptr(i)*4)) == name {
				(*Nk_table)(unsafe.Pointer(iter)).Seq = (*Nk_window)(unsafe.Pointer(win)).Seq
				return ((iter + 212 /* &.values */) + uintptr(i)*4)
			}
		}
		size = (((func() uint32 {
			if (uint32(unsafe.Sizeof(Nk_window{}))) < (uint32(unsafe.Sizeof(Nk_panel{}))) {
				return uint32(unsafe.Sizeof(Nk_panel{}))
			}
			return uint32(unsafe.Sizeof(Nk_window{}))
		}()) / uint32(unsafe.Sizeof(Nk_uint(0)))) / uint32(2))
		iter = (*Nk_table)(unsafe.Pointer(iter)).Next
	}
	return uintptr(0)
}

// ===============================================================
//
//                              PANEL
//
// ===============================================================
func nk_create_panel(ctx uintptr) uintptr { /* nuklear.h:19220:12: */
	var elem uintptr
	elem = nk_create_page_element(ctx)
	if !(elem != 0) {
		return uintptr(0)
	}
	nk_zero(elem, uint32(unsafe.Sizeof(Nk_page_element{})))
	return (elem /* &.data */ /* &.pan */)
}

func nk_free_panel(ctx uintptr, pan uintptr) { /* nuklear.h:19230:1: */
	var pd uintptr = ((func() uintptr {
		if 1 != 0 {
			return pan
		}
		return (uintptr(0) /* &.pan */)
	}()) - uintptr((Nk_ptr((uintptr(0) /* &.pan */)))))
	var pe uintptr = ((func() uintptr {
		if 1 != 0 {
			return pd
		}
		return (uintptr(0) /* &.data */)
	}()) - uintptr((Nk_ptr((uintptr(0) /* &.data */)))))
	nk_free_page_element(ctx, pe)
}

func nk_panel_has_header(flags Nk_flags, title uintptr) Nk_bool { /* nuklear.h:19237:1: */
	var active Nk_bool = 0
	active = (Nk_bool(flags & (Nk_flags(NK_WINDOW_CLOSABLE | NK_WINDOW_MINIMIZABLE))))
	active = (Bool32((active != 0) || ((flags & NK_WINDOW_TITLE) != 0)))
	active = (Bool32(((active != 0) && !((flags & NK_WINDOW_HIDDEN) != 0)) && (title != 0)))
	return active
}

func nk_panel_get_padding(style uintptr, type1 uint32) Nk_vec2 { /* nuklear.h:19246:1: */
	switch type1 {
	default:
		fallthrough
	case NK_PANEL_WINDOW:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Padding
	case NK_PANEL_GROUP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Group_padding
	case NK_PANEL_POPUP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Popup_padding
	case NK_PANEL_CONTEXTUAL:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Contextual_padding
	case NK_PANEL_COMBO:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Combo_padding
	case NK_PANEL_MENU:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_padding
	case NK_PANEL_TOOLTIP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_padding
	}
	return Nk_vec2{}
}

func nk_panel_get_border(style uintptr, flags Nk_flags, type1 uint32) float32 { /* nuklear.h:19259:1: */
	if (flags & NK_WINDOW_BORDER) != 0 {
		switch type1 {
		default:
			fallthrough
		case NK_PANEL_WINDOW:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Border
			fallthrough
		case NK_PANEL_GROUP:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Group_border
			fallthrough
		case NK_PANEL_POPUP:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Popup_border
			fallthrough
		case NK_PANEL_CONTEXTUAL:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Contextual_border
			fallthrough
		case NK_PANEL_COMBO:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Combo_border
			fallthrough
		case NK_PANEL_MENU:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_border
			fallthrough
		case NK_PANEL_TOOLTIP:
			return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_border
		}
	} else {
		return float32(0)
	}
	return float32(0)
}

func nk_panel_get_border_color(style uintptr, type1 uint32) Nk_color { /* nuklear.h:19275:1: */
	switch type1 {
	default:
		fallthrough
	case NK_PANEL_WINDOW:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Border_color
	case NK_PANEL_GROUP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Group_border_color
	case NK_PANEL_POPUP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Popup_border_color
	case NK_PANEL_CONTEXTUAL:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Contextual_border_color
	case NK_PANEL_COMBO:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Combo_border_color
	case NK_PANEL_MENU:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_border_color
	case NK_PANEL_TOOLTIP:
		return (*Nk_style)(unsafe.Pointer(style)).Window.Menu_border_color
	}
	return Nk_color{}
}

func nk_panel_is_sub(type1 uint32) Nk_bool { /* nuklear.h:19288:1: */
	if (int32(type1) & NK_PANEL_SET_SUB) != 0 {
		return 1
	}
	return 0
}

func nk_panel_is_nonblock(type1 uint32) Nk_bool { /* nuklear.h:19293:1: */
	if (int32(type1) & NK_PANEL_SET_NONBLOCK) != 0 {
		return 1
	}
	return 0
}

func nk_panel_begin(ctx uintptr, title uintptr, panel_type uint32) Nk_bool { /* nuklear.h:19298:1: */
	bp := tlsAlloc(104)
	defer tlsFree(104)

	var in uintptr
	var win uintptr
	var layout uintptr
	var out uintptr
	var style uintptr
	var font uintptr
	var scrollbar_size Nk_vec2
	var panel_padding Nk_vec2

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(19310), uintptr(unsafe.Pointer(&__func__204)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(19311), uintptr(unsafe.Pointer(&__func__204)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19312), uintptr(unsafe.Pointer(&__func__204)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}
	nk_zero((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout, uint32(unsafe.Sizeof(Nk_panel{})))
	if (((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Flags & NK_WINDOW_HIDDEN) != 0) || (((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Flags & NK_WINDOW_CLOSED) != 0) {
		nk_zero((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout, uint32(unsafe.Sizeof(Nk_panel{})))
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Type = panel_type
		return 0
	}
	// pull state into local stack
	style = (ctx + 360 /* &.style */)
	font = (*Nk_style)(unsafe.Pointer(style)).Font
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	out = (win + 100 /* &.buffer */)
	if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_NO_INPUT) != 0 {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	// pull style configuration into local stack
	scrollbar_size = (*Nk_style)(unsafe.Pointer(style)).Window.Scrollbar_size
	panel_padding = nk_panel_get_padding(style, panel_type)

	// window movement
	if (((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_MOVABLE) != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0) {
		var left_mouse_down int32
		var left_mouse_clicked int32
		var left_mouse_click_in_cursor int32

		// calculate draggable window space
		// var header Nk_rect at bp, 16

		(*Nk_rect)(unsafe.Pointer(bp /* &header */)).X = (*Nk_window)(unsafe.Pointer(win)).Bounds.X
		(*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y = (*Nk_window)(unsafe.Pointer(win)).Bounds.Y
		(*Nk_rect)(unsafe.Pointer(bp /* &header */)).W = (*Nk_window)(unsafe.Pointer(win)).Bounds.W
		if nk_panel_has_header((*Nk_window)(unsafe.Pointer(win)).Flags, title) != 0 {
			(*Nk_rect)(unsafe.Pointer(bp /* &header */)).H = ((*Nk_user_font)(unsafe.Pointer(font)).Height + (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.Y))
			*(*float32)(unsafe.Pointer(bp /* &header */ + 12 /* &.h */)) += (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.Y)
		} else {
			(*Nk_rect)(unsafe.Pointer(bp /* &header */)).H = panel_padding.Y
		}

		// window movement by dragging
		left_mouse_down = (*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down
		left_mouse_clicked = int32((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked)
		left_mouse_click_in_cursor = Xnk_input_has_mouse_click_down_in_rect(in,
			NK_BUTTON_LEFT, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), Nk_true)
		if ((left_mouse_down != 0) && (left_mouse_click_in_cursor != 0)) && !(left_mouse_clicked != 0) {
			(*Nk_window)(unsafe.Pointer(win)).Bounds.X = ((*Nk_window)(unsafe.Pointer(win)).Bounds.X + (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X)
			(*Nk_window)(unsafe.Pointer(win)).Bounds.Y = ((*Nk_window)(unsafe.Pointer(win)).Bounds.Y + (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y)
			*(*float32)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */) + 8 /* &.clicked_pos */ /* &.x */)) += ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X)
			*(*float32)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */) + 8 /* &.clicked_pos */ + 4 /* &.y */)) += ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y)
			(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active = *(*uintptr)(unsafe.Pointer((ctx + 360 /* &.style */ + 4 /* &.cursors */) + 2*4))
		}
	}

	// setup panel
	(*Nk_panel)(unsafe.Pointer(layout)).Type = panel_type
	(*Nk_panel)(unsafe.Pointer(layout)).Flags = (*Nk_window)(unsafe.Pointer(win)).Flags
	(*Nk_panel)(unsafe.Pointer(layout)).Bounds = (*Nk_window)(unsafe.Pointer(win)).Bounds
	*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ /* &.x */)) += (panel_padding.X)
	*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 8 /* &.w */)) -= (float32(2) * panel_padding.X)
	if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_BORDER) != 0 {
		(*Nk_panel)(unsafe.Pointer(layout)).Border = nk_panel_get_border(style, (*Nk_window)(unsafe.Pointer(win)).Flags, panel_type)
		(*Nk_panel)(unsafe.Pointer(layout)).Bounds = nk_shrink_rect((*Nk_panel)(unsafe.Pointer(layout)).Bounds, (*Nk_panel)(unsafe.Pointer(layout)).Border)
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Border = float32(0)
	}
	(*Nk_panel)(unsafe.Pointer(layout)).At_y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
	(*Nk_panel)(unsafe.Pointer(layout)).At_x = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.X
	(*Nk_panel)(unsafe.Pointer(layout)).Max_x = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Header_height = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Footer_height = float32(0)
	Xnk_layout_reset_min_row_height(ctx)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = 0
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns = 0
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = uintptr(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth = 0
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Height = panel_padding.Y
	(*Nk_panel)(unsafe.Pointer(layout)).Has_scrolling = Nk_true
	if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0) {
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 8 /* &.w */)) -= (scrollbar_size.X)
	}
	if !(nk_panel_is_nonblock(panel_type) != 0) {
		(*Nk_panel)(unsafe.Pointer(layout)).Footer_height = float32(0)
		if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0) || (((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_SCALABLE) != 0) {
			(*Nk_panel)(unsafe.Pointer(layout)).Footer_height = scrollbar_size.Y
		}
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 12 /* &.h */)) -= ((*Nk_panel)(unsafe.Pointer(layout)).Footer_height)
	}

	// panel header
	if nk_panel_has_header((*Nk_window)(unsafe.Pointer(win)).Flags, title) != 0 {
		// var text Nk_text at bp+72, 16

		// var header Nk_rect at bp+16, 16

		var background uintptr = uintptr(0)

		// calculate header bounds
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).X = (*Nk_window)(unsafe.Pointer(win)).Bounds.X
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).Y = (*Nk_window)(unsafe.Pointer(win)).Bounds.Y
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).W = (*Nk_window)(unsafe.Pointer(win)).Bounds.W
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).H = ((*Nk_user_font)(unsafe.Pointer(font)).Height + (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.Y))
		*(*float32)(unsafe.Pointer(bp + 16 /* &header */ + 12 /* &.h */)) += (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.Y)

		// shrink panel by header
		(*Nk_panel)(unsafe.Pointer(layout)).Header_height = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).H
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 4 /* &.y */)) += ((*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).H)
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 12 /* &.h */)) -= ((*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).H)
		*(*float32)(unsafe.Pointer(layout + 36 /* &.at_y */)) += ((*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).H)

		// select correct header background and text color
		if (*Nk_context)(unsafe.Pointer(ctx)).Active == win {
			background = (style + 4832 /* &.window */ /* &.header */ + 40 /* &.active */)
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_active
		} else if Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), *(*Nk_rect)(unsafe.Pointer(bp + 16 /* header */))) != 0 {
			background = (style + 4832 /* &.window */ /* &.header */ + 20 /* &.hover */)
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_hover
		} else {
			background = (style + 4832 /* &.window */ /* &.header */ /* &.normal */)
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_normal
		}

		// draw header background
		*(*float32)(unsafe.Pointer(bp + 16 /* &header */ + 12 /* &.h */)) += (1.0)
		if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
			Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 16 /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
		} else {
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
			Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* header */)), float32(0), *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		}

		/* window close button */
		{
			// var button Nk_rect at bp+36, 16

			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.Y)
			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.Y))
			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).W = (*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).H
			if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_CLOSABLE) != 0 {
				*(*Nk_flags)(unsafe.Pointer(bp + 32 /* ws */)) = Nk_flags(0)
				if int32((*Nk_style)(unsafe.Pointer(style)).Window.Header.Align) == NK_HEADER_RIGHT {
					(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X) - ((*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X))
					*(*float32)(unsafe.Pointer(bp + 16 /* &header */ + 8 /* &.w */)) -= (((*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Spacing.X) + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
				} else {
					(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
					*(*float32)(unsafe.Pointer(bp + 16 /* &header */ /* &.x */)) += (((*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Spacing.X) + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
				}

				if (nk_do_button_symbol(bp+32 /* &ws */, (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 36 /* button */)),
					(*Nk_style)(unsafe.Pointer(style)).Window.Header.Close_symbol, NK_BUTTON_DEFAULT,
					(style+4832 /* &.window */ /* &.header */ +60 /* &.close_button */), in, (*Nk_style)(unsafe.Pointer(style)).Font) != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0) {
					*(*Nk_flags)(unsafe.Pointer(layout + 4 /* &.flags */)) |= (NK_WINDOW_HIDDEN)
					*(*Nk_flags)(unsafe.Pointer(layout + 4 /* &.flags */)) &= (Uint32(Uint32FromInt32(CplInt32(NK_WINDOW_MINIMIZED))))
				}
			}

			// window minimize button
			if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_MINIMIZABLE) != 0 {
				*(*Nk_flags)(unsafe.Pointer(bp + 52 /* ws */)) = Nk_flags(0)
				if int32((*Nk_style)(unsafe.Pointer(style)).Window.Header.Align) == NK_HEADER_RIGHT {
					(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X) - (*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W)
					if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_CLOSABLE) != 0) {
						*(*float32)(unsafe.Pointer(bp + 36 /* &button */ /* &.x */)) -= ((*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
						*(*float32)(unsafe.Pointer(bp + 16 /* &header */ + 8 /* &.w */)) -= ((*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
					}
					*(*float32)(unsafe.Pointer(bp + 16 /* &header */ + 8 /* &.w */)) -= ((*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Spacing.X)
				} else {
					(*Nk_rect)(unsafe.Pointer(bp + 36 /* &button */)).X = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &header */)).X
					*(*float32)(unsafe.Pointer(bp + 16 /* &header */ /* &.x */)) += (((*Nk_rect)(unsafe.Pointer(bp+36 /* &button */)).W + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Spacing.X) + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
				}
				if (nk_do_button_symbol(bp+52 /* &ws */, (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 36 /* button */)), func() uint32 {
					if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0 {
						return (*Nk_style)(unsafe.Pointer(style)).Window.Header.Maximize_symbol
					}
					return (*Nk_style)(unsafe.Pointer(style)).Window.Header.Minimize_symbol
				}(),
					NK_BUTTON_DEFAULT, (style+4832 /* &.window */ /* &.header */ +188 /* &.minimize_button */), in, (*Nk_style)(unsafe.Pointer(style)).Font) != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0) {
					(*Nk_panel)(unsafe.Pointer(layout)).Flags = func() uint32 {
						if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0 {
							return ((*Nk_panel)(unsafe.Pointer(layout)).Flags & Uint32(Uint32FromInt32(CplInt32(NK_WINDOW_MINIMIZED))))
						}
						return ((*Nk_panel)(unsafe.Pointer(layout)).Flags | NK_WINDOW_MINIMIZED)
					}()
				}
			}
		}

		{ // window header title
			var text_len int32 = Xnk_strlen(title)
			*(*Nk_rect)(unsafe.Pointer(bp + 56 /* label */)) = Nk_rect{}
			var t float32 = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, title, text_len)
			(*Nk_text)(unsafe.Pointer(bp + 72 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))

			(*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.X)
			*(*float32)(unsafe.Pointer(bp + 56 /* &label */ /* &.x */)) += ((*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.X)
			(*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.Y)
			(*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).H = ((*Nk_user_font)(unsafe.Pointer(font)).Height + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.Y))
			(*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W = (t + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Spacing.X))
			(*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W = func() float32 {
				if (func() float32 {
					if ((*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W) < (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp+56 /* &label */)).X) {
						return (*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W
					}
					return (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp+56 /* &label */)).X)
				}()) < (float32(0)) {
					return float32(0)
				}
				return func() float32 {
					if ((*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W) < (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp+56 /* &label */)).X) {
						return (*Nk_rect)(unsafe.Pointer(bp + 56 /* &label */)).W
					}
					return (((*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp+56 /* &label */)).X)
				}()
			}()
			nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(bp + 56 /* label */)), title, text_len, bp+72 /* &text */, NK_TEXT_LEFT, font)
		}
	}

	// draw window background
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_DYNAMIC) != 0) {
		var body Nk_rect
		body.X = (*Nk_window)(unsafe.Pointer(win)).Bounds.X
		body.W = (*Nk_window)(unsafe.Pointer(win)).Bounds.W
		body.Y = ((*Nk_window)(unsafe.Pointer(win)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Header_height)
		body.H = ((*Nk_window)(unsafe.Pointer(win)).Bounds.H - (*Nk_panel)(unsafe.Pointer(layout)).Header_height)
		if int32((*Nk_style)(unsafe.Pointer(style)).Window.Fixed_background.Type) == NK_STYLE_ITEM_IMAGE {
			Xnk_draw_image(out, body, (style + 4832 /* &.window */ + 368 /* &.fixed_background */ + 4 /* &.data */ /* &.image */), nk_white)
		} else {
			Xnk_fill_rect(out, body, float32(0), *(*Nk_color)(unsafe.Pointer(style + 4832 /* &.window */ + 368 /* &.fixed_background */ + 4 /* &.data */)))
		}
	}

	/* set clipping rectangle */
	{
		// var clip Nk_rect at bp+88, 16

		(*Nk_panel)(unsafe.Pointer(layout)).Clip = (*Nk_panel)(unsafe.Pointer(layout)).Bounds
		nk_unify(bp+88 /* &clip */, (win + 100 /* &.buffer */ + 4 /* &.clip */), (*Nk_panel)(unsafe.Pointer(layout)).Clip.X, (*Nk_panel)(unsafe.Pointer(layout)).Clip.Y,
			((*Nk_panel)(unsafe.Pointer(layout)).Clip.X + (*Nk_panel)(unsafe.Pointer(layout)).Clip.W), ((*Nk_panel)(unsafe.Pointer(layout)).Clip.Y + (*Nk_panel)(unsafe.Pointer(layout)).Clip.H))
		Xnk_push_scissor(out, *(*Nk_rect)(unsafe.Pointer(bp + 88 /* clip */)))
		(*Nk_panel)(unsafe.Pointer(layout)).Clip = *(*Nk_rect)(unsafe.Pointer(bp + 88 /* clip */))
	}
	return (Bool32(!(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0)))
}

var __func__204 = *(*[15]int8)(unsafe.Pointer(ts + 21946 /* "nk_panel_begin" */)) /* nuklear.h:19299:1 */

func nk_panel_end(ctx uintptr) { /* nuklear.h:19521:1: */
	bp := tlsAlloc(40)
	defer tlsFree(40)

	var in uintptr
	var window uintptr
	var layout uintptr
	var style uintptr
	var out uintptr
	var scrollbar_size Nk_vec2
	var panel_padding Nk_vec2

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(19532), uintptr(unsafe.Pointer(&__func__205)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(19533), uintptr(unsafe.Pointer(&__func__205)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19534), uintptr(unsafe.Pointer(&__func__205)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	window = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(window)).Layout
	style = (ctx + 360 /* &.style */)
	out = (window + 100 /* &.buffer */)
	if (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_NO_INPUT) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if !(nk_panel_is_sub((*Nk_panel)(unsafe.Pointer(layout)).Type) != 0) {
		Xnk_push_scissor(out, nk_null_rect)
	}

	// cache configuration data
	scrollbar_size = (*Nk_style)(unsafe.Pointer(style)).Window.Scrollbar_size
	panel_padding = nk_panel_get_padding(style, (*Nk_panel)(unsafe.Pointer(layout)).Type)

	// update the current cursor Y-position to point over the last added widget
	*(*float32)(unsafe.Pointer(layout + 36 /* &.at_y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height)

	// dynamic panels
	if (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_DYNAMIC) != 0) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
		// update panel height to fit dynamic growth
		// var empty_space Nk_rect at bp, 16

		if (*Nk_panel)(unsafe.Pointer(layout)).At_y < ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H) {
			(*Nk_panel)(unsafe.Pointer(layout)).Bounds.H = ((*Nk_panel)(unsafe.Pointer(layout)).At_y - (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y)
		}

		// fill top empty space
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).X = (*Nk_window)(unsafe.Pointer(window)).Bounds.X
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).Y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).H = panel_padding.Y
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).W = (*Nk_window)(unsafe.Pointer(window)).Bounds.W
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* empty_space */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Window.Background)

		// fill left empty space
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).X = (*Nk_window)(unsafe.Pointer(window)).Bounds.X
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).Y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).W = (panel_padding.X + (*Nk_panel)(unsafe.Pointer(layout)).Border)
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).H = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* empty_space */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Window.Background)

		// fill right empty space
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).X = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W)
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).Y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).W = (panel_padding.X + (*Nk_panel)(unsafe.Pointer(layout)).Border)
		(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).H = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H
		if (*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y)) == Nk_uint(0)) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0) {
			*(*float32)(unsafe.Pointer(bp /* &empty_space */ + 8 /* &.w */)) += (scrollbar_size.X)
		}
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* empty_space */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Window.Background)

		// fill bottom empty space
		if (*Nk_panel)(unsafe.Pointer(layout)).Footer_height > float32(0) {
			(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).X = (*Nk_window)(unsafe.Pointer(window)).Bounds.X
			(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).Y = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H)
			(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).W = (*Nk_window)(unsafe.Pointer(window)).Bounds.W
			(*Nk_rect)(unsafe.Pointer(bp /* &empty_space */)).H = (*Nk_panel)(unsafe.Pointer(layout)).Footer_height
			Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* empty_space */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Window.Background)
		}
	}

	// scrollbars
	if (!(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0)) && ((*Nk_window)(unsafe.Pointer(window)).Scrollbar_hiding_timer < 4.0) {
		var scroll Nk_rect
		var scroll_has_scrolling int32
		var scroll_target float32
		var scroll_offset float32
		var scroll_step float32
		var scroll_inc float32

		// mouse wheel scrolling
		if nk_panel_is_sub((*Nk_panel)(unsafe.Pointer(layout)).Type) != 0 {
			// sub-window mouse wheel scrolling
			var root_window uintptr = window
			var root_panel uintptr = (*Nk_window)(unsafe.Pointer(window)).Layout
			for (*Nk_panel)(unsafe.Pointer(root_panel)).Parent != 0 {
				root_panel = (*Nk_panel)(unsafe.Pointer(root_panel)).Parent
			}
			for (*Nk_window)(unsafe.Pointer(root_window)).Parent != 0 {
				root_window = (*Nk_window)(unsafe.Pointer(root_window)).Parent
			}

			// only allow scrolling if parent window is active
			scroll_has_scrolling = 0
			if (root_window == (*Nk_context)(unsafe.Pointer(ctx)).Active) && ((*Nk_panel)(unsafe.Pointer(layout)).Has_scrolling != 0) {
				// and panel is being hovered and inside clip rect
				if (Xnk_input_is_mouse_hovering_rect(in, (*Nk_panel)(unsafe.Pointer(layout)).Bounds) != 0) && (((((*Nk_panel)(unsafe.Pointer(root_panel)).Clip.X < ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W)) && ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X < ((*Nk_panel)(unsafe.Pointer(root_panel)).Clip.X + (*Nk_panel)(unsafe.Pointer(root_panel)).Clip.W))) && ((*Nk_panel)(unsafe.Pointer(root_panel)).Clip.Y < ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H))) && ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y < ((*Nk_panel)(unsafe.Pointer(root_panel)).Clip.Y + (*Nk_panel)(unsafe.Pointer(root_panel)).Clip.H))) {
					// deactivate all parent scrolling
					root_panel = (*Nk_window)(unsafe.Pointer(window)).Layout
					for (*Nk_panel)(unsafe.Pointer(root_panel)).Parent != 0 {
						(*Nk_panel)(unsafe.Pointer(root_panel)).Has_scrolling = Nk_false
						root_panel = (*Nk_panel)(unsafe.Pointer(root_panel)).Parent
					}
					(*Nk_panel)(unsafe.Pointer(root_panel)).Has_scrolling = Nk_false
					scroll_has_scrolling = Nk_true
				}
			}
		} else if !(nk_panel_is_sub((*Nk_panel)(unsafe.Pointer(layout)).Type) != 0) {
			// window mouse wheel scrolling
			scroll_has_scrolling = (Bool32((window == (*Nk_context)(unsafe.Pointer(ctx)).Active) && ((*Nk_panel)(unsafe.Pointer(layout)).Has_scrolling != 0)))
			if ((in != 0) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta.Y > float32(0)) || ((*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta.X > float32(0)))) && (scroll_has_scrolling != 0) {
				(*Nk_window)(unsafe.Pointer(window)).Scrolled = Nk_true
			} else {
				(*Nk_window)(unsafe.Pointer(window)).Scrolled = Nk_false
			}
		} else {
			scroll_has_scrolling = Nk_false
		}

		{
			// vertical scrollbar
			*(*Nk_flags)(unsafe.Pointer(bp + 16 /* state */)) = Nk_flags(0)
			scroll.X = (((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W) + panel_padding.X)
			scroll.Y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
			scroll.W = scrollbar_size.X
			scroll.H = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H

			scroll_offset = float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y)))
			scroll_step = (scroll.H * 0.10)
			scroll_inc = (scroll.H * 0.01)
			scroll_target = float32((int32((*Nk_panel)(unsafe.Pointer(layout)).At_y - scroll.Y)))
			scroll_offset = nk_do_scrollbarv(bp+16 /* &state */, out, scroll, scroll_has_scrolling,
				scroll_offset, scroll_target, scroll_step, scroll_inc,
				(ctx + 360 /* &.style */ + 3564 /* &.scrollv */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
			*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y)) = Nk_uint(scroll_offset)
			if (in != 0) && (scroll_has_scrolling != 0) {
				(*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta.Y = float32(0)
			}

		}
		{
			// horizontal scrollbar
			*(*Nk_flags)(unsafe.Pointer(bp + 20 /* state */)) = Nk_flags(0)
			scroll.X = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.X
			scroll.Y = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H)
			scroll.W = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W
			scroll.H = scrollbar_size.Y

			scroll_offset = float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x)))
			scroll_target = float32((int32((*Nk_panel)(unsafe.Pointer(layout)).Max_x - scroll.X)))
			scroll_step = ((*Nk_panel)(unsafe.Pointer(layout)).Max_x * 0.05)
			scroll_inc = ((*Nk_panel)(unsafe.Pointer(layout)).Max_x * 0.005)
			scroll_offset = nk_do_scrollbarh(bp+20 /* &state */, out, scroll, scroll_has_scrolling,
				scroll_offset, scroll_target, scroll_step, scroll_inc,
				(ctx + 360 /* &.style */ + 3132 /* &.scrollh */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
			*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x)) = Nk_uint(scroll_offset)

		}
	}

	// hide scroll if no user input
	if ((*Nk_window)(unsafe.Pointer(window)).Flags & NK_WINDOW_SCROLL_AUTO_HIDE) != 0 {
		var has_input int32 = (Bool32((((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Delta.X != float32(0)) || ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Delta.Y != float32(0))) || ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Scroll_delta.Y != float32(0))))
		var is_window_hovered int32 = Xnk_window_is_hovered(ctx)
		var any_item_active int32 = (int32((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_MODIFIED))
		if (!(has_input != 0) && (is_window_hovered != 0)) || (!(is_window_hovered != 0) && !(any_item_active != 0)) {
			*(*float32)(unsafe.Pointer(window + 144 /* &.scrollbar_hiding_timer */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Delta_time_seconds)
		} else {
			(*Nk_window)(unsafe.Pointer(window)).Scrollbar_hiding_timer = float32(0)
		}
	} else {
		(*Nk_window)(unsafe.Pointer(window)).Scrollbar_hiding_timer = float32(0)
	}

	// window border
	if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_BORDER) != 0 {
		var border_color = nk_panel_get_border_color(style, (*Nk_panel)(unsafe.Pointer(layout)).Type)
		var padding_y float32
		if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0 {
			padding_y = (((*Nk_style)(unsafe.Pointer(style)).Window.Border + (*Nk_window)(unsafe.Pointer(window)).Bounds.Y) + (*Nk_panel)(unsafe.Pointer(layout)).Header_height)
		} else {
			padding_y = func() float32 {
				if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_DYNAMIC) != 0 {
					return (((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H) + (*Nk_panel)(unsafe.Pointer(layout)).Footer_height)
				}
				return ((*Nk_window)(unsafe.Pointer(window)).Bounds.Y + (*Nk_window)(unsafe.Pointer(window)).Bounds.H)
			}()
		}
		var b = (*Nk_window)(unsafe.Pointer(window)).Bounds
		b.H = (padding_y - (*Nk_window)(unsafe.Pointer(window)).Bounds.Y)
		Xnk_stroke_rect(out, b, float32(0), (*Nk_panel)(unsafe.Pointer(layout)).Border, border_color)
	}

	// scaler
	if ((((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_SCALABLE) != 0) && (in != 0)) && !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
		// calculate scaler bounds
		// var scaler Nk_rect at bp+24, 16

		(*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).W = scrollbar_size.X
		(*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).H = scrollbar_size.Y
		(*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).Y = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H)
		if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_SCALE_LEFT) != 0 {
			(*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).X = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X - (panel_padding.X * 0.5))
		} else {
			(*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).X = (((*Nk_panel)(unsafe.Pointer(layout)).Bounds.X + (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W) + panel_padding.X)
		}
		if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0 {
			*(*float32)(unsafe.Pointer(bp + 24 /* &scaler */ /* &.x */)) -= ((*Nk_rect)(unsafe.Pointer(bp + 24 /* &scaler */)).W)
		}

		/* draw scaler */
		{
			var item uintptr = (style + 4832 /* &.window */ + 420 /* &.scaler */)
			if int32((*Nk_style_item)(unsafe.Pointer(item)).Type) == NK_STYLE_ITEM_IMAGE {
				Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bp + 24 /* scaler */)), (item + 4 /* &.data */ /* &.image */), nk_white)
			} else {
				if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_SCALE_LEFT) != 0 {
					Xnk_fill_triangle(out, (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X, (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y, (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X,
						((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).H), ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).W),
						((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).H), *(*Nk_color)(unsafe.Pointer(item + 4 /* &.data */)))
				} else {
					Xnk_fill_triangle(out, ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).W), (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y, ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).W),
						((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).H), (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X, ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y + (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).H), *(*Nk_color)(unsafe.Pointer(item + 4 /* &.data */)))
				}
			}
		}

		// do window scaling
		if !(((*Nk_window)(unsafe.Pointer(window)).Flags & NK_WINDOW_ROM) != 0) {
			var window_size = (*Nk_style)(unsafe.Pointer(style)).Window.Min_size
			var left_mouse_down int32 = (*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down
			var left_mouse_click_in_scaler int32 = Xnk_input_has_mouse_click_down_in_rect(in,
				NK_BUTTON_LEFT, *(*Nk_rect)(unsafe.Pointer(bp + 24 /* scaler */)), Nk_true)

			if (left_mouse_down != 0) && (left_mouse_click_in_scaler != 0) {
				var delta_x float32 = (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X
				if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_SCALE_LEFT) != 0 {
					delta_x = -delta_x
					*(*float32)(unsafe.Pointer(window + 76 /* &.bounds */ /* &.x */)) += ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X)
				}
				// dragging in x-direction
				if ((*Nk_window)(unsafe.Pointer(window)).Bounds.W + delta_x) >= window_size.X {
					if (delta_x < float32(0)) || ((delta_x > float32(0)) && ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X >= (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X)) {
						(*Nk_window)(unsafe.Pointer(window)).Bounds.W = ((*Nk_window)(unsafe.Pointer(window)).Bounds.W + delta_x)
						*(*float32)(unsafe.Pointer(bp + 24 /* &scaler */ /* &.x */)) += ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X)
					}
				}
				// dragging in y-direction (only possible if static window)
				if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_DYNAMIC) != 0) {
					if window_size.Y < ((*Nk_window)(unsafe.Pointer(window)).Bounds.H + (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y) {
						if ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y < float32(0)) || (((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y > float32(0)) && ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y >= (*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y)) {
							(*Nk_window)(unsafe.Pointer(window)).Bounds.H = ((*Nk_window)(unsafe.Pointer(window)).Bounds.H + (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y)
							*(*float32)(unsafe.Pointer(bp + 24 /* &scaler */ + 4 /* &.y */)) += ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y)
						}
					}
				}
				(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active = *(*uintptr)(unsafe.Pointer((ctx + 360 /* &.style */ + 4 /* &.cursors */) + 6*4))
				(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.X = ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).X + ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).W / 2.0))
				(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.Y = ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).Y + ((*Nk_rect)(unsafe.Pointer(bp+24 /* &scaler */)).H / 2.0))
			}
		}
	}
	if !(nk_panel_is_sub((*Nk_panel)(unsafe.Pointer(layout)).Type) != 0) {
		// window is hidden so clear command buffer
		if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0 {
			nk_command_buffer_reset((window + 100 /* &.buffer */))
		} else {
			nk_finish(ctx, window)
		}
	}

	// NK_WINDOW_REMOVE_ROM flag was set so remove NK_WINDOW_ROM
	if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_REMOVE_ROM) != 0 {
		*(*Nk_flags)(unsafe.Pointer(layout + 4 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
		*(*Nk_flags)(unsafe.Pointer(layout + 4 /* &.flags */)) &= (CplUint32(NK_WINDOW_REMOVE_ROM))
	}
	(*Nk_window)(unsafe.Pointer(window)).Flags = (*Nk_panel)(unsafe.Pointer(layout)).Flags

	// property garbage collector
	if (((*Nk_window)(unsafe.Pointer(window)).Property.Active != 0) && ((*Nk_window)(unsafe.Pointer(window)).Property.Old != (*Nk_window)(unsafe.Pointer(window)).Property.Seq)) && ((*Nk_window)(unsafe.Pointer(window)).Property.Active == (*Nk_window)(unsafe.Pointer(window)).Property.Prev) {
		nk_zero((window + 148 /* &.property */), uint32(unsafe.Sizeof(Nk_property_state{})))
	} else {
		(*Nk_window)(unsafe.Pointer(window)).Property.Old = (*Nk_window)(unsafe.Pointer(window)).Property.Seq
		(*Nk_window)(unsafe.Pointer(window)).Property.Prev = (*Nk_window)(unsafe.Pointer(window)).Property.Active
		(*Nk_window)(unsafe.Pointer(window)).Property.Seq = uint32(0)
	}
	// edit garbage collector
	if (((*Nk_window)(unsafe.Pointer(window)).Edit.Active != 0) && ((*Nk_window)(unsafe.Pointer(window)).Edit.Old != (*Nk_window)(unsafe.Pointer(window)).Edit.Seq)) && ((*Nk_window)(unsafe.Pointer(window)).Edit.Active == (*Nk_window)(unsafe.Pointer(window)).Edit.Prev) {
		nk_zero((window + 320 /* &.edit */), uint32(unsafe.Sizeof(Nk_edit_state{})))
	} else {
		(*Nk_window)(unsafe.Pointer(window)).Edit.Old = (*Nk_window)(unsafe.Pointer(window)).Edit.Seq
		(*Nk_window)(unsafe.Pointer(window)).Edit.Prev = (*Nk_window)(unsafe.Pointer(window)).Edit.Active
		(*Nk_window)(unsafe.Pointer(window)).Edit.Seq = uint32(0)
	}
	// contextual garbage collector
	if ((*Nk_window)(unsafe.Pointer(window)).Popup.Active_con != 0) && ((*Nk_window)(unsafe.Pointer(window)).Popup.Con_old != (*Nk_window)(unsafe.Pointer(window)).Popup.Con_count) {
		(*Nk_window)(unsafe.Pointer(window)).Popup.Con_count = uint32(0)
		(*Nk_window)(unsafe.Pointer(window)).Popup.Con_old = uint32(0)
		(*Nk_window)(unsafe.Pointer(window)).Popup.Active_con = uint32(0)
	} else {
		(*Nk_window)(unsafe.Pointer(window)).Popup.Con_old = (*Nk_window)(unsafe.Pointer(window)).Popup.Con_count
		(*Nk_window)(unsafe.Pointer(window)).Popup.Con_count = uint32(0)
	}
	(*Nk_window)(unsafe.Pointer(window)).Popup.Combo_count = uint32(0)
	// helper to make sure you have a 'nk_tree_push' for every 'nk_tree_pop'
	if !((*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth != 0) {
	} else {
		X__assert_fail(ts+21961 /* "!layout->row.tre..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19813), uintptr(unsafe.Pointer(&__func__205)))
	}
}

var __func__205 = *(*[13]int8)(unsafe.Pointer(ts + 21985 /* "nk_panel_end" */)) /* nuklear.h:19522:1 */

// ===============================================================
//
//                              WINDOW
//
// ===============================================================
func nk_create_window(ctx uintptr) uintptr { /* nuklear.h:19825:12: */
	var elem uintptr
	elem = nk_create_page_element(ctx)
	if !(elem != 0) {
		return uintptr(0)
	}
	(*Nk_window)(unsafe.Pointer(elem /* &.data */)).Seq = (*Nk_context)(unsafe.Pointer(ctx)).Seq
	return (elem /* &.data */ /* &.win */)
}

func nk_free_window(ctx uintptr, win uintptr) { /* nuklear.h:19835:1: */
	// unlink windows from list
	var it uintptr = (*Nk_window)(unsafe.Pointer(win)).Tables
	if (*Nk_window)(unsafe.Pointer(win)).Popup.Win != 0 {
		nk_free_window(ctx, (*Nk_window)(unsafe.Pointer(win)).Popup.Win)
		(*Nk_window)(unsafe.Pointer(win)).Popup.Win = uintptr(0)
	}
	(*Nk_window)(unsafe.Pointer(win)).Next = uintptr(0)
	(*Nk_window)(unsafe.Pointer(win)).Prev = uintptr(0)

	for it != 0 {
		//free window state tables
		var n uintptr = (*Nk_table)(unsafe.Pointer(it)).Next
		nk_remove_table(win, it)
		nk_free_table(ctx, it)
		if it == (*Nk_window)(unsafe.Pointer(win)).Tables {
			(*Nk_window)(unsafe.Pointer(win)).Tables = n
		}
		it = n
	}

	/* link windows into freelist */
	{
		var pd uintptr = ((func() uintptr {
			if 1 != 0 {
				return win
			}
			return (uintptr(0) /* &.win */)
		}()) - uintptr((Nk_ptr((uintptr(0) /* &.win */)))))
		var pe uintptr = ((func() uintptr {
			if 1 != 0 {
				return pd
			}
			return (uintptr(0) /* &.data */)
		}()) - uintptr((Nk_ptr((uintptr(0) /* &.data */)))))
		nk_free_page_element(ctx, pe)
	}
}

func nk_find_window(ctx uintptr, hash Nk_hash, name uintptr) uintptr { /* nuklear.h:19861:24: */
	var iter uintptr
	iter = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	for iter != 0 {
		if iter != (*Nk_window)(unsafe.Pointer(iter)).Next {
		} else {
			X__assert_fail(ts+21998 /* "iter != iter->ne..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19867), uintptr(unsafe.Pointer(&__func__206)))
		}
		if (*Nk_window)(unsafe.Pointer(iter)).Name == hash {
			var max_len int32 = Xnk_strlen(iter + 8 /* &.name_string */)
			if !(Xnk_stricmpn(iter+8 /* &.name_string */, name, max_len) != 0) {
				return iter
			}
		}
		iter = (*Nk_window)(unsafe.Pointer(iter)).Next
	}
	return uintptr(0)
}

var __func__206 = *(*[15]int8)(unsafe.Pointer(ts + 22017 /* "nk_find_window" */)) /* nuklear.h:19863:1 */

func nk_insert_window(ctx uintptr, win uintptr, loc uint32) { /* nuklear.h:19878:1: */
	var iter uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(19882), uintptr(unsafe.Pointer(&__func__207)))
	}
	if win != 0 {
	} else {
		X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(19883), uintptr(unsafe.Pointer(&__func__207)))
	}
	if !(win != 0) || !(ctx != 0) {
		return
	}

	iter = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	for iter != 0 {
		if iter != (*Nk_window)(unsafe.Pointer(iter)).Next {
		} else {
			X__assert_fail(ts+21998 /* "iter != iter->ne..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19888), uintptr(unsafe.Pointer(&__func__207)))
		}
		if iter != win {
		} else {
			X__assert_fail(ts+22032 /* "iter != win" */, ts+2 /* "nuklear/nuklear...." */, uint32(19889), uintptr(unsafe.Pointer(&__func__207)))
		}
		if iter == win {
			return
		}
		iter = (*Nk_window)(unsafe.Pointer(iter)).Next
	}

	if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Begin) != 0) {
		(*Nk_window)(unsafe.Pointer(win)).Next = uintptr(0)
		(*Nk_window)(unsafe.Pointer(win)).Prev = uintptr(0)
		(*Nk_context)(unsafe.Pointer(ctx)).Begin = win
		(*Nk_context)(unsafe.Pointer(ctx)).End = win
		(*Nk_context)(unsafe.Pointer(ctx)).Count = uint32(1)
		return
	}
	if int32(loc) == NK_INSERT_BACK {
		var end uintptr
		end = (*Nk_context)(unsafe.Pointer(ctx)).End
		*(*Nk_flags)(unsafe.Pointer(end + 72 /* &.flags */)) |= (NK_WINDOW_ROM)
		(*Nk_window)(unsafe.Pointer(end)).Next = win
		(*Nk_window)(unsafe.Pointer(win)).Prev = (*Nk_context)(unsafe.Pointer(ctx)).End
		(*Nk_window)(unsafe.Pointer(win)).Next = uintptr(0)
		(*Nk_context)(unsafe.Pointer(ctx)).End = win
		(*Nk_context)(unsafe.Pointer(ctx)).Active = (*Nk_context)(unsafe.Pointer(ctx)).End
		*(*Nk_flags)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).End + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
	} else {
		//ctx->end->flags |= NK_WINDOW_ROM;
		(*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Begin)).Prev = win
		(*Nk_window)(unsafe.Pointer(win)).Next = (*Nk_context)(unsafe.Pointer(ctx)).Begin
		(*Nk_window)(unsafe.Pointer(win)).Prev = uintptr(0)
		(*Nk_context)(unsafe.Pointer(ctx)).Begin = win
		*(*Nk_flags)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Begin + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Count++
}

var __func__207 = *(*[17]int8)(unsafe.Pointer(ts + 22044 /* "nk_insert_window" */)) /* nuklear.h:19880:1 */

func nk_remove_window(ctx uintptr, win uintptr) { /* nuklear.h:19923:1: */
	if (win == (*Nk_context)(unsafe.Pointer(ctx)).Begin) || (win == (*Nk_context)(unsafe.Pointer(ctx)).End) {
		if win == (*Nk_context)(unsafe.Pointer(ctx)).Begin {
			(*Nk_context)(unsafe.Pointer(ctx)).Begin = (*Nk_window)(unsafe.Pointer(win)).Next
			if (*Nk_window)(unsafe.Pointer(win)).Next != 0 {
				(*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Next)).Prev = uintptr(0)
			}
		}
		if win == (*Nk_context)(unsafe.Pointer(ctx)).End {
			(*Nk_context)(unsafe.Pointer(ctx)).End = (*Nk_window)(unsafe.Pointer(win)).Prev
			if (*Nk_window)(unsafe.Pointer(win)).Prev != 0 {
				(*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Prev)).Next = uintptr(0)
			}
		}
	} else {
		if (*Nk_window)(unsafe.Pointer(win)).Next != 0 {
			(*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Next)).Prev = (*Nk_window)(unsafe.Pointer(win)).Prev
		}
		if (*Nk_window)(unsafe.Pointer(win)).Prev != 0 {
			(*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Prev)).Next = (*Nk_window)(unsafe.Pointer(win)).Next
		}
	}
	if (win == (*Nk_context)(unsafe.Pointer(ctx)).Active) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Active) != 0) {
		(*Nk_context)(unsafe.Pointer(ctx)).Active = (*Nk_context)(unsafe.Pointer(ctx)).End
		if (*Nk_context)(unsafe.Pointer(ctx)).End != 0 {
			*(*Nk_flags)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).End + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
		}
	}
	(*Nk_window)(unsafe.Pointer(win)).Next = uintptr(0)
	(*Nk_window)(unsafe.Pointer(win)).Prev = uintptr(0)
	(*Nk_context)(unsafe.Pointer(ctx)).Count--
}

func Xnk_begin(ctx uintptr, title uintptr, bounds Nk_rect, flags Nk_flags) Nk_bool { /* nuklear.h:19952:1: */
	return Xnk_begin_titled(ctx, title, title, bounds, flags)
}

func Xnk_begin_titled(ctx uintptr, name uintptr, title uintptr, bounds Nk_rect, flags Nk_flags) Nk_bool { /* nuklear.h:19958:1: */
	var win uintptr
	var style uintptr
	var name_hash Nk_hash
	var name_len int32
	var ret int32 = 0

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(19967), uintptr(unsafe.Pointer(&__func__208)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(19968), uintptr(unsafe.Pointer(&__func__208)))
	}
	if title != 0 {
	} else {
		X__assert_fail(ts+22061 /* "title" */, ts+2 /* "nuklear/nuklear...." */, uint32(19969), uintptr(unsafe.Pointer(&__func__208)))
	}
	if (((*Nk_context)(unsafe.Pointer(ctx)).Style.Font != 0) && ((*Nk_user_font)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Style.Font)).Width != 0)) && (1 != 0) {
	} else {
		X__assert_fail(ts+22067 /* "ctx->style.font ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19970), uintptr(unsafe.Pointer(&__func__208)))
	}
	if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) && (1 != 0) {
	} else {
		X__assert_fail(ts+22156 /* "!ctx->current &&..." */, ts+2 /* "nuklear/nuklear...." */, uint32(19971), uintptr(unsafe.Pointer(&__func__208)))
	}
	if ((!(ctx != 0) || ((*Nk_context)(unsafe.Pointer(ctx)).Current != 0)) || !(title != 0)) || !(name != 0) {
		return 0
	}

	// find or create window
	style = (ctx + 360 /* &.style */)
	name_len = Xnk_strlen(name)
	name_hash = Xnk_murmur_hash(name, name_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, name_hash, name)
	if !(win != 0) {
		// create new window
		var name_length Nk_size = Nk_size(name_len)
		win = nk_create_window(ctx)
		if win != 0 {
		} else {
			X__assert_fail(ts+21639 /* "win" */, ts+2 /* "nuklear/nuklear...." */, uint32(19984), uintptr(unsafe.Pointer(&__func__208)))
		}
		if !(win != 0) {
			return 0
		}

		if (flags & NK_WINDOW_BACKGROUND) != 0 {
			nk_insert_window(ctx, win, NK_INSERT_FRONT)
		} else {
			nk_insert_window(ctx, win, NK_INSERT_BACK)
		}
		nk_command_buffer_init((win + 100 /* &.buffer */), (ctx + 5748 /* &.memory */), NK_CLIPPING_ON)

		(*Nk_window)(unsafe.Pointer(win)).Flags = flags
		(*Nk_window)(unsafe.Pointer(win)).Bounds = bounds
		(*Nk_window)(unsafe.Pointer(win)).Name = name_hash
		name_length = func() uint32 {
			if (name_length) < (Nk_size(NK_WINDOW_MAX_NAME - 1)) {
				return name_length
			}
			return (uint32(NK_WINDOW_MAX_NAME - 1))
		}()
		nk_memcopy(win+8 /* &.name_string */, name, name_length)
		*(*int8)(unsafe.Pointer((win + 8 /* &.name_string */) + uintptr(name_length))) = int8(0)
		(*Nk_window)(unsafe.Pointer(win)).Popup.Win = uintptr(0)
		if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Active) != 0) {
			(*Nk_context)(unsafe.Pointer(ctx)).Active = win
		}
	} else {
		// update window
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) &= (CplUint32((Nk_flags(NK_WINDOW_PRIVATE - 1))))
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (flags)
		if !(((*Nk_window)(unsafe.Pointer(win)).Flags & (Nk_flags(NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE))) != 0) {
			(*Nk_window)(unsafe.Pointer(win)).Bounds = bounds
		}
		// If this assert triggers you either:
		//
		// I.) Have more than one window with the same name or
		// II.) You forgot to actually draw the window.
		//      More specific you did not call `nk_clear` (nk_clear will be
		//      automatically called for you if you are using one of the
		//      provided demo backends).
		if (*Nk_window)(unsafe.Pointer(win)).Seq != (*Nk_context)(unsafe.Pointer(ctx)).Seq {
		} else {
			X__assert_fail(ts+22219 /* "win->seq != ctx-..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20014), uintptr(unsafe.Pointer(&__func__208)))
		}
		(*Nk_window)(unsafe.Pointer(win)).Seq = (*Nk_context)(unsafe.Pointer(ctx)).Seq
		if !(int32((*Nk_context)(unsafe.Pointer(ctx)).Active) != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_HIDDEN) != 0) {
			(*Nk_context)(unsafe.Pointer(ctx)).Active = win
			(*Nk_context)(unsafe.Pointer(ctx)).End = win
		}
	}
	if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_HIDDEN) != 0 {
		(*Nk_context)(unsafe.Pointer(ctx)).Current = win
		(*Nk_window)(unsafe.Pointer(win)).Layout = uintptr(0)
		return 0
	} else {
		nk_start(ctx, win)
	}

	// window overlapping
	if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_HIDDEN) != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_NO_INPUT) != 0) {
		var inpanel int32
		var ishovered int32
		var iter uintptr = win
		var h float32 = (((*Nk_user_font)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Style.Font)).Height + (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Padding.Y)) + (2.0 * (*Nk_style)(unsafe.Pointer(style)).Window.Header.Label_padding.Y))
		var win_bounds Nk_rect
		if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_MINIMIZED) != 0) {
			win_bounds = (*Nk_window)(unsafe.Pointer(win)).Bounds
		} else {
			win_bounds = Xnk_rect((*Nk_window)(unsafe.Pointer(win)).Bounds.X, (*Nk_window)(unsafe.Pointer(win)).Bounds.Y, (*Nk_window)(unsafe.Pointer(win)).Bounds.W, h)
		}

		// activate window if hovered and no other window is overlapping this window
		inpanel = Xnk_input_has_mouse_click_down_in_rect((ctx /* &.input */), NK_BUTTON_LEFT, win_bounds, Nk_true)
		inpanel = (Bool32((inpanel != 0) && ((*Nk_mouse_button)(unsafe.Pointer((ctx /* &.input */ + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0)))
		ishovered = Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), win_bounds)
		if ((win != (*Nk_context)(unsafe.Pointer(ctx)).Active) && (ishovered != 0)) && !((*Nk_mouse_button)(unsafe.Pointer((ctx /* &.input */ + 260 /* &.mouse */ /* &.buttons */))).Down != 0) {
			iter = (*Nk_window)(unsafe.Pointer(win)).Next
			for iter != 0 {
				var iter_bounds Nk_rect
				if !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_MINIMIZED) != 0) {
					iter_bounds = (*Nk_window)(unsafe.Pointer(iter)).Bounds
				} else {
					iter_bounds = Xnk_rect((*Nk_window)(unsafe.Pointer(iter)).Bounds.X, (*Nk_window)(unsafe.Pointer(iter)).Bounds.Y, (*Nk_window)(unsafe.Pointer(iter)).Bounds.W, h)
				}
				if ((((iter_bounds.X < (win_bounds.X + win_bounds.W)) && (win_bounds.X < (iter_bounds.X + iter_bounds.W))) && (iter_bounds.Y < (win_bounds.Y + win_bounds.H))) && (win_bounds.Y < (iter_bounds.Y + iter_bounds.H))) && (!(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0)) {
					break
				}

				if ((((*Nk_window)(unsafe.Pointer(iter)).Popup.Win != 0) && ((*Nk_window)(unsafe.Pointer(iter)).Popup.Active != 0)) && !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0)) && (((((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.X < ((*Nk_window)(unsafe.Pointer(win)).Bounds.X + win_bounds.W)) && ((*Nk_window)(unsafe.Pointer(win)).Bounds.X < ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.X + (*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.W))) && ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.Y < (win_bounds.Y + win_bounds.H))) && (win_bounds.Y < ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.Y + (*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.H))) {
					break
				}
				iter = (*Nk_window)(unsafe.Pointer(iter)).Next
			}
		}

		// activate window if clicked
		if ((iter != 0) && (inpanel != 0)) && (win != (*Nk_context)(unsafe.Pointer(ctx)).End) {
			iter = (*Nk_window)(unsafe.Pointer(win)).Next
			for iter != 0 {
				// try to find a panel with higher priority in the same position
				var iter_bounds Nk_rect
				if !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_MINIMIZED) != 0) {
					iter_bounds = (*Nk_window)(unsafe.Pointer(iter)).Bounds
				} else {
					iter_bounds = Xnk_rect((*Nk_window)(unsafe.Pointer(iter)).Bounds.X, (*Nk_window)(unsafe.Pointer(iter)).Bounds.Y, (*Nk_window)(unsafe.Pointer(iter)).Bounds.W, h)
				}
				if ((((iter_bounds.X) <= ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.X)) && (((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.X) < (iter_bounds.X + iter_bounds.W))) && (((iter_bounds.Y) <= ((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.Y)) && (((*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.Y) < (iter_bounds.Y + iter_bounds.H)))) && !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0) {
					break
				}
				if ((((*Nk_window)(unsafe.Pointer(iter)).Popup.Win != 0) && ((*Nk_window)(unsafe.Pointer(iter)).Popup.Active != 0)) && !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0)) && (((((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.X < (win_bounds.X + win_bounds.W)) && (win_bounds.X < ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.X + (*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.W))) && ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.Y < (win_bounds.Y + win_bounds.H))) && (win_bounds.Y < ((*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.Y + (*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds.H))) {
					break
				}
				iter = (*Nk_window)(unsafe.Pointer(iter)).Next
			}
		}
		if ((iter != 0) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0)) && (((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_BACKGROUND) != 0) {
			*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_ROM)
			*(*Nk_flags)(unsafe.Pointer(iter + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
			(*Nk_context)(unsafe.Pointer(ctx)).Active = iter
			if !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_BACKGROUND) != 0) {
				// current window is active in that position so transfer to top
				// at the highest priority in stack
				nk_remove_window(ctx, iter)
				nk_insert_window(ctx, iter, NK_INSERT_BACK)
			}
		} else {
			if !(iter != 0) && ((*Nk_context)(unsafe.Pointer(ctx)).End != win) {
				if !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_BACKGROUND) != 0) {
					// current window is active in that position so transfer to top
					// at the highest priority in stack
					nk_remove_window(ctx, win)
					nk_insert_window(ctx, win, NK_INSERT_BACK)
				}
				*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
				(*Nk_context)(unsafe.Pointer(ctx)).Active = win
			}
			if ((*Nk_context)(unsafe.Pointer(ctx)).End != win) && !(((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_BACKGROUND) != 0) {
				*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_ROM)
			}
		}
	}
	(*Nk_window)(unsafe.Pointer(win)).Layout = nk_create_panel(ctx)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = win
	ret = nk_panel_begin(ctx, title, NK_PANEL_WINDOW)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Offset_x = (win + 92 /* &.scrollbar */ /* &.x */)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Offset_y = (win + 92 /* &.scrollbar */ + 4 /* &.y */)
	return ret
}

var __func__208 = *(*[16]int8)(unsafe.Pointer(ts + 22240 /* "nk_begin_titled" */)) /* nuklear.h:19960:1 */

func Xnk_end(ctx uintptr) { /* nuklear.h:20112:1: */
	var layout uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20115), uintptr(unsafe.Pointer(&__func__209)))
	}
	if ((*Nk_context)(unsafe.Pointer(ctx)).Current != 0) && (1 != 0) {
	} else {
		X__assert_fail(ts+22256 /* "ctx->current && ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20116), uintptr(unsafe.Pointer(&__func__209)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	layout = (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout
	if !(layout != 0) || ((int32((*Nk_panel)(unsafe.Pointer(layout)).Type) == NK_PANEL_WINDOW) && (((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Flags & NK_WINDOW_HIDDEN) != 0)) {
		(*Nk_context)(unsafe.Pointer(ctx)).Current = uintptr(0)
		return
	}
	nk_panel_end(ctx)
	nk_free_panel(ctx, (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = uintptr(0)
}

var __func__209 = *(*[7]int8)(unsafe.Pointer(ts + 22321 /* "nk_end" */)) /* nuklear.h:20113:1 */

func Xnk_window_get_bounds(ctx uintptr) Nk_rect { /* nuklear.h:20130:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20132), uintptr(unsafe.Pointer(&__func__210)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20133), uintptr(unsafe.Pointer(&__func__210)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_rect(float32(0), float32(0), float32(0), float32(0))
	}
	return (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds
}

var __func__210 = *(*[21]int8)(unsafe.Pointer(ts + 22328 /* "nk_window_get_bo..." */)) /* nuklear.h:20131:1 */

func Xnk_window_get_position(ctx uintptr) Nk_vec2 { /* nuklear.h:20138:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20140), uintptr(unsafe.Pointer(&__func__211)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20141), uintptr(unsafe.Pointer(&__func__211)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}
	return Xnk_vec2((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.X, (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.Y)
}

var __func__211 = *(*[23]int8)(unsafe.Pointer(ts + 22349 /* "nk_window_get_po..." */)) /* nuklear.h:20139:1 */

func Xnk_window_get_size(ctx uintptr) Nk_vec2 { /* nuklear.h:20146:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20148), uintptr(unsafe.Pointer(&__func__212)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20149), uintptr(unsafe.Pointer(&__func__212)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}
	return Xnk_vec2((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.W, (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.H)
}

var __func__212 = *(*[19]int8)(unsafe.Pointer(ts + 22372 /* "nk_window_get_si..." */)) /* nuklear.h:20147:1 */

func Xnk_window_get_width(ctx uintptr) float32 { /* nuklear.h:20154:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20156), uintptr(unsafe.Pointer(&__func__213)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20157), uintptr(unsafe.Pointer(&__func__213)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return float32(0)
	}
	return (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.W
}

var __func__213 = *(*[20]int8)(unsafe.Pointer(ts + 22391 /* "nk_window_get_wi..." */)) /* nuklear.h:20155:1 */

func Xnk_window_get_height(ctx uintptr) float32 { /* nuklear.h:20162:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20164), uintptr(unsafe.Pointer(&__func__214)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20165), uintptr(unsafe.Pointer(&__func__214)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return float32(0)
	}
	return (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds.H
}

var __func__214 = *(*[21]int8)(unsafe.Pointer(ts + 22411 /* "nk_window_get_he..." */)) /* nuklear.h:20163:1 */

func Xnk_window_get_content_region(ctx uintptr) Nk_rect { /* nuklear.h:20170:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20172), uintptr(unsafe.Pointer(&__func__215)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20173), uintptr(unsafe.Pointer(&__func__215)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_rect(float32(0), float32(0), float32(0), float32(0))
	}
	return (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip
}

var __func__215 = *(*[29]int8)(unsafe.Pointer(ts + 22432 /* "nk_window_get_co..." */)) /* nuklear.h:20171:1 */

func Xnk_window_get_content_region_min(ctx uintptr) Nk_vec2 { /* nuklear.h:20178:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20180), uintptr(unsafe.Pointer(&__func__216)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20181), uintptr(unsafe.Pointer(&__func__216)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20182), uintptr(unsafe.Pointer(&__func__216)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}
	return Xnk_vec2((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.X, (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.Y)
}

var __func__216 = *(*[33]int8)(unsafe.Pointer(ts + 22461 /* "nk_window_get_co..." */)) /* nuklear.h:20179:1 */

func Xnk_window_get_content_region_max(ctx uintptr) Nk_vec2 { /* nuklear.h:20187:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20189), uintptr(unsafe.Pointer(&__func__217)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20190), uintptr(unsafe.Pointer(&__func__217)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20191), uintptr(unsafe.Pointer(&__func__217)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}
	return Xnk_vec2(((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.X + (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.W),
		((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.Y + (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.H))
}

var __func__217 = *(*[33]int8)(unsafe.Pointer(ts + 22494 /* "nk_window_get_co..." */)) /* nuklear.h:20188:1 */

func Xnk_window_get_content_region_size(ctx uintptr) Nk_vec2 { /* nuklear.h:20197:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20199), uintptr(unsafe.Pointer(&__func__218)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20200), uintptr(unsafe.Pointer(&__func__218)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20201), uintptr(unsafe.Pointer(&__func__218)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}
	return Xnk_vec2((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.W, (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip.H)
}

var __func__218 = *(*[34]int8)(unsafe.Pointer(ts + 22527 /* "nk_window_get_co..." */)) /* nuklear.h:20198:1 */

func Xnk_window_get_canvas(ctx uintptr) uintptr { /* nuklear.h:20205:32: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20208), uintptr(unsafe.Pointer(&__func__219)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20209), uintptr(unsafe.Pointer(&__func__219)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20210), uintptr(unsafe.Pointer(&__func__219)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return uintptr(0)
	}
	return ((*Nk_context)(unsafe.Pointer(ctx)).Current + 100 /* &.buffer */)
}

var __func__219 = *(*[21]int8)(unsafe.Pointer(ts + 22561 /* "nk_window_get_ca..." */)) /* nuklear.h:20207:1 */

func Xnk_window_get_panel(ctx uintptr) uintptr { /* nuklear.h:20214:23: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20217), uintptr(unsafe.Pointer(&__func__220)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20218), uintptr(unsafe.Pointer(&__func__220)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return uintptr(0)
	}
	return (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout
}

var __func__220 = *(*[20]int8)(unsafe.Pointer(ts + 22582 /* "nk_window_get_pa..." */)) /* nuklear.h:20216:1 */

func Xnk_window_get_scroll(ctx uintptr, offset_x uintptr, offset_y uintptr) { /* nuklear.h:20223:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20226), uintptr(unsafe.Pointer(&__func__221)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20227), uintptr(unsafe.Pointer(&__func__221)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if offset_x != 0 {
		*(*Nk_uint)(unsafe.Pointer(offset_x)) = (*Nk_window)(unsafe.Pointer(win)).Scrollbar.X
	}
	if offset_y != 0 {
		*(*Nk_uint)(unsafe.Pointer(offset_y)) = (*Nk_window)(unsafe.Pointer(win)).Scrollbar.Y
	}
}

var __func__221 = *(*[21]int8)(unsafe.Pointer(ts + 22602 /* "nk_window_get_sc..." */)) /* nuklear.h:20224:1 */

func Xnk_window_has_focus(ctx uintptr) Nk_bool { /* nuklear.h:20237:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20239), uintptr(unsafe.Pointer(&__func__222)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20240), uintptr(unsafe.Pointer(&__func__222)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20241), uintptr(unsafe.Pointer(&__func__222)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return 0
	}
	return (Bool32((*Nk_context)(unsafe.Pointer(ctx)).Current == (*Nk_context)(unsafe.Pointer(ctx)).Active))
}

var __func__222 = *(*[20]int8)(unsafe.Pointer(ts + 22623 /* "nk_window_has_fo..." */)) /* nuklear.h:20238:1 */

func Xnk_window_is_hovered(ctx uintptr) Nk_bool { /* nuklear.h:20246:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20248), uintptr(unsafe.Pointer(&__func__223)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20249), uintptr(unsafe.Pointer(&__func__223)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return 0
	}
	if ((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Flags & NK_WINDOW_HIDDEN) != 0 {
		return 0
	}
	return Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Bounds)
}

var __func__223 = *(*[21]int8)(unsafe.Pointer(ts + 22643 /* "nk_window_is_hov..." */)) /* nuklear.h:20247:1 */

func Xnk_window_is_any_hovered(ctx uintptr) Nk_bool { /* nuklear.h:20256:1: */
	var iter uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20259), uintptr(unsafe.Pointer(&__func__224)))
	}
	if !(ctx != 0) {
		return 0
	}
	iter = (*Nk_context)(unsafe.Pointer(ctx)).Begin
	for iter != 0 {
		// check if window is being hovered
		if !(((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_HIDDEN) != 0) {
			// check if window popup is being hovered
			if (((*Nk_window)(unsafe.Pointer(iter)).Popup.Active != 0) && ((*Nk_window)(unsafe.Pointer(iter)).Popup.Win != 0)) && (Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), (*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(iter)).Popup.Win)).Bounds) != 0) {
				return 1
			}

			if ((*Nk_window)(unsafe.Pointer(iter)).Flags & NK_WINDOW_MINIMIZED) != 0 {
				var header = (*Nk_window)(unsafe.Pointer(iter)).Bounds
				header.H = ((*Nk_user_font)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Style.Font)).Height + (float32(2) * (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Header.Padding.Y))
				if Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), header) != 0 {
					return 1
				}
			} else if Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), (*Nk_window)(unsafe.Pointer(iter)).Bounds) != 0 {
				return 1
			}
		}
		iter = (*Nk_window)(unsafe.Pointer(iter)).Next
	}
	return 0
}

var __func__224 = *(*[25]int8)(unsafe.Pointer(ts + 22664 /* "nk_window_is_any..." */)) /* nuklear.h:20257:1 */

func Xnk_item_is_any_active(ctx uintptr) Nk_bool { /* nuklear.h:20283:1: */
	var any_hovered int32 = Xnk_window_is_any_hovered(ctx)
	var any_active int32 = (int32((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_MODIFIED))
	return (Bool32((any_hovered != 0) || (any_active != 0)))
}

func Xnk_window_is_collapsed(ctx uintptr, name uintptr) Nk_bool { /* nuklear.h:20290:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20295), uintptr(unsafe.Pointer(&__func__225)))
	}
	if !(ctx != 0) {
		return 0
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return 0
	}
	return (Nk_bool((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_MINIMIZED))
}

var __func__225 = *(*[23]int8)(unsafe.Pointer(ts + 22689 /* "nk_window_is_col..." */)) /* nuklear.h:20291:1 */

func Xnk_window_is_closed(ctx uintptr, name uintptr) Nk_bool { /* nuklear.h:20305:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20310), uintptr(unsafe.Pointer(&__func__226)))
	}
	if !(ctx != 0) {
		return 1
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return 1
	}
	return (Nk_bool((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_CLOSED))
}

var __func__226 = *(*[20]int8)(unsafe.Pointer(ts + 22712 /* "nk_window_is_clo..." */)) /* nuklear.h:20306:1 */

func Xnk_window_is_hidden(ctx uintptr, name uintptr) Nk_bool { /* nuklear.h:20320:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20325), uintptr(unsafe.Pointer(&__func__227)))
	}
	if !(ctx != 0) {
		return 1
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return 1
	}
	return (Nk_bool((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_HIDDEN))
}

var __func__227 = *(*[20]int8)(unsafe.Pointer(ts + 22732 /* "nk_window_is_hid..." */)) /* nuklear.h:20321:1 */

func Xnk_window_is_active(ctx uintptr, name uintptr) Nk_bool { /* nuklear.h:20335:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20340), uintptr(unsafe.Pointer(&__func__228)))
	}
	if !(ctx != 0) {
		return 0
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return 0
	}
	return (Bool32(win == (*Nk_context)(unsafe.Pointer(ctx)).Active))
}

var __func__228 = *(*[20]int8)(unsafe.Pointer(ts + 22752 /* "nk_window_is_act..." */)) /* nuklear.h:20336:1 */

func Xnk_window_find(ctx uintptr, name uintptr) uintptr { /* nuklear.h:20349:24: */
	var title_len int32
	var title_hash Nk_hash
	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	return nk_find_window(ctx, title_hash, name)
}

func Xnk_window_close(ctx uintptr, name uintptr) { /* nuklear.h:20359:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20362), uintptr(unsafe.Pointer(&__func__229)))
	}
	if !(ctx != 0) {
		return
	}
	win = Xnk_window_find(ctx, name)
	if !(win != 0) {
		return
	}
	if ((*Nk_context)(unsafe.Pointer(ctx)).Current != win) && (1 != 0) {
	} else {
		X__assert_fail(ts+22772 /* "ctx->current != ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20366), uintptr(unsafe.Pointer(&__func__229)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current == win {
		return
	}
	*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_HIDDEN)
	*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_CLOSED)
}

var __func__229 = *(*[16]int8)(unsafe.Pointer(ts + 22840 /* "nk_window_close" */)) /* nuklear.h:20360:1 */

func Xnk_window_set_bounds(ctx uintptr, name uintptr, bounds Nk_rect) { /* nuklear.h:20372:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20376), uintptr(unsafe.Pointer(&__func__230)))
	}
	if !(ctx != 0) {
		return
	}
	win = Xnk_window_find(ctx, name)
	if !(win != 0) {
		return
	}
	if ((*Nk_context)(unsafe.Pointer(ctx)).Current != win) && (1 != 0) {
	} else {
		X__assert_fail(ts+22856 /* "ctx->current != ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20380), uintptr(unsafe.Pointer(&__func__230)))
	}
	(*Nk_window)(unsafe.Pointer(win)).Bounds = bounds
}

var __func__230 = *(*[21]int8)(unsafe.Pointer(ts + 22930 /* "nk_window_set_bo..." */)) /* nuklear.h:20374:1 */

func Xnk_window_set_position(ctx uintptr, name uintptr, pos Nk_vec2) { /* nuklear.h:20384:1: */
	var win uintptr = Xnk_window_find(ctx, name)
	if !(win != 0) {
		return
	}
	(*Nk_window)(unsafe.Pointer(win)).Bounds.X = pos.X
	(*Nk_window)(unsafe.Pointer(win)).Bounds.Y = pos.Y
}

func Xnk_window_set_size(ctx uintptr, name uintptr, size Nk_vec2) { /* nuklear.h:20393:1: */
	var win uintptr = Xnk_window_find(ctx, name)
	if !(win != 0) {
		return
	}
	(*Nk_window)(unsafe.Pointer(win)).Bounds.W = size.X
	(*Nk_window)(unsafe.Pointer(win)).Bounds.H = size.Y
}

func Xnk_window_set_scroll(ctx uintptr, offset_x Nk_uint, offset_y Nk_uint) { /* nuklear.h:20402:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20405), uintptr(unsafe.Pointer(&__func__231)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20406), uintptr(unsafe.Pointer(&__func__231)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	(*Nk_window)(unsafe.Pointer(win)).Scrollbar.X = offset_x
	(*Nk_window)(unsafe.Pointer(win)).Scrollbar.Y = offset_y
}

var __func__231 = *(*[21]int8)(unsafe.Pointer(ts + 22951 /* "nk_window_set_sc..." */)) /* nuklear.h:20403:1 */

func Xnk_window_collapse(ctx uintptr, name uintptr, c uint32) { /* nuklear.h:20414:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20420), uintptr(unsafe.Pointer(&__func__232)))
	}
	if !(ctx != 0) {
		return
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return
	}
	if int32(c) == NK_MINIMIZED {
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_MINIMIZED)
	} else {
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_MINIMIZED))
	}
}

var __func__232 = *(*[19]int8)(unsafe.Pointer(ts + 22972 /* "nk_window_collap..." */)) /* nuklear.h:20416:1 */

func Xnk_window_collapse_if(ctx uintptr, name uintptr, c uint32, cond int32) { /* nuklear.h:20432:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20435), uintptr(unsafe.Pointer(&__func__233)))
	}
	if !(ctx != 0) || !(cond != 0) {
		return
	}
	Xnk_window_collapse(ctx, name, c)
}

var __func__233 = *(*[22]int8)(unsafe.Pointer(ts + 22991 /* "nk_window_collap..." */)) /* nuklear.h:20434:1 */

func Xnk_window_show(ctx uintptr, name uintptr, s uint32) { /* nuklear.h:20440:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20445), uintptr(unsafe.Pointer(&__func__234)))
	}
	if !(ctx != 0) {
		return
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if !(win != 0) {
		return
	}
	if int32(s) == NK_HIDDEN {
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) |= (NK_WINDOW_HIDDEN)
	} else {
		*(*Nk_flags)(unsafe.Pointer(win + 72 /* &.flags */)) &= (CplUint32(NK_WINDOW_HIDDEN))
	}
}

var __func__234 = *(*[15]int8)(unsafe.Pointer(ts + 23013 /* "nk_window_show" */)) /* nuklear.h:20441:1 */

func Xnk_window_show_if(ctx uintptr, name uintptr, s uint32, cond int32) { /* nuklear.h:20457:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20460), uintptr(unsafe.Pointer(&__func__235)))
	}
	if !(ctx != 0) || !(cond != 0) {
		return
	}
	Xnk_window_show(ctx, name, s)
}

var __func__235 = *(*[18]int8)(unsafe.Pointer(ts + 23028 /* "nk_window_show_i..." */)) /* nuklear.h:20459:1 */

func Xnk_window_set_focus(ctx uintptr, name uintptr) { /* nuklear.h:20466:1: */
	var title_len int32
	var title_hash Nk_hash
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20471), uintptr(unsafe.Pointer(&__func__236)))
	}
	if !(ctx != 0) {
		return
	}

	title_len = Xnk_strlen(name)
	title_hash = Xnk_murmur_hash(name, title_len, NK_WINDOW_TITLE)
	win = nk_find_window(ctx, title_hash, name)
	if (win != 0) && ((*Nk_context)(unsafe.Pointer(ctx)).End != win) {
		nk_remove_window(ctx, win)
		nk_insert_window(ctx, win, NK_INSERT_BACK)
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Active = win
}

var __func__236 = *(*[20]int8)(unsafe.Pointer(ts + 23046 /* "nk_window_set_fo..." */)) /* nuklear.h:20467:1 */

// ===============================================================
//
//                              POPUP
//
// ===============================================================
func Xnk_popup_begin(ctx uintptr, type1 uint32, title uintptr, flags Nk_flags, rect Nk_rect) Nk_bool { /* nuklear.h:20493:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_rect)(unsafe.Pointer(bp)) = rect

	var popup uintptr
	var win uintptr
	var panel uintptr
	_ = panel
	var title_len int32
	var title_hash Nk_hash
	var allocated Nk_size

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20504), uintptr(unsafe.Pointer(&__func__237)))
	}
	if title != 0 {
	} else {
		X__assert_fail(ts+22061 /* "title" */, ts+2 /* "nuklear/nuklear...." */, uint32(20505), uintptr(unsafe.Pointer(&__func__237)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20506), uintptr(unsafe.Pointer(&__func__237)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20507), uintptr(unsafe.Pointer(&__func__237)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	panel = (*Nk_window)(unsafe.Pointer(win)).Layout
	if !((int32((*Nk_panel)(unsafe.Pointer(panel)).Type) & NK_PANEL_SET_POPUP) != 0) && (1 != 0) {
	} else {
		X__assert_fail(ts+23066 /* "!(panel->type & ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20513), uintptr(unsafe.Pointer(&__func__237)))
	}
	_ = panel
	title_len = Xnk_strlen(title)
	title_hash = Xnk_murmur_hash(title, title_len, NK_PANEL_POPUP)

	popup = (*Nk_window)(unsafe.Pointer(win)).Popup.Win
	if !(popup != 0) {
		popup = nk_create_window(ctx)
		(*Nk_window)(unsafe.Pointer(popup)).Parent = win
		(*Nk_window)(unsafe.Pointer(win)).Popup.Win = popup
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 0
		(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_POPUP
	}

	// make sure we have correct popup
	if (*Nk_window)(unsafe.Pointer(win)).Popup.Name != title_hash {
		if !((*Nk_window)(unsafe.Pointer(win)).Popup.Active != 0) {
			nk_zero(popup, uint32(unsafe.Sizeof(Nk_window{})))
			(*Nk_window)(unsafe.Pointer(win)).Popup.Name = title_hash
			(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 1
			(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_POPUP
		} else {
			return 0
		}
	}

	// popup position is local to window
	(*Nk_context)(unsafe.Pointer(ctx)).Current = popup
	*(*float32)(unsafe.Pointer(bp /* &rect */ /* &.x */)) += ((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Clip.X)
	*(*float32)(unsafe.Pointer(bp /* &rect */ + 4 /* &.y */)) += ((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Clip.Y)

	// setup popup data
	(*Nk_window)(unsafe.Pointer(popup)).Parent = win
	(*Nk_window)(unsafe.Pointer(popup)).Bounds = *(*Nk_rect)(unsafe.Pointer(bp /* rect */))
	(*Nk_window)(unsafe.Pointer(popup)).Seq = (*Nk_context)(unsafe.Pointer(ctx)).Seq
	(*Nk_window)(unsafe.Pointer(popup)).Layout = nk_create_panel(ctx)
	(*Nk_window)(unsafe.Pointer(popup)).Flags = flags
	*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_BORDER)
	if int32(type1) == NK_POPUP_DYNAMIC {
		*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_DYNAMIC)
	}

	(*Nk_window)(unsafe.Pointer(popup)).Buffer = (*Nk_window)(unsafe.Pointer(win)).Buffer
	nk_start_popup(ctx, win)
	allocated = (*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated
	Xnk_push_scissor((popup + 100 /* &.buffer */), nk_null_rect)

	if nk_panel_begin(ctx, title, NK_PANEL_POPUP) != 0 {
		// popup is running therefore invalidate parent panels
		var root uintptr
		root = (*Nk_window)(unsafe.Pointer(win)).Layout
		for root != 0 {
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) |= (NK_WINDOW_ROM)
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) &= (CplUint32(NK_WINDOW_REMOVE_ROM))
			root = (*Nk_panel)(unsafe.Pointer(root)).Parent
		}
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 1
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Offset_x = (popup + 92 /* &.scrollbar */ /* &.x */)
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Offset_y = (popup + 92 /* &.scrollbar */ + 4 /* &.y */)
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Parent = (*Nk_window)(unsafe.Pointer(win)).Layout
		return 1
	} else {
		// popup was closed/is invalid so cleanup
		var root uintptr
		root = (*Nk_window)(unsafe.Pointer(win)).Layout
		for root != 0 {
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) |= (NK_WINDOW_REMOVE_ROM)
			root = (*Nk_panel)(unsafe.Pointer(root)).Parent
		}
		(*Nk_window)(unsafe.Pointer(win)).Popup.Buf.Active = 0
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 0
		(*Nk_context)(unsafe.Pointer(ctx)).Memory.Allocated = allocated
		(*Nk_context)(unsafe.Pointer(ctx)).Current = win
		nk_free_panel(ctx, (*Nk_window)(unsafe.Pointer(popup)).Layout)
		(*Nk_window)(unsafe.Pointer(popup)).Layout = uintptr(0)
		return 0
	}
	return Nk_bool(0)
}

var __func__237 = *(*[15]int8)(unsafe.Pointer(ts + 23145 /* "nk_popup_begin" */)) /* nuklear.h:20495:1 */

func nk_nonblock_begin(ctx uintptr, flags Nk_flags, body Nk_rect, header Nk_rect, panel_type uint32) Nk_bool { /* nuklear.h:20589:1: */
	var popup uintptr
	var win uintptr
	var panel uintptr
	_ = panel
	var is_active int32 = Nk_true

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20598), uintptr(unsafe.Pointer(&__func__238)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20599), uintptr(unsafe.Pointer(&__func__238)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20600), uintptr(unsafe.Pointer(&__func__238)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	// popups cannot have popups
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	panel = (*Nk_window)(unsafe.Pointer(win)).Layout
	if !((int32((*Nk_panel)(unsafe.Pointer(panel)).Type) & NK_PANEL_SET_POPUP) != 0) {
	} else {
		X__assert_fail(ts+23160 /* "!(panel->type & ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20607), uintptr(unsafe.Pointer(&__func__238)))
	}
	_ = panel
	popup = (*Nk_window)(unsafe.Pointer(win)).Popup.Win
	if !(popup != 0) {
		// create window for nonblocking popup
		popup = nk_create_window(ctx)
		(*Nk_window)(unsafe.Pointer(popup)).Parent = win
		(*Nk_window)(unsafe.Pointer(win)).Popup.Win = popup
		(*Nk_window)(unsafe.Pointer(win)).Popup.Type = panel_type
		nk_command_buffer_init((popup + 100 /* &.buffer */), (ctx + 5748 /* &.memory */), NK_CLIPPING_ON)
	} else {
		// close the popup if user pressed outside or in the header
		var pressed int32
		var in_body int32
		var in_header int32
		pressed = Xnk_input_is_mouse_pressed((ctx /* &.input */), NK_BUTTON_LEFT)
		in_body = Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), body)
		in_header = Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), header)
		if (pressed != 0) && (!(in_body != 0) || (in_header != 0)) {
			is_active = Nk_false
		}
	}
	(*Nk_window)(unsafe.Pointer(win)).Popup.Header = header

	if !(is_active != 0) {
		// remove read only mode from all parent panels
		var root uintptr = (*Nk_window)(unsafe.Pointer(win)).Layout
		for root != 0 {
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) |= (NK_WINDOW_REMOVE_ROM)
			root = (*Nk_panel)(unsafe.Pointer(root)).Parent
		}
		return is_active
	}
	(*Nk_window)(unsafe.Pointer(popup)).Bounds = body
	(*Nk_window)(unsafe.Pointer(popup)).Parent = win
	(*Nk_window)(unsafe.Pointer(popup)).Layout = nk_create_panel(ctx)
	(*Nk_window)(unsafe.Pointer(popup)).Flags = flags
	*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_BORDER)
	*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_DYNAMIC)
	(*Nk_window)(unsafe.Pointer(popup)).Seq = (*Nk_context)(unsafe.Pointer(ctx)).Seq
	(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 1
	if (*Nk_window)(unsafe.Pointer(popup)).Layout != 0 {
	} else {
		X__assert_fail(ts+23196 /* "popup->layout" */, ts+2 /* "nuklear/nuklear...." */, uint32(20649), uintptr(unsafe.Pointer(&__func__238)))
	}

	nk_start_popup(ctx, win)
	(*Nk_window)(unsafe.Pointer(popup)).Buffer = (*Nk_window)(unsafe.Pointer(win)).Buffer
	Xnk_push_scissor((popup + 100 /* &.buffer */), nk_null_rect)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = popup

	nk_panel_begin(ctx, uintptr(0), panel_type)
	(*Nk_window)(unsafe.Pointer(win)).Buffer = (*Nk_window)(unsafe.Pointer(popup)).Buffer
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Parent = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Offset_x = (popup + 92 /* &.scrollbar */ /* &.x */)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Offset_y = (popup + 92 /* &.scrollbar */ + 4 /* &.y */)

	/* set read only mode to all parent panels */
	{
		var root uintptr
		root = (*Nk_window)(unsafe.Pointer(win)).Layout
		for root != 0 {
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) |= (NK_WINDOW_ROM)
			root = (*Nk_panel)(unsafe.Pointer(root)).Parent
		}
	}
	return is_active
}

var __func__238 = *(*[18]int8)(unsafe.Pointer(ts + 23210 /* "nk_nonblock_begi..." */)) /* nuklear.h:20592:1 */

func Xnk_popup_close(ctx uintptr) { /* nuklear.h:20672:1: */
	var popup uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20675), uintptr(unsafe.Pointer(&__func__239)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	popup = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if (*Nk_window)(unsafe.Pointer(popup)).Parent != 0 {
	} else {
		X__assert_fail(ts+23228 /* "popup->parent" */, ts+2 /* "nuklear/nuklear...." */, uint32(20679), uintptr(unsafe.Pointer(&__func__239)))
	}
	if (int32((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(popup)).Layout)).Type) & NK_PANEL_SET_POPUP) != 0 {
	} else {
		X__assert_fail(ts+23242 /* "popup->layout->t..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20680), uintptr(unsafe.Pointer(&__func__239)))
	}
	*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_HIDDEN)
}

var __func__239 = *(*[15]int8)(unsafe.Pointer(ts + 23283 /* "nk_popup_close" */)) /* nuklear.h:20673:1 */

func Xnk_popup_end(ctx uintptr) { /* nuklear.h:20684:1: */
	var win uintptr
	var popup uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20689), uintptr(unsafe.Pointer(&__func__240)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20690), uintptr(unsafe.Pointer(&__func__240)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20691), uintptr(unsafe.Pointer(&__func__240)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	popup = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if !(int32((*Nk_window)(unsafe.Pointer(popup)).Parent) != 0) {
		return
	}
	win = (*Nk_window)(unsafe.Pointer(popup)).Parent
	if ((*Nk_window)(unsafe.Pointer(popup)).Flags & NK_WINDOW_HIDDEN) != 0 {
		var root uintptr
		root = (*Nk_window)(unsafe.Pointer(win)).Layout
		for root != 0 {
			*(*Nk_flags)(unsafe.Pointer(root + 4 /* &.flags */)) |= (NK_WINDOW_REMOVE_ROM)
			root = (*Nk_panel)(unsafe.Pointer(root)).Parent
		}
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active = 0
	}
	Xnk_push_scissor((popup + 100 /* &.buffer */), nk_null_rect)
	Xnk_end(ctx)

	(*Nk_window)(unsafe.Pointer(win)).Buffer = (*Nk_window)(unsafe.Pointer(popup)).Buffer
	nk_finish_popup(ctx, win)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = win
	Xnk_push_scissor((win + 100 /* &.buffer */), (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Clip)
}

var __func__240 = *(*[13]int8)(unsafe.Pointer(ts + 23298 /* "nk_popup_end" */)) /* nuklear.h:20685:1 */

func Xnk_popup_get_scroll(ctx uintptr, offset_x uintptr, offset_y uintptr) { /* nuklear.h:20716:1: */
	var popup uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20720), uintptr(unsafe.Pointer(&__func__241)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20721), uintptr(unsafe.Pointer(&__func__241)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20722), uintptr(unsafe.Pointer(&__func__241)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	popup = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if offset_x != 0 {
		*(*Nk_uint)(unsafe.Pointer(offset_x)) = (*Nk_window)(unsafe.Pointer(popup)).Scrollbar.X
	}
	if offset_y != 0 {
		*(*Nk_uint)(unsafe.Pointer(offset_y)) = (*Nk_window)(unsafe.Pointer(popup)).Scrollbar.Y
	}
}

var __func__241 = *(*[20]int8)(unsafe.Pointer(ts + 23311 /* "nk_popup_get_scr..." */)) /* nuklear.h:20717:1 */

func Xnk_popup_set_scroll(ctx uintptr, offset_x Nk_uint, offset_y Nk_uint) { /* nuklear.h:20733:1: */
	var popup uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20737), uintptr(unsafe.Pointer(&__func__242)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20738), uintptr(unsafe.Pointer(&__func__242)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20739), uintptr(unsafe.Pointer(&__func__242)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	popup = (*Nk_context)(unsafe.Pointer(ctx)).Current
	(*Nk_window)(unsafe.Pointer(popup)).Scrollbar.X = offset_x
	(*Nk_window)(unsafe.Pointer(popup)).Scrollbar.Y = offset_y
}

var __func__242 = *(*[20]int8)(unsafe.Pointer(ts + 23331 /* "nk_popup_set_scr..." */)) /* nuklear.h:20734:1 */

// ==============================================================
//
//                          CONTEXTUAL
//
// ===============================================================
func Xnk_contextual_begin(ctx uintptr, flags Nk_flags, size Nk_vec2, trigger_bounds Nk_rect) Nk_bool { /* nuklear.h:20757:1: */
	var win uintptr
	var popup uintptr
	var body Nk_rect
	var is_clicked int32 = 0
	var is_open int32 = 0
	var ret int32 = 0

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20769), uintptr(unsafe.Pointer(&__func__243)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20770), uintptr(unsafe.Pointer(&__func__243)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20771), uintptr(unsafe.Pointer(&__func__243)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	(*Nk_window)(unsafe.Pointer(win)).Popup.Con_count++
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != (*Nk_context)(unsafe.Pointer(ctx)).Active {
		return 0
	}

	// check if currently active contextual is active
	popup = (*Nk_window)(unsafe.Pointer(win)).Popup.Win
	is_open = (Bool32((popup != 0) && (int32((*Nk_window)(unsafe.Pointer(win)).Popup.Type) == NK_PANEL_CONTEXTUAL)))
	is_clicked = Xnk_input_mouse_clicked((ctx /* &.input */), NK_BUTTON_RIGHT, trigger_bounds)
	if ((*Nk_window)(unsafe.Pointer(win)).Popup.Active_con != 0) && ((*Nk_window)(unsafe.Pointer(win)).Popup.Con_count != (*Nk_window)(unsafe.Pointer(win)).Popup.Active_con) {
		return 0
	}
	if !(is_open != 0) && ((*Nk_window)(unsafe.Pointer(win)).Popup.Active_con != 0) {
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active_con = uint32(0)
	}
	if !(is_open != 0) && !(is_clicked != 0) {
		return 0
	}

	// calculate contextual position on click
	(*Nk_window)(unsafe.Pointer(win)).Popup.Active_con = (*Nk_window)(unsafe.Pointer(win)).Popup.Con_count
	if is_clicked != 0 {
		body.X = (*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.X
		body.Y = (*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Pos.Y
	} else {
		body.X = (*Nk_window)(unsafe.Pointer(popup)).Bounds.X
		body.Y = (*Nk_window)(unsafe.Pointer(popup)).Bounds.Y
	}
	body.W = size.X
	body.H = size.Y

	// start nonblocking contextual popup
	ret = nk_nonblock_begin(ctx, (flags | NK_WINDOW_NO_SCROLLBAR), body,
		null_rect, NK_PANEL_CONTEXTUAL)
	if ret != 0 {
		(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_CONTEXTUAL
	} else {
		(*Nk_window)(unsafe.Pointer(win)).Popup.Active_con = uint32(0)
		(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_NONE
		if (*Nk_window)(unsafe.Pointer(win)).Popup.Win != 0 {
			(*Nk_window)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Popup.Win)).Flags = Nk_flags(0)
		}
	}
	return ret
}

var __func__243 = *(*[20]int8)(unsafe.Pointer(ts + 23351 /* "nk_contextual_be..." */)) /* nuklear.h:20759:1 */
var null_rect = Nk_rect{X: float32(-1), Y: float32(-1)}                                /* nuklear.h:20764:37 */

func Xnk_contextual_item_text(ctx uintptr, text uintptr, len int32, alignment Nk_flags) Nk_bool { /* nuklear.h:20816:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20826), uintptr(unsafe.Pointer(&__func__244)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20827), uintptr(unsafe.Pointer(&__func__244)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20828), uintptr(unsafe.Pointer(&__func__244)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	state = Xnk_widget_fitting(bp /* &bounds */, ctx, (*Nk_style)(unsafe.Pointer(style)).Contextual_button.Padding)
	if !(state != 0) {
		return Nk_false
	}

	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		text, len, alignment, NK_BUTTON_DEFAULT, (style+184 /* &.contextual_button */), in, (*Nk_style)(unsafe.Pointer(style)).Font) != 0 {
		Xnk_contextual_close(ctx)
		return Nk_true
	}
	return Nk_false
}

var __func__244 = *(*[24]int8)(unsafe.Pointer(ts + 23371 /* "nk_contextual_it..." */)) /* nuklear.h:20818:1 */

func Xnk_contextual_item_label(ctx uintptr, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:20846:1: */
	return Xnk_contextual_item_text(ctx, label, Xnk_strlen(label), align)
}

func Xnk_contextual_item_image_text(ctx uintptr, img Nk_image, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:20851:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20861), uintptr(unsafe.Pointer(&__func__245)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20862), uintptr(unsafe.Pointer(&__func__245)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20863), uintptr(unsafe.Pointer(&__func__245)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	state = Xnk_widget_fitting(bp /* &bounds */, ctx, (*Nk_style)(unsafe.Pointer(style)).Contextual_button.Padding)
	if !(state != 0) {
		return Nk_false
	}

	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text_image((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		img, text, len, align, NK_BUTTON_DEFAULT, (style+184 /* &.contextual_button */), (*Nk_style)(unsafe.Pointer(style)).Font, in) != 0 {
		Xnk_contextual_close(ctx)
		return Nk_true
	}
	return Nk_false
}

var __func__245 = *(*[30]int8)(unsafe.Pointer(ts + 23395 /* "nk_contextual_it..." */)) /* nuklear.h:20853:1 */

func Xnk_contextual_item_image_label(ctx uintptr, img Nk_image, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:20881:1: */
	return Xnk_contextual_item_image_text(ctx, img, label, Xnk_strlen(label), align)
}

func Xnk_contextual_item_symbol_text(ctx uintptr, symbol uint32, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:20887:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20897), uintptr(unsafe.Pointer(&__func__246)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20898), uintptr(unsafe.Pointer(&__func__246)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20899), uintptr(unsafe.Pointer(&__func__246)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	state = Xnk_widget_fitting(bp /* &bounds */, ctx, (*Nk_style)(unsafe.Pointer(style)).Contextual_button.Padding)
	if !(state != 0) {
		return Nk_false
	}

	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text_symbol((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		symbol, text, len, align, NK_BUTTON_DEFAULT, (style+184 /* &.contextual_button */), (*Nk_style)(unsafe.Pointer(style)).Font, in) != 0 {
		Xnk_contextual_close(ctx)
		return Nk_true
	}
	return Nk_false
}

var __func__246 = *(*[31]int8)(unsafe.Pointer(ts + 23425 /* "nk_contextual_it..." */)) /* nuklear.h:20889:1 */

func Xnk_contextual_item_symbol_label(ctx uintptr, symbol uint32, text uintptr, align Nk_flags) Nk_bool { /* nuklear.h:20917:1: */
	return Xnk_contextual_item_symbol_text(ctx, symbol, text, Xnk_strlen(text), align)
}

func Xnk_contextual_close(ctx uintptr) { /* nuklear.h:20923:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20925), uintptr(unsafe.Pointer(&__func__247)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20926), uintptr(unsafe.Pointer(&__func__247)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20927), uintptr(unsafe.Pointer(&__func__247)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}
	Xnk_popup_close(ctx)
}

var __func__247 = *(*[20]int8)(unsafe.Pointer(ts + 23456 /* "nk_contextual_cl..." */)) /* nuklear.h:20924:1 */

func Xnk_contextual_end(ctx uintptr) { /* nuklear.h:20932:1: */
	var popup uintptr
	var panel uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20936), uintptr(unsafe.Pointer(&__func__248)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20937), uintptr(unsafe.Pointer(&__func__248)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	popup = (*Nk_context)(unsafe.Pointer(ctx)).Current
	panel = (*Nk_window)(unsafe.Pointer(popup)).Layout
	if (*Nk_window)(unsafe.Pointer(popup)).Parent != 0 {
	} else {
		X__assert_fail(ts+23228 /* "popup->parent" */, ts+2 /* "nuklear/nuklear...." */, uint32(20942), uintptr(unsafe.Pointer(&__func__248)))
	}
	if (int32((*Nk_panel)(unsafe.Pointer(panel)).Type) & NK_PANEL_SET_POPUP) != 0 {
	} else {
		X__assert_fail(ts+23476 /* "panel->type & NK..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20943), uintptr(unsafe.Pointer(&__func__248)))
	}
	if ((*Nk_panel)(unsafe.Pointer(panel)).Flags & NK_WINDOW_DYNAMIC) != 0 {
		// Close behavior
		//         This is a bit of a hack solution since we do not know before we end our popup
		//         how big it will be. We therefore do not directly know when a
		//         click outside the non-blocking popup must close it at that direct frame.
		//         Instead it will be closed in the next frame.
		var body = Nk_rect{}
		if (*Nk_panel)(unsafe.Pointer(panel)).At_y < ((*Nk_panel)(unsafe.Pointer(panel)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(panel)).Bounds.H) {
			var padding = nk_panel_get_padding((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer(panel)).Type)
			body = (*Nk_panel)(unsafe.Pointer(panel)).Bounds
			body.Y = (((((*Nk_panel)(unsafe.Pointer(panel)).At_y + (*Nk_panel)(unsafe.Pointer(panel)).Footer_height) + (*Nk_panel)(unsafe.Pointer(panel)).Border) + padding.Y) + (*Nk_panel)(unsafe.Pointer(panel)).Row.Height)
			body.H = (((*Nk_panel)(unsafe.Pointer(panel)).Bounds.Y + (*Nk_panel)(unsafe.Pointer(panel)).Bounds.H) - body.Y)
		}
		{
			var pressed int32 = Xnk_input_is_mouse_pressed((ctx /* &.input */), NK_BUTTON_LEFT)
			var in_body int32 = Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), body)
			if (pressed != 0) && (in_body != 0) {
				*(*Nk_flags)(unsafe.Pointer(popup + 72 /* &.flags */)) |= (NK_WINDOW_HIDDEN)
			}

		}
	}
	if ((*Nk_window)(unsafe.Pointer(popup)).Flags & NK_WINDOW_HIDDEN) != 0 {
		(*Nk_window)(unsafe.Pointer(popup)).Seq = uint32(0)
	}
	Xnk_popup_end(ctx)
	return
}

var __func__248 = *(*[18]int8)(unsafe.Pointer(ts + 23509 /* "nk_contextual_en..." */)) /* nuklear.h:20933:1 */

// ===============================================================
//
//                              MENU
//
// ===============================================================
func Xnk_menubar_begin(ctx uintptr) { /* nuklear.h:20979:1: */
	var layout uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(20982), uintptr(unsafe.Pointer(&__func__249)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(20983), uintptr(unsafe.Pointer(&__func__249)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20984), uintptr(unsafe.Pointer(&__func__249)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	layout = (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout
	if (*Nk_panel)(unsafe.Pointer(layout)).At_y == (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y {
	} else {
		X__assert_fail(ts+23527 /* "layout->at_y == ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(20989), uintptr(unsafe.Pointer(&__func__249)))
	}
	// if this assert triggers you allocated space between nk_begin and nk_menubar_begin.
	//     If you want a menubar the first nuklear function after `nk_begin` has to be a
	//     `nk_menubar_begin` call. Inside the menubar you then have to allocate space for
	//     widgets (also supports multiple rows).
	//     Example:
	//         if (nk_begin(...)) {
	//             nk_menubar_begin(...);
	//                 nk_layout_xxxx(...);
	//                 nk_button(...);
	//                 nk_layout_xxxx(...);
	//                 nk_button(...);
	//             nk_menubar_end(...);
	//         }
	//         nk_end(...);
	//
	if (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
		return
	}

	(*Nk_panel)(unsafe.Pointer(layout)).Menu.X = (*Nk_panel)(unsafe.Pointer(layout)).At_x
	(*Nk_panel)(unsafe.Pointer(layout)).Menu.Y = ((*Nk_panel)(unsafe.Pointer(layout)).At_y + (*Nk_panel)(unsafe.Pointer(layout)).Row.Height)
	(*Nk_panel)(unsafe.Pointer(layout)).Menu.W = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W
	(*Nk_panel)(unsafe.Pointer(layout)).Menu.Offset.X = *(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))
	(*Nk_panel)(unsafe.Pointer(layout)).Menu.Offset.Y = *(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))
	*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y)) = Nk_uint(0)
}

var __func__249 = *(*[17]int8)(unsafe.Pointer(ts + 23560 /* "nk_menubar_begin" */)) /* nuklear.h:20980:1 */

func Xnk_menubar_end(ctx uintptr) { /* nuklear.h:21016:1: */
	var win uintptr
	var layout uintptr
	var out uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21022), uintptr(unsafe.Pointer(&__func__250)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21023), uintptr(unsafe.Pointer(&__func__250)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21024), uintptr(unsafe.Pointer(&__func__250)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	out = (win + 100 /* &.buffer */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
		return
	}

	(*Nk_panel)(unsafe.Pointer(layout)).Menu.H = ((*Nk_panel)(unsafe.Pointer(layout)).At_y - (*Nk_panel)(unsafe.Pointer(layout)).Menu.Y)
	*(*float32)(unsafe.Pointer(layout + 76 /* &.menu */ + 12 /* &.h */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height + (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Spacing.Y)

	*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 4 /* &.y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Menu.H)
	*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 12 /* &.h */)) -= ((*Nk_panel)(unsafe.Pointer(layout)).Menu.H)

	*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x)) = (*Nk_panel)(unsafe.Pointer(layout)).Menu.Offset.X
	*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y)) = (*Nk_panel)(unsafe.Pointer(layout)).Menu.Offset.Y
	(*Nk_panel)(unsafe.Pointer(layout)).At_y = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y - (*Nk_panel)(unsafe.Pointer(layout)).Row.Height)

	(*Nk_panel)(unsafe.Pointer(layout)).Clip.Y = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y
	(*Nk_panel)(unsafe.Pointer(layout)).Clip.H = (*Nk_panel)(unsafe.Pointer(layout)).Bounds.H
	Xnk_push_scissor(out, (*Nk_panel)(unsafe.Pointer(layout)).Clip)
}

var __func__250 = *(*[15]int8)(unsafe.Pointer(ts + 23577 /* "nk_menubar_end" */)) /* nuklear.h:21017:1 */

func nk_menu_begin(ctx uintptr, win uintptr, id uintptr, is_clicked int32, header Nk_rect, size Nk_vec2) int32 { /* nuklear.h:21049:1: */
	var is_open int32 = 0
	var is_active int32 = 0
	var body Nk_rect
	var popup uintptr
	var hash Nk_hash = Xnk_murmur_hash(id, Xnk_strlen(id), NK_PANEL_MENU)

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21058), uintptr(unsafe.Pointer(&__func__251)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21059), uintptr(unsafe.Pointer(&__func__251)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21060), uintptr(unsafe.Pointer(&__func__251)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	body.X = header.X
	body.W = size.X
	body.Y = (header.Y + header.H)
	body.H = size.Y

	popup = (*Nk_window)(unsafe.Pointer(win)).Popup.Win
	if popup != 0 {
		is_open = Nk_true
	} else {
		is_open = Nk_false
	}
	is_active = (Bool32(((popup != 0) && ((*Nk_window)(unsafe.Pointer(win)).Popup.Name == hash)) && (int32((*Nk_window)(unsafe.Pointer(win)).Popup.Type) == NK_PANEL_MENU)))
	if ((((is_clicked != 0) && (is_open != 0)) && !(is_active != 0)) || ((is_open != 0) && !(is_active != 0))) || ((!(is_open != 0) && !(is_active != 0)) && !(is_clicked != 0)) {
		return 0
	}
	if !(nk_nonblock_begin(ctx, NK_WINDOW_NO_SCROLLBAR, body, header, NK_PANEL_MENU) != 0) {
		return 0
	}

	(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_MENU
	(*Nk_window)(unsafe.Pointer(win)).Popup.Name = hash
	return 1
}

var __func__251 = *(*[14]int8)(unsafe.Pointer(ts + 23592 /* "nk_menu_begin" */)) /* nuklear.h:21051:1 */

func Xnk_menu_begin_text(ctx uintptr, title uintptr, len int32, align Nk_flags, size Nk_vec2) Nk_bool { /* nuklear.h:21082:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var state Nk_flags

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21091), uintptr(unsafe.Pointer(&__func__252)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21092), uintptr(unsafe.Pointer(&__func__252)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21093), uintptr(unsafe.Pointer(&__func__252)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	state = Nk_flags(Xnk_widget(bp /* &header */, ctx))
	if !(state != 0) {
		return 0
	}
	if (state == NK_WIDGET_ROM) || (((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)),
		title, len, align, NK_BUTTON_DEFAULT, (ctx+360 /* &.style */ +312 /* &.menu_button */), in, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font) != 0 {
		is_clicked = Nk_true
	}
	return nk_menu_begin(ctx, win, title, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), size)
}

var __func__252 = *(*[19]int8)(unsafe.Pointer(ts + 23606 /* "nk_menu_begin_te..." */)) /* nuklear.h:21084:1 */

func Xnk_menu_begin_label(ctx uintptr, text uintptr, align Nk_flags, size Nk_vec2) Nk_bool { /* nuklear.h:21106:16: */
	return Xnk_menu_begin_text(ctx, text, Xnk_strlen(text), align, size)
}

func Xnk_menu_begin_image(ctx uintptr, id uintptr, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:21112:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	// var header Nk_rect at bp, 16

	var in uintptr
	var is_clicked int32 = Nk_false
	var state Nk_flags

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21121), uintptr(unsafe.Pointer(&__func__253)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21122), uintptr(unsafe.Pointer(&__func__253)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21123), uintptr(unsafe.Pointer(&__func__253)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	state = Nk_flags(Xnk_widget(bp /* &header */, ctx))
	if !(state != 0) {
		return 0
	}
	if (state == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_image((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)),
		img, NK_BUTTON_DEFAULT, (ctx+360 /* &.style */ +312 /* &.menu_button */), in) != 0 {
		is_clicked = Nk_true
	}
	return nk_menu_begin(ctx, win, id, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), size)
}

var __func__253 = *(*[20]int8)(unsafe.Pointer(ts + 23625 /* "nk_menu_begin_im..." */)) /* nuklear.h:21114:1 */

func Xnk_menu_begin_symbol(ctx uintptr, id uintptr, sym uint32, size Nk_vec2) Nk_bool { /* nuklear.h:21137:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var state Nk_flags

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21146), uintptr(unsafe.Pointer(&__func__254)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21147), uintptr(unsafe.Pointer(&__func__254)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21148), uintptr(unsafe.Pointer(&__func__254)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	state = Nk_flags(Xnk_widget(bp /* &header */, ctx))
	if !(state != 0) {
		return 0
	}
	if (state == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_symbol((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)),
		sym, NK_BUTTON_DEFAULT, (ctx+360 /* &.style */ +312 /* &.menu_button */), in, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font) != 0 {
		is_clicked = Nk_true
	}
	return nk_menu_begin(ctx, win, id, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), size)
}

var __func__254 = *(*[21]int8)(unsafe.Pointer(ts + 23645 /* "nk_menu_begin_sy..." */)) /* nuklear.h:21139:1 */

func Xnk_menu_begin_image_text(ctx uintptr, title uintptr, len int32, align Nk_flags, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:21162:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	// var header Nk_rect at bp, 16

	var in uintptr
	var is_clicked int32 = Nk_false
	var state Nk_flags

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21171), uintptr(unsafe.Pointer(&__func__255)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21172), uintptr(unsafe.Pointer(&__func__255)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21173), uintptr(unsafe.Pointer(&__func__255)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	state = Nk_flags(Xnk_widget(bp /* &header */, ctx))
	if !(state != 0) {
		return 0
	}
	if (state == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text_image((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */),
		*(*Nk_rect)(unsafe.Pointer(bp /* header */)), img, title, len, align, NK_BUTTON_DEFAULT, (ctx+360 /* &.style */ +312 /* &.menu_button */),
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Font, in) != 0 {
		is_clicked = Nk_true
	}
	return nk_menu_begin(ctx, win, title, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), size)
}

var __func__255 = *(*[25]int8)(unsafe.Pointer(ts + 23666 /* "nk_menu_begin_im..." */)) /* nuklear.h:21164:1 */

func Xnk_menu_begin_image_label(ctx uintptr, title uintptr, align Nk_flags, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:21188:1: */
	return Xnk_menu_begin_image_text(ctx, title, Xnk_strlen(title), align, img, size)
}

func Xnk_menu_begin_symbol_text(ctx uintptr, title uintptr, len int32, align Nk_flags, sym uint32, size Nk_vec2) Nk_bool { /* nuklear.h:21194:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	// var header Nk_rect at bp, 16

	var in uintptr
	var is_clicked int32 = Nk_false
	var state Nk_flags

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21203), uintptr(unsafe.Pointer(&__func__256)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21204), uintptr(unsafe.Pointer(&__func__256)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21205), uintptr(unsafe.Pointer(&__func__256)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	state = Nk_flags(Xnk_widget(bp /* &header */, ctx))
	if !(state != 0) {
		return 0
	}

	if (state == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_do_button_text_symbol((ctx+5820 /* &.last_widget_state */), (win+100 /* &.buffer */),
		*(*Nk_rect)(unsafe.Pointer(bp /* header */)), sym, title, len, align, NK_BUTTON_DEFAULT, (ctx+360 /* &.style */ +312 /* &.menu_button */),
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Font, in) != 0 {
		is_clicked = Nk_true
	}
	return nk_menu_begin(ctx, win, title, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), size)
}

var __func__256 = *(*[26]int8)(unsafe.Pointer(ts + 23691 /* "nk_menu_begin_sy..." */)) /* nuklear.h:21196:1 */

func Xnk_menu_begin_symbol_label(ctx uintptr, title uintptr, align Nk_flags, sym uint32, size Nk_vec2) Nk_bool { /* nuklear.h:21220:1: */
	return Xnk_menu_begin_symbol_text(ctx, title, Xnk_strlen(title), align, sym, size)
}

func Xnk_menu_item_text(ctx uintptr, title uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:21226:1: */
	return Xnk_contextual_item_text(ctx, title, len, align)
}

func Xnk_menu_item_label(ctx uintptr, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:21231:1: */
	return Xnk_contextual_item_label(ctx, label, align)
}

func Xnk_menu_item_image_label(ctx uintptr, img Nk_image, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:21236:1: */
	return Xnk_contextual_item_image_label(ctx, img, label, align)
}

func Xnk_menu_item_image_text(ctx uintptr, img Nk_image, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:21242:1: */
	return Xnk_contextual_item_image_text(ctx, img, text, len, align)
}

func Xnk_menu_item_symbol_text(ctx uintptr, sym uint32, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:21247:16: */
	return Xnk_contextual_item_symbol_text(ctx, sym, text, len, align)
}

func Xnk_menu_item_symbol_label(ctx uintptr, sym uint32, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:21252:16: */
	return Xnk_contextual_item_symbol_label(ctx, sym, label, align)
}

func Xnk_menu_close(ctx uintptr) { /* nuklear.h:21257:13: */
	Xnk_contextual_close(ctx)
}

func Xnk_menu_end(ctx uintptr) { /* nuklear.h:21262:1: */
	Xnk_contextual_end(ctx)
}

// ===============================================================
//
//                          LAYOUT
//
// ===============================================================
func Xnk_layout_set_min_row_height(ctx uintptr, height float32) { /* nuklear.h:21277:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21282), uintptr(unsafe.Pointer(&__func__257)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21283), uintptr(unsafe.Pointer(&__func__257)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21284), uintptr(unsafe.Pointer(&__func__257)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Min_height = height
}

var __func__257 = *(*[29]int8)(unsafe.Pointer(ts + 23717 /* "nk_layout_set_mi..." */)) /* nuklear.h:21278:1 */

func Xnk_layout_reset_min_row_height(ctx uintptr) { /* nuklear.h:21293:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21298), uintptr(unsafe.Pointer(&__func__258)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21299), uintptr(unsafe.Pointer(&__func__258)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21300), uintptr(unsafe.Pointer(&__func__258)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Min_height = (*Nk_user_font)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Style.Font)).Height
	*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 12 /* &.min_height */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Style.Text.Padding.Y * float32(2))
	*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 12 /* &.min_height */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Min_row_height_padding * float32(2))
}

var __func__258 = *(*[31]int8)(unsafe.Pointer(ts + 23746 /* "nk_layout_reset_..." */)) /* nuklear.h:21294:1 */

func nk_layout_row_calculate_usable_space(style uintptr, type1 uint32, total_space float32, columns int32) float32 { /* nuklear.h:21311:1: */
	var panel_spacing float32
	var panel_space float32
	var spacing Nk_vec2

	spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing

	// calculate the usable panel space
	panel_spacing = ((func() float32 {
		if (columns - 1) < (0) {
			return float32(0)
		}
		return (float32(columns - 1))
	}()) * spacing.X)
	panel_space = (total_space - panel_spacing)
	return panel_space
}

func nk_panel_layout(ctx uintptr, win uintptr, height float32, cols int32) { /* nuklear.h:21327:1: */
	var layout uintptr
	var style uintptr
	var out uintptr
	var item_spacing Nk_vec2
	var color Nk_color

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21337), uintptr(unsafe.Pointer(&__func__259)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21338), uintptr(unsafe.Pointer(&__func__259)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21339), uintptr(unsafe.Pointer(&__func__259)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	// prefetch some configuration data
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)
	out = (win + 100 /* &.buffer */)
	color = (*Nk_style)(unsafe.Pointer(style)).Window.Background
	item_spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing

	//  if one of these triggers you forgot to add an `if` condition around either
	//         a window, group, popup, combobox or contextual menu `begin` and `end` block.
	//         Example:
	//             if (nk_begin(...) {...} nk_end(...); or
	//             if (nk_group_begin(...) { nk_group_end(...);}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
	} else {
		X__assert_fail(ts+23777 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21355), uintptr(unsafe.Pointer(&__func__259)))
	}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0) {
	} else {
		X__assert_fail(ts+23816 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21356), uintptr(unsafe.Pointer(&__func__259)))
	}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_CLOSED) != 0) {
	} else {
		X__assert_fail(ts+23852 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21357), uintptr(unsafe.Pointer(&__func__259)))
	}

	// update the current row and set the current row layout
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = 0
	*(*float32)(unsafe.Pointer(layout + 36 /* &.at_y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns = cols
	if height == 0.0 {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Height = ((func() float32 {
			if (height) < ((*Nk_panel)(unsafe.Pointer(layout)).Row.Min_height) {
				return (*Nk_panel)(unsafe.Pointer(layout)).Row.Min_height
			}
			return height
		}()) + item_spacing.Y)
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Height = (height + item_spacing.Y)
	}

	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_DYNAMIC) != 0 {
		// draw background for dynamic panels
		var background Nk_rect
		background.X = (*Nk_window)(unsafe.Pointer(win)).Bounds.X
		background.W = (*Nk_window)(unsafe.Pointer(win)).Bounds.W
		background.Y = ((*Nk_panel)(unsafe.Pointer(layout)).At_y - 1.0)
		background.H = ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height + 1.0)
		Xnk_fill_rect(out, background, float32(0), color)
	}
}

var __func__259 = *(*[16]int8)(unsafe.Pointer(ts + 23888 /* "nk_panel_layout" */)) /* nuklear.h:21329:1 */

func nk_row_layout(ctx uintptr, fmt uint32, height float32, cols int32, width int32) { /* nuklear.h:21379:1: */
	// update the current row and set the current row layout
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21384), uintptr(unsafe.Pointer(&__func__260)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21385), uintptr(unsafe.Pointer(&__func__260)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21386), uintptr(unsafe.Pointer(&__func__260)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	nk_panel_layout(ctx, win, height, cols)
	if int32(fmt) == NK_DYNAMIC {
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Type = NK_LAYOUT_DYNAMIC_FIXED
	} else {
		(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Type = NK_LAYOUT_STATIC_FIXED
	}

	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Ratio = uintptr(0)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Filled = float32(0)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Item_offset = float32(0)
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Row.Item_width = float32(width)
}

var __func__260 = *(*[14]int8)(unsafe.Pointer(ts + 23904 /* "nk_row_layout" */)) /* nuklear.h:21381:1 */

func Xnk_layout_ratio_from_pixel(ctx uintptr, pixel_width float32) float32 { /* nuklear.h:21402:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21405), uintptr(unsafe.Pointer(&__func__261)))
	}
	if pixel_width != 0 {
	} else {
		X__assert_fail(ts+23918 /* "pixel_width" */, ts+2 /* "nuklear/nuklear...." */, uint32(21406), uintptr(unsafe.Pointer(&__func__261)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return float32(0)
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	return func() float32 {
		if (func() float32 {
			if (pixel_width / (*Nk_window)(unsafe.Pointer(win)).Bounds.X) < (1.0) {
				return (pixel_width / (*Nk_window)(unsafe.Pointer(win)).Bounds.X)
			}
			return 1.0
		}()) < (0.0) {
			return 0.0
		}
		return func() float32 {
			if (pixel_width / (*Nk_window)(unsafe.Pointer(win)).Bounds.X) < (1.0) {
				return (pixel_width / (*Nk_window)(unsafe.Pointer(win)).Bounds.X)
			}
			return 1.0
		}()
	}()
}

var __func__261 = *(*[27]int8)(unsafe.Pointer(ts + 23930 /* "nk_layout_ratio_..." */)) /* nuklear.h:21403:1 */

func Xnk_layout_row_dynamic(ctx uintptr, height float32, cols int32) { /* nuklear.h:21412:1: */
	nk_row_layout(ctx, NK_DYNAMIC, height, cols, 0)
}

func Xnk_layout_row_static(ctx uintptr, height float32, item_width int32, cols int32) { /* nuklear.h:21417:1: */
	nk_row_layout(ctx, NK_STATIC, height, cols, item_width)
}

func Xnk_layout_row_begin(ctx uintptr, fmt uint32, row_height float32, cols int32) { /* nuklear.h:21422:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21428), uintptr(unsafe.Pointer(&__func__262)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21429), uintptr(unsafe.Pointer(&__func__262)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21430), uintptr(unsafe.Pointer(&__func__262)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	nk_panel_layout(ctx, win, row_height, cols)
	if int32(fmt) == NK_DYNAMIC {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_DYNAMIC_ROW
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_STATIC_ROW
	}

	(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = uintptr(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Filled = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns = cols
}

var __func__262 = *(*[20]int8)(unsafe.Pointer(ts + 23957 /* "nk_layout_row_be..." */)) /* nuklear.h:21424:1 */

func Xnk_layout_row_push(ctx uintptr, ratio_or_width float32) { /* nuklear.h:21448:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21453), uintptr(unsafe.Pointer(&__func__263)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21454), uintptr(unsafe.Pointer(&__func__263)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21455), uintptr(unsafe.Pointer(&__func__263)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_STATIC_ROW) || (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_DYNAMIC_ROW) {
	} else {
		X__assert_fail(ts+23977 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21461), uintptr(unsafe.Pointer(&__func__263)))
	}
	if (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_STATIC_ROW) && (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_DYNAMIC_ROW) {
		return
	}

	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_DYNAMIC_ROW {
		var ratio float32 = ratio_or_width
		if (ratio + (*Nk_panel)(unsafe.Pointer(layout)).Row.Filled) > 1.0 {
			return
		}
		if ratio > 0.0 {
			(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = func() float32 {
				if (float32(0)) < (func() float32 {
					if (1.0) < (ratio) {
						return 1.0
					}
					return ratio
				}()) {
					return func() float32 {
						if (1.0) < (ratio) {
							return 1.0
						}
						return ratio
					}()
				}
				return float32(0)
			}()
		} else {
			(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = (1.0 - (*Nk_panel)(unsafe.Pointer(layout)).Row.Filled)
		}
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = ratio_or_width
	}
}

var __func__263 = *(*[19]int8)(unsafe.Pointer(ts + 24063 /* "nk_layout_row_pu..." */)) /* nuklear.h:21449:1 */

func Xnk_layout_row_end(ctx uintptr) { /* nuklear.h:21474:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21479), uintptr(unsafe.Pointer(&__func__264)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21480), uintptr(unsafe.Pointer(&__func__264)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21481), uintptr(unsafe.Pointer(&__func__264)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_STATIC_ROW) || (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_DYNAMIC_ROW) {
	} else {
		X__assert_fail(ts+23977 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21487), uintptr(unsafe.Pointer(&__func__264)))
	}
	if (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_STATIC_ROW) && (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_DYNAMIC_ROW) {
		return
	}
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
}

var __func__264 = *(*[18]int8)(unsafe.Pointer(ts + 24082 /* "nk_layout_row_en..." */)) /* nuklear.h:21475:1 */

func Xnk_layout_row(ctx uintptr, fmt uint32, height float32, cols int32, ratio uintptr) { /* nuklear.h:21494:1: */
	var i int32
	var n_undef int32 = 0
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21502), uintptr(unsafe.Pointer(&__func__265)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21503), uintptr(unsafe.Pointer(&__func__265)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21504), uintptr(unsafe.Pointer(&__func__265)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	nk_panel_layout(ctx, win, height, cols)
	if int32(fmt) == NK_DYNAMIC {
		// calculate width of undefined widget ratios
		var r float32 = float32(0)
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = ratio
		for i = 0; i < cols; i++ {
			if *(*float32)(unsafe.Pointer(ratio + uintptr(i)*4)) < 0.0 {
				n_undef++
			} else {
				r = r + (*(*float32)(unsafe.Pointer(ratio + uintptr(i)*4)))
			}
		}
		r = func() float32 {
			if (float32(0)) < (func() float32 {
				if (1.0) < (1.0 - r) {
					return 1.0
				}
				return (1.0 - r)
			}()) {
				return func() float32 {
					if (1.0) < (1.0 - r) {
						return 1.0
					}
					return (1.0 - r)
				}()
			}
			return float32(0)
		}()
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_DYNAMIC
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = func() float32 {
			if (r > float32(0)) && (n_undef > 0) {
				return (r / float32(n_undef))
			}
			return float32(0)
		}()
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = ratio
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_STATIC
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	}
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Filled = float32(0)
}

var __func__265 = *(*[14]int8)(unsafe.Pointer(ts + 24100 /* "nk_layout_row" */)) /* nuklear.h:21496:1 */

func Xnk_layout_row_template_begin(ctx uintptr, height float32) { /* nuklear.h:21533:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21538), uintptr(unsafe.Pointer(&__func__266)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21539), uintptr(unsafe.Pointer(&__func__266)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21540), uintptr(unsafe.Pointer(&__func__266)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	nk_panel_layout(ctx, win, height, 1)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_TEMPLATE
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns = 0
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = uintptr(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_height = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Filled = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item.X = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item.Y = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item.W = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item.H = float32(0)
}

var __func__266 = *(*[29]int8)(unsafe.Pointer(ts + 24114 /* "nk_layout_row_te..." */)) /* nuklear.h:21534:1 */

func Xnk_layout_row_template_push_dynamic(ctx uintptr) { /* nuklear.h:21560:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21565), uintptr(unsafe.Pointer(&__func__267)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21566), uintptr(unsafe.Pointer(&__func__267)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21567), uintptr(unsafe.Pointer(&__func__267)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_TEMPLATE {
	} else {
		X__assert_fail(ts+24143 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21573), uintptr(unsafe.Pointer(&__func__267)))
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
	} else {
		X__assert_fail(ts+24182 /* "layout->row.colu..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21574), uintptr(unsafe.Pointer(&__func__267)))
	}
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_TEMPLATE {
		return
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
		return
	}
	*(*float32)(unsafe.Pointer((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr(PostIncInt32(&(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns, 1))*4)) = -1.0
}

var __func__267 = *(*[36]int8)(unsafe.Pointer(ts + 24207 /* "nk_layout_row_te..." */)) /* nuklear.h:21561:1 */

func Xnk_layout_row_template_push_variable(ctx uintptr, min_width float32) { /* nuklear.h:21580:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21585), uintptr(unsafe.Pointer(&__func__268)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21586), uintptr(unsafe.Pointer(&__func__268)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21587), uintptr(unsafe.Pointer(&__func__268)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_TEMPLATE {
	} else {
		X__assert_fail(ts+24143 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21593), uintptr(unsafe.Pointer(&__func__268)))
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
	} else {
		X__assert_fail(ts+24182 /* "layout->row.colu..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21594), uintptr(unsafe.Pointer(&__func__268)))
	}
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_TEMPLATE {
		return
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
		return
	}
	*(*float32)(unsafe.Pointer((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr(PostIncInt32(&(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns, 1))*4)) = -min_width
}

var __func__268 = *(*[37]int8)(unsafe.Pointer(ts + 24243 /* "nk_layout_row_te..." */)) /* nuklear.h:21581:1 */

func Xnk_layout_row_template_push_static(ctx uintptr, width float32) { /* nuklear.h:21600:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21605), uintptr(unsafe.Pointer(&__func__269)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21606), uintptr(unsafe.Pointer(&__func__269)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21607), uintptr(unsafe.Pointer(&__func__269)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_TEMPLATE {
	} else {
		X__assert_fail(ts+24143 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21613), uintptr(unsafe.Pointer(&__func__269)))
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
	} else {
		X__assert_fail(ts+24182 /* "layout->row.colu..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21614), uintptr(unsafe.Pointer(&__func__269)))
	}
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_TEMPLATE {
		return
	}
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns >= NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
		return
	}
	*(*float32)(unsafe.Pointer((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr(PostIncInt32(&(*Nk_panel)(unsafe.Pointer(layout)).Row.Columns, 1))*4)) = width
}

var __func__269 = *(*[35]int8)(unsafe.Pointer(ts + 24280 /* "nk_layout_row_te..." */)) /* nuklear.h:21601:1 */

func Xnk_layout_row_template_end(ctx uintptr) { /* nuklear.h:21620:1: */
	var win uintptr
	var layout uintptr

	var i int32 = 0
	var variable_count int32 = 0
	var min_variable_count int32 = 0
	var min_fixed_width float32 = 0.0
	var total_fixed_width float32 = 0.0
	var max_variable_width float32 = 0.0

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21632), uintptr(unsafe.Pointer(&__func__270)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21633), uintptr(unsafe.Pointer(&__func__270)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21634), uintptr(unsafe.Pointer(&__func__270)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) == NK_LAYOUT_TEMPLATE {
	} else {
		X__assert_fail(ts+24143 /* "layout->row.type..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21640), uintptr(unsafe.Pointer(&__func__270)))
	}
	if int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_TEMPLATE {
		return
	}
	for i = 0; i < (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns; i++ {
		var width float32 = *(*float32)(unsafe.Pointer((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr(i)*4))
		if width >= 0.0 {
			total_fixed_width = total_fixed_width + (width)
			min_fixed_width = min_fixed_width + (width)
		} else if width < -1.0 {
			width = -width
			total_fixed_width = total_fixed_width + (width)
			max_variable_width = func() float32 {
				if (max_variable_width) < (width) {
					return width
				}
				return max_variable_width
			}()
			variable_count++
		} else {
			min_variable_count++
			variable_count++
		}
	}
	if variable_count != 0 {
		var space float32 = nk_layout_row_calculate_usable_space((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer(layout)).Type,
			(*Nk_panel)(unsafe.Pointer(layout)).Bounds.W, (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns)
		var var_width float32 = ((func() float32 {
			if (space - min_fixed_width) < (0.0) {
				return 0.0
			}
			return (space - min_fixed_width)
		}()) / float32(variable_count))
		var enough_space int32 = (Bool32(var_width >= max_variable_width))
		if !(enough_space != 0) {
			var_width = ((func() float32 {
				if (space - total_fixed_width) < (float32(0)) {
					return float32(0)
				}
				return (space - total_fixed_width)
			}()) / float32(min_variable_count))
		}
		for i = 0; i < (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns; i++ {
			var width uintptr = ((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr(i)*4)
			*(*float32)(unsafe.Pointer(width)) = func() float32 {
				if *(*float32)(unsafe.Pointer(width)) >= 0.0 {
					return *(*float32)(unsafe.Pointer(width))
				}
				return func() float32 {
					if (*(*float32)(unsafe.Pointer(width)) < -1.0) && !(enough_space != 0) {
						return -*(*float32)(unsafe.Pointer(width))
					}
					return var_width
				}()
			}()
		}
	}
}

var __func__270 = *(*[27]int8)(unsafe.Pointer(ts + 24315 /* "nk_layout_row_te..." */)) /* nuklear.h:21621:1 */

func Xnk_layout_space_begin(ctx uintptr, fmt uint32, height float32, widget_count int32) { /* nuklear.h:21671:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21677), uintptr(unsafe.Pointer(&__func__271)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21678), uintptr(unsafe.Pointer(&__func__271)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21679), uintptr(unsafe.Pointer(&__func__271)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	nk_panel_layout(ctx, win, height, widget_count)
	if int32(fmt) == NK_STATIC {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_STATIC_FREE
	} else {
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Type = NK_LAYOUT_DYNAMIC_FREE
	}

	(*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio = uintptr(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Filled = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
}

var __func__271 = *(*[22]int8)(unsafe.Pointer(ts + 24342 /* "nk_layout_space_..." */)) /* nuklear.h:21673:1 */

func Xnk_layout_space_end(ctx uintptr) { /* nuklear.h:21696:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21701), uintptr(unsafe.Pointer(&__func__272)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21702), uintptr(unsafe.Pointer(&__func__272)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21703), uintptr(unsafe.Pointer(&__func__272)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_height = float32(0)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset = float32(0)
	nk_zero((layout + 100 /* &.row */ + 40 /* &.item */), uint32(unsafe.Sizeof(Nk_rect{})))
}

var __func__272 = *(*[20]int8)(unsafe.Pointer(ts + 24364 /* "nk_layout_space_..." */)) /* nuklear.h:21697:1 */

func Xnk_layout_space_push(ctx uintptr, rect Nk_rect) { /* nuklear.h:21715:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21720), uintptr(unsafe.Pointer(&__func__273)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21721), uintptr(unsafe.Pointer(&__func__273)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21722), uintptr(unsafe.Pointer(&__func__273)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Item = rect
}

var __func__273 = *(*[21]int8)(unsafe.Pointer(ts + 24384 /* "nk_layout_space_..." */)) /* nuklear.h:21716:1 */

func Xnk_layout_space_bounds(ctx uintptr) Nk_rect { /* nuklear.h:21731:1: */
	var ret Nk_rect
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21737), uintptr(unsafe.Pointer(&__func__274)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21738), uintptr(unsafe.Pointer(&__func__274)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21739), uintptr(unsafe.Pointer(&__func__274)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	ret.X = (*Nk_panel)(unsafe.Pointer(layout)).Clip.X
	ret.Y = (*Nk_panel)(unsafe.Pointer(layout)).Clip.Y
	ret.W = (*Nk_panel)(unsafe.Pointer(layout)).Clip.W
	ret.H = (*Nk_panel)(unsafe.Pointer(layout)).Row.Height
	return ret
}

var __func__274 = *(*[23]int8)(unsafe.Pointer(ts + 24405 /* "nk_layout_space_..." */)) /* nuklear.h:21732:1 */

func Xnk_layout_widget_bounds(ctx uintptr) Nk_rect { /* nuklear.h:21750:1: */
	var ret Nk_rect
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21756), uintptr(unsafe.Pointer(&__func__275)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21757), uintptr(unsafe.Pointer(&__func__275)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21758), uintptr(unsafe.Pointer(&__func__275)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	ret.X = (*Nk_panel)(unsafe.Pointer(layout)).At_x
	ret.Y = (*Nk_panel)(unsafe.Pointer(layout)).At_y
	ret.W = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.W - (func() float32 {
		if ((*Nk_panel)(unsafe.Pointer(layout)).At_x - (*Nk_panel)(unsafe.Pointer(layout)).Bounds.X) < (float32(0)) {
			return float32(0)
		}
		return ((*Nk_panel)(unsafe.Pointer(layout)).At_x - (*Nk_panel)(unsafe.Pointer(layout)).Bounds.X)
	}()))
	ret.H = (*Nk_panel)(unsafe.Pointer(layout)).Row.Height
	return ret
}

var __func__275 = *(*[24]int8)(unsafe.Pointer(ts + 24428 /* "nk_layout_widget..." */)) /* nuklear.h:21751:1 */

func Xnk_layout_space_to_screen(ctx uintptr, ret Nk_vec2) Nk_vec2 { /* nuklear.h:21769:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)
	*(*Nk_vec2)(unsafe.Pointer(bp)) = ret

	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21774), uintptr(unsafe.Pointer(&__func__276)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21775), uintptr(unsafe.Pointer(&__func__276)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21776), uintptr(unsafe.Pointer(&__func__276)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	*(*float32)(unsafe.Pointer(bp /* &ret */ /* &.x */)) += ((*Nk_panel)(unsafe.Pointer(layout)).At_x - float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
	*(*float32)(unsafe.Pointer(bp /* &ret */ + 4 /* &.y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).At_y - float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
	return *(*Nk_vec2)(unsafe.Pointer(bp /* ret */))
}

var __func__276 = *(*[26]int8)(unsafe.Pointer(ts + 24452 /* "nk_layout_space_..." */)) /* nuklear.h:21770:1 */

func Xnk_layout_space_to_local(ctx uintptr, ret Nk_vec2) Nk_vec2 { /* nuklear.h:21785:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)
	*(*Nk_vec2)(unsafe.Pointer(bp)) = ret

	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21790), uintptr(unsafe.Pointer(&__func__277)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21791), uintptr(unsafe.Pointer(&__func__277)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21792), uintptr(unsafe.Pointer(&__func__277)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	*(*float32)(unsafe.Pointer(bp /* &ret */ /* &.x */)) += (-(*Nk_panel)(unsafe.Pointer(layout)).At_x + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
	*(*float32)(unsafe.Pointer(bp /* &ret */ + 4 /* &.y */)) += (-(*Nk_panel)(unsafe.Pointer(layout)).At_y + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
	return *(*Nk_vec2)(unsafe.Pointer(bp /* ret */))
}

var __func__277 = *(*[25]int8)(unsafe.Pointer(ts + 24478 /* "nk_layout_space_..." */)) /* nuklear.h:21786:1 */

func Xnk_layout_space_rect_to_screen(ctx uintptr, ret Nk_rect) Nk_rect { /* nuklear.h:21801:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_rect)(unsafe.Pointer(bp)) = ret

	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21806), uintptr(unsafe.Pointer(&__func__278)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21807), uintptr(unsafe.Pointer(&__func__278)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21808), uintptr(unsafe.Pointer(&__func__278)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	*(*float32)(unsafe.Pointer(bp /* &ret */ /* &.x */)) += ((*Nk_panel)(unsafe.Pointer(layout)).At_x - float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
	*(*float32)(unsafe.Pointer(bp /* &ret */ + 4 /* &.y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).At_y - float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
	return *(*Nk_rect)(unsafe.Pointer(bp /* ret */))
}

var __func__278 = *(*[31]int8)(unsafe.Pointer(ts + 24503 /* "nk_layout_space_..." */)) /* nuklear.h:21802:1 */

func Xnk_layout_space_rect_to_local(ctx uintptr, ret Nk_rect) Nk_rect { /* nuklear.h:21817:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_rect)(unsafe.Pointer(bp)) = ret

	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21822), uintptr(unsafe.Pointer(&__func__279)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21823), uintptr(unsafe.Pointer(&__func__279)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21824), uintptr(unsafe.Pointer(&__func__279)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	*(*float32)(unsafe.Pointer(bp /* &ret */ /* &.x */)) += (-(*Nk_panel)(unsafe.Pointer(layout)).At_x + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
	*(*float32)(unsafe.Pointer(bp /* &ret */ + 4 /* &.y */)) += (-(*Nk_panel)(unsafe.Pointer(layout)).At_y + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
	return *(*Nk_rect)(unsafe.Pointer(bp /* ret */))
}

var __func__279 = *(*[30]int8)(unsafe.Pointer(ts + 24534 /* "nk_layout_space_..." */)) /* nuklear.h:21818:1 */

func nk_panel_alloc_row(ctx uintptr, win uintptr) { /* nuklear.h:21833:1: */
	var layout uintptr = (*Nk_window)(unsafe.Pointer(win)).Layout
	var spacing = (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Spacing
	var row_height float32 = ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height - spacing.Y)
	nk_panel_layout(ctx, win, row_height, (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns)
}

func nk_layout_widget_space(bounds uintptr, ctx uintptr, win uintptr, modify int32) { /* nuklear.h:21841:1: */
	var layout uintptr
	var style uintptr
	var spacing Nk_vec2

	var item_offset float32 = float32(0)
	var item_width float32 = float32(0)
	var item_spacing float32 = float32(0)
	var panel_space float32 = float32(0)

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21854), uintptr(unsafe.Pointer(&__func__280)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21855), uintptr(unsafe.Pointer(&__func__280)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21856), uintptr(unsafe.Pointer(&__func__280)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)
	if bounds != 0 {
	} else {
		X__assert_fail(ts+24564 /* "bounds" */, ts+2 /* "nuklear/nuklear...." */, uint32(21863), uintptr(unsafe.Pointer(&__func__280)))
	}

	spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing
	panel_space = nk_layout_row_calculate_usable_space((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer(layout)).Type,
		(*Nk_panel)(unsafe.Pointer(layout)).Bounds.W, (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns)

	// calculate the width of one item inside the current layout space
	switch (*Nk_panel)(unsafe.Pointer(layout)).Row.Type {
	case NK_LAYOUT_DYNAMIC_FIXED:
		{
			// scaling fixed size widgets item width
			var w float32 = ((func() float32 {
				if (1.0) < (panel_space) {
					return panel_space
				}
				return 1.0
			}()) / float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Columns))
			item_offset = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * w)
			item_width = (w + (item_offset - float32(int32(item_offset))))
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)

		}
		break
	case NK_LAYOUT_DYNAMIC_ROW:
		{
			// scaling single ratio widget width
			var w float32 = ((*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width * panel_space)
			item_offset = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset
			item_width = (w + (item_offset - float32(int32(item_offset))))
			item_spacing = float32(0)

			if modify != 0 {
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 32 /* &.item_offset */)) += (w + spacing.X)
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 36 /* &.filled */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width)
				(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = 0
			}

		}
		break
	case NK_LAYOUT_DYNAMIC_FREE:
		{
			// panel width depended free widget placing
			(*Nk_rect)(unsafe.Pointer(bounds)).X = ((*Nk_panel)(unsafe.Pointer(layout)).At_x + ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.W * (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.X))
			*(*float32)(unsafe.Pointer(bounds /* &.x */)) -= (float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
			(*Nk_rect)(unsafe.Pointer(bounds)).Y = ((*Nk_panel)(unsafe.Pointer(layout)).At_y + ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height * (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.Y))
			*(*float32)(unsafe.Pointer(bounds + 4 /* &.y */)) -= (float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
			(*Nk_rect)(unsafe.Pointer(bounds)).W = (((*Nk_panel)(unsafe.Pointer(layout)).Bounds.W * (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.W) + ((*Nk_rect)(unsafe.Pointer(bounds)).X - float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).X))))
			(*Nk_rect)(unsafe.Pointer(bounds)).H = (((*Nk_panel)(unsafe.Pointer(layout)).Row.Height * (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.H) + ((*Nk_rect)(unsafe.Pointer(bounds)).Y - float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).Y))))
			return

		}
	case NK_LAYOUT_DYNAMIC:
		{
			// scaling arrays of panel width ratios for every widget
			var ratio float32
			var w float32
			if (*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio != 0 {
			} else {
				X__assert_fail(ts+24571 /* "layout->row.rati..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21905), uintptr(unsafe.Pointer(&__func__280)))
			}
			if *(*float32)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio + uintptr((*Nk_panel)(unsafe.Pointer(layout)).Row.Index)*4)) < float32(0) {
				ratio = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width
			} else {
				ratio = *(*float32)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio + uintptr((*Nk_panel)(unsafe.Pointer(layout)).Row.Index)*4))
			}

			w = (ratio * panel_space)
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)
			item_offset = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset
			item_width = (w + (item_offset - float32(int32(item_offset))))

			if modify != 0 {
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 32 /* &.item_offset */)) += (w)
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 36 /* &.filled */)) += (ratio)
			}

		}
		break
	case NK_LAYOUT_STATIC_FIXED:
		{
			// non-scaling fixed widgets item width
			item_width = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width
			item_offset = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * item_width)
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)

		}
		break
	case NK_LAYOUT_STATIC_ROW:
		{
			// scaling single ratio widget width
			item_width = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_width
			item_offset = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)
			if modify != 0 {
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 32 /* &.item_offset */)) += (item_width)
			}

		}
		break
	case NK_LAYOUT_STATIC_FREE:
		{
			// free widget placing
			(*Nk_rect)(unsafe.Pointer(bounds)).X = ((*Nk_panel)(unsafe.Pointer(layout)).At_x + (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.X)
			(*Nk_rect)(unsafe.Pointer(bounds)).W = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.W
			if (((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W) > (*Nk_panel)(unsafe.Pointer(layout)).Max_x) && (modify != 0) {
				(*Nk_panel)(unsafe.Pointer(layout)).Max_x = ((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W)
			}
			*(*float32)(unsafe.Pointer(bounds /* &.x */)) -= (float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
			(*Nk_rect)(unsafe.Pointer(bounds)).Y = ((*Nk_panel)(unsafe.Pointer(layout)).At_y + (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.Y)
			*(*float32)(unsafe.Pointer(bounds + 4 /* &.y */)) -= (float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
			(*Nk_rect)(unsafe.Pointer(bounds)).H = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item.H
			return

		}
	case NK_LAYOUT_STATIC:
		{
			// non-scaling array of panel pixel width for every widget
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)
			item_width = *(*float32)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Row.Ratio + uintptr((*Nk_panel)(unsafe.Pointer(layout)).Row.Index)*4))
			item_offset = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset
			if modify != 0 {
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 32 /* &.item_offset */)) += (item_width)
			}

		}
		break
	case NK_LAYOUT_TEMPLATE:
		{
			// stretchy row layout with combined dynamic/static widget width
			var w float32
			if (*Nk_panel)(unsafe.Pointer(layout)).Row.Index < (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns {
			} else {
				X__assert_fail(ts+24589 /* "layout->row.inde..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21954), uintptr(unsafe.Pointer(&__func__280)))
			}
			if (*Nk_panel)(unsafe.Pointer(layout)).Row.Index < NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS {
			} else {
				X__assert_fail(ts+24629 /* "layout->row.inde..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21955), uintptr(unsafe.Pointer(&__func__280)))
			}
			w = *(*float32)(unsafe.Pointer((layout + 100 /* &.row */ + 60 /* &.templates */) + uintptr((*Nk_panel)(unsafe.Pointer(layout)).Row.Index)*4))
			item_offset = (*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset
			item_width = (w + (item_offset - float32(int32(item_offset))))
			item_spacing = (float32((*Nk_panel)(unsafe.Pointer(layout)).Row.Index) * spacing.X)
			if modify != 0 {
				*(*float32)(unsafe.Pointer(layout + 100 /* &.row */ + 32 /* &.item_offset */)) += (w)
			}

		}
		break
	default:
		if 0 != 0 {
		} else {
			X__assert_fail(ts+2953 /* "0" */, ts+2 /* "nuklear/nuklear...." */, uint32(21963), uintptr(unsafe.Pointer(&__func__280)))
		}
		break
	}

	// set the bounds of the newly allocated widget
	(*Nk_rect)(unsafe.Pointer(bounds)).W = item_width
	(*Nk_rect)(unsafe.Pointer(bounds)).H = ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height - spacing.Y)
	(*Nk_rect)(unsafe.Pointer(bounds)).Y = ((*Nk_panel)(unsafe.Pointer(layout)).At_y - float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_y))))
	(*Nk_rect)(unsafe.Pointer(bounds)).X = (((*Nk_panel)(unsafe.Pointer(layout)).At_x + item_offset) + item_spacing)
	if (((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W) > (*Nk_panel)(unsafe.Pointer(layout)).Max_x) && (modify != 0) {
		(*Nk_panel)(unsafe.Pointer(layout)).Max_x = ((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W)
	}
	*(*float32)(unsafe.Pointer(bounds /* &.x */)) -= (float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
}

var __func__280 = *(*[23]int8)(unsafe.Pointer(ts + 24652 /* "nk_layout_widget..." */)) /* nuklear.h:21843:1 */

func nk_panel_alloc_space(bounds uintptr, ctx uintptr) { /* nuklear.h:21976:1: */
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(21981), uintptr(unsafe.Pointer(&__func__281)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(21982), uintptr(unsafe.Pointer(&__func__281)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(21983), uintptr(unsafe.Pointer(&__func__281)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	// check if the end of the row has been hit and begin new row if so
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Index >= (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns {
		nk_panel_alloc_row(ctx, win)
	}

	// calculate widget position and size
	nk_layout_widget_space(bounds, ctx, win, Nk_true)
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Index++
}

var __func__281 = *(*[21]int8)(unsafe.Pointer(ts + 24675 /* "nk_panel_alloc_s..." */)) /* nuklear.h:21977:1 */

func nk_layout_peek(bounds uintptr, ctx uintptr) { /* nuklear.h:21998:1: */
	var y float32
	var index int32
	var win uintptr
	var layout uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22005), uintptr(unsafe.Pointer(&__func__282)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22006), uintptr(unsafe.Pointer(&__func__282)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22007), uintptr(unsafe.Pointer(&__func__282)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	y = (*Nk_panel)(unsafe.Pointer(layout)).At_y
	index = (*Nk_panel)(unsafe.Pointer(layout)).Row.Index
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Index >= (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns {
		*(*float32)(unsafe.Pointer(layout + 36 /* &.at_y */)) += ((*Nk_panel)(unsafe.Pointer(layout)).Row.Height)
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = 0
	}
	nk_layout_widget_space(bounds, ctx, win, Nk_false)
	if !((*Nk_panel)(unsafe.Pointer(layout)).Row.Index != 0) {
		*(*float32)(unsafe.Pointer(bounds /* &.x */)) -= ((*Nk_panel)(unsafe.Pointer(layout)).Row.Item_offset)
	}
	(*Nk_panel)(unsafe.Pointer(layout)).At_y = y
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = index
}

var __func__282 = *(*[15]int8)(unsafe.Pointer(ts + 24696 /* "nk_layout_peek" */)) /* nuklear.h:21999:1 */

// ===============================================================
//
//                              TREE
//
// ===============================================================
func nk_tree_state_base(ctx uintptr, type1 uint32, img uintptr, title uintptr, state uintptr) int32 { /* nuklear.h:22037:1: */
	bp := tlsAlloc(52)
	defer tlsFree(52)

	var win uintptr
	var layout uintptr
	var style uintptr
	var out uintptr
	var in uintptr
	var button uintptr
	var symbol uint32
	var row_height float32
	var item_spacing Nk_vec2
	*(*Nk_rect)(unsafe.Pointer(bp /* header */)) = Nk_rect{}
	*(*Nk_rect)(unsafe.Pointer(bp + 20 /* sym */)) = Nk_rect{}
	// var text Nk_text at bp+36, 16

	*(*Nk_flags)(unsafe.Pointer(bp + 16 /* ws */)) = Nk_flags(0)
	var widget_state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22057), uintptr(unsafe.Pointer(&__func__283)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22058), uintptr(unsafe.Pointer(&__func__283)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22059), uintptr(unsafe.Pointer(&__func__283)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	// cache some data
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	out = (win + 100 /* &.buffer */)
	style = (ctx + 360 /* &.style */)
	item_spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing

	// calculate header bounds and draw background
	row_height = ((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.Y))
	Xnk_layout_set_min_row_height(ctx, row_height)
	Xnk_layout_row_dynamic(ctx, row_height, 1)
	Xnk_layout_reset_min_row_height(ctx)

	widget_state = Xnk_widget(bp /* &header */, ctx)
	if int32(type1) == NK_TREE_TAB {
		var background uintptr = (style + 3996 /* &.tab */ /* &.background */)
		if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
			Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
			(*Nk_text)(unsafe.Pointer(bp + 36 /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
		} else {
			(*Nk_text)(unsafe.Pointer(bp + 36 /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
			Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Tab.Border_color)
			Xnk_fill_rect(out, nk_shrink_rect(*(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Tab.Border),
				(*Nk_style)(unsafe.Pointer(style)).Tab.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		}
	} else {
		(*Nk_text)(unsafe.Pointer(bp + 36 /* &text */)).Background = (*Nk_style)(unsafe.Pointer(style)).Window.Background
	}

	// update node state
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = (ctx /* &.input */)
	} else {
		in = uintptr(0)
	}
	if (in != 0) && (int32(widget_state) == NK_WIDGET_VALID) {
		in = (ctx /* &.input */)
	} else {
		in = uintptr(0)
	}
	if nk_button_behavior(bp+16 /* &ws */, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		*(*uint32)(unsafe.Pointer(state)) = func() uint32 {
			if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
				return NK_MINIMIZED
			}
			return NK_MAXIMIZED
		}()
	}

	// select correct button style
	if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
		symbol = (*Nk_style)(unsafe.Pointer(style)).Tab.Sym_maximize
		if int32(type1) == NK_TREE_TAB {
			button = (style + 3996 /* &.tab */ + 28 /* &.tab_maximize_button */)
		} else {
			button = (style + 3996 /* &.tab */ + 284 /* &.node_maximize_button */)
		}
	} else {
		symbol = (*Nk_style)(unsafe.Pointer(style)).Tab.Sym_minimize
		if int32(type1) == NK_TREE_TAB {
			button = (style + 3996 /* &.tab */ + 156 /* &.tab_minimize_button */)
		} else {
			button = (style + 3996 /* &.tab */ + 412 /* &.node_minimize_button */)
		}
	}

	{ // draw triangle button
		(*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).W = AssignPtrFloat32(bp+20 /* &sym */ +12 /* &.h */, (*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height)
		(*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.X)
		nk_do_button_symbol(bp+16 /* &ws */, (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 20 /* sym */)), symbol, NK_BUTTON_DEFAULT,
			button, uintptr(0), (*Nk_style)(unsafe.Pointer(style)).Font)

		if img != 0 {
			// draw optional image icon
			(*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).X = (((*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).X + (*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).W) + (float32(4) * item_spacing.X))
			Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 20 /* sym */)), img, nk_white)
			(*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).W = ((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height + (*Nk_style)(unsafe.Pointer(style)).Tab.Spacing.X)
		}

	}

	{ // draw label
		var label Nk_rect
		(*Nk_rect)(unsafe.Pointer(bp /* &header */)).W = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) < ((*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).W + item_spacing.X) {
				return ((*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).W + item_spacing.X)
			}
			return (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W
		}()
		label.X = (((*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).X + (*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).W) + item_spacing.X)
		label.Y = (*Nk_rect)(unsafe.Pointer(bp + 20 /* &sym */)).Y
		label.W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (((*Nk_rect)(unsafe.Pointer(bp+20 /* &sym */)).W + item_spacing.Y) + (*Nk_style)(unsafe.Pointer(style)).Tab.Indent))
		label.H = (*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height
		(*Nk_text)(unsafe.Pointer(bp + 36 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Tab.Text
		(*Nk_text)(unsafe.Pointer(bp + 36 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
		nk_widget_text(out, label, title, Xnk_strlen(title), bp+36, /* &text */
			NK_TEXT_LEFT, (*Nk_style)(unsafe.Pointer(style)).Font)
	}

	// increase x-axis cursor widget position pointer
	if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
		(*Nk_panel)(unsafe.Pointer(layout)).At_x = (((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x)))) + (*Nk_style)(unsafe.Pointer(style)).Tab.Indent)
		(*Nk_panel)(unsafe.Pointer(layout)).Bounds.W = func() float32 {
			if ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.W) < ((*Nk_style)(unsafe.Pointer(style)).Tab.Indent) {
				return (*Nk_style)(unsafe.Pointer(style)).Tab.Indent
			}
			return (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W
		}()
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 8 /* &.w */)) -= ((*Nk_style)(unsafe.Pointer(style)).Tab.Indent + (*Nk_style)(unsafe.Pointer(style)).Window.Padding.X)
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth++
		return Nk_true
	} else {
		return Nk_false
	}
	return int32(0)
}

var __func__283 = *(*[19]int8)(unsafe.Pointer(ts + 24711 /* "nk_tree_state_ba..." */)) /* nuklear.h:22039:1 */

func nk_tree_base(ctx uintptr, type1 uint32, img uintptr, title uintptr, initial_state uint32, hash uintptr, len int32, line int32) int32 { /* nuklear.h:22145:1: */
	var win uintptr = (*Nk_context)(unsafe.Pointer(ctx)).Current
	var title_len int32 = 0
	var tree_hash Nk_hash = Nk_hash(0)
	var state uintptr = uintptr(0)

	// retrieve tree state from internal widget state tables
	if !(hash != 0) {
		title_len = Xnk_strlen(title)
		tree_hash = Xnk_murmur_hash(title, title_len, Nk_hash(line))
	} else {
		tree_hash = Xnk_murmur_hash(hash, len, Nk_hash(line))
	}
	state = nk_find_value(win, tree_hash)
	if !(state != 0) {
		state = nk_add_value(ctx, win, tree_hash, uint32(0))
		*(*Nk_uint)(unsafe.Pointer(state)) = Nk_uint(initial_state)
	}
	return nk_tree_state_base(ctx, type1, img, title, state)
}

func Xnk_tree_state_push(ctx uintptr, type1 uint32, title uintptr, state uintptr) Nk_bool { /* nuklear.h:22167:1: */
	return nk_tree_state_base(ctx, type1, uintptr(0), title, state)
}

func Xnk_tree_state_image_push(ctx uintptr, type1 uint32, img Nk_image, title uintptr, state uintptr) Nk_bool { /* nuklear.h:22173:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_image)(unsafe.Pointer(bp)) = img

	return nk_tree_state_base(ctx, type1, bp /* &img */, title, state)
}

func Xnk_tree_state_pop(ctx uintptr) { /* nuklear.h:22179:1: */
	var win uintptr = uintptr(0)
	var layout uintptr = uintptr(0)

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22184), uintptr(unsafe.Pointer(&__func__284)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22185), uintptr(unsafe.Pointer(&__func__284)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22186), uintptr(unsafe.Pointer(&__func__284)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	*(*float32)(unsafe.Pointer(layout + 32 /* &.at_x */)) -= ((*Nk_context)(unsafe.Pointer(ctx)).Style.Tab.Indent + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x))))
	*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 8 /* &.w */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Style.Tab.Indent + (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Padding.X)
	if (*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth != 0 {
	} else {
		X__assert_fail(ts+24730 /* "layout->row.tree..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22194), uintptr(unsafe.Pointer(&__func__284)))
	}
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth--
}

var __func__284 = *(*[18]int8)(unsafe.Pointer(ts + 24753 /* "nk_tree_state_po..." */)) /* nuklear.h:22180:1 */

func Xnk_tree_push_hashed(ctx uintptr, type1 uint32, title uintptr, initial_state uint32, hash uintptr, len int32, line int32) Nk_bool { /* nuklear.h:22198:1: */
	return nk_tree_base(ctx, type1, uintptr(0), title, initial_state, hash, len, line)
}

func Xnk_tree_image_push_hashed(ctx uintptr, type1 uint32, img Nk_image, title uintptr, initial_state uint32, hash uintptr, len int32, seed int32) Nk_bool { /* nuklear.h:22205:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_image)(unsafe.Pointer(bp)) = img

	return nk_tree_base(ctx, type1, bp /* &img */, title, initial_state, hash, len, seed)
}

func Xnk_tree_pop(ctx uintptr) { /* nuklear.h:22212:1: */
	Xnk_tree_state_pop(ctx)
}

func nk_tree_element_image_push_hashed_base(ctx uintptr, type1 uint32, img uintptr, title uintptr, title_len int32, state uintptr, selected uintptr) int32 { /* nuklear.h:22217:1: */
	bp := tlsAlloc(40)
	defer tlsFree(40)

	var win uintptr
	var layout uintptr
	var style uintptr
	var out uintptr
	var in uintptr
	var button uintptr
	var symbol uint32
	var row_height float32
	var padding Nk_vec2
	var text_len int32
	var text_width float32
	var item_spacing Nk_vec2
	*(*Nk_rect)(unsafe.Pointer(bp /* header */)) = Nk_rect{}
	*(*Nk_rect)(unsafe.Pointer(bp + 16 /* sym */)) = Nk_rect{}

	*(*Nk_flags)(unsafe.Pointer(bp + 32 /* ws */)) = Nk_flags(0)
	var widget_state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22241), uintptr(unsafe.Pointer(&__func__285)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22242), uintptr(unsafe.Pointer(&__func__285)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22243), uintptr(unsafe.Pointer(&__func__285)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	// cache some data
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	out = (win + 100 /* &.buffer */)
	style = (ctx + 360 /* &.style */)
	item_spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing
	padding = (*Nk_style)(unsafe.Pointer(style)).Selectable.Padding

	// calculate header bounds and draw background
	row_height = ((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.Y))
	Xnk_layout_set_min_row_height(ctx, row_height)
	Xnk_layout_row_dynamic(ctx, row_height, 1)
	Xnk_layout_reset_min_row_height(ctx)

	widget_state = Xnk_widget(bp /* &header */, ctx)
	if int32(type1) == NK_TREE_TAB {
		var background uintptr = (style + 3996 /* &.tab */ /* &.background */)
		if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
			Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
		} else {
			Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* header */)), float32(0), (*Nk_style)(unsafe.Pointer(style)).Tab.Border_color)
			Xnk_fill_rect(out, nk_shrink_rect(*(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Tab.Border),
				(*Nk_style)(unsafe.Pointer(style)).Tab.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		}
	}

	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = (ctx /* &.input */)
	} else {
		in = uintptr(0)
	}
	if (in != 0) && (int32(widget_state) == NK_WIDGET_VALID) {
		in = (ctx /* &.input */)
	} else {
		in = uintptr(0)
	}

	// select correct button style
	if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
		symbol = (*Nk_style)(unsafe.Pointer(style)).Tab.Sym_maximize
		if int32(type1) == NK_TREE_TAB {
			button = (style + 3996 /* &.tab */ + 28 /* &.tab_maximize_button */)
		} else {
			button = (style + 3996 /* &.tab */ + 284 /* &.node_maximize_button */)
		}
	} else {
		symbol = (*Nk_style)(unsafe.Pointer(style)).Tab.Sym_minimize
		if int32(type1) == NK_TREE_TAB {
			button = (style + 3996 /* &.tab */ + 156 /* &.tab_minimize_button */)
		} else {
			button = (style + 3996 /* &.tab */ + 412 /* &.node_minimize_button */)
		}
	}
	{ // draw triangle button
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &sym */)).W = AssignPtrFloat32(bp+16 /* &sym */ +12 /* &.h */, (*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &sym */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &sym */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Tab.Padding.X)
		if nk_do_button_symbol(bp+32 /* &ws */, (win+100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 16 /* sym */)), symbol, NK_BUTTON_DEFAULT, button, in, (*Nk_style)(unsafe.Pointer(style)).Font) != 0 {
			*(*uint32)(unsafe.Pointer(state)) = func() uint32 {
				if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
					return NK_MINIMIZED
				}
				return NK_MAXIMIZED
			}()
		}
	}

	/* draw label */
	{
		*(*Nk_flags)(unsafe.Pointer(bp + 36 /* dummy */)) = Nk_flags(0)
		var label Nk_rect
		// calculate size of the text and tooltip
		text_len = Xnk_strlen(title)
		text_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer(((*Nk_style)(unsafe.Pointer(style)).Font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Userdata, (*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height, title, text_len)
		text_width = text_width + (float32(4) * padding.X)

		(*Nk_rect)(unsafe.Pointer(bp /* &header */)).W = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) < ((*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).W + item_spacing.X) {
				return ((*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).W + item_spacing.X)
			}
			return (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W
		}()
		label.X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).W) + item_spacing.X)
		label.Y = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &sym */)).Y
		label.W = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (((*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).W + item_spacing.Y) + (*Nk_style)(unsafe.Pointer(style)).Tab.Indent)) < (text_width) {
				return ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (((*Nk_rect)(unsafe.Pointer(bp+16 /* &sym */)).W + item_spacing.Y) + (*Nk_style)(unsafe.Pointer(style)).Tab.Indent))
			}
			return text_width
		}()
		label.H = (*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height

		if img != 0 {
			nk_do_selectable_image(bp+36 /* &dummy */, (win + 100 /* &.buffer */), label, title, title_len, NK_TEXT_LEFT,
				selected, img, (style + 760 /* &.selectable */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
		} else {
			nk_do_selectable(bp+36 /* &dummy */, (win + 100 /* &.buffer */), label, title, title_len, NK_TEXT_LEFT,
				selected, (style + 760 /* &.selectable */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
		}

	}
	// increase x-axis cursor widget position pointer
	if int32(*(*uint32)(unsafe.Pointer(state))) == NK_MAXIMIZED {
		(*Nk_panel)(unsafe.Pointer(layout)).At_x = (((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + float32(*(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(layout)).Offset_x)))) + (*Nk_style)(unsafe.Pointer(style)).Tab.Indent)
		(*Nk_panel)(unsafe.Pointer(layout)).Bounds.W = func() float32 {
			if ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.W) < ((*Nk_style)(unsafe.Pointer(style)).Tab.Indent) {
				return (*Nk_style)(unsafe.Pointer(style)).Tab.Indent
			}
			return (*Nk_panel)(unsafe.Pointer(layout)).Bounds.W
		}()
		*(*float32)(unsafe.Pointer(layout + 8 /* &.bounds */ + 8 /* &.w */)) -= ((*Nk_style)(unsafe.Pointer(style)).Tab.Indent + (*Nk_style)(unsafe.Pointer(style)).Window.Padding.X)
		(*Nk_panel)(unsafe.Pointer(layout)).Row.Tree_depth++
		return Nk_true
	} else {
		return Nk_false
	}
	return int32(0)
}

var __func__285 = *(*[39]int8)(unsafe.Pointer(ts + 24771 /* "nk_tree_element_..." */)) /* nuklear.h:22220:1 */

func nk_tree_element_base(ctx uintptr, type1 uint32, img uintptr, title uintptr, initial_state uint32, selected uintptr, hash uintptr, len int32, line int32) int32 { /* nuklear.h:22325:1: */
	var win uintptr = (*Nk_context)(unsafe.Pointer(ctx)).Current
	var title_len int32 = 0
	var tree_hash Nk_hash = Nk_hash(0)
	var state uintptr = uintptr(0)

	// retrieve tree state from internal widget state tables
	if !(hash != 0) {
		title_len = Xnk_strlen(title)
		tree_hash = Xnk_murmur_hash(title, title_len, Nk_hash(line))
	} else {
		tree_hash = Xnk_murmur_hash(hash, len, Nk_hash(line))
	}
	state = nk_find_value(win, tree_hash)
	if !(state != 0) {
		state = nk_add_value(ctx, win, tree_hash, uint32(0))
		*(*Nk_uint)(unsafe.Pointer(state)) = Nk_uint(initial_state)
	}
	return nk_tree_element_image_push_hashed_base(ctx, type1, img, title,
		Xnk_strlen(title), state, selected)
}

func Xnk_tree_element_push_hashed(ctx uintptr, type1 uint32, title uintptr, initial_state uint32, selected uintptr, hash uintptr, len int32, seed int32) Nk_bool { /* nuklear.h:22347:1: */
	return nk_tree_element_base(ctx, type1, uintptr(0), title, initial_state, selected, hash, len, seed)
}

func Xnk_tree_element_image_push_hashed(ctx uintptr, type1 uint32, img Nk_image, title uintptr, initial_state uint32, selected uintptr, hash uintptr, len int32, seed int32) Nk_bool { /* nuklear.h:22354:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_image)(unsafe.Pointer(bp)) = img

	return nk_tree_element_base(ctx, type1, bp /* &img */, title, initial_state, selected, hash, len, seed)
}

func Xnk_tree_element_pop(ctx uintptr) { /* nuklear.h:22361:1: */
	Xnk_tree_state_pop(ctx)
}

// ===============================================================
//
//                          GROUP
//
// ===============================================================
func Xnk_group_scrolled_offset_begin(ctx uintptr, x_offset uintptr, y_offset uintptr, title uintptr, flags Nk_flags) Nk_bool { /* nuklear.h:22376:1: */
	bp := tlsAlloc(404)
	defer tlsFree(404)

	// var bounds Nk_rect at bp, 16

	// var panel Nk_window at bp+16, 388

	var win uintptr

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	nk_panel_alloc_space(bp /* &bounds */, ctx)
	{
		var c uintptr = ((*Nk_window)(unsafe.Pointer(win)).Layout + 60 /* &.clip */)
		if !(((((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X < ((*Nk_rect)(unsafe.Pointer(c)).X + (*Nk_rect)(unsafe.Pointer(c)).W)) && ((*Nk_rect)(unsafe.Pointer(c)).X < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W))) && ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y < ((*Nk_rect)(unsafe.Pointer(c)).Y + (*Nk_rect)(unsafe.Pointer(c)).H))) && ((*Nk_rect)(unsafe.Pointer(c)).Y < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))) && !((flags & NK_WINDOW_MOVABLE) != 0) {
			return 0
		}
	}
	if ((*Nk_window)(unsafe.Pointer(win)).Flags & NK_WINDOW_ROM) != 0 {
		flags = flags | (NK_WINDOW_ROM)
	}

	// initialize a fake window to create the panel from
	nk_zero(bp+16 /* &panel */, uint32(unsafe.Sizeof(Nk_window{})))
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Bounds = *(*Nk_rect)(unsafe.Pointer(bp /* bounds */))
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Flags = flags
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Scrollbar.X = *(*Nk_uint)(unsafe.Pointer(x_offset))
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Scrollbar.Y = *(*Nk_uint)(unsafe.Pointer(y_offset))
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Buffer = (*Nk_window)(unsafe.Pointer(win)).Buffer
	(*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout = nk_create_panel(ctx)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = bp + 16 /* &panel */
	nk_panel_begin(ctx, func() uintptr {
		if (flags & NK_WINDOW_TITLE) != 0 {
			return title
		}
		return uintptr(0)
	}(), NK_PANEL_GROUP)

	(*Nk_window)(unsafe.Pointer(win)).Buffer = (*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Buffer
	(*Nk_window)(unsafe.Pointer(win)).Buffer.Clip = (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout)).Clip
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout)).Offset_x = x_offset
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout)).Offset_y = y_offset
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout)).Parent = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_window)(unsafe.Pointer(win)).Layout = (*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout

	(*Nk_context)(unsafe.Pointer(ctx)).Current = win
	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp+16 /* &panel */)).Layout)).Flags & NK_WINDOW_CLOSED) != 0) || (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp+16 /* &panel */)).Layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
		var f Nk_flags = (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(bp + 16 /* &panel */)).Layout)).Flags
		Xnk_group_scrolled_end(ctx)
		if (f & NK_WINDOW_CLOSED) != 0 {
			return NK_WINDOW_CLOSED
		}
		if (f & NK_WINDOW_MINIMIZED) != 0 {
			return NK_WINDOW_MINIMIZED
		}
	}
	return 1
}

func Xnk_group_scrolled_end(ctx uintptr) { /* nuklear.h:22425:1: */
	bp := tlsAlloc(404)
	defer tlsFree(404)

	var win uintptr
	var parent uintptr
	var g uintptr
	// var clip Nk_rect at bp+388, 16

	// var pan Nk_window at bp, 388

	var panel_padding Nk_vec2

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22435), uintptr(unsafe.Pointer(&__func__286)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22436), uintptr(unsafe.Pointer(&__func__286)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	// make sure nk_group_begin was called correctly
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22441), uintptr(unsafe.Pointer(&__func__286)))
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if (*Nk_window)(unsafe.Pointer(win)).Layout != 0 {
	} else {
		X__assert_fail(ts+24810 /* "win->layout" */, ts+2 /* "nuklear/nuklear...." */, uint32(22443), uintptr(unsafe.Pointer(&__func__286)))
	}
	g = (*Nk_window)(unsafe.Pointer(win)).Layout
	if (*Nk_panel)(unsafe.Pointer(g)).Parent != 0 {
	} else {
		X__assert_fail(ts+24822 /* "g->parent" */, ts+2 /* "nuklear/nuklear...." */, uint32(22445), uintptr(unsafe.Pointer(&__func__286)))
	}
	parent = (*Nk_panel)(unsafe.Pointer(g)).Parent

	// dummy window
	nk_zero(bp /* &pan */, uint32(unsafe.Sizeof(Nk_window{})))
	panel_padding = nk_panel_get_padding((ctx + 360 /* &.style */), NK_PANEL_GROUP)
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.Y = ((*Nk_panel)(unsafe.Pointer(g)).Bounds.Y - ((*Nk_panel)(unsafe.Pointer(g)).Header_height + (*Nk_panel)(unsafe.Pointer(g)).Menu.H))
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.X = ((*Nk_panel)(unsafe.Pointer(g)).Bounds.X - panel_padding.X)
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.W = ((*Nk_panel)(unsafe.Pointer(g)).Bounds.W + (float32(2) * panel_padding.X))
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.H = (((*Nk_panel)(unsafe.Pointer(g)).Bounds.H + (*Nk_panel)(unsafe.Pointer(g)).Header_height) + (*Nk_panel)(unsafe.Pointer(g)).Menu.H)
	if ((*Nk_panel)(unsafe.Pointer(g)).Flags & NK_WINDOW_BORDER) != 0 {
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ /* &.x */)) -= ((*Nk_panel)(unsafe.Pointer(g)).Border)
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ + 4 /* &.y */)) -= ((*Nk_panel)(unsafe.Pointer(g)).Border)
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ + 8 /* &.w */)) += (float32(2) * (*Nk_panel)(unsafe.Pointer(g)).Border)
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ + 12 /* &.h */)) += (float32(2) * (*Nk_panel)(unsafe.Pointer(g)).Border)
	}
	if !(((*Nk_panel)(unsafe.Pointer(g)).Flags & NK_WINDOW_NO_SCROLLBAR) != 0) {
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ + 8 /* &.w */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Scrollbar_size.X)
		*(*float32)(unsafe.Pointer(bp /* &pan */ + 76 /* &.bounds */ + 12 /* &.h */)) += ((*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Scrollbar_size.Y)
	}
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Scrollbar.X = *(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(g)).Offset_x))
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Scrollbar.Y = *(*Nk_uint)(unsafe.Pointer((*Nk_panel)(unsafe.Pointer(g)).Offset_y))
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Flags = (*Nk_panel)(unsafe.Pointer(g)).Flags
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Buffer = (*Nk_window)(unsafe.Pointer(win)).Buffer
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Layout = g
	(*Nk_window)(unsafe.Pointer(bp /* &pan */)).Parent = win
	(*Nk_context)(unsafe.Pointer(ctx)).Current = bp /* &pan */

	// make sure group has correct clipping rectangle
	nk_unify(bp+388 /* &clip */, (parent + 60 /* &.clip */), (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.X, (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.Y,
		((*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.X + (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.W), (((*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.Y + (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds.H) + panel_padding.X))
	Xnk_push_scissor((bp /* &pan */ + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 388 /* clip */)))
	Xnk_end(ctx)

	(*Nk_window)(unsafe.Pointer(win)).Buffer = (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Buffer
	Xnk_push_scissor((win + 100 /* &.buffer */), (*Nk_panel)(unsafe.Pointer(parent)).Clip)
	(*Nk_context)(unsafe.Pointer(ctx)).Current = win
	(*Nk_window)(unsafe.Pointer(win)).Layout = parent
	(*Nk_panel)(unsafe.Pointer(g)).Bounds = (*Nk_window)(unsafe.Pointer(bp /* &pan */)).Bounds
	return
}

var __func__286 = *(*[22]int8)(unsafe.Pointer(ts + 24832 /* "nk_group_scrolle..." */)) /* nuklear.h:22426:1 */

func Xnk_group_scrolled_begin(ctx uintptr, scroll uintptr, title uintptr, flags Nk_flags) Nk_bool { /* nuklear.h:22487:1: */
	return Xnk_group_scrolled_offset_begin(ctx, (scroll /* &.x */), (scroll + 4 /* &.y */), title, flags)
}

func Xnk_group_begin_titled(ctx uintptr, id uintptr, title uintptr, flags Nk_flags) Nk_bool { /* nuklear.h:22493:1: */
	var id_len int32
	var id_hash Nk_hash
	var win uintptr
	var x_offset uintptr
	var y_offset uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22502), uintptr(unsafe.Pointer(&__func__287)))
	}
	if id != 0 {
	} else {
		X__assert_fail(ts+24854 /* "id" */, ts+2 /* "nuklear/nuklear...." */, uint32(22503), uintptr(unsafe.Pointer(&__func__287)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22504), uintptr(unsafe.Pointer(&__func__287)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22505), uintptr(unsafe.Pointer(&__func__287)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(id != 0) {
		return 0
	}

	// find persistent group scrollbar value
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	id_len = Xnk_strlen(id)
	id_hash = Xnk_murmur_hash(id, id_len, NK_PANEL_GROUP)
	x_offset = nk_find_value(win, id_hash)
	if !(x_offset != 0) {
		x_offset = nk_add_value(ctx, win, id_hash, uint32(0))
		y_offset = nk_add_value(ctx, win, (id_hash + Nk_hash(1)), uint32(0))

		if x_offset != 0 {
		} else {
			X__assert_fail(ts+24857 /* "x_offset" */, ts+2 /* "nuklear/nuklear...." */, uint32(22518), uintptr(unsafe.Pointer(&__func__287)))
		}
		if y_offset != 0 {
		} else {
			X__assert_fail(ts+24866 /* "y_offset" */, ts+2 /* "nuklear/nuklear...." */, uint32(22519), uintptr(unsafe.Pointer(&__func__287)))
		}
		if !(x_offset != 0) || !(y_offset != 0) {
			return 0
		}
		*(*Nk_uint)(unsafe.Pointer(x_offset)) = AssignPtrUint32(y_offset, Nk_uint(0))
	} else {
		y_offset = nk_find_value(win, (id_hash + Nk_hash(1)))
	}
	return Xnk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags)
}

var __func__287 = *(*[22]int8)(unsafe.Pointer(ts + 24875 /* "nk_group_begin_t..." */)) /* nuklear.h:22495:1 */

func Xnk_group_begin(ctx uintptr, title uintptr, flags Nk_flags) Nk_bool { /* nuklear.h:22526:1: */
	return Xnk_group_begin_titled(ctx, title, title, flags)
}

func Xnk_group_end(ctx uintptr) { /* nuklear.h:22531:1: */
	Xnk_group_scrolled_end(ctx)
}

func Xnk_group_get_scroll(ctx uintptr, id uintptr, x_offset uintptr, y_offset uintptr) { /* nuklear.h:22536:1: */
	var id_len int32
	var id_hash Nk_hash
	var win uintptr
	var x_offset_ptr uintptr
	var y_offset_ptr uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22544), uintptr(unsafe.Pointer(&__func__288)))
	}
	if id != 0 {
	} else {
		X__assert_fail(ts+24854 /* "id" */, ts+2 /* "nuklear/nuklear...." */, uint32(22545), uintptr(unsafe.Pointer(&__func__288)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22546), uintptr(unsafe.Pointer(&__func__288)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22547), uintptr(unsafe.Pointer(&__func__288)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(id != 0) {
		return
	}

	// find persistent group scrollbar value
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	id_len = Xnk_strlen(id)
	id_hash = Xnk_murmur_hash(id, id_len, NK_PANEL_GROUP)
	x_offset_ptr = nk_find_value(win, id_hash)
	if !(x_offset_ptr != 0) {
		x_offset_ptr = nk_add_value(ctx, win, id_hash, uint32(0))
		y_offset_ptr = nk_add_value(ctx, win, (id_hash + Nk_hash(1)), uint32(0))

		if x_offset_ptr != 0 {
		} else {
			X__assert_fail(ts+24897 /* "x_offset_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(22560), uintptr(unsafe.Pointer(&__func__288)))
		}
		if y_offset_ptr != 0 {
		} else {
			X__assert_fail(ts+24910 /* "y_offset_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(22561), uintptr(unsafe.Pointer(&__func__288)))
		}
		if !(x_offset_ptr != 0) || !(y_offset_ptr != 0) {
			return
		}
		*(*Nk_uint)(unsafe.Pointer(x_offset_ptr)) = AssignPtrUint32(y_offset_ptr, Nk_uint(0))
	} else {
		y_offset_ptr = nk_find_value(win, (id_hash + Nk_hash(1)))
	}
	if x_offset != 0 {
		*(*Nk_uint)(unsafe.Pointer(x_offset)) = *(*Nk_uint)(unsafe.Pointer(x_offset_ptr))
	}
	if y_offset != 0 {
		*(*Nk_uint)(unsafe.Pointer(y_offset)) = *(*Nk_uint)(unsafe.Pointer(y_offset_ptr))
	}
}

var __func__288 = *(*[20]int8)(unsafe.Pointer(ts + 24923 /* "nk_group_get_scr..." */)) /* nuklear.h:22537:1 */

func Xnk_group_set_scroll(ctx uintptr, id uintptr, x_offset Nk_uint, y_offset Nk_uint) { /* nuklear.h:22571:1: */
	var id_len int32
	var id_hash Nk_hash
	var win uintptr
	var x_offset_ptr uintptr
	var y_offset_ptr uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22579), uintptr(unsafe.Pointer(&__func__289)))
	}
	if id != 0 {
	} else {
		X__assert_fail(ts+24854 /* "id" */, ts+2 /* "nuklear/nuklear...." */, uint32(22580), uintptr(unsafe.Pointer(&__func__289)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22581), uintptr(unsafe.Pointer(&__func__289)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22582), uintptr(unsafe.Pointer(&__func__289)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(id != 0) {
		return
	}

	// find persistent group scrollbar value
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	id_len = Xnk_strlen(id)
	id_hash = Xnk_murmur_hash(id, id_len, NK_PANEL_GROUP)
	x_offset_ptr = nk_find_value(win, id_hash)
	if !(x_offset_ptr != 0) {
		x_offset_ptr = nk_add_value(ctx, win, id_hash, uint32(0))
		y_offset_ptr = nk_add_value(ctx, win, (id_hash + Nk_hash(1)), uint32(0))

		if x_offset_ptr != 0 {
		} else {
			X__assert_fail(ts+24897 /* "x_offset_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(22595), uintptr(unsafe.Pointer(&__func__289)))
		}
		if y_offset_ptr != 0 {
		} else {
			X__assert_fail(ts+24910 /* "y_offset_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(22596), uintptr(unsafe.Pointer(&__func__289)))
		}
		if !(x_offset_ptr != 0) || !(y_offset_ptr != 0) {
			return
		}
		*(*Nk_uint)(unsafe.Pointer(x_offset_ptr)) = AssignPtrUint32(y_offset_ptr, Nk_uint(0))
	} else {
		y_offset_ptr = nk_find_value(win, (id_hash + Nk_hash(1)))
	}
	*(*Nk_uint)(unsafe.Pointer(x_offset_ptr)) = x_offset
	*(*Nk_uint)(unsafe.Pointer(y_offset_ptr)) = y_offset
}

var __func__289 = *(*[20]int8)(unsafe.Pointer(ts + 24943 /* "nk_group_set_scr..." */)) /* nuklear.h:22572:1 */

// ===============================================================
//
//                          LIST VIEW
//
// ===============================================================
func Xnk_list_view_begin(ctx uintptr, view uintptr, title uintptr, flags Nk_flags, row_height int32, row_count int32) Nk_bool { /* nuklear.h:22613:1: */
	var title_len int32
	var title_hash Nk_hash
	var x_offset uintptr
	var y_offset uintptr
	var result int32
	var win uintptr
	var layout uintptr
	var style uintptr
	var item_spacing Nk_vec2

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22627), uintptr(unsafe.Pointer(&__func__290)))
	}
	if view != 0 {
	} else {
		X__assert_fail(ts+24963 /* "view" */, ts+2 /* "nuklear/nuklear...." */, uint32(22628), uintptr(unsafe.Pointer(&__func__290)))
	}
	if title != 0 {
	} else {
		X__assert_fail(ts+22061 /* "title" */, ts+2 /* "nuklear/nuklear...." */, uint32(22629), uintptr(unsafe.Pointer(&__func__290)))
	}
	if (!(ctx != 0) || !(view != 0)) || !(title != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	item_spacing = (*Nk_style)(unsafe.Pointer(style)).Window.Spacing
	row_height = row_height + (func() int32 {
		if (0) < (int32(item_spacing.Y)) {
			return int32(item_spacing.Y)
		}
		return 0
	}())

	// find persistent list view scrollbar offset
	title_len = Xnk_strlen(title)
	title_hash = Xnk_murmur_hash(title, title_len, NK_PANEL_GROUP)
	x_offset = nk_find_value(win, title_hash)
	if !(x_offset != 0) {
		x_offset = nk_add_value(ctx, win, title_hash, uint32(0))
		y_offset = nk_add_value(ctx, win, (title_hash + Nk_hash(1)), uint32(0))

		if x_offset != 0 {
		} else {
			X__assert_fail(ts+24857 /* "x_offset" */, ts+2 /* "nuklear/nuklear...." */, uint32(22645), uintptr(unsafe.Pointer(&__func__290)))
		}
		if y_offset != 0 {
		} else {
			X__assert_fail(ts+24866 /* "y_offset" */, ts+2 /* "nuklear/nuklear...." */, uint32(22646), uintptr(unsafe.Pointer(&__func__290)))
		}
		if !(x_offset != 0) || !(y_offset != 0) {
			return 0
		}
		*(*Nk_uint)(unsafe.Pointer(x_offset)) = AssignPtrUint32(y_offset, Nk_uint(0))
	} else {
		y_offset = nk_find_value(win, (title_hash + Nk_hash(1)))
	}
	(*Nk_list_view)(unsafe.Pointer(view)).Scroll_value = *(*Nk_uint)(unsafe.Pointer(y_offset))
	(*Nk_list_view)(unsafe.Pointer(view)).Scroll_pointer = y_offset

	*(*Nk_uint)(unsafe.Pointer(y_offset)) = Nk_uint(0)
	result = Xnk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags)
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	(*Nk_list_view)(unsafe.Pointer(view)).Total_height = (row_height * (func() int32 {
		if (row_count) < (1) {
			return 1
		}
		return row_count
	}()))
	(*Nk_list_view)(unsafe.Pointer(view)).Begin = func() int32 {
		if (float32((*Nk_list_view)(unsafe.Pointer(view)).Scroll_value) / float32(row_height)) < (0.0) {
			return int32(0.0)
		}
		return (int32(float32((*Nk_list_view)(unsafe.Pointer(view)).Scroll_value) / float32(row_height)))
	}()
	(*Nk_list_view)(unsafe.Pointer(view)).Count = func() int32 {
		if (nk_iceilf((((*Nk_panel)(unsafe.Pointer(layout)).Clip.H) / float32(row_height)))) < (0) {
			return 0
		}
		return nk_iceilf((((*Nk_panel)(unsafe.Pointer(layout)).Clip.H) / float32(row_height)))
	}()
	(*Nk_list_view)(unsafe.Pointer(view)).Count = func() int32 {
		if ((*Nk_list_view)(unsafe.Pointer(view)).Count) < (row_count - (*Nk_list_view)(unsafe.Pointer(view)).Begin) {
			return (*Nk_list_view)(unsafe.Pointer(view)).Count
		}
		return (row_count - (*Nk_list_view)(unsafe.Pointer(view)).Begin)
	}()
	(*Nk_list_view)(unsafe.Pointer(view)).End = ((*Nk_list_view)(unsafe.Pointer(view)).Begin + (*Nk_list_view)(unsafe.Pointer(view)).Count)
	(*Nk_list_view)(unsafe.Pointer(view)).Ctx = ctx
	return result
}

var __func__290 = *(*[19]int8)(unsafe.Pointer(ts + 24968 /* "nk_list_view_beg..." */)) /* nuklear.h:22615:1 */

func Xnk_list_view_end(view uintptr) { /* nuklear.h:22667:1: */
	var ctx uintptr
	var win uintptr
	var layout uintptr

	if view != 0 {
	} else {
		X__assert_fail(ts+24963 /* "view" */, ts+2 /* "nuklear/nuklear...." */, uint32(22673), uintptr(unsafe.Pointer(&__func__291)))
	}
	if (*Nk_list_view)(unsafe.Pointer(view)).Ctx != 0 {
	} else {
		X__assert_fail(ts+24987 /* "view->ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22674), uintptr(unsafe.Pointer(&__func__291)))
	}
	if (*Nk_list_view)(unsafe.Pointer(view)).Scroll_pointer != 0 {
	} else {
		X__assert_fail(ts+24997 /* "view->scroll_poi..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22675), uintptr(unsafe.Pointer(&__func__291)))
	}
	if !(view != 0) || !(int32((*Nk_list_view)(unsafe.Pointer(view)).Ctx) != 0) {
		return
	}

	ctx = (*Nk_list_view)(unsafe.Pointer(view)).Ctx
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	(*Nk_panel)(unsafe.Pointer(layout)).At_y = ((*Nk_panel)(unsafe.Pointer(layout)).Bounds.Y + float32((*Nk_list_view)(unsafe.Pointer(view)).Total_height))
	*(*Nk_uint)(unsafe.Pointer((*Nk_list_view)(unsafe.Pointer(view)).Scroll_pointer)) = (*(*Nk_uint)(unsafe.Pointer((*Nk_list_view)(unsafe.Pointer(view)).Scroll_pointer)) + (*Nk_list_view)(unsafe.Pointer(view)).Scroll_value)
	Xnk_group_end((*Nk_list_view)(unsafe.Pointer(view)).Ctx)
}

var __func__291 = *(*[17]int8)(unsafe.Pointer(ts + 25018 /* "nk_list_view_end" */)) /* nuklear.h:22668:1 */

// ===============================================================
//
//                              WIDGET
//
// ===============================================================
func Xnk_widget_bounds(ctx uintptr) Nk_rect { /* nuklear.h:22696:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22699), uintptr(unsafe.Pointer(&__func__292)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22700), uintptr(unsafe.Pointer(&__func__292)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_rect(float32(0), float32(0), float32(0), float32(0))
	}
	nk_layout_peek(bp /* &bounds */, ctx)
	return *(*Nk_rect)(unsafe.Pointer(bp /* bounds */))
}

var __func__292 = *(*[17]int8)(unsafe.Pointer(ts + 25035 /* "nk_widget_bounds" */)) /* nuklear.h:22697:1 */

func Xnk_widget_position(ctx uintptr) Nk_vec2 { /* nuklear.h:22707:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22710), uintptr(unsafe.Pointer(&__func__293)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22711), uintptr(unsafe.Pointer(&__func__293)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}

	nk_layout_peek(bp /* &bounds */, ctx)
	return Xnk_vec2((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y)
}

var __func__293 = *(*[19]int8)(unsafe.Pointer(ts + 25052 /* "nk_widget_positi..." */)) /* nuklear.h:22708:1 */

func Xnk_widget_size(ctx uintptr) Nk_vec2 { /* nuklear.h:22719:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22722), uintptr(unsafe.Pointer(&__func__294)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22723), uintptr(unsafe.Pointer(&__func__294)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return Xnk_vec2(float32(0), float32(0))
	}

	nk_layout_peek(bp /* &bounds */, ctx)
	return Xnk_vec2((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H)
}

var __func__294 = *(*[15]int8)(unsafe.Pointer(ts + 25071 /* "nk_widget_size" */)) /* nuklear.h:22720:1 */

func Xnk_widget_width(ctx uintptr) float32 { /* nuklear.h:22731:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22734), uintptr(unsafe.Pointer(&__func__295)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22735), uintptr(unsafe.Pointer(&__func__295)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return float32(0)
	}

	nk_layout_peek(bp /* &bounds */, ctx)
	return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W
}

var __func__295 = *(*[16]int8)(unsafe.Pointer(ts + 25086 /* "nk_widget_width" */)) /* nuklear.h:22732:1 */

func Xnk_widget_height(ctx uintptr) float32 { /* nuklear.h:22743:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22746), uintptr(unsafe.Pointer(&__func__296)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22747), uintptr(unsafe.Pointer(&__func__296)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return float32(0)
	}

	nk_layout_peek(bp /* &bounds */, ctx)
	return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
}

var __func__296 = *(*[17]int8)(unsafe.Pointer(ts + 25102 /* "nk_widget_height" */)) /* nuklear.h:22744:1 */

func Xnk_widget_is_hovered(ctx uintptr) Nk_bool { /* nuklear.h:22755:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	// var c Nk_rect at bp+32, 16

	// var v Nk_rect at bp+16, 16

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22759), uintptr(unsafe.Pointer(&__func__297)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22760), uintptr(unsafe.Pointer(&__func__297)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || ((*Nk_context)(unsafe.Pointer(ctx)).Active != (*Nk_context)(unsafe.Pointer(ctx)).Current) {
		return 0
	}

	*(*Nk_rect)(unsafe.Pointer(bp + 32 /* c */)) = (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H))

	nk_layout_peek(bp /* &bounds */, ctx)
	nk_unify(bp+16 /* &v */, bp+32 /* &c */, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y, ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W), ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))
	if !(((((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).W)) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W))) && ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).H))) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))) {
		return 0
	}
	return Xnk_input_is_mouse_hovering_rect((ctx /* &.input */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)))
}

var __func__297 = *(*[21]int8)(unsafe.Pointer(ts + 25119 /* "nk_widget_is_hov..." */)) /* nuklear.h:22756:1 */

func Xnk_widget_is_mouse_clicked(ctx uintptr, btn uint32) Nk_bool { /* nuklear.h:22777:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	// var c Nk_rect at bp+32, 16

	// var v Nk_rect at bp+16, 16

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22781), uintptr(unsafe.Pointer(&__func__298)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22782), uintptr(unsafe.Pointer(&__func__298)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || ((*Nk_context)(unsafe.Pointer(ctx)).Active != (*Nk_context)(unsafe.Pointer(ctx)).Current) {
		return 0
	}

	*(*Nk_rect)(unsafe.Pointer(bp + 32 /* c */)) = (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H))

	nk_layout_peek(bp /* &bounds */, ctx)
	nk_unify(bp+16 /* &v */, bp+32 /* &c */, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y, ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W), ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))
	if !(((((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).W)) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W))) && ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).H))) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))) {
		return 0
	}
	return Xnk_input_mouse_clicked((ctx /* &.input */), btn, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)))
}

var __func__298 = *(*[27]int8)(unsafe.Pointer(ts + 25140 /* "nk_widget_is_mou..." */)) /* nuklear.h:22778:1 */

func Xnk_widget_has_mouse_click_down(ctx uintptr, btn uint32, down Nk_bool) Nk_bool { /* nuklear.h:22799:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	// var c Nk_rect at bp+32, 16

	// var v Nk_rect at bp+16, 16

	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22803), uintptr(unsafe.Pointer(&__func__299)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22804), uintptr(unsafe.Pointer(&__func__299)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || ((*Nk_context)(unsafe.Pointer(ctx)).Active != (*Nk_context)(unsafe.Pointer(ctx)).Current) {
		return 0
	}

	*(*Nk_rect)(unsafe.Pointer(bp + 32 /* c */)) = (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Clip
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).X))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).Y))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).W))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 32 /* &c */)).H))

	nk_layout_peek(bp /* &bounds */, ctx)
	nk_unify(bp+16 /* &v */, bp+32 /* &c */, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X, (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y, ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W), ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))
	if !(((((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).W)) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).X < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W))) && ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y < ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y + (*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).H))) && ((*Nk_rect)(unsafe.Pointer(bp+32 /* &c */)).Y < ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H))) {
		return 0
	}
	return Xnk_input_has_mouse_click_down_in_rect((ctx /* &.input */), btn, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), down)
}

var __func__299 = *(*[31]int8)(unsafe.Pointer(ts + 25167 /* "nk_widget_has_mo..." */)) /* nuklear.h:22800:1 */

func Xnk_widget(bounds uintptr, ctx uintptr) uint32 { /* nuklear.h:22821:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)

	// var c Nk_rect at bp+16, 16

	// var v Nk_rect at bp, 16

	var win uintptr
	var layout uintptr
	var in uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22828), uintptr(unsafe.Pointer(&__func__300)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22829), uintptr(unsafe.Pointer(&__func__300)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22830), uintptr(unsafe.Pointer(&__func__300)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return NK_WIDGET_INVALID
	}

	// allocate space and check if the widget needs to be updated and drawn
	nk_panel_alloc_space(bounds, ctx)
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	in = (ctx /* &.input */)
	*(*Nk_rect)(unsafe.Pointer(bp + 16 /* c */)) = (*Nk_panel)(unsafe.Pointer(layout)).Clip

	//  if one of these triggers you forgot to add an `if` condition around either
	//         a window, group, popup, combobox or contextual menu `begin` and `end` block.
	//         Example:
	//             if (nk_begin(...) {...} nk_end(...); or
	//             if (nk_group_begin(...) { nk_group_end(...);}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_MINIMIZED) != 0) {
	} else {
		X__assert_fail(ts+23777 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22846), uintptr(unsafe.Pointer(&__func__300)))
	}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_HIDDEN) != 0) {
	} else {
		X__assert_fail(ts+23816 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22847), uintptr(unsafe.Pointer(&__func__300)))
	}
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_CLOSED) != 0) {
	} else {
		X__assert_fail(ts+23852 /* "!(layout->flags ..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22848), uintptr(unsafe.Pointer(&__func__300)))
	}

	// need to convert to int here to remove floating point errors
	(*Nk_rect)(unsafe.Pointer(bounds)).X = float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).X))
	(*Nk_rect)(unsafe.Pointer(bounds)).Y = float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).Y))
	(*Nk_rect)(unsafe.Pointer(bounds)).W = float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).W))
	(*Nk_rect)(unsafe.Pointer(bounds)).H = float32(int32((*Nk_rect)(unsafe.Pointer(bounds)).H))

	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).X = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).X))
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).Y = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).Y))
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).W = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).W))
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).H = float32(int32((*Nk_rect)(unsafe.Pointer(bp + 16 /* &c */)).H))

	nk_unify(bp /* &v */, bp+16 /* &c */, (*Nk_rect)(unsafe.Pointer(bounds)).X, (*Nk_rect)(unsafe.Pointer(bounds)).Y, ((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W), ((*Nk_rect)(unsafe.Pointer(bounds)).Y + (*Nk_rect)(unsafe.Pointer(bounds)).H))
	if !(((((*Nk_rect)(unsafe.Pointer(bounds)).X < ((*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).W)) && ((*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).X < ((*Nk_rect)(unsafe.Pointer(bounds)).X + (*Nk_rect)(unsafe.Pointer(bounds)).W))) && ((*Nk_rect)(unsafe.Pointer(bounds)).Y < ((*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).Y + (*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).H))) && ((*Nk_rect)(unsafe.Pointer(bp+16 /* &c */)).Y < ((*Nk_rect)(unsafe.Pointer(bounds)).Y + (*Nk_rect)(unsafe.Pointer(bounds)).H))) {
		return NK_WIDGET_INVALID
	}
	if !(((((*Nk_rect)(unsafe.Pointer(bp /* &v */)).X) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X) < ((*Nk_rect)(unsafe.Pointer(bp /* &v */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &v */)).W))) && ((((*Nk_rect)(unsafe.Pointer(bp /* &v */)).Y) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y) < ((*Nk_rect)(unsafe.Pointer(bp /* &v */)).Y + (*Nk_rect)(unsafe.Pointer(bp /* &v */)).H)))) {
		return NK_WIDGET_ROM
	}
	return NK_WIDGET_VALID
}

var __func__300 = *(*[10]int8)(unsafe.Pointer(ts + 25198 /* "nk_widget" */)) /* nuklear.h:22822:1 */

func Xnk_widget_fitting(bounds uintptr, ctx uintptr, item_padding Nk_vec2) uint32 { /* nuklear.h:22869:1: */
	// update the bounds to stand without padding
	var state uint32
	_ = item_padding

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22876), uintptr(unsafe.Pointer(&__func__301)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22877), uintptr(unsafe.Pointer(&__func__301)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22878), uintptr(unsafe.Pointer(&__func__301)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return NK_WIDGET_INVALID
	}

	state = Xnk_widget(bounds, ctx)
	return state
}

var __func__301 = *(*[18]int8)(unsafe.Pointer(ts + 25208 /* "nk_widget_fittin..." */)) /* nuklear.h:22871:1 */

func Xnk_spacing(ctx uintptr, cols int32) { /* nuklear.h:22886:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	// var none Nk_rect at bp, 16

	var i int32
	var index int32
	var rows int32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(22893), uintptr(unsafe.Pointer(&__func__302)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(22894), uintptr(unsafe.Pointer(&__func__302)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(22895), uintptr(unsafe.Pointer(&__func__302)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	// spacing over row boundaries
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	index = (((*Nk_panel)(unsafe.Pointer(layout)).Row.Index + cols) % (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns)
	rows = (((*Nk_panel)(unsafe.Pointer(layout)).Row.Index + cols) / (*Nk_panel)(unsafe.Pointer(layout)).Row.Columns)
	if rows != 0 {
		for i = 0; i < rows; i++ {
			nk_panel_alloc_row(ctx, win)
		}
		cols = index
	}
	// non table layout need to allocate space
	if (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_DYNAMIC_FIXED) && (int32((*Nk_panel)(unsafe.Pointer(layout)).Row.Type) != NK_LAYOUT_STATIC_FIXED) {
		for i = 0; i < cols; i++ {
			nk_panel_alloc_space(bp /* &none */, ctx)
		}
	}
	(*Nk_panel)(unsafe.Pointer(layout)).Row.Index = index
}

var __func__302 = *(*[11]int8)(unsafe.Pointer(ts + 25226 /* "nk_spacing" */)) /* nuklear.h:22887:1 */

// ===============================================================
//
//                              TEXT
//
// ===============================================================
func nk_widget_text(o uintptr, b Nk_rect, string uintptr, len int32, t uintptr, a Nk_flags, f uintptr) { /* nuklear.h:22927:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var label Nk_rect at bp, 16

	var text_width float32

	if o != 0 {
	} else {
		X__assert_fail(ts+25237 /* "o" */, ts+2 /* "nuklear/nuklear...." */, uint32(22934), uintptr(unsafe.Pointer(&__func__303)))
	}
	if t != 0 {
	} else {
		X__assert_fail(ts+25239 /* "t" */, ts+2 /* "nuklear/nuklear...." */, uint32(22935), uintptr(unsafe.Pointer(&__func__303)))
	}
	if !(o != 0) || !(t != 0) {
		return
	}

	b.H = func() float32 {
		if (b.H) < (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y) {
			return (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y)
		}
		return b.H
	}()
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = float32(0)
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = float32(0)
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).Y = (b.Y + (*Nk_text)(unsafe.Pointer(t)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).H = func() float32 {
		if ((*Nk_user_font)(unsafe.Pointer(f)).Height) < (b.H - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y)) {
			return (*Nk_user_font)(unsafe.Pointer(f)).Height
		}
		return (b.H - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y))
	}()

	text_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((f + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(f)).Userdata, (*Nk_user_font)(unsafe.Pointer(f)).Height, string, len)
	text_width = text_width + (2.0 * (*Nk_text)(unsafe.Pointer(t)).Padding.X)

	// align in x-axis
	if (a & NK_TEXT_ALIGN_LEFT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = func() float32 {
			if (float32(0)) < (b.W - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X)) {
				return (b.W - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X))
			}
			return float32(0)
		}()
	} else if (a & NK_TEXT_ALIGN_CENTERED) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = func() float32 {
			if (float32(1)) < ((float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X) + text_width) {
				return ((float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X) + text_width)
			}
			return float32(1)
		}()
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = ((b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X) + (((b.W - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X)) - (*Nk_rect)(unsafe.Pointer(bp /* &label */)).W) / float32(2)))
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = func() float32 {
			if (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X) < ((*Nk_rect)(unsafe.Pointer(bp /* &label */)).X) {
				return (*Nk_rect)(unsafe.Pointer(bp /* &label */)).X
			}
			return (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X)
		}()
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = func() float32 {
			if (b.X + b.W) < ((*Nk_rect)(unsafe.Pointer(bp /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &label */)).W) {
				return (b.X + b.W)
			}
			return ((*Nk_rect)(unsafe.Pointer(bp /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &label */)).W)
		}()
		if (*Nk_rect)(unsafe.Pointer(bp /* &label */)).W >= (*Nk_rect)(unsafe.Pointer(bp /* &label */)).X {
			*(*float32)(unsafe.Pointer(bp /* &label */ + 8 /* &.w */)) -= ((*Nk_rect)(unsafe.Pointer(bp /* &label */)).X)
		}
	} else if (a & NK_TEXT_ALIGN_RIGHT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = func() float32 {
			if (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X) < ((b.X + b.W) - ((float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X) + text_width)) {
				return ((b.X + b.W) - ((float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X) + text_width))
			}
			return (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X)
		}()
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = (text_width + (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X))
	} else {
		return
	}

	// align in y-axis
	if (a & NK_TEXT_ALIGN_MIDDLE) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).Y = ((b.Y + (b.H / 2.0)) - ((*Nk_user_font)(unsafe.Pointer(f)).Height / 2.0))
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).H = func() float32 {
			if (b.H / 2.0) < (b.H - ((b.H / 2.0) + ((*Nk_user_font)(unsafe.Pointer(f)).Height / 2.0))) {
				return (b.H - ((b.H / 2.0) + ((*Nk_user_font)(unsafe.Pointer(f)).Height / 2.0)))
			}
			return (b.H / 2.0)
		}()
	} else if (a & NK_TEXT_ALIGN_BOTTOM) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).Y = ((b.Y + b.H) - (*Nk_user_font)(unsafe.Pointer(f)).Height)
		(*Nk_rect)(unsafe.Pointer(bp /* &label */)).H = (*Nk_user_font)(unsafe.Pointer(f)).Height
	}
	Xnk_draw_text(o, *(*Nk_rect)(unsafe.Pointer(bp /* label */)), string, len, f, (*Nk_text)(unsafe.Pointer(t)).Background, (*Nk_text)(unsafe.Pointer(t)).Text)
}

var __func__303 = *(*[15]int8)(unsafe.Pointer(ts + 25241 /* "nk_widget_text" */)) /* nuklear.h:22930:1 */

func nk_widget_text_wrap(o uintptr, b Nk_rect, string uintptr, len int32, t uintptr, f uintptr) { /* nuklear.h:22972:1: */
	bp := tlsAlloc(40)
	defer tlsFree(40)

	// var width float32 at bp+4, 4

	*(*int32)(unsafe.Pointer(bp /* glyphs */)) = 0
	var fitting int32 = 0
	var done int32 = 0
	// var line Nk_rect at bp+24, 16

	// var text Nk_text at bp+8, 16

	if o != 0 {
	} else {
		X__assert_fail(ts+25237 /* "o" */, ts+2 /* "nuklear/nuklear...." */, uint32(22984), uintptr(unsafe.Pointer(&__func__304)))
	}
	if t != 0 {
	} else {
		X__assert_fail(ts+25239 /* "t" */, ts+2 /* "nuklear/nuklear...." */, uint32(22985), uintptr(unsafe.Pointer(&__func__304)))
	}
	if !(o != 0) || !(t != 0) {
		return
	}

	(*Nk_text)(unsafe.Pointer(bp + 8 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
	(*Nk_text)(unsafe.Pointer(bp + 8 /* &text */)).Background = (*Nk_text)(unsafe.Pointer(t)).Background
	(*Nk_text)(unsafe.Pointer(bp + 8 /* &text */)).Text = (*Nk_text)(unsafe.Pointer(t)).Text

	b.W = func() float32 {
		if (b.W) < (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X) {
			return (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X)
		}
		return b.W
	}()
	b.H = func() float32 {
		if (b.H) < (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y) {
			return (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y)
		}
		return b.H
	}()
	b.H = (b.H - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y))

	(*Nk_rect)(unsafe.Pointer(bp + 24 /* &line */)).X = (b.X + (*Nk_text)(unsafe.Pointer(t)).Padding.X)
	(*Nk_rect)(unsafe.Pointer(bp + 24 /* &line */)).Y = (b.Y + (*Nk_text)(unsafe.Pointer(t)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp + 24 /* &line */)).W = (b.W - (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.X))
	(*Nk_rect)(unsafe.Pointer(bp + 24 /* &line */)).H = ((float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y) + (*Nk_user_font)(unsafe.Pointer(f)).Height)

	fitting = nk_text_clamp(f, string, len, (*Nk_rect)(unsafe.Pointer(bp+24 /* &line */)).W, bp /* &glyphs */, bp+4 /* &width */, uintptr(unsafe.Pointer(&seperator)), (int32(uint32(unsafe.Sizeof(seperator)) / uint32(unsafe.Sizeof(Nk_rune(0))))))
	for done < len {
		if !(fitting != 0) || (((*Nk_rect)(unsafe.Pointer(bp+24 /* &line */)).Y + (*Nk_rect)(unsafe.Pointer(bp+24 /* &line */)).H) >= (b.Y + b.H)) {
			break
		}
		nk_widget_text(o, *(*Nk_rect)(unsafe.Pointer(bp + 24 /* line */)), (string + uintptr(done)), fitting, bp+8 /* &text */, NK_TEXT_LEFT, f)
		done = done + (fitting)
		*(*float32)(unsafe.Pointer(bp + 24 /* &line */ + 4 /* &.y */)) += ((*Nk_user_font)(unsafe.Pointer(f)).Height + (float32(2) * (*Nk_text)(unsafe.Pointer(t)).Padding.Y))
		fitting = nk_text_clamp(f, (string + uintptr(done)), (len - done), (*Nk_rect)(unsafe.Pointer(bp+24 /* &line */)).W, bp /* &glyphs */, bp+4 /* &width */, uintptr(unsafe.Pointer(&seperator)), (int32(uint32(unsafe.Sizeof(seperator)) / uint32(unsafe.Sizeof(Nk_rune(0))))))
	}
}

var __func__304 = *(*[20]int8)(unsafe.Pointer(ts + 25256 /* "nk_widget_text_w..." */)) /* nuklear.h:22975:1 */
var seperator = [1]Nk_rune{Nk_rune(' ')}                                               /* nuklear.h:22982:23 */

func Xnk_text_colored(ctx uintptr, str uintptr, len int32, alignment Nk_flags, color Nk_color) { /* nuklear.h:23011:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)

	var win uintptr
	var style uintptr
	var item_padding Nk_vec2
	// var bounds Nk_rect at bp, 16

	// var text Nk_text at bp+16, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23021), uintptr(unsafe.Pointer(&__func__305)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23022), uintptr(unsafe.Pointer(&__func__305)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23023), uintptr(unsafe.Pointer(&__func__305)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	nk_panel_alloc_space(bp /* &bounds */, ctx)
	item_padding = (*Nk_style)(unsafe.Pointer(style)).Text.Padding

	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Padding.X = item_padding.X
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Padding.Y = item_padding.Y
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Background = (*Nk_style)(unsafe.Pointer(style)).Window.Background
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Text = color
	nk_widget_text((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), str, len, bp+16 /* &text */, alignment, (*Nk_style)(unsafe.Pointer(style)).Font)
}

var __func__305 = *(*[16]int8)(unsafe.Pointer(ts + 25276 /* "nk_text_colored" */)) /* nuklear.h:23013:1 */

func Xnk_text_wrap_colored(ctx uintptr, str uintptr, len int32, color Nk_color) { /* nuklear.h:23038:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)

	var win uintptr
	var style uintptr
	var item_padding Nk_vec2
	// var bounds Nk_rect at bp, 16

	// var text Nk_text at bp+16, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23048), uintptr(unsafe.Pointer(&__func__306)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23049), uintptr(unsafe.Pointer(&__func__306)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23050), uintptr(unsafe.Pointer(&__func__306)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	nk_panel_alloc_space(bp /* &bounds */, ctx)
	item_padding = (*Nk_style)(unsafe.Pointer(style)).Text.Padding

	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Padding.X = item_padding.X
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Padding.Y = item_padding.Y
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Background = (*Nk_style)(unsafe.Pointer(style)).Window.Background
	(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Text = color
	nk_widget_text_wrap((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), str, len, bp+16 /* &text */, (*Nk_style)(unsafe.Pointer(style)).Font)
}

var __func__306 = *(*[21]int8)(unsafe.Pointer(ts + 25292 /* "nk_text_wrap_col..." */)) /* nuklear.h:23040:1 */

func Xnk_text(ctx uintptr, str uintptr, len int32, alignment Nk_flags) { /* nuklear.h:23175:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23177), uintptr(unsafe.Pointer(&__func__307)))
	}
	if !(ctx != 0) {
		return
	}
	Xnk_text_colored(ctx, str, len, alignment, (*Nk_context)(unsafe.Pointer(ctx)).Style.Text.Color)
}

var __func__307 = *(*[8]int8)(unsafe.Pointer(ts + 25313 /* "nk_text" */)) /* nuklear.h:23176:1 */

func Xnk_text_wrap(ctx uintptr, str uintptr, len int32) { /* nuklear.h:23182:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23184), uintptr(unsafe.Pointer(&__func__308)))
	}
	if !(ctx != 0) {
		return
	}
	Xnk_text_wrap_colored(ctx, str, len, (*Nk_context)(unsafe.Pointer(ctx)).Style.Text.Color)
}

var __func__308 = *(*[13]int8)(unsafe.Pointer(ts + 25321 /* "nk_text_wrap" */)) /* nuklear.h:23183:1 */

func Xnk_label(ctx uintptr, str uintptr, alignment Nk_flags) { /* nuklear.h:23189:1: */
	Xnk_text(ctx, str, Xnk_strlen(str), alignment)
}

func Xnk_label_colored(ctx uintptr, str uintptr, align Nk_flags, color Nk_color) { /* nuklear.h:23194:1: */
	Xnk_text_colored(ctx, str, Xnk_strlen(str), align, color)
}

func Xnk_label_wrap(ctx uintptr, str uintptr) { /* nuklear.h:23200:1: */
	Xnk_text_wrap(ctx, str, Xnk_strlen(str))
}

func Xnk_label_colored_wrap(ctx uintptr, str uintptr, color Nk_color) { /* nuklear.h:23205:1: */
	Xnk_text_wrap_colored(ctx, str, Xnk_strlen(str), color)
}

// ===============================================================
//
//                          IMAGE
//
// ===============================================================
func Xnk_handle_ptr(ptr uintptr) Nk_handle { /* nuklear.h:23220:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	*(*Nk_handle)(unsafe.Pointer(bp /* handle */)) = Nk_handle{}
	*(*uintptr)(unsafe.Pointer(bp /* &handle */)) = ptr
	return *(*Nk_handle)(unsafe.Pointer(bp /* handle */))
}

func Xnk_handle_id(id int32) Nk_handle { /* nuklear.h:23227:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var handle Nk_handle at bp, 4

	nk_zero(bp /* &handle */, uint32(unsafe.Sizeof(Nk_handle{})))
	*(*int32)(unsafe.Pointer(bp /* &handle */)) = id
	return *(*Nk_handle)(unsafe.Pointer(bp /* handle */))
}

func Xnk_subimage_ptr(ptr uintptr, w uint16, h uint16, r Nk_rect) Nk_image { /* nuklear.h:23235:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	*(*uintptr)(unsafe.Pointer(bp /* &s */ /* &.handle */)) = ptr
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = w
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = h
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(r.X)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(r.Y)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(r.W)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(r.H)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

func Xnk_subimage_id(id int32, w uint16, h uint16, r Nk_rect) Nk_image { /* nuklear.h:23248:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	*(*int32)(unsafe.Pointer(bp /* &s */ /* &.handle */)) = id
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = w
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = h
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(r.X)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(r.Y)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(r.W)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(r.H)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

func Xnk_subimage_handle(handle Nk_handle, w uint16, h uint16, r Nk_rect) Nk_image { /* nuklear.h:23261:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).Handle = handle
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = w
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = h
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(r.X)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(r.Y)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(r.W)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(r.H)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

func Xnk_image_handle(handle Nk_handle) Nk_image { /* nuklear.h:23275:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).Handle = handle
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = uint16(0)
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(0)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

func Xnk_image_ptr(ptr uintptr) Nk_image { /* nuklear.h:23288:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	if ptr != 0 {
	} else {
		X__assert_fail(ts+68 /* "ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(23292), uintptr(unsafe.Pointer(&__func__309)))
	}
	*(*uintptr)(unsafe.Pointer(bp /* &s */ /* &.handle */)) = ptr
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = uint16(0)
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(0)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

var __func__309 = *(*[13]int8)(unsafe.Pointer(ts + 25334 /* "nk_image_ptr" */)) /* nuklear.h:23289:1 */

func Xnk_image_id(id int32) Nk_image { /* nuklear.h:23302:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var s Nk_image at bp, 16

	nk_zero(bp /* &s */, uint32(unsafe.Sizeof(Nk_image{})))
	*(*int32)(unsafe.Pointer(bp /* &s */ /* &.handle */)) = id
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).W = uint16(0)
	(*Nk_image)(unsafe.Pointer(bp /* &s */)).H = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */))) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 1*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 2*2)) = uint16(0)
	*(*uint16)(unsafe.Pointer((bp /* &s */ + 8 /* &.region */) + 3*2)) = uint16(0)
	return *(*Nk_image)(unsafe.Pointer(bp /* s */))
}

func Xnk_image_is_subimage(img uintptr) Nk_bool { /* nuklear.h:23315:1: */
	if img != 0 {
	} else {
		X__assert_fail(ts+25347 /* "img" */, ts+2 /* "nuklear/nuklear...." */, uint32(23317), uintptr(unsafe.Pointer(&__func__310)))
	}
	return BoolInt32(!((int32((*Nk_image)(unsafe.Pointer(img)).W) == 0) && (int32((*Nk_image)(unsafe.Pointer(img)).H) == 0)))
}

var __func__310 = *(*[21]int8)(unsafe.Pointer(ts + 25351 /* "nk_image_is_subi..." */)) /* nuklear.h:23316:1 */

func Xnk_image(ctx uintptr, img Nk_image) { /* nuklear.h:23321:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_image)(unsafe.Pointer(bp + 16)) = img

	var win uintptr
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23326), uintptr(unsafe.Pointer(&__func__311)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23327), uintptr(unsafe.Pointer(&__func__311)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23328), uintptr(unsafe.Pointer(&__func__311)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if !(Xnk_widget(bp /* &bounds */, ctx) != 0) {
		return
	}
	Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), bp+16 /* &img */, nk_white)
}

var __func__311 = *(*[9]int8)(unsafe.Pointer(ts + 25372 /* "nk_image" */)) /* nuklear.h:23322:1 */

func Xnk_image_color(ctx uintptr, img Nk_image, col Nk_color) { /* nuklear.h:23336:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_image)(unsafe.Pointer(bp + 16)) = img

	var win uintptr
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23341), uintptr(unsafe.Pointer(&__func__312)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23342), uintptr(unsafe.Pointer(&__func__312)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23343), uintptr(unsafe.Pointer(&__func__312)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if !(Xnk_widget(bp /* &bounds */, ctx) != 0) {
		return
	}
	Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), bp+16 /* &img */, col)
}

var __func__312 = *(*[15]int8)(unsafe.Pointer(ts + 25381 /* "nk_image_color" */)) /* nuklear.h:23337:1 */

// ==============================================================
//
//                          BUTTON
//
// ===============================================================
func nk_draw_symbol(out uintptr, type1 uint32, content Nk_rect, background Nk_color, foreground Nk_color, border_width float32, font uintptr) { /* nuklear.h:23361:1: */
	bp := tlsAlloc(40)
	defer tlsFree(40)

	switch type1 {
	case NK_SYMBOL_X:
		fallthrough
	case NK_SYMBOL_UNDERSCORE:
		fallthrough
	case NK_SYMBOL_PLUS:
		fallthrough
	case NK_SYMBOL_MINUS:
		{
			// single character text symbol
			var X uintptr
			if int32(type1) == NK_SYMBOL_X {
				X = ts + 25396 /* "x" */
			} else {
				if int32(type1) == NK_SYMBOL_UNDERSCORE {
					X = ts + 25398 /* "_" */
				} else {
					if int32(type1) == NK_SYMBOL_PLUS {
						X = ts + 25400 /* "+" */
					} else {
						X = ts + 25402 /* "-" */
					}
				}
			}
			// var text Nk_text at bp, 16

			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = background
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = foreground
			nk_widget_text(out, content, X, 1, bp /* &text */, NK_TEXT_CENTERED, font)

		}
		break
	case NK_SYMBOL_CIRCLE_SOLID:
		fallthrough
	case NK_SYMBOL_CIRCLE_OUTLINE:
		fallthrough
	case NK_SYMBOL_RECT_SOLID:
		fallthrough
	case NK_SYMBOL_RECT_OUTLINE:
		{
			// simple empty/filled shapes
			if (int32(type1) == NK_SYMBOL_RECT_SOLID) || (int32(type1) == NK_SYMBOL_RECT_OUTLINE) {
				Xnk_fill_rect(out, content, float32(0), foreground)
				if int32(type1) == NK_SYMBOL_RECT_OUTLINE {
					Xnk_fill_rect(out, nk_shrink_rect(content, border_width), float32(0), background)
				}
			} else {
				Xnk_fill_circle(out, content, foreground)
				if int32(type1) == NK_SYMBOL_CIRCLE_OUTLINE {
					Xnk_fill_circle(out, nk_shrink_rect(content, float32(1)), background)
				}
			}

		}
		break
	case NK_SYMBOL_TRIANGLE_UP:
		fallthrough
	case NK_SYMBOL_TRIANGLE_DOWN:
		fallthrough
	case NK_SYMBOL_TRIANGLE_LEFT:
		fallthrough
	case NK_SYMBOL_TRIANGLE_RIGHT:
		{
			var heading uint32
			// var points [3]Nk_vec2 at bp+16, 24

			if int32(type1) == NK_SYMBOL_TRIANGLE_RIGHT {
				heading = NK_RIGHT
			} else {
				if int32(type1) == NK_SYMBOL_TRIANGLE_LEFT {
					heading = NK_LEFT
				} else {
					if int32(type1) == NK_SYMBOL_TRIANGLE_UP {
						heading = NK_UP
					} else {
						heading = NK_DOWN
					}
				}
			}
			Xnk_triangle_from_direction(bp+16 /* &points[0] */, content, float32(0), float32(0), heading)
			Xnk_fill_triangle(out, (*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */)).X, (*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */)).Y, (*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */ +1*8)).X, (*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */ +1*8)).Y,
				(*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */ +2*8)).X, (*Nk_vec2)(unsafe.Pointer(bp+16 /* &points */ +2*8)).Y, foreground)

		}
		break
	default:
		fallthrough
	case NK_SYMBOL_NONE:
		fallthrough
	case NK_SYMBOL_MAX:
		break
	}
}

func nk_button_behavior(state uintptr, r Nk_rect, i uintptr, behavior uint32) Nk_bool { /* nuklear.h:23414:1: */
	var ret int32 = 0
	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if !(i != 0) {
		return 0
	}
	if Xnk_input_is_mouse_hovering_rect(i, r) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
		if Xnk_input_is_mouse_down(i, NK_BUTTON_LEFT) != 0 {
			*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
		}
		if Xnk_input_has_mouse_click_in_rect(i, NK_BUTTON_LEFT, r) != 0 {
			if int32(behavior) != NK_BUTTON_DEFAULT {
				ret = Xnk_input_is_mouse_down(i, NK_BUTTON_LEFT)
			} else {
				ret = Xnk_input_is_mouse_pressed(i, NK_BUTTON_LEFT)
			}
		}
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(i, r) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(i, r) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return ret
}

func nk_draw_button(out uintptr, bounds uintptr, state Nk_flags, style uintptr) uintptr { /* nuklear.h:23440:34: */
	var background uintptr
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 40 /* &.active */)
	} else {
		background = (style /* &.normal */)
	}

	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_button)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_button)(unsafe.Pointer(style)).Rounding, (*Nk_style_button)(unsafe.Pointer(style)).Border, (*Nk_style_button)(unsafe.Pointer(style)).Border_color)
	}
	return background
}

func nk_do_button(state uintptr, out uintptr, r Nk_rect, style uintptr, in uintptr, behavior uint32, content uintptr) Nk_bool { /* nuklear.h:23461:1: */
	var bounds Nk_rect
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23466), uintptr(unsafe.Pointer(&__func__313)))
	}
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(23467), uintptr(unsafe.Pointer(&__func__313)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23468), uintptr(unsafe.Pointer(&__func__313)))
	}
	if !(out != 0) || !(style != 0) {
		return Nk_false
	}

	// calculate button content space
	(*Nk_rect)(unsafe.Pointer(content)).X = (((r.X + (*Nk_style_button)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_button)(unsafe.Pointer(style)).Border) + (*Nk_style_button)(unsafe.Pointer(style)).Rounding)
	(*Nk_rect)(unsafe.Pointer(content)).Y = (((r.Y + (*Nk_style_button)(unsafe.Pointer(style)).Padding.Y) + (*Nk_style_button)(unsafe.Pointer(style)).Border) + (*Nk_style_button)(unsafe.Pointer(style)).Rounding)
	(*Nk_rect)(unsafe.Pointer(content)).W = (r.W - (((float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_button)(unsafe.Pointer(style)).Border) + ((*Nk_style_button)(unsafe.Pointer(style)).Rounding * float32(2))))
	(*Nk_rect)(unsafe.Pointer(content)).H = (r.H - (((float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.Y) + (*Nk_style_button)(unsafe.Pointer(style)).Border) + ((*Nk_style_button)(unsafe.Pointer(style)).Rounding * float32(2))))

	// execute button behavior
	bounds.X = (r.X - (*Nk_style_button)(unsafe.Pointer(style)).Touch_padding.X)
	bounds.Y = (r.Y - (*Nk_style_button)(unsafe.Pointer(style)).Touch_padding.Y)
	bounds.W = (r.W + (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Touch_padding.X))
	bounds.H = (r.H + (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Touch_padding.Y))
	return nk_button_behavior(state, bounds, in, behavior)
}

var __func__313 = *(*[13]int8)(unsafe.Pointer(ts + 25420 /* "nk_do_button" */)) /* nuklear.h:23464:1 */

func nk_draw_button_text(out uintptr, bounds uintptr, content uintptr, state Nk_flags, style uintptr, txt uintptr, len int32, text_alignment Nk_flags, font uintptr) { /* nuklear.h:23486:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var text Nk_text at bp, 16

	var background uintptr
	background = nk_draw_button(out, bounds, state, style)

	// select correct colors/images
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = (*Nk_style_button)(unsafe.Pointer(style)).Text_background
	}
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_active
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_normal
	}

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(content)), txt, len, bp /* &text */, text_alignment, font)
}

func nk_do_button_text(state uintptr, out uintptr, bounds Nk_rect, string uintptr, len int32, align Nk_flags, behavior uint32, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:23509:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds

	// var content Nk_rect at bp, 16

	var ret int32 = Nk_false

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(23518), uintptr(unsafe.Pointer(&__func__314)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23519), uintptr(unsafe.Pointer(&__func__314)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23520), uintptr(unsafe.Pointer(&__func__314)))
	}
	if string != 0 {
	} else {
		X__assert_fail(ts+25433 /* "string" */, ts+2 /* "nuklear/nuklear...." */, uint32(23521), uintptr(unsafe.Pointer(&__func__314)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(23522), uintptr(unsafe.Pointer(&__func__314)))
	}
	if ((!(out != 0) || !(style != 0)) || !(font != 0)) || !(string != 0) {
		return Nk_false
	}

	ret = nk_do_button(state, out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)), style, in, behavior, bp /* &content */)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 120 /* &.draw_begin */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_button_text(out, bp+16 /* &bounds */, bp /* &content */, *(*Nk_flags)(unsafe.Pointer(state)), style, string, len, align, font)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 124 /* &.draw_end */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	return ret
}

var __func__314 = *(*[18]int8)(unsafe.Pointer(ts + 25440 /* "nk_do_button_tex..." */)) /* nuklear.h:23514:1 */

func nk_draw_button_symbol(out uintptr, bounds uintptr, content uintptr, state Nk_flags, style uintptr, type1 uint32, font uintptr) { /* nuklear.h:23533:1: */
	var sym Nk_color
	var bg Nk_color
	var background uintptr

	// select correct colors/images
	background = nk_draw_button(out, bounds, state, style)
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		bg = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
	} else {
		bg = (*Nk_style_button)(unsafe.Pointer(style)).Text_background
	}

	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_active
	} else {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_normal
	}
	nk_draw_symbol(out, type1, *(*Nk_rect)(unsafe.Pointer(content)), bg, sym, float32(1), font)
}

func nk_do_button_symbol(state uintptr, out uintptr, bounds Nk_rect, symbol uint32, behavior uint32, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:23555:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds

	var ret int32
	// var content Nk_rect at bp, 16

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(23564), uintptr(unsafe.Pointer(&__func__315)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23565), uintptr(unsafe.Pointer(&__func__315)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(23566), uintptr(unsafe.Pointer(&__func__315)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23567), uintptr(unsafe.Pointer(&__func__315)))
	}
	if ((!(out != 0) || !(style != 0)) || !(font != 0)) || !(state != 0) {
		return Nk_false
	}

	ret = nk_do_button(state, out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)), style, in, behavior, bp /* &content */)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 120 /* &.draw_begin */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_button_symbol(out, bp+16 /* &bounds */, bp /* &content */, *(*Nk_flags)(unsafe.Pointer(state)), style, symbol, font)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 124 /* &.draw_end */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	return ret
}

var __func__315 = *(*[20]int8)(unsafe.Pointer(ts + 25458 /* "nk_do_button_sym..." */)) /* nuklear.h:23560:1 */

func nk_draw_button_image(out uintptr, bounds uintptr, content uintptr, state Nk_flags, style uintptr, img uintptr) { /* nuklear.h:23578:1: */
	nk_draw_button(out, bounds, state, style)
	Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(content)), img, nk_white)
}

func nk_do_button_image(state uintptr, out uintptr, bounds Nk_rect, img Nk_image, b uint32, style uintptr, in uintptr) Nk_bool { /* nuklear.h:23586:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds
	*(*Nk_image)(unsafe.Pointer(bp + 32)) = img

	var ret int32
	// var content Nk_rect at bp, 16

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(23594), uintptr(unsafe.Pointer(&__func__316)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23595), uintptr(unsafe.Pointer(&__func__316)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23596), uintptr(unsafe.Pointer(&__func__316)))
	}
	if (!(out != 0) || !(style != 0)) || !(state != 0) {
		return Nk_false
	}

	ret = nk_do_button(state, out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)), style, in, b, bp /* &content */)
	*(*float32)(unsafe.Pointer(bp /* &content */ /* &.x */)) += ((*Nk_style_button)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &content */ + 4 /* &.y */)) += ((*Nk_style_button)(unsafe.Pointer(style)).Image_padding.Y)
	*(*float32)(unsafe.Pointer(bp /* &content */ + 8 /* &.w */)) -= (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &content */ + 12 /* &.h */)) -= (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Image_padding.Y)

	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 120 /* &.draw_begin */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_button_image(out, bp+16 /* &bounds */, bp /* &content */, *(*Nk_flags)(unsafe.Pointer(state)), style, bp+32 /* &img */)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 124 /* &.draw_end */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	return ret
}

var __func__316 = *(*[19]int8)(unsafe.Pointer(ts + 25478 /* "nk_do_button_ima..." */)) /* nuklear.h:23590:1 */

func nk_draw_button_text_symbol(out uintptr, bounds uintptr, label uintptr, symbol uintptr, state Nk_flags, style uintptr, str uintptr, len int32, type1 uint32, font uintptr) { /* nuklear.h:23612:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var sym Nk_color
	// var text Nk_text at bp, 16

	var background uintptr

	// select correct background colors/images
	background = nk_draw_button(out, bounds, state, style)
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = (*Nk_style_button)(unsafe.Pointer(style)).Text_background
	}

	// select correct text colors
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_hover
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_active
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_active
	} else {
		sym = (*Nk_style_button)(unsafe.Pointer(style)).Text_normal
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_normal
	}

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
	nk_draw_symbol(out, type1, *(*Nk_rect)(unsafe.Pointer(symbol)), (*Nk_style_button)(unsafe.Pointer(style)).Text_background, sym, float32(0), font)
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(label)), str, len, bp /* &text */, NK_TEXT_CENTERED, font)
}

func nk_do_button_text_symbol(state uintptr, out uintptr, bounds Nk_rect, symbol uint32, str uintptr, len int32, align Nk_flags, behavior uint32, style uintptr, font uintptr, in uintptr) Nk_bool { /* nuklear.h:23645:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds

	var ret int32
	*(*Nk_rect)(unsafe.Pointer(bp + 32 /* tri */)) = Nk_rect{}
	// var content Nk_rect at bp, 16

	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23655), uintptr(unsafe.Pointer(&__func__317)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23656), uintptr(unsafe.Pointer(&__func__317)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(23657), uintptr(unsafe.Pointer(&__func__317)))
	}
	if (!(out != 0) || !(style != 0)) || !(font != 0) {
		return Nk_false
	}

	ret = nk_do_button(state, out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)), style, in, behavior, bp /* &content */)
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).Y = (((*Nk_rect)(unsafe.Pointer(bp /* &content */)).Y + ((*Nk_rect)(unsafe.Pointer(bp /* &content */)).H / float32(2))) - ((*Nk_user_font)(unsafe.Pointer(font)).Height / float32(2)))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).W = (*Nk_user_font)(unsafe.Pointer(font)).Height
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).H = (*Nk_user_font)(unsafe.Pointer(font)).Height
	if (align & NK_TEXT_ALIGN_LEFT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).X = (((*Nk_rect)(unsafe.Pointer(bp /* &content */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &content */)).W) - ((float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.X) + (*Nk_rect)(unsafe.Pointer(bp+32 /* &tri */)).W))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).X = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).X) < (float32(0)) {
				return float32(0)
			}
			return (*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).X
		}()
	} else {
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &tri */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &content */)).X + (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.X))
	}

	// draw button
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 120 /* &.draw_begin */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_button_text_symbol(out, bp+16 /* &bounds */, bp /* &content */, bp+32, /* &tri */
		*(*Nk_flags)(unsafe.Pointer(state)), style, str, len, symbol, font)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 124 /* &.draw_end */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	return ret
}

var __func__317 = *(*[25]int8)(unsafe.Pointer(ts + 25497 /* "nk_do_button_tex..." */)) /* nuklear.h:23650:1 */

func nk_draw_button_text_image(out uintptr, bounds uintptr, label uintptr, image uintptr, state Nk_flags, style uintptr, str uintptr, len int32, font uintptr, img uintptr) { /* nuklear.h:23677:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var text Nk_text at bp, 16

	var background uintptr
	background = nk_draw_button(out, bounds, state, style)

	// select correct colors
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = (*Nk_style_button)(unsafe.Pointer(style)).Text_background
	}
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_active
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_button)(unsafe.Pointer(style)).Text_normal
	}

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(label)), str, len, bp /* &text */, NK_TEXT_CENTERED, font)
	Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(image)), img, nk_white)
}

func nk_do_button_text_image(state uintptr, out uintptr, bounds Nk_rect, img Nk_image, str uintptr, len int32, align Nk_flags, behavior uint32, style uintptr, font uintptr, in uintptr) Nk_bool { /* nuklear.h:23702:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)
	*(*Nk_rect)(unsafe.Pointer(bp + 32)) = bounds
	*(*Nk_image)(unsafe.Pointer(bp + 48)) = img

	var ret int32
	// var icon Nk_rect at bp+16, 16

	// var content Nk_rect at bp, 16

	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23712), uintptr(unsafe.Pointer(&__func__318)))
	}
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(23713), uintptr(unsafe.Pointer(&__func__318)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(23714), uintptr(unsafe.Pointer(&__func__318)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(23715), uintptr(unsafe.Pointer(&__func__318)))
	}
	if ((!(out != 0) || !(font != 0)) || !(style != 0)) || !(str != 0) {
		return Nk_false
	}

	ret = nk_do_button(state, out, *(*Nk_rect)(unsafe.Pointer(bp + 32 /* bounds */)), style, in, behavior, bp /* &content */)
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).Y + (*Nk_style_button)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).W = AssignPtrFloat32(bp+16 /* &icon */ +12 /* &.h */, ((*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).H - (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.Y)))
	if (align & NK_TEXT_ALIGN_LEFT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).X = (((*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).W) - ((float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.X) + (*Nk_rect)(unsafe.Pointer(bp+16 /* &icon */)).W))
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).X = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).X) < (float32(0)) {
				return float32(0)
			}
			return (*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).X
		}()
	} else {
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &icon */)).X = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).X + (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Padding.X))
	}

	*(*float32)(unsafe.Pointer(bp + 16 /* &icon */ /* &.x */)) += ((*Nk_style_button)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp + 16 /* &icon */ + 4 /* &.y */)) += ((*Nk_style_button)(unsafe.Pointer(style)).Image_padding.Y)
	*(*float32)(unsafe.Pointer(bp + 16 /* &icon */ + 8 /* &.w */)) -= (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp + 16 /* &icon */ + 12 /* &.h */)) -= (float32(2) * (*Nk_style_button)(unsafe.Pointer(style)).Image_padding.Y)

	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 120 /* &.draw_begin */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_button_text_image(out, bp+32 /* &bounds */, bp /* &content */, bp+16 /* &icon */, *(*Nk_flags)(unsafe.Pointer(state)), style, str, len, font, bp+48 /* &img */)
	if (*Nk_style_button)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 124 /* &.draw_end */))))(out, (*Nk_style_button)(unsafe.Pointer(style)).Userdata)
	}
	return ret
}

var __func__318 = *(*[24]int8)(unsafe.Pointer(ts + 25522 /* "nk_do_button_tex..." */)) /* nuklear.h:23707:1 */

func Xnk_button_set_behavior(ctx uintptr, behavior uint32) { /* nuklear.h:23738:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23740), uintptr(unsafe.Pointer(&__func__319)))
	}
	if !(ctx != 0) {
		return
	}
	(*Nk_context)(unsafe.Pointer(ctx)).Button_behavior = behavior
}

var __func__319 = *(*[23]int8)(unsafe.Pointer(ts + 25546 /* "nk_button_set_be..." */)) /* nuklear.h:23739:1 */

func Xnk_button_push_behavior(ctx uintptr, behavior uint32) Nk_bool { /* nuklear.h:23745:1: */
	var button_stack uintptr
	var element uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23750), uintptr(unsafe.Pointer(&__func__320)))
	}
	if !(ctx != 0) {
		return 0
	}

	button_stack = (ctx + 5828 /* &.stacks */ + 1432 /* &.button_behaviors */)
	if (*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head < (int32(uint32(unsafe.Sizeof([8]Nk_config_stack_button_behavior_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_button_behavior_element{})))) {
	} else {
		X__assert_fail(ts+25569 /* "button_stack->he..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23754), uintptr(unsafe.Pointer(&__func__320)))
	}
	if (*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head >= (int32(uint32(unsafe.Sizeof([8]Nk_config_stack_button_behavior_element{})) / uint32(unsafe.Sizeof(Nk_config_stack_button_behavior_element{})))) {
		return 0
	}

	element = ((button_stack + 4 /* &.elements */) + uintptr(PostIncInt32(&(*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head, 1))*8)
	(*Nk_config_stack_button_behavior_element)(unsafe.Pointer(element)).Address = (ctx + 5824 /* &.button_behavior */)
	(*Nk_config_stack_button_behavior_element)(unsafe.Pointer(element)).Old_value = (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior
	(*Nk_context)(unsafe.Pointer(ctx)).Button_behavior = behavior
	return 1
}

var __func__320 = *(*[24]int8)(unsafe.Pointer(ts + 25662 /* "nk_button_push_b..." */)) /* nuklear.h:23746:1 */

func Xnk_button_pop_behavior(ctx uintptr) Nk_bool { /* nuklear.h:23765:1: */
	var button_stack uintptr
	var element uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23770), uintptr(unsafe.Pointer(&__func__321)))
	}
	if !(ctx != 0) {
		return 0
	}

	button_stack = (ctx + 5828 /* &.stacks */ + 1432 /* &.button_behaviors */)
	if (*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head > 0 {
	} else {
		X__assert_fail(ts+25686 /* "button_stack->he..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23774), uintptr(unsafe.Pointer(&__func__321)))
	}
	if (*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head < 1 {
		return 0
	}

	element = ((button_stack + 4 /* &.elements */) + uintptr(PreDecInt32(&(*Nk_config_stack_button_behavior)(unsafe.Pointer(button_stack)).Head, 1))*8)
	*(*uint32)(unsafe.Pointer((*Nk_config_stack_button_behavior_element)(unsafe.Pointer(element)).Address)) = (*Nk_config_stack_button_behavior_element)(unsafe.Pointer(element)).Old_value
	return 1
}

var __func__321 = *(*[23]int8)(unsafe.Pointer(ts + 25709 /* "nk_button_pop_be..." */)) /* nuklear.h:23766:1 */

func Xnk_button_text_styled(ctx uintptr, style uintptr, title uintptr, len int32) Nk_bool { /* nuklear.h:23783:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23793), uintptr(unsafe.Pointer(&__func__322)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(23794), uintptr(unsafe.Pointer(&__func__322)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23795), uintptr(unsafe.Pointer(&__func__322)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23796), uintptr(unsafe.Pointer(&__func__322)))
	}
	if ((!(style != 0) || !(ctx != 0)) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	state = Xnk_widget(bp /* &bounds */, ctx)

	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_button_text((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		title, len, (*Nk_style_button)(unsafe.Pointer(style)).Text_alignment, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior,
		style, in, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font)
}

var __func__322 = *(*[22]int8)(unsafe.Pointer(ts + 25732 /* "nk_button_text_s..." */)) /* nuklear.h:23785:1 */

func Xnk_button_text(ctx uintptr, title uintptr, len int32) Nk_bool { /* nuklear.h:23810:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23812), uintptr(unsafe.Pointer(&__func__323)))
	}
	if !(ctx != 0) {
		return 0
	}
	return Xnk_button_text_styled(ctx, (ctx + 360 /* &.style */ + 56 /* &.button */), title, len)
}

var __func__323 = *(*[15]int8)(unsafe.Pointer(ts + 25754 /* "nk_button_text" */)) /* nuklear.h:23811:1 */

func Xnk_button_label_styled(ctx uintptr, style uintptr, title uintptr) Nk_bool { /* nuklear.h:23816:16: */
	return Xnk_button_text_styled(ctx, style, title, Xnk_strlen(title))
}

func Xnk_button_label(ctx uintptr, title uintptr) Nk_bool { /* nuklear.h:23821:16: */
	return Xnk_button_text(ctx, title, Xnk_strlen(title))
}

func Xnk_button_color(ctx uintptr, color Nk_color) Nk_bool { /* nuklear.h:23826:1: */
	bp := tlsAlloc(160)
	defer tlsFree(160)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var button Nk_style_button at bp+16, 128

	var ret int32 = 0
	// var bounds Nk_rect at bp, 16

	// var content Nk_rect at bp+144, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23838), uintptr(unsafe.Pointer(&__func__324)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23839), uintptr(unsafe.Pointer(&__func__324)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23840), uintptr(unsafe.Pointer(&__func__324)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}

	*(*Nk_style_button)(unsafe.Pointer(bp + 16 /* button */)) = (*Nk_context)(unsafe.Pointer(ctx)).Style.Button
	(*Nk_style_button)(unsafe.Pointer(bp + 16 /* &button */)).Normal = Xnk_style_item_color(color)
	(*Nk_style_button)(unsafe.Pointer(bp + 16 /* &button */)).Hover = Xnk_style_item_color(color)
	(*Nk_style_button)(unsafe.Pointer(bp + 16 /* &button */)).Active = Xnk_style_item_color(color)
	ret = nk_do_button((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		bp+16 /* &button */, in, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior, bp+144 /* &content */)
	nk_draw_button((win + 100 /* &.buffer */), bp /* &bounds */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state, bp+16 /* &button */)
	return ret
}

var __func__324 = *(*[16]int8)(unsafe.Pointer(ts + 25769 /* "nk_button_color" */)) /* nuklear.h:23827:1 */

func Xnk_button_symbol_styled(ctx uintptr, style uintptr, symbol uint32) Nk_bool { /* nuklear.h:23861:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23871), uintptr(unsafe.Pointer(&__func__325)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23872), uintptr(unsafe.Pointer(&__func__325)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23873), uintptr(unsafe.Pointer(&__func__325)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_button_symbol((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		symbol, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior, style, in, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font)
}

var __func__325 = *(*[24]int8)(unsafe.Pointer(ts + 25785 /* "nk_button_symbol..." */)) /* nuklear.h:23863:1 */

func Xnk_button_symbol(ctx uintptr, symbol uint32) Nk_bool { /* nuklear.h:23886:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23888), uintptr(unsafe.Pointer(&__func__326)))
	}
	if !(ctx != 0) {
		return 0
	}
	return Xnk_button_symbol_styled(ctx, (ctx + 360 /* &.style */ + 56 /* &.button */), symbol)
}

var __func__326 = *(*[17]int8)(unsafe.Pointer(ts + 25809 /* "nk_button_symbol" */)) /* nuklear.h:23887:1 */

func Xnk_button_image_styled(ctx uintptr, style uintptr, img Nk_image) Nk_bool { /* nuklear.h:23893:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23903), uintptr(unsafe.Pointer(&__func__327)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23904), uintptr(unsafe.Pointer(&__func__327)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23905), uintptr(unsafe.Pointer(&__func__327)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_button_image((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		img, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior, style, in)
}

var __func__327 = *(*[23]int8)(unsafe.Pointer(ts + 25826 /* "nk_button_image_..." */)) /* nuklear.h:23895:1 */

func Xnk_button_image(ctx uintptr, img Nk_image) Nk_bool { /* nuklear.h:23919:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23921), uintptr(unsafe.Pointer(&__func__328)))
	}
	if !(ctx != 0) {
		return 0
	}
	return Xnk_button_image_styled(ctx, (ctx + 360 /* &.style */ + 56 /* &.button */), img)
}

var __func__328 = *(*[16]int8)(unsafe.Pointer(ts + 25849 /* "nk_button_image" */)) /* nuklear.h:23920:1 */

func Xnk_button_symbol_text_styled(ctx uintptr, style uintptr, symbol uint32, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:23926:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23937), uintptr(unsafe.Pointer(&__func__329)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23938), uintptr(unsafe.Pointer(&__func__329)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23939), uintptr(unsafe.Pointer(&__func__329)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_button_text_symbol((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		symbol, text, len, align, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior,
		style, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font, in)
}

var __func__329 = *(*[29]int8)(unsafe.Pointer(ts + 25865 /* "nk_button_symbol..." */)) /* nuklear.h:23929:1 */

func Xnk_button_symbol_text(ctx uintptr, symbol uint32, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:23954:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23957), uintptr(unsafe.Pointer(&__func__330)))
	}
	if !(ctx != 0) {
		return 0
	}
	return Xnk_button_symbol_text_styled(ctx, (ctx + 360 /* &.style */ + 56 /* &.button */), symbol, text, len, align)
}

var __func__330 = *(*[22]int8)(unsafe.Pointer(ts + 25894 /* "nk_button_symbol..." */)) /* nuklear.h:23956:1 */

func Xnk_button_symbol_label(ctx uintptr, symbol uint32, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:23961:16: */
	return Xnk_button_symbol_text(ctx, symbol, label, Xnk_strlen(label), align)
}

func Xnk_button_symbol_label_styled(ctx uintptr, style uintptr, symbol uint32, title uintptr, align Nk_flags) Nk_bool { /* nuklear.h:23966:16: */
	return Xnk_button_symbol_text_styled(ctx, style, symbol, title, Xnk_strlen(title), align)
}

func Xnk_button_image_text_styled(ctx uintptr, style uintptr, img Nk_image, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:23973:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(23984), uintptr(unsafe.Pointer(&__func__331)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(23985), uintptr(unsafe.Pointer(&__func__331)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(23986), uintptr(unsafe.Pointer(&__func__331)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_button_text_image((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */),
		*(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), img, text, len, align, (*Nk_context)(unsafe.Pointer(ctx)).Button_behavior,
		style, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font, in)
}

var __func__331 = *(*[28]int8)(unsafe.Pointer(ts + 25916 /* "nk_button_image_..." */)) /* nuklear.h:23976:1 */

func Xnk_button_image_text(ctx uintptr, img Nk_image, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:24001:1: */
	return Xnk_button_image_text_styled(ctx, (ctx + 360 /* &.style */ + 56 /* &.button */), img, text, len, align)
}

func Xnk_button_image_label(ctx uintptr, img Nk_image, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:24006:16: */
	return Xnk_button_image_text(ctx, img, label, Xnk_strlen(label), align)
}

func Xnk_button_image_label_styled(ctx uintptr, style uintptr, img Nk_image, label uintptr, text_alignment Nk_flags) Nk_bool { /* nuklear.h:24011:16: */
	return Xnk_button_image_text_styled(ctx, style, img, label, Xnk_strlen(label), text_alignment)
}

// ===============================================================
//
//                              TOGGLE
//
// ===============================================================
func nk_toggle_behavior(in uintptr, select1 Nk_rect, state uintptr, active Nk_bool) Nk_bool { /* nuklear.h:24028:1: */
	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if nk_button_behavior(state, select1, in, NK_BUTTON_DEFAULT) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
		active = BoolInt32(!(active != 0))
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, select1) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, select1) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return active
}

func nk_draw_checkbox(out uintptr, state Nk_flags, style uintptr, active Nk_bool, label uintptr, selector uintptr, cursors uintptr, string uintptr, len int32, font uintptr) { /* nuklear.h:24043:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var background uintptr
	var cursor uintptr
	// var text Nk_text at bp, 16

	// select correct colors/images
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_active
	} else {
		background = (style /* &.normal */)
		cursor = (style + 64 /* &.cursor_normal */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_normal
	}

	// draw background and cursor
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(selector)), float32(0), (*Nk_style_toggle)(unsafe.Pointer(style)).Border_color)
		Xnk_fill_rect(out, nk_shrink_rect(*(*Nk_rect)(unsafe.Pointer(selector)), (*Nk_style_toggle)(unsafe.Pointer(style)).Border), float32(0), *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(selector)), (background + 4 /* &.data */ /* &.image */), nk_white)
	}
	if active != 0 {
		if int32((*Nk_style_item)(unsafe.Pointer(cursor)).Type) == NK_STYLE_ITEM_IMAGE {
			Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(cursors)), (cursor + 4 /* &.data */ /* &.image */), nk_white)
		} else {
			Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(cursors)), float32(0), *(*Nk_color)(unsafe.Pointer(cursor + 4 /* &.data */)))
		}
	}

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding.X = float32(0)
	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding.Y = float32(0)
	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_background
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(label)), string, len, bp /* &text */, NK_TEXT_LEFT, font)
}

func nk_draw_option(out uintptr, state Nk_flags, style uintptr, active Nk_bool, label uintptr, selector uintptr, cursors uintptr, string uintptr, len int32, font uintptr) { /* nuklear.h:24085:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var background uintptr
	var cursor uintptr
	// var text Nk_text at bp, 16

	// select correct colors/images
	if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_hover
	} else if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_active
	} else {
		background = (style /* &.normal */)
		cursor = (style + 64 /* &.cursor_normal */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_normal
	}

	// draw background and cursor
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_circle(out, *(*Nk_rect)(unsafe.Pointer(selector)), (*Nk_style_toggle)(unsafe.Pointer(style)).Border_color)
		Xnk_fill_circle(out, nk_shrink_rect(*(*Nk_rect)(unsafe.Pointer(selector)), (*Nk_style_toggle)(unsafe.Pointer(style)).Border), *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(selector)), (background + 4 /* &.data */ /* &.image */), nk_white)
	}
	if active != 0 {
		if int32((*Nk_style_item)(unsafe.Pointer(cursor)).Type) == NK_STYLE_ITEM_IMAGE {
			Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(cursors)), (cursor + 4 /* &.data */ /* &.image */), nk_white)
		} else {
			Xnk_fill_circle(out, *(*Nk_rect)(unsafe.Pointer(cursors)), *(*Nk_color)(unsafe.Pointer(cursor + 4 /* &.data */)))
		}
	}

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding.X = float32(0)
	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding.Y = float32(0)
	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = (*Nk_style_toggle)(unsafe.Pointer(style)).Text_background
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(label)), string, len, bp /* &text */, NK_TEXT_LEFT, font)
}

func nk_do_toggle(state uintptr, out uintptr, r Nk_rect, active uintptr, str uintptr, len int32, type1 uint32, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:24127:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	var was_active int32
	var bounds Nk_rect
	// var select1 Nk_rect at bp+16, 16

	// var cursor Nk_rect at bp+32, 16

	// var label Nk_rect at bp, 16

	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(24139), uintptr(unsafe.Pointer(&__func__332)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(24140), uintptr(unsafe.Pointer(&__func__332)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(24141), uintptr(unsafe.Pointer(&__func__332)))
	}
	if ((!(out != 0) || !(style != 0)) || !(font != 0)) || !(active != 0) {
		return 0
	}

	r.W = func() float32 {
		if (r.W) < ((*Nk_user_font)(unsafe.Pointer(font)).Height + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.X)) {
			return ((*Nk_user_font)(unsafe.Pointer(font)).Height + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.X))
		}
		return r.W
	}()
	r.H = func() float32 {
		if (r.H) < ((*Nk_user_font)(unsafe.Pointer(font)).Height + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.Y)) {
			return ((*Nk_user_font)(unsafe.Pointer(font)).Height + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.Y))
		}
		return r.H
	}()

	// add additional touch padding for touch screen devices
	bounds.X = (r.X - (*Nk_style_toggle)(unsafe.Pointer(style)).Touch_padding.X)
	bounds.Y = (r.Y - (*Nk_style_toggle)(unsafe.Pointer(style)).Touch_padding.Y)
	bounds.W = (r.W + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Touch_padding.X))
	bounds.H = (r.H + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Touch_padding.Y))

	// calculate the selector space
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).W = (*Nk_user_font)(unsafe.Pointer(font)).Height
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).W
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).Y = ((r.Y + (r.H / 2.0)) - ((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).H / 2.0))
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).X = r.X

	// calculate the bounds of the cursor inside the selector
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &cursor */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).X + (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_toggle)(unsafe.Pointer(style)).Border)
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &cursor */)).Y = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).Y + (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.Y) + (*Nk_style_toggle)(unsafe.Pointer(style)).Border)
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &cursor */)).W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).W - ((float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.X) + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Border)))
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &cursor */)).H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).H - ((float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Padding.Y) + (float32(2) * (*Nk_style_toggle)(unsafe.Pointer(style)).Border)))

	// label behind the selector
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &select1 */)).W) + (*Nk_style_toggle)(unsafe.Pointer(style)).Spacing)
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).Y = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).Y
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).W = ((func() float32 {
		if (r.X + r.W) < ((*Nk_rect)(unsafe.Pointer(bp /* &label */)).X) {
			return (*Nk_rect)(unsafe.Pointer(bp /* &label */)).X
		}
		return (r.X + r.W)
	}()) - (*Nk_rect)(unsafe.Pointer(bp /* &label */)).X)
	(*Nk_rect)(unsafe.Pointer(bp /* &label */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &select1 */)).W

	// update selector
	was_active = *(*Nk_bool)(unsafe.Pointer(active))
	*(*Nk_bool)(unsafe.Pointer(active)) = nk_toggle_behavior(in, bounds, state, *(*Nk_bool)(unsafe.Pointer(active)))

	// draw selector
	if (*Nk_style_toggle)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 152 /* &.draw_begin */))))(out, (*Nk_style_toggle)(unsafe.Pointer(style)).Userdata)
	}
	if int32(type1) == NK_TOGGLE_CHECK {
		nk_draw_checkbox(out, *(*Nk_flags)(unsafe.Pointer(state)), style, *(*Nk_bool)(unsafe.Pointer(active)), bp /* &label */, bp+16 /* &select1 */, bp+32 /* &cursor */, str, len, font)
	} else {
		nk_draw_option(out, *(*Nk_flags)(unsafe.Pointer(state)), style, *(*Nk_bool)(unsafe.Pointer(active)), bp /* &label */, bp+16 /* &select1 */, bp+32 /* &cursor */, str, len, font)
	}
	if (*Nk_style_toggle)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 156 /* &.draw_end */))))(out, (*Nk_style_toggle)(unsafe.Pointer(style)).Userdata)
	}
	return (Bool32(was_active != *(*Nk_bool)(unsafe.Pointer(active))))
}

var __func__332 = *(*[13]int8)(unsafe.Pointer(ts + 25944 /* "nk_do_toggle" */)) /* nuklear.h:24132:1 */

// ----------------------------------------------------------------
//
//                          CHECKBOX
//
// --------------------------------------------------------------
func Xnk_check_text(ctx uintptr, text uintptr, len int32, active Nk_bool) Nk_bool { /* nuklear.h:24194:1: */
	bp := tlsAlloc(20)
	defer tlsFree(20)
	*(*Nk_bool)(unsafe.Pointer(bp + 16)) = active

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24204), uintptr(unsafe.Pointer(&__func__333)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24205), uintptr(unsafe.Pointer(&__func__333)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24206), uintptr(unsafe.Pointer(&__func__333)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return *(*Nk_bool)(unsafe.Pointer(bp + 16 /* active */))
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return *(*Nk_bool)(unsafe.Pointer(bp + 16 /* active */))
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	nk_do_toggle((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), bp+16, /* &active */
		text, len, NK_TOGGLE_CHECK, (style + 600 /* &.checkbox */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
	return *(*Nk_bool)(unsafe.Pointer(bp + 16 /* active */))
}

var __func__333 = *(*[14]int8)(unsafe.Pointer(ts + 25957 /* "nk_check_text" */)) /* nuklear.h:24195:1 */

func Xnk_check_flags_text(ctx uintptr, text uintptr, len int32, flags uint32, value uint32) uint32 { /* nuklear.h:24222:1: */
	var old_active int32
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24226), uintptr(unsafe.Pointer(&__func__334)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(24227), uintptr(unsafe.Pointer(&__func__334)))
	}
	if !(ctx != 0) || !(text != 0) {
		return flags
	}
	old_active = (int32((flags & value) & value))
	if Xnk_check_text(ctx, text, len, old_active) != 0 {
		flags = flags | (value)
	} else {
		flags = flags & (^value)
	}
	return flags
}

var __func__334 = *(*[20]int8)(unsafe.Pointer(ts + 25971 /* "nk_check_flags_t..." */)) /* nuklear.h:24224:1 */

func Xnk_checkbox_text(ctx uintptr, text uintptr, len int32, active uintptr) Nk_bool { /* nuklear.h:24236:1: */
	var old_val int32
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24239), uintptr(unsafe.Pointer(&__func__335)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(24240), uintptr(unsafe.Pointer(&__func__335)))
	}
	if active != 0 {
	} else {
		X__assert_fail(ts+25991 /* "active" */, ts+2 /* "nuklear/nuklear...." */, uint32(24241), uintptr(unsafe.Pointer(&__func__335)))
	}
	if (!(ctx != 0) || !(text != 0)) || !(active != 0) {
		return 0
	}
	old_val = *(*Nk_bool)(unsafe.Pointer(active))
	*(*Nk_bool)(unsafe.Pointer(active)) = Xnk_check_text(ctx, text, len, *(*Nk_bool)(unsafe.Pointer(active)))
	return (Bool32(old_val != *(*Nk_bool)(unsafe.Pointer(active))))
}

var __func__335 = *(*[17]int8)(unsafe.Pointer(ts + 25998 /* "nk_checkbox_text" */)) /* nuklear.h:24237:1 */

func Xnk_checkbox_flags_text(ctx uintptr, text uintptr, len int32, flags uintptr, value uint32) Nk_bool { /* nuklear.h:24248:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var active Nk_bool at bp, 4

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24252), uintptr(unsafe.Pointer(&__func__336)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(24253), uintptr(unsafe.Pointer(&__func__336)))
	}
	if flags != 0 {
	} else {
		X__assert_fail(ts+26015 /* "flags" */, ts+2 /* "nuklear/nuklear...." */, uint32(24254), uintptr(unsafe.Pointer(&__func__336)))
	}
	if (!(ctx != 0) || !(text != 0)) || !(flags != 0) {
		return 0
	}

	*(*Nk_bool)(unsafe.Pointer(bp /* active */)) = (int32((*(*uint32)(unsafe.Pointer(flags)) & value) & value))
	if Xnk_checkbox_text(ctx, text, len, bp /* &active */) != 0 {
		if *(*Nk_bool)(unsafe.Pointer(bp /* active */)) != 0 {
			*(*uint32)(unsafe.Pointer(flags)) |= (value)
		} else {
			*(*uint32)(unsafe.Pointer(flags)) &= (^value)
		}
		return 1
	}
	return 0
}

var __func__336 = *(*[23]int8)(unsafe.Pointer(ts + 26021 /* "nk_checkbox_flag..." */)) /* nuklear.h:24250:1 */

func Xnk_check_label(ctx uintptr, label uintptr, active Nk_bool) Nk_bool { /* nuklear.h:24265:16: */
	return Xnk_check_text(ctx, label, Xnk_strlen(label), active)
}

func Xnk_check_flags_label(ctx uintptr, label uintptr, flags uint32, value uint32) uint32 { /* nuklear.h:24269:21: */
	return Xnk_check_flags_text(ctx, label, Xnk_strlen(label), flags, value)
}

func Xnk_checkbox_label(ctx uintptr, label uintptr, active uintptr) Nk_bool { /* nuklear.h:24274:16: */
	return Xnk_checkbox_text(ctx, label, Xnk_strlen(label), active)
}

func Xnk_checkbox_flags_label(ctx uintptr, label uintptr, flags uintptr, value uint32) Nk_bool { /* nuklear.h:24278:16: */
	return Xnk_checkbox_flags_text(ctx, label, Xnk_strlen(label), flags, value)
}

// ----------------------------------------------------------------
//
//                          OPTION
//
// --------------------------------------------------------------
func Xnk_option_text(ctx uintptr, text uintptr, len int32, is_active Nk_bool) Nk_bool { /* nuklear.h:24289:1: */
	bp := tlsAlloc(20)
	defer tlsFree(20)
	*(*Nk_bool)(unsafe.Pointer(bp + 16)) = is_active

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24299), uintptr(unsafe.Pointer(&__func__337)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24300), uintptr(unsafe.Pointer(&__func__337)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24301), uintptr(unsafe.Pointer(&__func__337)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return *(*Nk_bool)(unsafe.Pointer(bp + 16 /* is_active */))
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return int32(state)
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	nk_do_toggle((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), bp+16, /* &is_active */
		text, len, NK_TOGGLE_OPTION, (style + 440 /* &.option */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
	return *(*Nk_bool)(unsafe.Pointer(bp + 16 /* is_active */))
}

var __func__337 = *(*[15]int8)(unsafe.Pointer(ts + 26044 /* "nk_option_text" */)) /* nuklear.h:24290:1 */

func Xnk_radio_text(ctx uintptr, text uintptr, len int32, active uintptr) Nk_bool { /* nuklear.h:24317:1: */
	var old_value int32
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24320), uintptr(unsafe.Pointer(&__func__338)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(24321), uintptr(unsafe.Pointer(&__func__338)))
	}
	if active != 0 {
	} else {
		X__assert_fail(ts+25991 /* "active" */, ts+2 /* "nuklear/nuklear...." */, uint32(24322), uintptr(unsafe.Pointer(&__func__338)))
	}
	if (!(ctx != 0) || !(text != 0)) || !(active != 0) {
		return 0
	}
	old_value = *(*Nk_bool)(unsafe.Pointer(active))
	*(*Nk_bool)(unsafe.Pointer(active)) = Xnk_option_text(ctx, text, len, old_value)
	return (Bool32(old_value != *(*Nk_bool)(unsafe.Pointer(active))))
}

var __func__338 = *(*[14]int8)(unsafe.Pointer(ts + 26059 /* "nk_radio_text" */)) /* nuklear.h:24318:1 */

func Xnk_option_label(ctx uintptr, label uintptr, active Nk_bool) Nk_bool { /* nuklear.h:24329:1: */
	return Xnk_option_text(ctx, label, Xnk_strlen(label), active)
}

func Xnk_radio_label(ctx uintptr, label uintptr, active uintptr) Nk_bool { /* nuklear.h:24334:1: */
	return Xnk_radio_text(ctx, label, Xnk_strlen(label), active)
}

// ===============================================================
//
//                              SELECTABLE
//
// ===============================================================
func nk_draw_selectable(out uintptr, state Nk_flags, style uintptr, active Nk_bool, bounds uintptr, icon uintptr, img uintptr, sym uint32, string uintptr, len int32, align Nk_flags, font uintptr) { /* nuklear.h:24349:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var background uintptr
	// var text Nk_text at bp, 16

	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = (*Nk_style_selectable)(unsafe.Pointer(style)).Padding

	// select correct colors/images
	if !(active != 0) {
		if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
			background = (style + 40 /* &.pressed */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_pressed
		} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
			background = (style + 20 /* &.hover */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_hover
		} else {
			background = (style /* &.normal */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_normal
		}
	} else {
		if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
			background = (style + 100 /* &.pressed_active */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_pressed_active
		} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
			background = (style + 80 /* &.hover_active */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_hover_active
		} else {
			background = (style + 60 /* &.normal_active */)
			(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_selectable)(unsafe.Pointer(style)).Text_normal_active
		}
	}
	// draw selectable background and text
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
	} else {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_selectable)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
	}
	if icon != 0 {
		if img != 0 {
			Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(icon)), img, nk_white)
		} else {
			nk_draw_symbol(out, sym, *(*Nk_rect)(unsafe.Pointer(icon)), (*Nk_text)(unsafe.Pointer(bp /* &text */)).Background, (*Nk_text)(unsafe.Pointer(bp /* &text */)).Text, float32(1), font)
		}
	}
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(bounds)), string, len, bp /* &text */, align, font)
}

func nk_do_selectable(state uintptr, out uintptr, bounds Nk_rect, str uintptr, len int32, align Nk_flags, value uintptr, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:24398:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_rect)(unsafe.Pointer(bp)) = bounds

	var old_value int32
	var touch Nk_rect

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(24406), uintptr(unsafe.Pointer(&__func__339)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(24407), uintptr(unsafe.Pointer(&__func__339)))
	}
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(24408), uintptr(unsafe.Pointer(&__func__339)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(24409), uintptr(unsafe.Pointer(&__func__339)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24410), uintptr(unsafe.Pointer(&__func__339)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(24411), uintptr(unsafe.Pointer(&__func__339)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(24412), uintptr(unsafe.Pointer(&__func__339)))
	}

	if (((((!(state != 0) || !(out != 0)) || !(str != 0)) || !(len != 0)) || !(value != 0)) || !(style != 0)) || !(font != 0) {
		return 0
	}
	old_value = *(*Nk_bool)(unsafe.Pointer(value))

	// remove padding
	touch.X = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X)
	touch.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y)
	touch.W = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X * float32(2)))
	touch.H = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y * float32(2)))

	// update button
	if nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT) != 0 {
		*(*Nk_bool)(unsafe.Pointer(value)) = BoolInt32(!(*(*Nk_bool)(unsafe.Pointer(value)) != 0))
	}

	// draw selectable
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 184 /* &.draw_begin */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_selectable(out, *(*Nk_flags)(unsafe.Pointer(state)), style, *(*Nk_bool)(unsafe.Pointer(value)), bp /* &bounds */, uintptr(0), uintptr(0), NK_SYMBOL_NONE, str, len, align, font)
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 188 /* &.draw_end */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	return (Bool32(old_value != *(*Nk_bool)(unsafe.Pointer(value))))
}

var __func__339 = *(*[17]int8)(unsafe.Pointer(ts + 26079 /* "nk_do_selectable" */)) /* nuklear.h:24402:1 */

func nk_do_selectable_image(state uintptr, out uintptr, bounds Nk_rect, str uintptr, len int32, align Nk_flags, value uintptr, img uintptr, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:24434:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds

	var old_value Nk_bool
	var touch Nk_rect
	// var icon Nk_rect at bp, 16

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(24443), uintptr(unsafe.Pointer(&__func__340)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(24444), uintptr(unsafe.Pointer(&__func__340)))
	}
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(24445), uintptr(unsafe.Pointer(&__func__340)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(24446), uintptr(unsafe.Pointer(&__func__340)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24447), uintptr(unsafe.Pointer(&__func__340)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(24448), uintptr(unsafe.Pointer(&__func__340)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(24449), uintptr(unsafe.Pointer(&__func__340)))
	}

	if (((((!(state != 0) || !(out != 0)) || !(str != 0)) || !(len != 0)) || !(value != 0)) || !(style != 0)) || !(font != 0) {
		return 0
	}
	old_value = *(*Nk_bool)(unsafe.Pointer(value))

	// toggle behavior
	touch.X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X)
	touch.Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).Y - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y)
	touch.W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).W + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X * float32(2)))
	touch.H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).H + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y * float32(2)))
	if nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT) != 0 {
		*(*Nk_bool)(unsafe.Pointer(value)) = BoolInt32(!(*(*Nk_bool)(unsafe.Pointer(value)) != 0))
	}

	(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).Y + (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).W = AssignPtrFloat32(bp /* &icon */ +12 /* &.h */, ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).H - (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.Y)))
	if (align & NK_TEXT_ALIGN_LEFT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).W) - ((float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.X) + (*Nk_rect)(unsafe.Pointer(bp /* &icon */)).W))
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X) < (float32(0)) {
				return float32(0)
			}
			return (*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X
		}()
	} else {
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X + (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.X))
	}

	*(*float32)(unsafe.Pointer(bp /* &icon */ /* &.x */)) += ((*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 4 /* &.y */)) += ((*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.Y)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 8 /* &.w */)) -= (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 12 /* &.h */)) -= (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.Y)

	// draw selectable
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 184 /* &.draw_begin */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_selectable(out, *(*Nk_flags)(unsafe.Pointer(state)), style, *(*Nk_bool)(unsafe.Pointer(value)), bp+16 /* &bounds */, bp /* &icon */, img, NK_SYMBOL_NONE, str, len, align, font)
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 188 /* &.draw_end */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	return (Bool32(old_value != *(*Nk_bool)(unsafe.Pointer(value))))
}

var __func__340 = *(*[23]int8)(unsafe.Pointer(ts + 26096 /* "nk_do_selectable..." */)) /* nuklear.h:24438:1 */

func nk_do_selectable_symbol(state uintptr, out uintptr, bounds Nk_rect, str uintptr, len int32, align Nk_flags, value uintptr, sym uint32, style uintptr, in uintptr, font uintptr) Nk_bool { /* nuklear.h:24481:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_rect)(unsafe.Pointer(bp + 16)) = bounds

	var old_value int32
	var touch Nk_rect
	// var icon Nk_rect at bp, 16

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(24490), uintptr(unsafe.Pointer(&__func__341)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(24491), uintptr(unsafe.Pointer(&__func__341)))
	}
	if str != 0 {
	} else {
		X__assert_fail(ts+80 /* "str" */, ts+2 /* "nuklear/nuklear...." */, uint32(24492), uintptr(unsafe.Pointer(&__func__341)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(24493), uintptr(unsafe.Pointer(&__func__341)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24494), uintptr(unsafe.Pointer(&__func__341)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(24495), uintptr(unsafe.Pointer(&__func__341)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(24496), uintptr(unsafe.Pointer(&__func__341)))
	}

	if (((((!(state != 0) || !(out != 0)) || !(str != 0)) || !(len != 0)) || !(value != 0)) || !(style != 0)) || !(font != 0) {
		return 0
	}
	old_value = *(*Nk_bool)(unsafe.Pointer(value))

	// toggle behavior
	touch.X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X)
	touch.Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).Y - (*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y)
	touch.W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).W + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.X * float32(2)))
	touch.H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).H + ((*Nk_style_selectable)(unsafe.Pointer(style)).Touch_padding.Y * float32(2)))
	if nk_button_behavior(state, touch, in, NK_BUTTON_DEFAULT) != 0 {
		*(*Nk_bool)(unsafe.Pointer(value)) = BoolInt32(!(*(*Nk_bool)(unsafe.Pointer(value)) != 0))
	}

	(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).Y + (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).W = AssignPtrFloat32(bp /* &icon */ +12 /* &.h */, ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).H - (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.Y)))
	if (align & NK_TEXT_ALIGN_LEFT) != 0 {
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).W) - ((float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.X) + (*Nk_rect)(unsafe.Pointer(bp /* &icon */)).W))
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X) < (float32(0)) {
				return float32(0)
			}
			return (*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X
		}()
	} else {
		(*Nk_rect)(unsafe.Pointer(bp /* &icon */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X + (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Padding.X))
	}

	*(*float32)(unsafe.Pointer(bp /* &icon */ /* &.x */)) += ((*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 4 /* &.y */)) += ((*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.Y)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 8 /* &.w */)) -= (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.X)
	*(*float32)(unsafe.Pointer(bp /* &icon */ + 12 /* &.h */)) -= (float32(2) * (*Nk_style_selectable)(unsafe.Pointer(style)).Image_padding.Y)

	// draw selectable
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 184 /* &.draw_begin */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_selectable(out, *(*Nk_flags)(unsafe.Pointer(state)), style, *(*Nk_bool)(unsafe.Pointer(value)), bp+16 /* &bounds */, bp /* &icon */, uintptr(0), sym, str, len, align, font)
	if (*Nk_style_selectable)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 188 /* &.draw_end */))))(out, (*Nk_style_selectable)(unsafe.Pointer(style)).Userdata)
	}
	return (Bool32(old_value != *(*Nk_bool)(unsafe.Pointer(value))))
}

var __func__341 = *(*[24]int8)(unsafe.Pointer(ts + 26119 /* "nk_do_selectable..." */)) /* nuklear.h:24485:1 */

func Xnk_selectable_text(ctx uintptr, str uintptr, len int32, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24529:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	var state uint32
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24540), uintptr(unsafe.Pointer(&__func__342)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24541), uintptr(unsafe.Pointer(&__func__342)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24542), uintptr(unsafe.Pointer(&__func__342)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24543), uintptr(unsafe.Pointer(&__func__342)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(value != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_selectable((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		str, len, align, value, (style + 760 /* &.selectable */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
}

var __func__342 = *(*[19]int8)(unsafe.Pointer(ts + 26143 /* "nk_selectable_te..." */)) /* nuklear.h:24531:1 */

func Xnk_selectable_image_text(ctx uintptr, img Nk_image, str uintptr, len int32, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24558:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_image)(unsafe.Pointer(bp + 16)) = img

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	var state uint32
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24569), uintptr(unsafe.Pointer(&__func__343)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24570), uintptr(unsafe.Pointer(&__func__343)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24571), uintptr(unsafe.Pointer(&__func__343)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24572), uintptr(unsafe.Pointer(&__func__343)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(value != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_selectable_image((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		str, len, align, value, bp+16 /* &img */, (style + 760 /* &.selectable */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
}

var __func__343 = *(*[25]int8)(unsafe.Pointer(ts + 26162 /* "nk_selectable_im..." */)) /* nuklear.h:24560:1 */

func Xnk_selectable_symbol_text(ctx uintptr, sym uint32, str uintptr, len int32, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24587:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	var state uint32
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24598), uintptr(unsafe.Pointer(&__func__344)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24599), uintptr(unsafe.Pointer(&__func__344)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24600), uintptr(unsafe.Pointer(&__func__344)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24601), uintptr(unsafe.Pointer(&__func__344)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(value != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_selectable_symbol((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		str, len, align, value, sym, (style + 760 /* &.selectable */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
}

var __func__344 = *(*[26]int8)(unsafe.Pointer(ts + 26187 /* "nk_selectable_sy..." */)) /* nuklear.h:24589:1 */

func Xnk_selectable_symbol_label(ctx uintptr, sym uint32, title uintptr, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24616:1: */
	return Xnk_selectable_symbol_text(ctx, sym, title, Xnk_strlen(title), align, value)
}

func Xnk_select_text(ctx uintptr, str uintptr, len int32, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24621:16: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_bool)(unsafe.Pointer(bp)) = value

	Xnk_selectable_text(ctx, str, len, align, bp /* &value */)
	return *(*Nk_bool)(unsafe.Pointer(bp /* value */))
}

func Xnk_selectable_label(ctx uintptr, str uintptr, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24626:16: */
	return Xnk_selectable_text(ctx, str, Xnk_strlen(str), align, value)
}

func Xnk_selectable_image_label(ctx uintptr, img Nk_image, str uintptr, align Nk_flags, value uintptr) Nk_bool { /* nuklear.h:24630:16: */
	return Xnk_selectable_image_text(ctx, img, str, Xnk_strlen(str), align, value)
}

func Xnk_select_label(ctx uintptr, str uintptr, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24635:16: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_bool)(unsafe.Pointer(bp)) = value

	Xnk_selectable_text(ctx, str, Xnk_strlen(str), align, bp /* &value */)
	return *(*Nk_bool)(unsafe.Pointer(bp /* value */))
}

func Xnk_select_image_label(ctx uintptr, img Nk_image, str uintptr, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24639:16: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_bool)(unsafe.Pointer(bp)) = value

	Xnk_selectable_image_text(ctx, img, str, Xnk_strlen(str), align, bp /* &value */)
	return *(*Nk_bool)(unsafe.Pointer(bp /* value */))
}

func Xnk_select_image_text(ctx uintptr, img Nk_image, str uintptr, len int32, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24644:16: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_bool)(unsafe.Pointer(bp)) = value

	Xnk_selectable_image_text(ctx, img, str, len, align, bp /* &value */)
	return *(*Nk_bool)(unsafe.Pointer(bp /* value */))
}

func Xnk_select_symbol_text(ctx uintptr, sym uint32, title uintptr, title_len int32, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24650:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_bool)(unsafe.Pointer(bp)) = value

	Xnk_selectable_symbol_text(ctx, sym, title, title_len, align, bp /* &value */)
	return *(*Nk_bool)(unsafe.Pointer(bp /* value */))
}

func Xnk_select_symbol_label(ctx uintptr, sym uint32, title uintptr, align Nk_flags, value Nk_bool) Nk_bool { /* nuklear.h:24656:1: */
	return Xnk_select_symbol_text(ctx, sym, title, Xnk_strlen(title), align, value)
}

// ===============================================================
//
//                              SLIDER
//
// ===============================================================
func nk_slider_behavior(state uintptr, logical_cursor uintptr, visual_cursor uintptr, in uintptr, bounds Nk_rect, slider_min float32, slider_max float32, slider_value float32, slider_step float32, slider_steps float32) float32 { /* nuklear.h:24672:1: */
	var left_mouse_down int32
	var left_mouse_click_in_cursor int32

	// check if visual cursor is being dragged
	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	left_mouse_down = (Bool32((in != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0)))
	left_mouse_click_in_cursor = (Bool32((in != 0) && (Xnk_input_has_mouse_click_down_in_rect(in,
		NK_BUTTON_LEFT, *(*Nk_rect)(unsafe.Pointer(visual_cursor)), Nk_true) != 0)))

	if (left_mouse_down != 0) && (left_mouse_click_in_cursor != 0) {
		var ratio float32 = float32(0)
		var d float32 = ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - ((*Nk_rect)(unsafe.Pointer(visual_cursor)).X + ((*Nk_rect)(unsafe.Pointer(visual_cursor)).W * 0.5)))
		var pxstep float32 = (bounds.W / slider_steps)

		// only update value if the next slider step is reached
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
		if (func() float32 {
			if (d) < float32(0) {
				return -d
			}
			return d
		}()) >= pxstep {
			var steps float32 = float32((int32((func() float32 {
				if (d) < float32(0) {
					return -d
				}
				return d
			}()) / pxstep)))
			slider_value = slider_value + (func() float32 {
				if d > float32(0) {
					return (slider_step * steps)
				}
				return -(slider_step * steps)
			}())
			slider_value = func() float32 {
				if (func() float32 {
					if (slider_value) < (slider_max) {
						return slider_value
					}
					return slider_max
				}()) < (slider_min) {
					return slider_min
				}
				return func() float32 {
					if (slider_value) < (slider_max) {
						return slider_value
					}
					return slider_max
				}()
			}()
			ratio = ((slider_value - slider_min) / slider_step)
			(*Nk_rect)(unsafe.Pointer(logical_cursor)).X = (bounds.X + ((*Nk_rect)(unsafe.Pointer(logical_cursor)).W * ratio))
			(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.X = (*Nk_rect)(unsafe.Pointer(logical_cursor)).X
		}
	}

	// slider widget state
	if Xnk_input_is_mouse_hovering_rect(in, bounds) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, bounds) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, bounds) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return slider_value
}

func nk_draw_slider(out uintptr, state Nk_flags, style uintptr, bounds uintptr, visual_cursor uintptr, min float32, value float32, max float32) { /* nuklear.h:24714:1: */
	var fill Nk_rect
	var bar Nk_rect
	var background uintptr

	// select correct slider images/colors
	var bar_color Nk_color
	var cursor uintptr

	_ = min
	_ = max
	_ = value

	if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 40 /* &.active */)
		bar_color = (*Nk_style_slider)(unsafe.Pointer(style)).Bar_active
		cursor = (style + 120 /* &.cursor_active */)
	} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		bar_color = (*Nk_style_slider)(unsafe.Pointer(style)).Bar_hover
		cursor = (style + 100 /* &.cursor_hover */)
	} else {
		background = (style /* &.normal */)
		bar_color = (*Nk_style_slider)(unsafe.Pointer(style)).Bar_normal
		cursor = (style + 80 /* &.cursor_normal */)
	}
	// calculate slider background bar
	bar.X = (*Nk_rect)(unsafe.Pointer(bounds)).X
	bar.Y = (((*Nk_rect)(unsafe.Pointer(visual_cursor)).Y + ((*Nk_rect)(unsafe.Pointer(visual_cursor)).H / float32(2))) - ((*Nk_rect)(unsafe.Pointer(bounds)).H / float32(12)))
	bar.W = (*Nk_rect)(unsafe.Pointer(bounds)).W
	bar.H = ((*Nk_rect)(unsafe.Pointer(bounds)).H / float32(6))

	// filled background bar style
	fill.W = (((*Nk_rect)(unsafe.Pointer(visual_cursor)).X + ((*Nk_rect)(unsafe.Pointer(visual_cursor)).W / 2.0)) - bar.X)
	fill.X = bar.X
	fill.Y = bar.Y
	fill.H = bar.H

	// draw background
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_slider)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_slider)(unsafe.Pointer(style)).Rounding, (*Nk_style_slider)(unsafe.Pointer(style)).Border, (*Nk_style_slider)(unsafe.Pointer(style)).Border_color)
	}

	// draw slider bar
	Xnk_fill_rect(out, bar, (*Nk_style_slider)(unsafe.Pointer(style)).Rounding, bar_color)
	Xnk_fill_rect(out, fill, (*Nk_style_slider)(unsafe.Pointer(style)).Rounding, (*Nk_style_slider)(unsafe.Pointer(style)).Bar_filled)

	// draw cursor
	if int32((*Nk_style_item)(unsafe.Pointer(cursor)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(visual_cursor)), (cursor + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_circle(out, *(*Nk_rect)(unsafe.Pointer(visual_cursor)), *(*Nk_color)(unsafe.Pointer(cursor + 4 /* &.data */)))
	}
}

func nk_do_slider(state uintptr, out uintptr, bounds Nk_rect, min float32, val float32, max float32, step float32, style uintptr, in uintptr, font uintptr) float32 { /* nuklear.h:24773:1: */
	bp := tlsAlloc(52)
	defer tlsFree(52)
	*(*Nk_rect)(unsafe.Pointer(bp)) = bounds

	var slider_range float32
	var slider_min float32
	var slider_max float32
	var slider_value float32
	var slider_steps float32
	var cursor_offset float32
	// var visual_cursor Nk_rect at bp+36, 16

	// var logical_cursor Nk_rect at bp+20, 16

	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(24789), uintptr(unsafe.Pointer(&__func__345)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(24790), uintptr(unsafe.Pointer(&__func__345)))
	}
	if !(out != 0) || !(style != 0) {
		return float32(0)
	}

	// remove padding from slider bounds
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_style_slider)(unsafe.Pointer(style)).Padding.X)
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_style_slider)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H) < (float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.Y) {
			return (float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.Y)
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
	}()
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W) < ((float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.X) {
			return ((float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.X)
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W
	}()
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 8 /* &.w */)) -= (float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.X)
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 12 /* &.h */)) -= (float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Padding.Y)

	// optional buttons
	if (*Nk_style_slider)(unsafe.Pointer(style)).Show_buttons != 0 {
		// var ws Nk_flags at bp+16, 4

		var button Nk_rect
		button.Y = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y
		button.W = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
		button.H = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H

		// decrement button
		button.X = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X
		if nk_do_button_symbol(bp+16 /* &ws */, out, button, (*Nk_style_slider)(unsafe.Pointer(style)).Dec_symbol, NK_BUTTON_DEFAULT,
			(style+308 /* &.dec_button */), in, font) != 0 {
			val = val - (step)
		}

		// increment button
		button.X = (((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W) - button.W)
		if nk_do_button_symbol(bp+16 /* &ws */, out, button, (*Nk_style_slider)(unsafe.Pointer(style)).Inc_symbol, NK_BUTTON_DEFAULT,
			(style+180 /* &.inc_button */), in, font) != 0 {
			val = val + (step)
		}

		(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X = (((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + button.W) + (*Nk_style_slider)(unsafe.Pointer(style)).Spacing.X)
		(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W - ((float32(2) * button.W) + (float32(2) * (*Nk_style_slider)(unsafe.Pointer(style)).Spacing.X)))
	}

	// remove one cursor size to support visual cursor
	*(*float32)(unsafe.Pointer(bp /* &bounds */ /* &.x */)) += ((*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.X * 0.5)
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 8 /* &.w */)) -= ((*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.X)

	// make sure the provided values are correct
	slider_max = func() float32 {
		if (min) < (max) {
			return max
		}
		return min
	}()
	slider_min = func() float32 {
		if (min) < (max) {
			return min
		}
		return max
	}()
	slider_value = func() float32 {
		if (func() float32 {
			if (val) < (slider_max) {
				return val
			}
			return slider_max
		}()) < (slider_min) {
			return slider_min
		}
		return func() float32 {
			if (val) < (slider_max) {
				return val
			}
			return slider_max
		}()
	}()
	slider_range = (slider_max - slider_min)
	slider_steps = (slider_range / step)
	cursor_offset = ((slider_value - slider_min) / step)

	// calculate cursor
	//     Basically you have two cursors. One for visual representation and interaction
	//     and one for updating the actual cursor value.
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &logical_cursor */)).H = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &logical_cursor */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W / slider_steps)
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &logical_cursor */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + ((*Nk_rect)(unsafe.Pointer(bp+20 /* &logical_cursor */)).W * cursor_offset))
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &logical_cursor */)).Y = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y

	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &visual_cursor */)).H = (*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.Y
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &visual_cursor */)).W = (*Nk_style_slider)(unsafe.Pointer(style)).Cursor_size.X
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &visual_cursor */)).Y = (((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H * 0.5)) - ((*Nk_rect)(unsafe.Pointer(bp+36 /* &visual_cursor */)).H * 0.5))
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &visual_cursor */)).X = ((*Nk_rect)(unsafe.Pointer(bp+20 /* &logical_cursor */)).X - ((*Nk_rect)(unsafe.Pointer(bp+36 /* &visual_cursor */)).W * 0.5))

	slider_value = nk_slider_behavior(state, bp+20 /* &logical_cursor */, bp+36, /* &visual_cursor */
		in, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), slider_min, slider_max, slider_value, step, slider_steps)
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &visual_cursor */)).X = ((*Nk_rect)(unsafe.Pointer(bp+20 /* &logical_cursor */)).X - ((*Nk_rect)(unsafe.Pointer(bp+36 /* &visual_cursor */)).W * 0.5))

	// draw slider
	if (*Nk_style_slider)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 448 /* &.draw_begin */))))(out, (*Nk_style_slider)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_slider(out, *(*Nk_flags)(unsafe.Pointer(state)), style, bp /* &bounds */, bp+36 /* &visual_cursor */, slider_min, slider_value, slider_max)
	if (*Nk_style_slider)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 452 /* &.draw_end */))))(out, (*Nk_style_slider)(unsafe.Pointer(style)).Userdata)
	}
	return slider_value
}

var __func__345 = *(*[13]int8)(unsafe.Pointer(ts + 26213 /* "nk_do_slider" */)) /* nuklear.h:24778:1 */

func Xnk_slider_float(ctx uintptr, min_value float32, value uintptr, max_value float32, value_step float32) Nk_bool { /* nuklear.h:24862:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr

	var ret int32 = 0
	var old_value float32
	// var bounds Nk_rect at bp, 16

	var state uint32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(24875), uintptr(unsafe.Pointer(&__func__346)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(24876), uintptr(unsafe.Pointer(&__func__346)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(24877), uintptr(unsafe.Pointer(&__func__346)))
	}
	if value != 0 {
	} else {
		X__assert_fail(ts+26073 /* "value" */, ts+2 /* "nuklear/nuklear...." */, uint32(24878), uintptr(unsafe.Pointer(&__func__346)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(value != 0) {
		return ret
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout

	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return ret
	}
	if ((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0 {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}

	old_value = *(*float32)(unsafe.Pointer(value))
	*(*float32)(unsafe.Pointer(value)) = nk_do_slider((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), min_value,
		old_value, max_value, value_step, (style + 952 /* &.slider */), in, (*Nk_style)(unsafe.Pointer(style)).Font)
	return (Bool32((old_value > *(*float32)(unsafe.Pointer(value))) || (old_value < *(*float32)(unsafe.Pointer(value)))))
}

var __func__346 = *(*[16]int8)(unsafe.Pointer(ts + 26226 /* "nk_slider_float" */)) /* nuklear.h:24864:1 */

func Xnk_slide_float(ctx uintptr, min float32, val float32, max float32, step float32) float32 { /* nuklear.h:24896:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*float32)(unsafe.Pointer(bp)) = val

	Xnk_slider_float(ctx, min, bp /* &val */, max, step)
	return *(*float32)(unsafe.Pointer(bp /* val */))
}

func Xnk_slide_int(ctx uintptr, min int32, val int32, max int32, step int32) int32 { /* nuklear.h:24901:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	*(*float32)(unsafe.Pointer(bp /* value */)) = float32(val)
	Xnk_slider_float(ctx, float32(min), bp /* &value */, float32(max), float32(step))
	return int32(*(*float32)(unsafe.Pointer(bp /* value */)))
}

func Xnk_slider_int(ctx uintptr, min int32, val uintptr, max int32, step int32) Nk_bool { /* nuklear.h:24908:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var ret int32
	*(*float32)(unsafe.Pointer(bp /* value */)) = float32(*(*int32)(unsafe.Pointer(val)))
	ret = Xnk_slider_float(ctx, float32(min), bp /* &value */, float32(max), float32(step))
	*(*int32)(unsafe.Pointer(val)) = int32(*(*float32)(unsafe.Pointer(bp /* value */)))
	return ret
}

// ===============================================================
//
//                          PROGRESS
//
// ===============================================================
func nk_progress_behavior(state uintptr, in uintptr, r Nk_rect, cursor Nk_rect, max Nk_size, value Nk_size, modifiable Nk_bool) Nk_size { /* nuklear.h:24927:1: */
	var left_mouse_down int32 = 0
	var left_mouse_click_in_cursor int32 = 0

	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if !(in != 0) || !(modifiable != 0) {
		return value
	}
	left_mouse_down = (Bool32((in != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0)))
	left_mouse_click_in_cursor = (Bool32((in != 0) && (Xnk_input_has_mouse_click_down_in_rect(in,
		NK_BUTTON_LEFT, cursor, Nk_true) != 0)))
	if Xnk_input_is_mouse_hovering_rect(in, r) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
	}

	if ((in != 0) && (left_mouse_down != 0)) && (left_mouse_click_in_cursor != 0) {
		if (left_mouse_down != 0) && (left_mouse_click_in_cursor != 0) {
			var ratio float32 = ((func() float32 {
				if (float32(0)) < ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - cursor.X) {
					return ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - cursor.X)
				}
				return float32(0)
			}()) / cursor.W)
			value = func() uint32 {
				if (func() float32 {
					if (float32(max) * ratio) < (float32(max)) {
						return (float32(max) * ratio)
					}
					return float32(max)
				}()) < (float32(0)) {
					return uint32(0)
				}
				return func() uint32 {
					if (float32(max) * ratio) < (float32(max)) {
						return (uint32(float32(max) * ratio))
					}
					return uint32(float32(max))
				}()
			}()
			(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.X = (cursor.X + (cursor.W / 2.0))
			*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ACTIVE)
		}
	}
	// set progressbar widget state
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, r) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, r) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return value
}

func nk_draw_progress(out uintptr, state Nk_flags, style uintptr, bounds uintptr, scursor uintptr, value Nk_size, max Nk_size) { /* nuklear.h:24957:1: */
	var background uintptr
	var cursor uintptr

	_ = max
	_ = value

	// select correct colors/images to draw
	if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 40 /* &.active */)
		cursor = (style + 104 /* &.cursor_active */)
	} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
	} else {
		background = (style /* &.normal */)
		cursor = (style + 64 /* &.cursor_normal */)
	}

	// draw background
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_progress)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_progress)(unsafe.Pointer(style)).Rounding, (*Nk_style_progress)(unsafe.Pointer(style)).Border, (*Nk_style_progress)(unsafe.Pointer(style)).Border_color)
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
	}

	// draw cursor
	if int32((*Nk_style_item)(unsafe.Pointer(cursor)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(scursor)), (*Nk_style_progress)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(cursor + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(scursor)), (*Nk_style_progress)(unsafe.Pointer(style)).Rounding, (*Nk_style_progress)(unsafe.Pointer(style)).Border, (*Nk_style_progress)(unsafe.Pointer(style)).Border_color)
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(scursor)), (cursor + 4 /* &.data */ /* &.image */), nk_white)
	}
}

func nk_do_progress(state uintptr, out uintptr, bounds Nk_rect, value Nk_size, max Nk_size, modifiable Nk_bool, style uintptr, in uintptr) Nk_size { /* nuklear.h:24992:1: */
	bp := tlsAlloc(32)
	defer tlsFree(32)
	*(*Nk_rect)(unsafe.Pointer(bp)) = bounds

	var prog_scale float32
	var prog_value Nk_size
	// var cursor Nk_rect at bp+16, 16

	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(25001), uintptr(unsafe.Pointer(&__func__347)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(25002), uintptr(unsafe.Pointer(&__func__347)))
	}
	if !(out != 0) || !(style != 0) {
		return Nk_size(0)
	}

	// calculate progressbar cursor
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &cursor */)).W = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W) < ((float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Padding.X) + (float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Border)) {
			return ((float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Padding.X) + (float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Border))
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W
	}()
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &cursor */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H) < ((float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Padding.Y) + (float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Border)) {
			return ((float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Padding.Y) + (float32(2) * (*Nk_style_progress)(unsafe.Pointer(style)).Border))
		}
		return (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
	}()
	*(*Nk_rect)(unsafe.Pointer(bp + 16 /* cursor */)) = nk_pad_rect(*(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), Xnk_vec2(((*Nk_style_progress)(unsafe.Pointer(style)).Padding.X+(*Nk_style_progress)(unsafe.Pointer(style)).Border), ((*Nk_style_progress)(unsafe.Pointer(style)).Padding.Y+(*Nk_style_progress)(unsafe.Pointer(style)).Border)))
	prog_scale = (float32(value) / float32(max))

	// update progressbar
	prog_value = func() uint32 {
		if (value) < (max) {
			return value
		}
		return max
	}()
	prog_value = nk_progress_behavior(state, in, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), *(*Nk_rect)(unsafe.Pointer(bp + 16 /* cursor */)), max, prog_value, modifiable)
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &cursor */)).W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &cursor */)).W * prog_scale)

	// draw progressbar
	if (*Nk_style_progress)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 156 /* &.draw_begin */))))(out, (*Nk_style_progress)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_progress(out, *(*Nk_flags)(unsafe.Pointer(state)), style, bp /* &bounds */, bp+16 /* &cursor */, value, max)
	if (*Nk_style_progress)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 160 /* &.draw_end */))))(out, (*Nk_style_progress)(unsafe.Pointer(style)).Userdata)
	}
	return prog_value
}

var __func__347 = *(*[15]int8)(unsafe.Pointer(ts + 26242 /* "nk_do_progress" */)) /* nuklear.h:24996:1 */

func Xnk_progress(ctx uintptr, cur uintptr, max Nk_size, is_modifyable Nk_bool) Nk_bool { /* nuklear.h:25023:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var style uintptr
	var in uintptr
	// var bounds Nk_rect at bp, 16

	var state uint32
	var old_value Nk_size

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(25034), uintptr(unsafe.Pointer(&__func__348)))
	}
	if cur != 0 {
	} else {
		X__assert_fail(ts+26257 /* "cur" */, ts+2 /* "nuklear/nuklear...." */, uint32(25035), uintptr(unsafe.Pointer(&__func__348)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(25036), uintptr(unsafe.Pointer(&__func__348)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(25037), uintptr(unsafe.Pointer(&__func__348)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(cur != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}

	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	old_value = *(*Nk_size)(unsafe.Pointer(cur))
	*(*Nk_size)(unsafe.Pointer(cur)) = nk_do_progress((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		*(*Nk_size)(unsafe.Pointer(cur)), max, is_modifyable, (style + 1408 /* &.progress */), in)
	return (Bool32(*(*Nk_size)(unsafe.Pointer(cur)) != old_value))
}

var __func__348 = *(*[12]int8)(unsafe.Pointer(ts + 26261 /* "nk_progress" */)) /* nuklear.h:25024:1 */

func Xnk_prog(ctx uintptr, cur Nk_size, max Nk_size, modifyable Nk_bool) Nk_size { /* nuklear.h:25054:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)
	*(*Nk_size)(unsafe.Pointer(bp)) = cur

	Xnk_progress(ctx, bp /* &cur */, max, modifyable)
	return *(*Nk_size)(unsafe.Pointer(bp /* cur */))
}

// ===============================================================
//
//                              SCROLLBAR
//
// ===============================================================
func nk_scrollbar_behavior(state uintptr, in uintptr, has_scrolling int32, scroll uintptr, cursor uintptr, empty0 uintptr, empty1 uintptr, scroll_offset float32, target float32, scroll_step float32, o uint32) float32 { /* nuklear.h:25070:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	*(*Nk_flags)(unsafe.Pointer(bp /* ws */)) = Nk_flags(0)
	var left_mouse_down int32
	var left_mouse_clicked int32
	var left_mouse_click_in_cursor int32
	var scroll_delta float32

	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if !(in != 0) {
		return scroll_offset
	}

	left_mouse_down = (*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down
	left_mouse_clicked = int32((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked)
	left_mouse_click_in_cursor = Xnk_input_has_mouse_click_down_in_rect(in,
		NK_BUTTON_LEFT, *(*Nk_rect)(unsafe.Pointer(cursor)), Nk_true)
	if Xnk_input_is_mouse_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(scroll))) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
	}

	if int32(o) == NK_VERTICAL {
		scroll_delta = (*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta.Y
	} else {
		scroll_delta = (*Nk_input)(unsafe.Pointer(in)).Mouse.Scroll_delta.X
	}
	if ((left_mouse_down != 0) && (left_mouse_click_in_cursor != 0)) && !(left_mouse_clicked != 0) {
		// update cursor by mouse dragging
		var pixel float32
		var delta float32
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
		if int32(o) == NK_VERTICAL {
			var cursor_y float32
			pixel = (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y
			delta = ((pixel / (*Nk_rect)(unsafe.Pointer(scroll)).H) * target)
			scroll_offset = func() float32 {
				if (func() float32 {
					if (scroll_offset + delta) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
						return (scroll_offset + delta)
					}
					return (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
				}()) < (float32(0)) {
					return float32(0)
				}
				return func() float32 {
					if (scroll_offset + delta) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
						return (scroll_offset + delta)
					}
					return (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
				}()
			}()
			cursor_y = ((*Nk_rect)(unsafe.Pointer(scroll)).Y + ((scroll_offset / target) * (*Nk_rect)(unsafe.Pointer(scroll)).H))
			(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.Y = (cursor_y + ((*Nk_rect)(unsafe.Pointer(cursor)).H / 2.0))
		} else {
			var cursor_x float32
			pixel = (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X
			delta = ((pixel / (*Nk_rect)(unsafe.Pointer(scroll)).W) * target)
			scroll_offset = func() float32 {
				if (func() float32 {
					if (scroll_offset + delta) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
						return (scroll_offset + delta)
					}
					return (target - (*Nk_rect)(unsafe.Pointer(scroll)).W)
				}()) < (float32(0)) {
					return float32(0)
				}
				return func() float32 {
					if (scroll_offset + delta) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
						return (scroll_offset + delta)
					}
					return (target - (*Nk_rect)(unsafe.Pointer(scroll)).W)
				}()
			}()
			cursor_x = ((*Nk_rect)(unsafe.Pointer(scroll)).X + ((scroll_offset / target) * (*Nk_rect)(unsafe.Pointer(scroll)).W))
			(*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked_pos.X = (cursor_x + ((*Nk_rect)(unsafe.Pointer(cursor)).W / 2.0))
		}
	} else if (((Xnk_input_is_key_pressed(in, NK_KEY_SCROLL_UP) != 0) && (int32(o) == NK_VERTICAL)) && (has_scrolling != 0)) || (nk_button_behavior(bp /* &ws */, *(*Nk_rect)(unsafe.Pointer(empty0)), in, NK_BUTTON_DEFAULT) != 0) {
		// scroll page up by click on empty space or shortcut
		if int32(o) == NK_VERTICAL {
			scroll_offset = func() float32 {
				if (float32(0)) < (scroll_offset - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
					return (scroll_offset - (*Nk_rect)(unsafe.Pointer(scroll)).H)
				}
				return float32(0)
			}()
		} else {
			scroll_offset = func() float32 {
				if (float32(0)) < (scroll_offset - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
					return (scroll_offset - (*Nk_rect)(unsafe.Pointer(scroll)).W)
				}
				return float32(0)
			}()
		}
	} else if (((Xnk_input_is_key_pressed(in, NK_KEY_SCROLL_DOWN) != 0) && (int32(o) == NK_VERTICAL)) && (has_scrolling != 0)) || (nk_button_behavior(bp /* &ws */, *(*Nk_rect)(unsafe.Pointer(empty1)), in, NK_BUTTON_DEFAULT) != 0) {
		// scroll page down by click on empty space or shortcut
		if int32(o) == NK_VERTICAL {
			scroll_offset = func() float32 {
				if (scroll_offset + (*Nk_rect)(unsafe.Pointer(scroll)).H) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
					return (scroll_offset + (*Nk_rect)(unsafe.Pointer(scroll)).H)
				}
				return (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
			}()
		} else {
			scroll_offset = func() float32 {
				if (scroll_offset + (*Nk_rect)(unsafe.Pointer(scroll)).W) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
					return (scroll_offset + (*Nk_rect)(unsafe.Pointer(scroll)).W)
				}
				return (target - (*Nk_rect)(unsafe.Pointer(scroll)).W)
			}()
		}
	} else if has_scrolling != 0 {
		if (scroll_delta < float32(0)) || (scroll_delta > float32(0)) {
			// update cursor by mouse scrolling
			scroll_offset = (scroll_offset + (scroll_step * (-scroll_delta)))
			if int32(o) == NK_VERTICAL {
				scroll_offset = func() float32 {
					if (func() float32 {
						if (scroll_offset) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
							return scroll_offset
						}
						return (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
					}()) < (float32(0)) {
						return float32(0)
					}
					return func() float32 {
						if (scroll_offset) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).H) {
							return scroll_offset
						}
						return (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
					}()
				}()
			} else {
				scroll_offset = func() float32 {
					if (func() float32 {
						if (scroll_offset) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
							return scroll_offset
						}
						return (target - (*Nk_rect)(unsafe.Pointer(scroll)).W)
					}()) < (float32(0)) {
						return float32(0)
					}
					return func() float32 {
						if (scroll_offset) < (target - (*Nk_rect)(unsafe.Pointer(scroll)).W) {
							return scroll_offset
						}
						return (target - (*Nk_rect)(unsafe.Pointer(scroll)).W)
					}()
				}()
			}
		} else if Xnk_input_is_key_pressed(in, NK_KEY_SCROLL_START) != 0 {
			// update cursor to the beginning
			if int32(o) == NK_VERTICAL {
				scroll_offset = float32(0)
			}
		} else if Xnk_input_is_key_pressed(in, NK_KEY_SCROLL_END) != 0 {
			// update cursor to the end
			if int32(o) == NK_VERTICAL {
				scroll_offset = (target - (*Nk_rect)(unsafe.Pointer(scroll)).H)
			}
		}
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(scroll))) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(scroll))) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return scroll_offset
}

func nk_draw_scrollbar(out uintptr, state Nk_flags, style uintptr, bounds uintptr, scroll uintptr) { /* nuklear.h:25146:1: */
	var background uintptr
	var cursor uintptr

	// select correct colors/images to draw
	if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 40 /* &.active */)
		cursor = (style + 104 /* &.cursor_active */)
	} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		cursor = (style + 84 /* &.cursor_hover */)
	} else {
		background = (style /* &.normal */)
		cursor = (style + 64 /* &.cursor_normal */)
	}

	// draw background
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_scrollbar)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_scrollbar)(unsafe.Pointer(style)).Rounding, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border_color)
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
	}

	// draw cursor
	if int32((*Nk_style_item)(unsafe.Pointer(cursor)).Type) == NK_STYLE_ITEM_COLOR {
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(scroll)), (*Nk_style_scrollbar)(unsafe.Pointer(style)).Rounding_cursor, *(*Nk_color)(unsafe.Pointer(cursor + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(scroll)), (*Nk_style_scrollbar)(unsafe.Pointer(style)).Rounding_cursor, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border_cursor, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Cursor_border_color)
	} else {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(scroll)), (cursor + 4 /* &.data */ /* &.image */), nk_white)
	}
}

func nk_do_scrollbarv(state uintptr, out uintptr, scroll Nk_rect, has_scrolling int32, offset float32, target float32, step float32, button_pixel_inc float32, style uintptr, in uintptr, font uintptr) float32 { /* nuklear.h:25180:1: */
	bp := tlsAlloc(68)
	defer tlsFree(68)
	*(*Nk_rect)(unsafe.Pointer(bp + 4)) = scroll

	// var empty_north Nk_rect at bp+36, 16

	// var empty_south Nk_rect at bp+52, 16

	// var cursor Nk_rect at bp+20, 16

	var scroll_step float32
	var scroll_offset float32
	var scroll_off float32
	var scroll_ratio float32

	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(25195), uintptr(unsafe.Pointer(&__func__349)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(25196), uintptr(unsafe.Pointer(&__func__349)))
	}
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(25197), uintptr(unsafe.Pointer(&__func__349)))
	}
	if !(out != 0) || !(style != 0) {
		return float32(0)
	}

	(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W) < (float32(1)) {
			return float32(1)
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
	}()
	(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H) < (float32(0)) {
			return float32(0)
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H
	}()
	if target <= (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H {
		return float32(0)
	}

	// optional scrollbar buttons
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Show_buttons != 0 {
		// var ws Nk_flags at bp, 4

		var scroll_h float32
		var button Nk_rect

		button.X = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X
		button.W = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
		button.H = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W

		scroll_h = func() float32 {
			if ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H - (float32(2) * button.H)) < (float32(0)) {
				return float32(0)
			}
			return ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H - (float32(2) * button.H))
		}()
		scroll_step = func() float32 {
			if (step) < (button_pixel_inc) {
				return step
			}
			return button_pixel_inc
		}()

		// decrement button
		button.Y = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y
		if nk_do_button_symbol(bp /* &ws */, out, button, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Dec_symbol,
			NK_BUTTON_REPEATER, (style+284 /* &.dec_button */), in, font) != 0 {
			offset = (offset - scroll_step)
		}

		// increment button
		button.Y = (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) - button.H)
		if nk_do_button_symbol(bp /* &ws */, out, button, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Inc_symbol,
			NK_BUTTON_REPEATER, (style+156 /* &.inc_button */), in, font) != 0 {
			offset = (offset + scroll_step)
		}

		(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + button.H)
		(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H = scroll_h
	}

	// calculate scrollbar constants
	scroll_step = func() float32 {
		if (step) < ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H) {
			return step
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H
	}()
	scroll_offset = func() float32 {
		if (func() float32 {
			if (offset) < (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) {
				return offset
			}
			return (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H)
		}()) < (float32(0)) {
			return float32(0)
		}
		return func() float32 {
			if (offset) < (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) {
				return offset
			}
			return (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H)
		}()
	}()
	scroll_ratio = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H / target)
	scroll_off = (scroll_offset / target)

	// calculate scrollbar cursor bounds
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).H = func() float32 {
		if ((scroll_ratio * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) - ((float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y))) < (float32(0)) {
			return float32(0)
		}
		return ((scroll_ratio * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) - ((float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y)))
	}()
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).Y = ((((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (scroll_off * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H)) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).W = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W - ((float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.X)))
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).X = (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.X)

	// calculate empty space around cursor
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_north */)).X = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_north */)).Y = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_north */)).W = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_north */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).Y - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y) < (float32(0)) {
			return float32(0)
		}
		return ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).Y - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y)
	}()

	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_south */)).X = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_south */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).Y + (*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).H)
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_south */)).W = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_south */)).H = func() float32 {
		if (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) - ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).Y + (*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).H)) < (float32(0)) {
			return float32(0)
		}
		return (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) - ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).Y + (*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).H))
	}()

	// update scrollbar
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, bp+4 /* &scroll */, bp+20, /* &cursor */
		bp+36 /* &empty_north */, bp+52 /* &empty_south */, scroll_offset, target, scroll_step, NK_VERTICAL)
	scroll_off = (scroll_offset / target)
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).Y = ((((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (scroll_off * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H)) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border_cursor) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y)

	// draw scrollbar
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 424 /* &.draw_begin */))))(out, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_scrollbar(out, *(*Nk_flags)(unsafe.Pointer(state)), style, bp+4 /* &scroll */, bp+20 /* &cursor */)
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 428 /* &.draw_end */))))(out, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Userdata)
	}
	return scroll_offset
}

var __func__349 = *(*[17]int8)(unsafe.Pointer(ts + 26273 /* "nk_do_scrollbarv" */)) /* nuklear.h:25185:1 */

func nk_do_scrollbarh(state uintptr, out uintptr, scroll Nk_rect, has_scrolling int32, offset float32, target float32, step float32, button_pixel_inc float32, style uintptr, in uintptr, font uintptr) float32 { /* nuklear.h:25269:1: */
	bp := tlsAlloc(68)
	defer tlsFree(68)
	*(*Nk_rect)(unsafe.Pointer(bp + 4)) = scroll

	// var cursor Nk_rect at bp+20, 16

	// var empty_west Nk_rect at bp+36, 16

	// var empty_east Nk_rect at bp+52, 16

	var scroll_step float32
	var scroll_offset float32
	var scroll_off float32
	var scroll_ratio float32

	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(25284), uintptr(unsafe.Pointer(&__func__350)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(25285), uintptr(unsafe.Pointer(&__func__350)))
	}
	if !(out != 0) || !(style != 0) {
		return float32(0)
	}

	// scrollbar background
	(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H) < (float32(1)) {
			return float32(1)
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H
	}()
	(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W = func() float32 {
		if ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W) < (float32(2) * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H) {
			return (float32(2) * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H)
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
	}()
	if target <= (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W {
		return float32(0)
	}

	// optional scrollbar buttons
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Show_buttons != 0 {
		// var ws Nk_flags at bp, 4

		var scroll_w float32
		var button Nk_rect
		button.Y = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y
		button.W = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H
		button.H = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H

		scroll_w = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W - (float32(2) * button.W))
		scroll_step = func() float32 {
			if (step) < (button_pixel_inc) {
				return step
			}
			return button_pixel_inc
		}()

		// decrement button
		button.X = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X
		if nk_do_button_symbol(bp /* &ws */, out, button, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Dec_symbol,
			NK_BUTTON_REPEATER, (style+284 /* &.dec_button */), in, font) != 0 {
			offset = (offset - scroll_step)
		}

		// increment button
		button.X = (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W) - button.W)
		if nk_do_button_symbol(bp /* &ws */, out, button, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Inc_symbol,
			NK_BUTTON_REPEATER, (style+156 /* &.inc_button */), in, font) != 0 {
			offset = (offset + scroll_step)
		}

		(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + button.W)
		(*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W = scroll_w
	}

	// calculate scrollbar constants
	scroll_step = func() float32 {
		if (step) < ((*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W) {
			return step
		}
		return (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).W
	}()
	scroll_offset = func() float32 {
		if (func() float32 {
			if (offset) < (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W) {
				return offset
			}
			return (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W)
		}()) < (float32(0)) {
			return float32(0)
		}
		return func() float32 {
			if (offset) < (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W) {
				return offset
			}
			return (target - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W)
		}()
	}()
	scroll_ratio = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W / target)
	scroll_off = (scroll_offset / target)

	// calculate cursor bounds
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).W = ((scroll_ratio * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W) - ((float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.X)))
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).X = ((((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + (scroll_off * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W)) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.X)
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).H = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).H - ((float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y)))
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).Y = (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).Y + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Border) + (*Nk_style_scrollbar)(unsafe.Pointer(style)).Padding.Y)

	// calculate empty space around cursor
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_west */)).X = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).X
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_west */)).Y = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_west */)).W = ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).X - (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X)
	(*Nk_rect)(unsafe.Pointer(bp + 36 /* &empty_west */)).H = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H

	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_east */)).X = ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).X + (*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).W)
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_east */)).Y = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_east */)).W = (((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W) - ((*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).X + (*Nk_rect)(unsafe.Pointer(bp+20 /* &cursor */)).W))
	(*Nk_rect)(unsafe.Pointer(bp + 52 /* &empty_east */)).H = (*Nk_rect)(unsafe.Pointer(bp + 4 /* &scroll */)).H

	// update scrollbar
	scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, bp+4 /* &scroll */, bp+20, /* &cursor */
		bp+36 /* &empty_west */, bp+52 /* &empty_east */, scroll_offset, target, scroll_step, NK_HORIZONTAL)
	scroll_off = (scroll_offset / target)
	(*Nk_rect)(unsafe.Pointer(bp + 20 /* &cursor */)).X = ((*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).X + (scroll_off * (*Nk_rect)(unsafe.Pointer(bp+4 /* &scroll */)).W))

	// draw scrollbar
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 424 /* &.draw_begin */))))(out, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_scrollbar(out, *(*Nk_flags)(unsafe.Pointer(state)), style, bp+4 /* &scroll */, bp+20 /* &cursor */)
	if (*Nk_style_scrollbar)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 428 /* &.draw_end */))))(out, (*Nk_style_scrollbar)(unsafe.Pointer(style)).Userdata)
	}
	return scroll_offset
}

var __func__350 = *(*[17]int8)(unsafe.Pointer(ts + 26290 /* "nk_do_scrollbarh" */)) /* nuklear.h:25274:1 */

// ===============================================================
//
//                          TEXT EDITOR
//
// ===============================================================
// stb_textedit.h - v1.8  - public domain - Sean Barrett
type Nk_text_find = struct {
	X          float32
	Y          float32
	Height     float32
	First_char int32
	Length     int32
	Prev_first int32
} /* nuklear.h:25367:1 */

type Nk_text_edit_row = struct {
	X0               float32
	X1               float32
	Baseline_y_delta float32
	Ymin             float32
	Ymax             float32
	Num_chars        int32
} /* nuklear.h:25374:1 */

func nk_textedit_get_width(edit uintptr, line_start int32, char_id int32, font uintptr) float32 { /* nuklear.h:25391:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	*(*int32)(unsafe.Pointer(bp + 4 /* len */)) = 0
	*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
	var str uintptr = Xnk_str_at_const((edit + 12 /* &.string */), (line_start + char_id), bp /* &unicode */, bp+4 /* &len */)
	return (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, str, *(*int32)(unsafe.Pointer(bp + 4 /* len */)))
}

func nk_textedit_layout_row(r uintptr, edit uintptr, line_start_id int32, row_height float32, font uintptr) { /* nuklear.h:25400:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var l int32 at bp+4, 4

	*(*int32)(unsafe.Pointer(bp + 12 /* glyphs */)) = 0
	// var unicode Nk_rune at bp, 4

	// var remaining uintptr at bp+8, 4

	var len int32 = Xnk_str_len_char((edit + 12 /* &.string */))
	var end uintptr = (Xnk_str_get_const((edit + 12 /* &.string */)) + uintptr(len))
	var text uintptr = Xnk_str_at_const((edit + 12 /* &.string */), line_start_id, bp /* &unicode */, bp+4 /* &l */)
	var size = nk_text_calculate_text_bounds(font,
		text, (int32((int32(end) - int32(text)) / 1)), row_height, bp+8 /* &remaining */, uintptr(0), bp+12 /* &glyphs */, NK_STOP_ON_NEW_LINE)

	(*Nk_text_edit_row)(unsafe.Pointer(r)).X0 = 0.0
	(*Nk_text_edit_row)(unsafe.Pointer(r)).X1 = size.X
	(*Nk_text_edit_row)(unsafe.Pointer(r)).Baseline_y_delta = size.Y
	(*Nk_text_edit_row)(unsafe.Pointer(r)).Ymin = 0.0
	(*Nk_text_edit_row)(unsafe.Pointer(r)).Ymax = size.Y
	(*Nk_text_edit_row)(unsafe.Pointer(r)).Num_chars = *(*int32)(unsafe.Pointer(bp + 12 /* glyphs */))
}

func nk_textedit_locate_coord(edit uintptr, x float32, y float32, font uintptr, row_height float32) int32 { /* nuklear.h:25421:1: */
	bp := tlsAlloc(24)
	defer tlsFree(24)

	// var r Nk_text_edit_row at bp, 24

	var n int32 = (*Nk_text_edit)(unsafe.Pointer(edit)).String.Len
	var base_y float32 = float32(0)
	var prev_x float32
	var i int32 = 0
	var k int32

	(*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X0 = AssignPtrFloat32(bp /* &r */ +4 /* &.x1 */, float32(0))
	(*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymin = AssignPtrFloat32(bp /* &r */ +16 /* &.ymax */, float32(0))
	(*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars = 0

	// search rows to find one that straddles 'y'
	for i < n {
		nk_textedit_layout_row(bp /* &r */, edit, i, row_height, font)
		if (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars <= 0 {
			return n
		}

		if (i == 0) && (y < (base_y + (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymin)) {
			return 0
		}

		if y < (base_y + (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymax) {
			break
		}

		i = i + ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars)
		base_y = base_y + ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Baseline_y_delta)
	}

	// below all text, return 'after' last character
	if i >= n {
		return n
	}

	// check if it's before the beginning of the line
	if x < (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X0 {
		return i
	}

	// check if it's before the end of the line
	if x < (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X1 {
		// search characters in row for one that straddles 'x'
		k = i
		prev_x = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X0
		for i = 0; i < (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars; i++ {
			var w float32 = nk_textedit_get_width(edit, k, i, font)
			if x < (prev_x + w) {
				if x < (prev_x + (w / float32(2))) {
					return (k + i)
				} else {
					return ((k + i) + 1)
				}
			}
			prev_x = prev_x + (w)
		}
		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that.
	// otherwise return 'after' the last character
	if Xnk_str_rune_at((edit+12 /* &.string */), ((i+(*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars)-1)) == Nk_rune('\n') {
		return ((i + (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars) - 1)
	} else {
		return (i + (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars)
	}
	return int32(0)
}

func nk_textedit_click(state uintptr, x float32, y float32, font uintptr, row_height float32) { /* nuklear.h:25481:1: */
	// API click: on mouse down, move the cursor to the clicked location,
	// and reset the selection
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = nk_textedit_locate_coord(state, x, y, font, row_height)
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
}

func nk_textedit_drag(state uintptr, x float32, y float32, font uintptr, row_height float32) { /* nuklear.h:25492:1: */
	// API drag: on mouse drag, move the cursor and selection endpoint
	// to the clicked location
	var p int32 = nk_textedit_locate_coord(state, x, y, font, row_height)
	if (*Nk_text_edit)(unsafe.Pointer(state)).Select_start == (*Nk_text_edit)(unsafe.Pointer(state)).Select_end {
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = AssignPtrInt32(state+96 /* &.select_end */, p)
}

func nk_textedit_find_charpos(find uintptr, state uintptr, n int32, single_line int32, font uintptr, row_height float32) { /* nuklear.h:25503:1: */
	bp := tlsAlloc(24)
	defer tlsFree(24)

	// find the x/y location of a character, and remember info about the previous
	// row in case we get a move-up event (for page up, we'll have to rescan)
	// var r Nk_text_edit_row at bp, 24

	var prev_start int32 = 0
	var z int32 = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
	var i int32 = 0
	var first int32

	nk_zero(bp /* &r */, uint32(unsafe.Sizeof(Nk_text_edit_row{})))
	if n == z {
		// if it's at the end, then find the last line -- simpler than trying to
		//         explicitly handle this case in the regular code
		nk_textedit_layout_row(bp /* &r */, state, 0, row_height, font)
		if single_line != 0 {
			(*Nk_text_find)(unsafe.Pointer(find)).First_char = 0
			(*Nk_text_find)(unsafe.Pointer(find)).Length = z
		} else {
			for i < z {
				prev_start = i
				i = i + ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars)
				nk_textedit_layout_row(bp /* &r */, state, i, row_height, font)
			}

			(*Nk_text_find)(unsafe.Pointer(find)).First_char = i
			(*Nk_text_find)(unsafe.Pointer(find)).Length = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars
		}
		(*Nk_text_find)(unsafe.Pointer(find)).X = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X1
		(*Nk_text_find)(unsafe.Pointer(find)).Y = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymin
		(*Nk_text_find)(unsafe.Pointer(find)).Height = ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymax - (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymin)
		(*Nk_text_find)(unsafe.Pointer(find)).Prev_first = prev_start
		return
	}

	// search rows to find the one that straddles character n
	(*Nk_text_find)(unsafe.Pointer(find)).Y = float32(0)

	for {
		nk_textedit_layout_row(bp /* &r */, state, i, row_height, font)
		if n < (i + (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars) {
			break
		}
		prev_start = i
		i = i + ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars)
		*(*float32)(unsafe.Pointer(find + 4 /* &.y */)) += ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Baseline_y_delta)
	}

	(*Nk_text_find)(unsafe.Pointer(find)).First_char = AssignInt32(&first, i)
	(*Nk_text_find)(unsafe.Pointer(find)).Length = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Num_chars
	(*Nk_text_find)(unsafe.Pointer(find)).Height = ((*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymax - (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).Ymin)
	(*Nk_text_find)(unsafe.Pointer(find)).Prev_first = prev_start

	// now scan to find xpos
	(*Nk_text_find)(unsafe.Pointer(find)).X = (*Nk_text_edit_row)(unsafe.Pointer(bp /* &r */)).X0
	for i = 0; (first + i) < n; i++ {
		*(*float32)(unsafe.Pointer(find /* &.x */)) += (nk_textedit_get_width(state, first, i, font))
	}
}

func nk_textedit_clamp(state uintptr) { /* nuklear.h:25560:1: */
	// make the selection/cursor state valid if client altered the string
	var n int32 = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
	if (*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end {
		if (*Nk_text_edit)(unsafe.Pointer(state)).Select_start > n {
			(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = n
		}
		if (*Nk_text_edit)(unsafe.Pointer(state)).Select_end > n {
			(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = n
		}
		// if clamping forced them to be equal, move the cursor to match
		if (*Nk_text_edit)(unsafe.Pointer(state)).Select_start == (*Nk_text_edit)(unsafe.Pointer(state)).Select_end {
			(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_start
		}
	}
	if (*Nk_text_edit)(unsafe.Pointer(state)).Cursor > n {
		(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = n
	}
}

func Xnk_textedit_delete(state uintptr, where int32, len int32) { /* nuklear.h:25574:1: */
	// delete characters while updating undo
	nk_textedit_makeundo_delete(state, where, len)
	Xnk_str_delete_runes((state + 12 /* &.string */), where, len)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
}

func Xnk_textedit_delete_selection(state uintptr) { /* nuklear.h:25582:1: */
	// delete the section
	nk_textedit_clamp(state)
	if (*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end {
		if (*Nk_text_edit)(unsafe.Pointer(state)).Select_start < (*Nk_text_edit)(unsafe.Pointer(state)).Select_end {
			Xnk_textedit_delete(state, (*Nk_text_edit)(unsafe.Pointer(state)).Select_start,
				((*Nk_text_edit)(unsafe.Pointer(state)).Select_end - (*Nk_text_edit)(unsafe.Pointer(state)).Select_start))
			(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = AssignPtrInt32(state+88 /* &.cursor */, (*Nk_text_edit)(unsafe.Pointer(state)).Select_start)
		} else {
			Xnk_textedit_delete(state, (*Nk_text_edit)(unsafe.Pointer(state)).Select_end,
				((*Nk_text_edit)(unsafe.Pointer(state)).Select_start - (*Nk_text_edit)(unsafe.Pointer(state)).Select_end))
			(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = AssignPtrInt32(state+88 /* &.cursor */, (*Nk_text_edit)(unsafe.Pointer(state)).Select_end)
		}
		(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	}
}

func nk_textedit_sortselection(state uintptr) { /* nuklear.h:25600:1: */
	// canonicalize the selection so start <= end
	if (*Nk_text_edit)(unsafe.Pointer(state)).Select_end < (*Nk_text_edit)(unsafe.Pointer(state)).Select_start {
		var temp int32 = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Select_start
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = temp
	}
}

func nk_textedit_move_to_first(state uintptr) { /* nuklear.h:25610:1: */
	// move cursor to first character of selection
	if (*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end {
		nk_textedit_sortselection(state)
		(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_start
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Select_start
		(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	}
}

func nk_textedit_move_to_last(state uintptr) { /* nuklear.h:25621:1: */
	// move cursor to last character of selection
	if (*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end {
		nk_textedit_sortselection(state)
		nk_textedit_clamp(state)
		(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
		(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	}
}

func nk_is_word_boundary(state uintptr, idx int32) int32 { /* nuklear.h:25633:1: */
	bp := tlsAlloc(8)
	defer tlsFree(8)

	// var len int32 at bp+4, 4

	// var c Nk_rune at bp, 4

	if idx <= 0 {
		return 1
	}
	if !(Xnk_str_at_rune((state+12 /* &.string */), idx, bp /* &c */, bp+4 /* &len */) != 0) {
		return 1
	}
	return (Bool32((((((((((((*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(' ')) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('\t'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(0x3000))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(','))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(';'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('('))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(')'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('{'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('}'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('['))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune(']'))) || (*(*Nk_rune)(unsafe.Pointer(bp /* c */)) == Nk_rune('|'))))
}

func nk_textedit_move_to_word_previous(state uintptr) int32 { /* nuklear.h:25644:1: */
	var c int32 = ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor - 1)
	for (c >= 0) && !(nk_is_word_boundary(state, c) != 0) {
		c--
	}

	if c < 0 {
		c = 0
	}

	return c
}

func nk_textedit_move_to_word_next(state uintptr) int32 { /* nuklear.h:25656:1: */
	var len int32 = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
	var c int32 = ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor + 1)
	for (c < len) && !(nk_is_word_boundary(state, c) != 0) {
		c++
	}

	if c > len {
		c = len
	}

	return c
}

func nk_textedit_prep_selection_at_cursor(state uintptr) { /* nuklear.h:25669:1: */
	// update selection and cursor to match each other
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = AssignPtrInt32(state+96 /* &.select_end */, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor)
	} else {
		(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
	}
}

func Xnk_textedit_cut(state uintptr) Nk_bool { /* nuklear.h:25677:1: */
	// API cut: delete selection
	if int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW {
		return 0
	}
	if (*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end {
		Xnk_textedit_delete_selection(state) // implicitly clamps
		(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
		return 1
	}
	return 0
}

func Xnk_textedit_paste(state uintptr, ctext uintptr, len int32) Nk_bool { /* nuklear.h:25690:1: */
	// API paste: replace existing selection with passed-in text
	var glyphs int32
	var text uintptr = ctext
	if int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW {
		return 0
	}

	// if there's a selection, the paste should delete it
	nk_textedit_clamp(state)
	Xnk_textedit_delete_selection(state)

	// try to insert the characters
	glyphs = Xnk_utf_len(ctext, len)
	if Xnk_str_insert_text_char((state+12 /* &.string */), (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, text, len) != 0 {
		nk_textedit_makeundo_insert(state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, glyphs)
		*(*int32)(unsafe.Pointer(state + 88 /* &.cursor */)) += (len)
		(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
		return 1
	}
	// remove the undo since we didn't actually insert the characters
	if (*Nk_text_edit)(unsafe.Pointer(state)).Undo.Undo_point != 0 {
		(*Nk_text_edit)(unsafe.Pointer(state)).Undo.Undo_point--
	}
	return 0
}

func Xnk_textedit_text(state uintptr, text uintptr, total_len int32) { /* nuklear.h:25715:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	// var unicode Nk_rune at bp, 4

	var glyph_len int32
	var text_len int32
	text_len = 0

	if !(state != 0) {
		goto __1
	}
	goto __2
__1:
	X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(25721), uintptr(unsafe.Pointer(&__func__351)))
__2:
	;
	if !(text != 0) {
		goto __3
	}
	goto __4
__3:
	X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(25722), uintptr(unsafe.Pointer(&__func__351)))
__4:
	;
	if !((!(text != 0) || !(total_len != 0)) || (int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW)) {
		goto __5
	}
	return
__5:
	;

	glyph_len = Xnk_utf_decode(text, bp /* &unicode */, total_len)
__6:
	if !((text_len < total_len) && (glyph_len != 0)) {
		goto __7
	}

	// don't insert a backward delete, just process the event
	if !(*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune(127)) {
		goto __8
	}
	goto next
__8:
	;
	// can't add newline in single-line mode
	if !((*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune('\n')) && ((*Nk_text_edit)(unsafe.Pointer(state)).Single_line != 0)) {
		goto __9
	}
	goto next
__9:
	;
	// filter incoming text
	if !(((*Nk_text_edit)(unsafe.Pointer(state)).Filter != 0) && !((*(*func(uintptr, Nk_rune) Nk_bool)(unsafe.Pointer((state + 76 /* &.filter */))))(state, *(*Nk_rune)(unsafe.Pointer(bp /* unicode */))) != 0)) {
		goto __10
	}
	goto next
__10:
	;

	if !(!((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) && ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor < (*Nk_text_edit)(unsafe.Pointer(state)).String.Len)) {
		goto __11
	}

	if !(int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_REPLACE) {
		goto __13
	}
	nk_textedit_makeundo_replace(state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, 1, 1)
	Xnk_str_delete_runes((state + 12 /* &.string */), (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, 1)
__13:
	;
	if !(Xnk_str_insert_text_utf8((state+12 /* &.string */), (*Nk_text_edit)(unsafe.Pointer(state)).Cursor,
		(text+uintptr(text_len)), 1) != 0) {
		goto __14
	}

	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor++
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__14:
	;
	goto __12
__11:
	Xnk_textedit_delete_selection(state) // implicitly clamps
	if !(Xnk_str_insert_text_utf8((state+12 /* &.string */), (*Nk_text_edit)(unsafe.Pointer(state)).Cursor,
		(text+uintptr(text_len)), 1) != 0) {
		goto __15
	}

	nk_textedit_makeundo_insert(state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, 1)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor++
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__15:
	;
__12:
	;
next:
	text_len = text_len + (glyph_len)
	glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp /* &unicode */, (total_len - text_len))
	goto __6
__7:
	;
}

var __func__351 = *(*[17]int8)(unsafe.Pointer(ts + 26307 /* "nk_textedit_text" */)) /* nuklear.h:25716:1 */

func nk_textedit_key(state uintptr, key uint32, shift_mod int32, font uintptr, row_height float32) { /* nuklear.h:25764:1: */
	bp := tlsAlloc(192)
	defer tlsFree(192)

	var dx float32
	var x float32
	var goal_x float32
	var start int32
	// var find Nk_text_find at bp, 24

	// var row Nk_text_edit_row at bp+24, 24

	var i int32
	var sel int32
	var dx1 float32
	// now find character position up a row
	var x1 float32
	var goal_x1 float32
	// var find1 Nk_text_find at bp+48, 24

	// var row1 Nk_text_edit_row at bp+72, 24

	var i1 int32
	var sel1 int32
	var n int32
	// var find2 Nk_text_find at bp+96, 24

	// var find3 Nk_text_find at bp+120, 24

	// var find4 Nk_text_find at bp+144, 24

	// var find5 Nk_text_find at bp+168, 24

retry:
	switch key {
	case NK_KEY_NONE:
		goto __2
	case NK_KEY_CTRL:
		goto __3
	case NK_KEY_ENTER:
		goto __4
	case NK_KEY_SHIFT:
		goto __5
	case NK_KEY_TAB:
		goto __6
	case NK_KEY_COPY:
		goto __7
	case NK_KEY_CUT:
		goto __8
	case NK_KEY_PASTE:
		goto __9
	case NK_KEY_MAX:
		goto __10
	default:
		goto __11
	case NK_KEY_TEXT_UNDO:
		goto __12

	case NK_KEY_TEXT_REDO:
		goto __13

	case NK_KEY_TEXT_SELECT_ALL:
		goto __14

	case NK_KEY_TEXT_INSERT_MODE:
		goto __15
	case NK_KEY_TEXT_REPLACE_MODE:
		goto __16
	case NK_KEY_TEXT_RESET_MODE:
		goto __17

	case NK_KEY_LEFT:
		goto __18

	case NK_KEY_RIGHT:
		goto __19

	case NK_KEY_TEXT_WORD_LEFT:
		goto __20

	case NK_KEY_TEXT_WORD_RIGHT:
		goto __21

	case NK_KEY_DOWN:
		goto __22

	case NK_KEY_UP:
		goto __23

	case NK_KEY_DEL:
		goto __24

	case NK_KEY_BACKSPACE:
		goto __25

	case NK_KEY_TEXT_START:
		goto __26

	case NK_KEY_TEXT_END:
		goto __27

	case NK_KEY_TEXT_LINE_START:
		goto __28

	case NK_KEY_TEXT_LINE_END:
		goto __29
	}
	goto __1

__2:
__3:
__4:
__5:
__6:
__7:
__8:
__9:
__10:
__11:
	goto __1
__12:
	Xnk_textedit_undo(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __1

__13:
	Xnk_textedit_redo(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __1

__14:
	Xnk_textedit_select_all(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __1

__15:
	if !(int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW) {
		goto __30
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Mode = NK_TEXT_EDIT_MODE_INSERT
__30:
	;
	goto __1
__16:
	if !(int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW) {
		goto __31
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Mode = NK_TEXT_EDIT_MODE_REPLACE
__31:
	;
	goto __1
__17:
	if !((int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_INSERT) || (int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_REPLACE)) {
		goto __32
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Mode = NK_TEXT_EDIT_MODE_VIEW
__32:
	;
	goto __1

__18:
	if !(shift_mod != 0) {
		goto __33
	}
	nk_textedit_clamp(state)
	nk_textedit_prep_selection_at_cursor(state)
	// move selection left
	if !((*Nk_text_edit)(unsafe.Pointer(state)).Select_end > 0) {
		goto __35
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end--
__35:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __34
__33:
	// if currently there's a selection,
	// move cursor to start of selection
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __36
	}
	nk_textedit_move_to_first(state)
	goto __37
__36:
	if !((*Nk_text_edit)(unsafe.Pointer(state)).Cursor > 0) {
		goto __38
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__38:
	;
__37:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__34:
	;
	goto __1

__19:
	if !(shift_mod != 0) {
		goto __39
	}
	nk_textedit_prep_selection_at_cursor(state)
	// move selection right
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end++
	nk_textedit_clamp(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).Select_end
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __40
__39:
	// if currently there's a selection,
	// move cursor to end of selection
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __41
	}
	nk_textedit_move_to_last(state)
	goto __42
__41:
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor++
__42:
	;
	nk_textedit_clamp(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__40:
	;
	goto __1

__20:
	if !(shift_mod != 0) {
		goto __43
	}
	if !(!((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end)) {
		goto __45
	}
	nk_textedit_prep_selection_at_cursor(state)
__45:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = nk_textedit_move_to_word_previous(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	nk_textedit_clamp(state)
	goto __44
__43:
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __46
	}
	nk_textedit_move_to_first(state)
	goto __47
__46:
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = nk_textedit_move_to_word_previous(state)
	nk_textedit_clamp(state)
__47:
	;
__44:
	;
	goto __1

__21:
	if !(shift_mod != 0) {
		goto __48
	}
	if !(!((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end)) {
		goto __50
	}
	nk_textedit_prep_selection_at_cursor(state)
__50:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = nk_textedit_move_to_word_next(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	nk_textedit_clamp(state)
	goto __49
__48:
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __51
	}
	nk_textedit_move_to_last(state)
	goto __52
__51:
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = nk_textedit_move_to_word_next(state)
	nk_textedit_clamp(state)
__52:
	;
__49:
	;
	goto __1

__22:
	sel = shift_mod

	if !((*Nk_text_edit)(unsafe.Pointer(state)).Single_line != 0) {
		goto __53
	}
	// on windows, up&down in single-line behave like left&right
	key = NK_KEY_RIGHT
	goto retry
__53:
	;

	if !(sel != 0) {
		goto __54
	}
	nk_textedit_prep_selection_at_cursor(state)
	goto __55
__54:
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __56
	}
	nk_textedit_move_to_last(state)
__56:
	;
__55:
	;

	// compute current position of cursor point
	nk_textedit_clamp(state)
	nk_textedit_find_charpos(bp /* &find */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)

	// now find character position down a row
	if !((*Nk_text_find)(unsafe.Pointer(bp /* &find */)).Length != 0) {
		goto __57
	}

	if (*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x != 0 {
		goal_x = (*Nk_text_edit)(unsafe.Pointer(state)).Preferred_x
	} else {
		goal_x = (*Nk_text_find)(unsafe.Pointer(bp /* &find */)).X
	}
	start = ((*Nk_text_find)(unsafe.Pointer(bp /* &find */)).First_char + (*Nk_text_find)(unsafe.Pointer(bp /* &find */)).Length)

	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = start
	nk_textedit_layout_row(bp+24 /* &row */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, row_height, font)
	x = (*Nk_text_edit_row)(unsafe.Pointer(bp + 24 /* &row */)).X0

	i = 0
__58:
	if !((i < (*Nk_text_edit_row)(unsafe.Pointer(bp+24 /* &row */)).Num_chars) && (x < (*Nk_text_edit_row)(unsafe.Pointer(bp+24 /* &row */)).X1)) {
		goto __60
	}
	dx = nk_textedit_get_width(state, start, i, font)
	x = x + (dx)
	if !(x > goal_x) {
		goto __61
	}
	goto __60
__61:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor++
	goto __59
__59:
	i++
	goto __58
	goto __60
__60:
	;
	nk_textedit_clamp(state)

	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(1)
	(*Nk_text_edit)(unsafe.Pointer(state)).Preferred_x = goal_x
	if !(sel != 0) {
		goto __62
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
__62:
	;
__57:
	;
	goto __1

__23:
	sel1 = shift_mod

	if !((*Nk_text_edit)(unsafe.Pointer(state)).Single_line != 0) {
		goto __63
	}
	// on windows, up&down become left&right
	key = NK_KEY_LEFT
	goto retry
__63:
	;

	if !(sel1 != 0) {
		goto __64
	}
	nk_textedit_prep_selection_at_cursor(state)
	goto __65
__64:
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __66
	}
	nk_textedit_move_to_first(state)
__66:
	;
__65:
	;

	// compute current position of cursor point
	nk_textedit_clamp(state)
	nk_textedit_find_charpos(bp+48 /* &find1 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)

	// can only go up if there's a previous row
	if !((*Nk_text_find)(unsafe.Pointer(bp+48 /* &find1 */)).Prev_first != (*Nk_text_find)(unsafe.Pointer(bp+48 /* &find1 */)).First_char) {
		goto __67
	}
	if (*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x != 0 {
		goal_x1 = (*Nk_text_edit)(unsafe.Pointer(state)).Preferred_x
	} else {
		goal_x1 = (*Nk_text_find)(unsafe.Pointer(bp + 48 /* &find1 */)).X
	}

	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_find)(unsafe.Pointer(bp + 48 /* &find1 */)).Prev_first
	nk_textedit_layout_row(bp+72 /* &row1 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, row_height, font)
	x1 = (*Nk_text_edit_row)(unsafe.Pointer(bp + 72 /* &row1 */)).X0

	i1 = 0
__68:
	if !((i1 < (*Nk_text_edit_row)(unsafe.Pointer(bp+72 /* &row1 */)).Num_chars) && (x1 < (*Nk_text_edit_row)(unsafe.Pointer(bp+72 /* &row1 */)).X1)) {
		goto __70
	}
	dx1 = nk_textedit_get_width(state, (*Nk_text_find)(unsafe.Pointer(bp+48 /* &find1 */)).Prev_first, i1, font)
	x1 = x1 + (dx1)
	if !(x1 > goal_x1) {
		goto __71
	}
	goto __70
__71:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor++
	goto __69
__69:
	i1++
	goto __68
	goto __70
__70:
	;
	nk_textedit_clamp(state)

	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(1)
	(*Nk_text_edit)(unsafe.Pointer(state)).Preferred_x = goal_x1
	if !(sel1 != 0) {
		goto __72
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
__72:
	;
__67:
	;
	goto __1

__24:
	if !(int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW) {
		goto __73
	}
	goto __1
__73:
	;
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __74
	}
	Xnk_textedit_delete_selection(state)
	goto __75
__74:
	n = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
	if !((*Nk_text_edit)(unsafe.Pointer(state)).Cursor < n) {
		goto __76
	}
	Xnk_textedit_delete(state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, 1)
__76:
	;
__75:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __1

__25:
	if !(int32((*Nk_text_edit)(unsafe.Pointer(state)).Mode) == NK_TEXT_EDIT_MODE_VIEW) {
		goto __77
	}
	goto __1
__77:
	;
	if !((*Nk_text_edit)(unsafe.Pointer((state))).Select_start != (*Nk_text_edit)(unsafe.Pointer((state))).Select_end) {
		goto __78
	}
	Xnk_textedit_delete_selection(state)
	goto __79
__78:
	nk_textedit_clamp(state)
	if !((*Nk_text_edit)(unsafe.Pointer(state)).Cursor > 0) {
		goto __80
	}
	Xnk_textedit_delete(state, ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor - 1), 1)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__80:
	;
__79:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __1

__26:
	if !(shift_mod != 0) {
		goto __81
	}
	nk_textedit_prep_selection_at_cursor(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = AssignPtrInt32(state+96 /* &.select_end */, 0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __82
__81:
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = AssignPtrInt32(state+92 /* &.select_start */, AssignPtrInt32(state+96 /* &.select_end */, 0))
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__82:
	;
	goto __1

__27:
	if !(shift_mod != 0) {
		goto __83
	}
	nk_textedit_prep_selection_at_cursor(state)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = AssignPtrInt32(state+96 /* &.select_end */, (*Nk_text_edit)(unsafe.Pointer(state)).String.Len)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __84
__83:
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = AssignPtrInt32(state+96 /* &.select_end */, 0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__84:
	;
	goto __1

__28:
	if !(shift_mod != 0) {
		goto __85
	}
	nk_textedit_clamp(state)
	nk_textedit_prep_selection_at_cursor(state)
	if !(((*Nk_text_edit)(unsafe.Pointer(state)).String.Len != 0) && ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor == (*Nk_text_edit)(unsafe.Pointer(state)).String.Len)) {
		goto __87
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__87:
	;
	nk_textedit_find_charpos(bp+96 /* &find2 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = AssignPtrInt32(state+96 /* &.select_end */, (*Nk_text_find)(unsafe.Pointer(bp+96 /* &find2 */)).First_char)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	goto __86
__85:
	if !(((*Nk_text_edit)(unsafe.Pointer(state)).String.Len != 0) && ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor == (*Nk_text_edit)(unsafe.Pointer(state)).String.Len)) {
		goto __88
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__88:
	;
	nk_textedit_clamp(state)
	nk_textedit_move_to_first(state)
	nk_textedit_find_charpos(bp+120 /* &find3 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (*Nk_text_find)(unsafe.Pointer(bp + 120 /* &find3 */)).First_char
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
__86:
	;
	goto __1

__29:
	if !(shift_mod != 0) {
		goto __89
	}
	nk_textedit_clamp(state)
	nk_textedit_prep_selection_at_cursor(state)
	nk_textedit_find_charpos(bp+144 /* &find4 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = ((*Nk_text_find)(unsafe.Pointer(bp+144 /* &find4 */)).First_char + (*Nk_text_find)(unsafe.Pointer(bp+144 /* &find4 */)).Length)
	if !(((*Nk_text_find)(unsafe.Pointer(bp+144 /* &find4 */)).Length > 0) && (Xnk_str_rune_at((state+12 /* &.string */), ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor-1)) == Nk_rune('\n'))) {
		goto __91
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__91:
	;
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).Cursor
	goto __90
__89:
	nk_textedit_clamp(state)
	nk_textedit_move_to_first(state)
	nk_textedit_find_charpos(bp+168 /* &find5 */, state, (*Nk_text_edit)(unsafe.Pointer(state)).Cursor, int32((*Nk_text_edit)(unsafe.Pointer(state)).Single_line),
		font, row_height)

	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = ((*Nk_text_find)(unsafe.Pointer(bp+168 /* &find5 */)).First_char + (*Nk_text_find)(unsafe.Pointer(bp+168 /* &find5 */)).Length)
	if !(((*Nk_text_find)(unsafe.Pointer(bp+168 /* &find5 */)).Length > 0) && (Xnk_str_rune_at((state+12 /* &.string */), ((*Nk_text_edit)(unsafe.Pointer(state)).Cursor-1)) == Nk_rune('\n'))) {
		goto __92
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor--
__92:
	;
__90:
	;
	goto __1
__1:
	;
}

func nk_textedit_flush_redo(state uintptr) { /* nuklear.h:26074:1: */
	(*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point = int16(NK_TEXTEDIT_UNDOSTATECOUNT)
	(*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point = int16(NK_TEXTEDIT_UNDOCHARCOUNT)
}

func nk_textedit_discard_undo(state uintptr) { /* nuklear.h:26080:1: */
	// discard the oldest entry in the undo list
	if int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point) > 0 {
		// if the 0th undo state has characters, clean those up
		if int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */))).Char_storage) >= 0 {
			var n int32 = int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */))).Insert_length)
			var i int32
			// delete n characters from all other records
			(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point) - n))
			nk_memcopy(state+1188 /* &.undo_char */, ((state + 1188 /* &.undo_char */) + uintptr(n)*4),
				(Nk_size((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point) * Nk_size(unsafe.Sizeof(Nk_rune(0)))))
			for i = 0; i < int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point); i++ {
				if int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */)+uintptr(i)*12)).Char_storage) >= 0 {
					(*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */) + uintptr(i)*12)).Char_storage = (int16(int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */)+uintptr(i)*12)).Char_storage) - n))
				}
			}
		}
		(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point--
		nk_memcopy(state /* &.undo_rec */, ((state /* &.undo_rec */) + uintptr(1)*12),
			(Nk_size((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point) * Nk_size(unsafe.Sizeof(Nk_text_undo_record{}))))
	}
}

func nk_textedit_discard_redo(state uintptr) { /* nuklear.h:26103:1: */
	//  discard the oldest entry in the redo list--it's bad if this
	//     ever happens, but because undo & redo have to store the actual
	//     characters in different cases, the redo character buffer can
	//     fill up even though the undo buffer didn't
	var num Nk_size
	var k int32 = (NK_TEXTEDIT_UNDOSTATECOUNT - 1)
	if int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point) <= k {
		// if the k'th undo state has characters, clean those up
		if int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */)+uintptr(k)*12)).Char_storage) >= 0 {
			var n int32 = int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */) + uintptr(k)*12)).Insert_length)
			var i int32
			// delete n characters from all other records
			(*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point) + n))
			num = (Nk_size(NK_TEXTEDIT_UNDOCHARCOUNT - int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point)))
			nk_memcopy(((state + 1188 /* &.undo_char */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point)*4),
				(((state + 1188 /* &.undo_char */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_char_point)*4) - uintptr(n)*4), (num * Nk_size(unsafe.Sizeof(int8(0)))))
			for i = int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point); i < k; i++ {
				if int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */)+uintptr(i)*12)).Char_storage) >= 0 {
					(*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */) + uintptr(i)*12)).Char_storage = (int16(int32((*Nk_text_undo_record)(unsafe.Pointer((state /* &.undo_rec */)+uintptr(i)*12)).Char_storage) + n))
				}
			}
		}
		(*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point++
		num = (Nk_size(NK_TEXTEDIT_UNDOSTATECOUNT - int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point)))
		if num != 0 {
			nk_memcopy((((state /* &.undo_rec */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point)*12) - uintptr(1)*12),
				((state /* &.undo_rec */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(state)).Redo_point)*12), (num * Nk_size(unsafe.Sizeof(Nk_text_undo_record{}))))
		}
	}
}

func nk_textedit_create_undo_record(state uintptr, numchars int32) uintptr { /* nuklear.h:26133:37: */
	// any time we create a new undo record, we discard redo
	nk_textedit_flush_redo(state)

	// if we have no free records, we have to make room,
	// by sliding the existing records down
	if int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point) == NK_TEXTEDIT_UNDOSTATECOUNT {
		nk_textedit_discard_undo(state)
	}

	// if the characters to store won't possibly fit in the buffer,
	// we can't undo
	if numchars > NK_TEXTEDIT_UNDOCHARCOUNT {
		(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point = int16(0)
		(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point = int16(0)
		return uintptr(0)
	}

	// if we don't have enough free characters in the buffer,
	// we have to make room
	for (int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point) + numchars) > NK_TEXTEDIT_UNDOCHARCOUNT {
		nk_textedit_discard_undo(state)
	}
	return ((state /* &.undo_rec */) + uintptr(PostIncInt16(&(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_point, 1))*12)
}

func nk_textedit_createundo(state uintptr, pos int32, insert_len int32, delete_len int32) uintptr { /* nuklear.h:26158:18: */
	var r uintptr = nk_textedit_create_undo_record(state, insert_len)
	if r == uintptr(0) {
		return uintptr(0)
	}

	(*Nk_text_undo_record)(unsafe.Pointer(r)).Where = pos
	(*Nk_text_undo_record)(unsafe.Pointer(r)).Insert_length = int16(insert_len)
	(*Nk_text_undo_record)(unsafe.Pointer(r)).Delete_length = int16(delete_len)

	if insert_len == 0 {
		(*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage = int16(-1)
		return uintptr(0)
	} else {
		(*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage = (*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point
		(*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(state)).Undo_char_point) + insert_len))
		return ((state + 1188 /* &.undo_char */) + uintptr((*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage)*4)
	}
	return uintptr(0)
}

func Xnk_textedit_undo(state uintptr) { /* nuklear.h:26180:1: */
	var s uintptr = (state + 112 /* &.undo */)
	var u Nk_text_undo_record
	var r uintptr
	if int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_point) == 0 {
		return
	}

	// we need to do two things: apply the undo record, and create a redo record
	u = *(*Nk_text_undo_record)(unsafe.Pointer((s /* &.undo_rec */) + uintptr((int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_point)-1))*12))
	r = ((s /* &.undo_rec */) + uintptr((int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point)-1))*12)
	(*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage = int16(-1)

	(*Nk_text_undo_record)(unsafe.Pointer(r)).Insert_length = u.Delete_length
	(*Nk_text_undo_record)(unsafe.Pointer(r)).Delete_length = u.Insert_length
	(*Nk_text_undo_record)(unsafe.Pointer(r)).Where = u.Where

	if u.Delete_length != 0 {
		//   if the undo record says to delete characters, then the redo record will
		//             need to re-insert the characters that get deleted, so we need to store
		//             them.
		//             there are three cases:
		//                 - there's enough room to store the characters
		//                 - characters stored for *redoing* don't leave room for redo
		//                 - characters stored for *undoing* don't leave room for redo
		//             if the last is true, we have to bail
		if (int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point) + int32(u.Delete_length)) >= NK_TEXTEDIT_UNDOCHARCOUNT {
			// the undo records take up too much character space; there's no space
			// to store the redo characters
			(*Nk_text_undo_record)(unsafe.Pointer(r)).Insert_length = int16(0)
		} else {
			var i int32
			// there's definitely room to store the characters eventually
			for (int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point) + int32(u.Delete_length)) > int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_char_point) {
				// there's currently not enough room, so discard a redo record
				nk_textedit_discard_redo(s)
				// should never happen:
				if int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point) == NK_TEXTEDIT_UNDOSTATECOUNT {
					return
				}
			}

			r = ((s /* &.undo_rec */) + uintptr((int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point)-1))*12)
			(*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_char_point) - int32(u.Delete_length)))
			(*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_char_point) - int32(u.Delete_length)))

			// now save the characters
			for i = 0; i < int32(u.Delete_length); i++ {
				*(*Nk_rune)(unsafe.Pointer((s + 1188 /* &.undo_char */) + uintptr((int32((*Nk_text_undo_record)(unsafe.Pointer(r)).Char_storage)+i))*4)) = Xnk_str_rune_at((state + 12 /* &.string */), (u.Where + i))
			}
		}
		// now we can carry out the deletion
		Xnk_str_delete_runes((state + 12 /* &.string */), u.Where, int32(u.Delete_length))
	}

	// check type of recorded action:
	if u.Insert_length != 0 {
		// easy case: was a deletion, so we need to insert n characters
		Xnk_str_insert_text_runes((state + 12 /* &.string */), u.Where,
			((s + 1188 /* &.undo_char */) + uintptr(u.Char_storage)*4), int32(u.Insert_length))
		(*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point) - int32(u.Insert_length)))
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = int32((int16(u.Where + int32(u.Insert_length))))

	(*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_point--
	(*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point--
}

func Xnk_textedit_redo(state uintptr) { /* nuklear.h:26247:1: */
	var s uintptr = (state + 112 /* &.undo */)
	var u uintptr
	var r Nk_text_undo_record
	if int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point) == NK_TEXTEDIT_UNDOSTATECOUNT {
		return
	}

	// we need to do two things: apply the redo record, and create an undo record
	u = ((s /* &.undo_rec */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_point)*12)
	r = *(*Nk_text_undo_record)(unsafe.Pointer((s /* &.undo_rec */) + uintptr((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point)*12))

	// we KNOW there must be room for the undo record, because the redo record
	//     was derived from an undo record
	(*Nk_text_undo_record)(unsafe.Pointer(u)).Delete_length = r.Insert_length
	(*Nk_text_undo_record)(unsafe.Pointer(u)).Insert_length = r.Delete_length
	(*Nk_text_undo_record)(unsafe.Pointer(u)).Where = r.Where
	(*Nk_text_undo_record)(unsafe.Pointer(u)).Char_storage = int16(-1)

	if r.Delete_length != 0 {
		// the redo record requires us to delete characters, so the undo record
		//         needs to store the characters
		if (int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point) + int32((*Nk_text_undo_record)(unsafe.Pointer(u)).Insert_length)) > int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_char_point) {
			(*Nk_text_undo_record)(unsafe.Pointer(u)).Insert_length = int16(0)
			(*Nk_text_undo_record)(unsafe.Pointer(u)).Delete_length = int16(0)
		} else {
			var i int32
			(*Nk_text_undo_record)(unsafe.Pointer(u)).Char_storage = (*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point
			(*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point = (int16(int32((*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_char_point) + int32((*Nk_text_undo_record)(unsafe.Pointer(u)).Insert_length)))

			// now save the characters
			for i = 0; i < int32((*Nk_text_undo_record)(unsafe.Pointer(u)).Insert_length); i++ {
				*(*Nk_rune)(unsafe.Pointer((s + 1188 /* &.undo_char */) + uintptr((int32((*Nk_text_undo_record)(unsafe.Pointer(u)).Char_storage)+i))*4)) = Xnk_str_rune_at((state + 12 /* &.string */), ((*Nk_text_undo_record)(unsafe.Pointer(u)).Where + i))
			}
		}
		Xnk_str_delete_runes((state + 12 /* &.string */), r.Where, int32(r.Delete_length))
	}

	if r.Insert_length != 0 {
		// easy case: need to insert n characters
		Xnk_str_insert_text_runes((state + 12 /* &.string */), r.Where,
			((s + 1188 /* &.undo_char */) + uintptr(r.Char_storage)*4), int32(r.Insert_length))
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = (r.Where + int32(r.Insert_length))

	(*Nk_text_undo_state)(unsafe.Pointer(s)).Undo_point++
	(*Nk_text_undo_state)(unsafe.Pointer(s)).Redo_point++
}

func nk_textedit_makeundo_insert(state uintptr, where int32, length int32) { /* nuklear.h:26296:1: */
	nk_textedit_createundo((state + 112 /* &.undo */), where, 0, length)
}

func nk_textedit_makeundo_delete(state uintptr, where int32, length int32) { /* nuklear.h:26301:1: */
	var i int32
	var p uintptr = nk_textedit_createundo((state + 112 /* &.undo */), where, length, 0)
	if p != 0 {
		for i = 0; i < length; i++ {
			*(*Nk_rune)(unsafe.Pointer(p + uintptr(i)*4)) = Xnk_str_rune_at((state + 12 /* &.string */), (where + i))
		}
	}
}

func nk_textedit_makeundo_replace(state uintptr, where int32, old_length int32, new_length int32) { /* nuklear.h:26311:1: */
	var i int32
	var p uintptr = nk_textedit_createundo((state + 112 /* &.undo */), where, old_length, new_length)
	if p != 0 {
		for i = 0; i < old_length; i++ {
			*(*Nk_rune)(unsafe.Pointer(p + uintptr(i)*4)) = Xnk_str_rune_at((state + 12 /* &.string */), (where + i))
		}
	}
}

func nk_textedit_clear_state(state uintptr, type1 uint32, filter Nk_plugin_filter) { /* nuklear.h:26322:1: */
	// reset the state to default
	(*Nk_text_edit)(unsafe.Pointer(state)).Undo.Undo_point = int16(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Undo.Undo_char_point = int16(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Undo.Redo_point = int16(NK_TEXTEDIT_UNDOSTATECOUNT)
	(*Nk_text_edit)(unsafe.Pointer(state)).Undo.Redo_char_point = int16(NK_TEXTEDIT_UNDOCHARCOUNT)
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = AssignPtrInt32(state+92 /* &.select_start */, 0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor = 0
	(*Nk_text_edit)(unsafe.Pointer(state)).Has_preferred_x = uint8(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Preferred_x = float32(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Cursor_at_end_of_line = uint8(0)
	(*Nk_text_edit)(unsafe.Pointer(state)).Initialized = uint8(1)
	(*Nk_text_edit)(unsafe.Pointer(state)).Single_line = (uint8(Bool32(int32(type1) == NK_TEXT_EDIT_SINGLE_LINE)))
	(*Nk_text_edit)(unsafe.Pointer(state)).Mode = NK_TEXT_EDIT_MODE_VIEW
	(*Nk_text_edit)(unsafe.Pointer(state)).Filter = filter
	(*Nk_text_edit)(unsafe.Pointer(state)).Scrollbar = Xnk_vec2(float32(0), float32(0))
}

func Xnk_textedit_init_fixed(state uintptr, memory uintptr, size Nk_size) { /* nuklear.h:26342:1: */
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26344), uintptr(unsafe.Pointer(&__func__352)))
	}
	if memory != 0 {
	} else {
		X__assert_fail(ts+19964 /* "memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(26345), uintptr(unsafe.Pointer(&__func__352)))
	}
	if (!(state != 0) || !(memory != 0)) || !(size != 0) {
		return
	}
	nk_memset(state, 0, uint32(unsafe.Sizeof(Nk_text_edit{})))
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, uintptr(0))
	Xnk_str_init_fixed((state + 12 /* &.string */), memory, size)
}

var __func__352 = *(*[23]int8)(unsafe.Pointer(ts + 26324 /* "nk_textedit_init..." */)) /* nuklear.h:26343:1 */

func Xnk_textedit_init(state uintptr, alloc uintptr, size Nk_size) { /* nuklear.h:26352:1: */
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26354), uintptr(unsafe.Pointer(&__func__353)))
	}
	if alloc != 0 {
	} else {
		X__assert_fail(ts+4629 /* "alloc" */, ts+2 /* "nuklear/nuklear...." */, uint32(26355), uintptr(unsafe.Pointer(&__func__353)))
	}
	if !(state != 0) || !(alloc != 0) {
		return
	}
	nk_memset(state, 0, uint32(unsafe.Sizeof(Nk_text_edit{})))
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, uintptr(0))
	Xnk_str_init((state + 12 /* &.string */), alloc, size)
}

var __func__353 = *(*[17]int8)(unsafe.Pointer(ts + 26347 /* "nk_textedit_init" */)) /* nuklear.h:26353:1 */

func Xnk_textedit_init_default(state uintptr) { /* nuklear.h:26363:1: */
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26365), uintptr(unsafe.Pointer(&__func__354)))
	}
	if !(state != 0) {
		return
	}
	nk_memset(state, 0, uint32(unsafe.Sizeof(Nk_text_edit{})))
	nk_textedit_clear_state(state, NK_TEXT_EDIT_SINGLE_LINE, uintptr(0))
	Xnk_str_init_default((state + 12 /* &.string */))
}

var __func__354 = *(*[25]int8)(unsafe.Pointer(ts + 26364 /* "nk_textedit_init..." */)) /* nuklear.h:26364:1 */

func Xnk_textedit_select_all(state uintptr) { /* nuklear.h:26373:1: */
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26375), uintptr(unsafe.Pointer(&__func__355)))
	}
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_start = 0
	(*Nk_text_edit)(unsafe.Pointer(state)).Select_end = (*Nk_text_edit)(unsafe.Pointer(state)).String.Len
}

var __func__355 = *(*[23]int8)(unsafe.Pointer(ts + 26389 /* "nk_textedit_sele..." */)) /* nuklear.h:26374:1 */

func Xnk_textedit_free(state uintptr) { /* nuklear.h:26380:1: */
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26382), uintptr(unsafe.Pointer(&__func__356)))
	}
	if !(state != 0) {
		return
	}
	Xnk_str_free((state + 12 /* &.string */))
}

var __func__356 = *(*[17]int8)(unsafe.Pointer(ts + 26412 /* "nk_textedit_free" */)) /* nuklear.h:26381:1 */

// ===============================================================
//
//                          FILTER
//
// ===============================================================
func Xnk_filter_default(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26397:1: */
	_ = unicode
	_ = box
	return Nk_true
}

func Xnk_filter_ascii(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26404:1: */
	_ = box
	if unicode > Nk_rune(128) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

func Xnk_filter_float(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26411:1: */
	_ = box
	if (((unicode < Nk_rune('0')) || (unicode > Nk_rune('9'))) && (unicode != Nk_rune('.'))) && (unicode != Nk_rune('-')) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

func Xnk_filter_decimal(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26419:1: */
	_ = box
	if ((unicode < Nk_rune('0')) || (unicode > Nk_rune('9'))) && (unicode != Nk_rune('-')) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

func Xnk_filter_hex(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26427:1: */
	_ = box
	if (((unicode < Nk_rune('0')) || (unicode > Nk_rune('9'))) && ((unicode < Nk_rune('a')) || (unicode > Nk_rune('f')))) && ((unicode < Nk_rune('A')) || (unicode > Nk_rune('F'))) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

func Xnk_filter_oct(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26437:1: */
	_ = box
	if (unicode < Nk_rune('0')) || (unicode > Nk_rune('7')) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

func Xnk_filter_binary(box uintptr, unicode Nk_rune) Nk_bool { /* nuklear.h:26445:1: */
	_ = box
	if (unicode != Nk_rune('0')) && (unicode != Nk_rune('1')) {
		return Nk_false
	} else {
		return Nk_true
	}
	return Nk_bool(0)
}

// ===============================================================
//
//                          EDIT
//
// ===============================================================
func nk_edit_draw_text(out uintptr, style uintptr, pos_x float32, pos_y float32, x_offset float32, text uintptr, byte_len int32, row_height float32, font uintptr, background Nk_color, foreground Nk_color, is_selected Nk_bool) { /* nuklear.h:26459:1: */
	bp := tlsAlloc(52)
	defer tlsFree(52)

	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(26465), uintptr(unsafe.Pointer(&__func__357)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(26466), uintptr(unsafe.Pointer(&__func__357)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(26467), uintptr(unsafe.Pointer(&__func__357)))
	}
	if ((!(text != 0) || !(byte_len != 0)) || !(out != 0)) || !(style != 0) {
		return
	}

	{
		var glyph_len int32 = 0
		*(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) = Nk_rune(0)
		var text_len int32 = 0
		var line_width float32 = float32(0)
		var glyph_width float32
		var line uintptr = text
		var line_offset float32 = float32(0)
		var line_count int32 = 0
		// var txt Nk_text at bp+20, 16

		(*Nk_text)(unsafe.Pointer(bp + 20 /* &txt */)).Padding = Xnk_vec2(float32(0), float32(0))
		(*Nk_text)(unsafe.Pointer(bp + 20 /* &txt */)).Background = background
		(*Nk_text)(unsafe.Pointer(bp + 20 /* &txt */)).Text = foreground

		glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
		if !(glyph_len != 0) {
			return
		}
		for (text_len < byte_len) && (glyph_len != 0) {
			if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune('\n') {
				// new line separator so draw previous line
				// var label Nk_rect at bp+4, 16

				(*Nk_rect)(unsafe.Pointer(bp + 4 /* &label */)).Y = (pos_y + line_offset)
				(*Nk_rect)(unsafe.Pointer(bp + 4 /* &label */)).H = row_height
				(*Nk_rect)(unsafe.Pointer(bp + 4 /* &label */)).W = line_width
				(*Nk_rect)(unsafe.Pointer(bp + 4 /* &label */)).X = pos_x
				if !(line_count != 0) {
					*(*float32)(unsafe.Pointer(bp + 4 /* &label */ /* &.x */)) += (x_offset)
				}

				if is_selected != 0 { // selection needs to draw different background color
					Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp + 4 /* label */)), float32(0), background)
				}
				nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(bp + 4 /* label */)), line, (int32(((int32(text + uintptr(text_len))) - int32(line)) / 1)),
					bp+20 /* &txt */, NK_TEXT_CENTERED, font)

				text_len++
				line_count++
				line_width = float32(0)
				line = (text + uintptr(text_len))
				line_offset = line_offset + (row_height)
				glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
				continue
			}
			if *(*Nk_rune)(unsafe.Pointer(bp /* unicode */)) == Nk_rune('\r') {
				text_len++
				glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
				continue
			}
			glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, (text + uintptr(text_len)), glyph_len)
			line_width = line_width + (glyph_width)
			text_len = text_len + (glyph_len)
			glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp /* &unicode */, (byte_len - text_len))
			continue
		}
		if line_width > float32(0) {
			// draw last line
			// var label Nk_rect at bp+36, 16

			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &label */)).Y = (pos_y + line_offset)
			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &label */)).H = row_height
			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &label */)).W = line_width
			(*Nk_rect)(unsafe.Pointer(bp + 36 /* &label */)).X = pos_x
			if !(line_count != 0) {
				*(*float32)(unsafe.Pointer(bp + 36 /* &label */ /* &.x */)) += (x_offset)
			}

			if is_selected != 0 {
				Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp + 36 /* label */)), float32(0), background)
			}
			nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(bp + 36 /* label */)), line, (int32(((int32(text + uintptr(text_len))) - int32(line)) / 1)),
				bp+20 /* &txt */, NK_TEXT_LEFT, font)
		}
	}
}

var __func__357 = *(*[18]int8)(unsafe.Pointer(ts + 26429 /* "nk_edit_draw_tex..." */)) /* nuklear.h:26464:1 */

func nk_do_edit(state uintptr, out uintptr, bounds Nk_rect, flags Nk_flags, filter Nk_plugin_filter, edit uintptr, style uintptr, in uintptr, font uintptr) Nk_flags { /* nuklear.h:26539:1: */
	bp := tlsAlloc(132)
	defer tlsFree(132)

	var area Nk_rect
	var ret Nk_flags = Nk_flags(0)
	var row_height float32
	var prev_state int8 = int8(0)
	var is_hovered int8 = int8(0)
	var select_all int8 = int8(0)
	var cursor_follow int8 = int8(0)
	// var old_clip Nk_rect at bp+16, 16

	// var clip Nk_rect at bp, 16

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(26554), uintptr(unsafe.Pointer(&__func__358)))
	}
	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(26555), uintptr(unsafe.Pointer(&__func__358)))
	}
	if style != 0 {
	} else {
		X__assert_fail(ts+25404 /* "style" */, ts+2 /* "nuklear/nuklear...." */, uint32(26556), uintptr(unsafe.Pointer(&__func__358)))
	}
	if (!(state != 0) || !(out != 0)) || !(style != 0) {
		return ret
	}

	// visible text area calculation
	area.X = ((bounds.X + (*Nk_style_edit)(unsafe.Pointer(style)).Padding.X) + (*Nk_style_edit)(unsafe.Pointer(style)).Border)
	area.Y = ((bounds.Y + (*Nk_style_edit)(unsafe.Pointer(style)).Padding.Y) + (*Nk_style_edit)(unsafe.Pointer(style)).Border)
	area.W = (bounds.W - ((2.0 * (*Nk_style_edit)(unsafe.Pointer(style)).Padding.X) + (float32(2) * (*Nk_style_edit)(unsafe.Pointer(style)).Border)))
	area.H = (bounds.H - ((2.0 * (*Nk_style_edit)(unsafe.Pointer(style)).Padding.Y) + (float32(2) * (*Nk_style_edit)(unsafe.Pointer(style)).Border)))
	if (flags & NK_EDIT_MULTILINE) != 0 {
		area.W = func() float32 {
			if (float32(0)) < (area.W - (*Nk_style_edit)(unsafe.Pointer(style)).Scrollbar_size.X) {
				return (area.W - (*Nk_style_edit)(unsafe.Pointer(style)).Scrollbar_size.X)
			}
			return float32(0)
		}()
	}
	if (flags & NK_EDIT_MULTILINE) != 0 {
		row_height = ((*Nk_user_font)(unsafe.Pointer(font)).Height + (*Nk_style_edit)(unsafe.Pointer(style)).Row_padding)
	} else {
		row_height = area.H
	}

	// calculate clipping rectangle
	*(*Nk_rect)(unsafe.Pointer(bp + 16 /* old_clip */)) = (*Nk_command_buffer)(unsafe.Pointer(out)).Clip
	nk_unify(bp /* &clip */, bp+16 /* &old_clip */, area.X, area.Y, (area.X + area.W), (area.Y + area.H))

	// update edit state
	prev_state = int8((*Nk_text_edit)(unsafe.Pointer(edit)).Active)
	is_hovered = int8(Xnk_input_is_mouse_hovering_rect(in, bounds))
	if ((in != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0)) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0) {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Active = (uint8(Bool32((((bounds.X) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X) < (bounds.X + bounds.W))) && (((bounds.Y) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y) < (bounds.Y + bounds.H))))))
	}

	// (de)activate text editor
	if !(prev_state != 0) && ((*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0) {
		var type1 uint32
		if (flags & NK_EDIT_MULTILINE) != 0 {
			type1 = NK_TEXT_EDIT_MULTI_LINE
		} else {
			type1 = NK_TEXT_EDIT_SINGLE_LINE
		}
		// keep scroll position when re-activating edit widget
		var oldscrollbar = (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar
		nk_textedit_clear_state(edit, type1, filter)
		(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar = oldscrollbar
		if (flags & NK_EDIT_AUTO_SELECT) != 0 {
			select_all = Nk_true
		}
		if (flags & NK_EDIT_GOTO_END_ON_ACTIVATE) != 0 {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Cursor = (*Nk_text_edit)(unsafe.Pointer(edit)).String.Len
			in = uintptr(0)
		}
	} else if !(int32((*Nk_text_edit)(unsafe.Pointer(edit)).Active) != 0) {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Mode = NK_TEXT_EDIT_MODE_VIEW
	}
	if (flags & NK_EDIT_READ_ONLY) != 0 {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Mode = NK_TEXT_EDIT_MODE_VIEW
	} else if (flags & NK_EDIT_ALWAYS_INSERT_MODE) != 0 {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Mode = NK_TEXT_EDIT_MODE_INSERT
	}

	if (*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0 {
		ret = NK_EDIT_ACTIVE
	} else {
		ret = NK_EDIT_INACTIVE
	}
	if int32(prev_state) != int32((*Nk_text_edit)(unsafe.Pointer(edit)).Active) {
		ret = ret | (func() uint32 {
			if (*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0 {
				return NK_EDIT_ACTIVATED
			}
			return NK_EDIT_DEACTIVATED
		}())
	}

	// handle user input
	if ((*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0) && (in != 0) {
		var shift_mod int32 = (*Nk_key)(unsafe.Pointer((in /* &.keyboard */ /* &.keys */) + 1*8)).Down
		var mouse_x float32 = (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - area.X) + (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X)
		var mouse_y float32 = (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - area.Y) + (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y)

		// mouse click handler
		is_hovered = int8(Xnk_input_is_mouse_hovering_rect(in, area))
		if select_all != 0 {
			Xnk_textedit_select_all(edit)
		} else if ((is_hovered != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0)) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0) {
			nk_textedit_click(edit, mouse_x, mouse_y, font, row_height)
		} else if ((is_hovered != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X != 0.0) || ((*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.Y != 0.0)) {
			nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height)
			cursor_follow = Nk_true
		} else if ((is_hovered != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in+260 /* &.mouse */ /* &.buttons */)+2*16)).Clicked != 0)) && ((*Nk_mouse_button)(unsafe.Pointer((in+260 /* &.mouse */ /* &.buttons */)+2*16)).Down != 0) {
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_LEFT, Nk_false, font, row_height)
			nk_textedit_key(edit, NK_KEY_TEXT_WORD_RIGHT, Nk_true, font, row_height)
			cursor_follow = Nk_true
		}

		{
			var i int32 // keyboard input
			var old_mode int32 = int32((*Nk_text_edit)(unsafe.Pointer(edit)).Mode)
			for i = 0; i < NK_KEY_MAX; i++ {
				if (i == NK_KEY_ENTER) || (i == NK_KEY_TAB) {
					continue
				} // special case
				if Xnk_input_is_key_pressed(in, uint32(i)) != 0 {
					nk_textedit_key(edit, uint32(i), shift_mod, font, row_height)
					cursor_follow = Nk_true
				}
			}
			if old_mode != int32((*Nk_text_edit)(unsafe.Pointer(edit)).Mode) {
				(*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len = 0
			}
		}

		// text input
		(*Nk_text_edit)(unsafe.Pointer(edit)).Filter = filter
		if (*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len != 0 {
			Xnk_textedit_text(edit, in /* &.keyboard */ +240 /* &.text */, (*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len)
			cursor_follow = Nk_true
			(*Nk_input)(unsafe.Pointer(in)).Keyboard.Text_len = 0
		}

		// enter key handler
		if Xnk_input_is_key_pressed(in, NK_KEY_ENTER) != 0 {
			cursor_follow = Nk_true
			if ((flags & NK_EDIT_CTRL_ENTER_NEWLINE) != 0) && (shift_mod != 0) {
				Xnk_textedit_text(edit, ts+26447 /* "\n" */, 1)
			} else if (flags & NK_EDIT_SIG_ENTER) != 0 {
				ret = ret | (NK_EDIT_COMMITED)
			} else {
				Xnk_textedit_text(edit, ts+26447 /* "\n" */, 1)
			}
		}

		/* cut & copy handler */
		{
			var copy int32 = Xnk_input_is_key_pressed(in, NK_KEY_COPY)
			var cut int32 = Xnk_input_is_key_pressed(in, NK_KEY_CUT)
			if ((copy != 0) || (cut != 0)) && ((flags & NK_EDIT_CLIPBOARD) != 0) {
				// var glyph_len int32 at bp+36, 4

				// var unicode Nk_rune at bp+32, 4

				var text uintptr
				var b int32 = (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start
				var e int32 = (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end

				var begin int32 = func() int32 {
					if (b) < (e) {
						return b
					}
					return e
				}()
				var end int32 = func() int32 {
					if (b) < (e) {
						return e
					}
					return b
				}()
				text = Xnk_str_at_const((edit + 12 /* &.string */), begin, bp+32 /* &unicode */, bp+36 /* &glyph_len */)
				if (*Nk_text_edit)(unsafe.Pointer(edit)).Clip.Copy != 0 {
					(*(*func(Nk_handle, uintptr, int32))(unsafe.Pointer((edit /* &.clip */ + 8 /* &.copy */))))((*Nk_text_edit)(unsafe.Pointer(edit)).Clip.Userdata, text, (end - begin))
				}
				if (cut != 0) && !((flags & NK_EDIT_READ_ONLY) != 0) {
					Xnk_textedit_cut(edit)
					cursor_follow = Nk_true
				}
			}
		}

		/* paste handler */
		{
			var paste int32 = Xnk_input_is_key_pressed(in, NK_KEY_PASTE)
			if ((paste != 0) && ((flags & NK_EDIT_CLIPBOARD) != 0)) && ((*Nk_text_edit)(unsafe.Pointer(edit)).Clip.Paste != 0) {
				(*(*func(Nk_handle, uintptr))(unsafe.Pointer((edit /* &.clip */ + 4 /* &.paste */))))((*Nk_text_edit)(unsafe.Pointer(edit)).Clip.Userdata, edit)
				cursor_follow = Nk_true
			}
		}

		/* tab handler */
		{
			var tab int32 = Xnk_input_is_key_pressed(in, NK_KEY_TAB)
			if (tab != 0) && ((flags & NK_EDIT_ALLOW_TAB) != 0) {
				Xnk_textedit_text(edit, ts+26449 /* "    " */, 4)
				cursor_follow = Nk_true
			}
		}
	}

	// set widget state
	if (*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
	} else if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if is_hovered != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_HOVERED)
	}

	/* DRAW EDIT */
	{
		var text uintptr = Xnk_str_get_const((edit + 12 /* &.string */))
		var len int32 = Xnk_str_len_char((edit + 12 /* &.string */))

		{ // select background colors/images
			var background uintptr
			if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_ACTIVED) != 0 {
				background = (style + 40 /* &.active */)
			} else if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0 {
				background = (style + 20 /* &.hover */)
			} else {
				background = (style /* &.normal */)
			}

			// draw background frame
			if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_COLOR {
				Xnk_fill_rect(out, bounds, (*Nk_style_edit)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
				Xnk_stroke_rect(out, bounds, (*Nk_style_edit)(unsafe.Pointer(style)).Rounding, (*Nk_style_edit)(unsafe.Pointer(style)).Border, (*Nk_style_edit)(unsafe.Pointer(style)).Border_color)
			} else {
				Xnk_draw_image(out, bounds, (background + 4 /* &.data */ /* &.image */), nk_white)
			}
		}

		area.W = func() float32 {
			if (float32(0)) < (area.W - (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_size) {
				return (area.W - (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_size)
			}
			return float32(0)
		}()
		if (*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0 {
			var total_lines int32 = 1
			var text_size = Xnk_vec2(float32(0), float32(0))

			// text pointer positions
			var cursor_ptr uintptr = uintptr(0)
			var select_begin_ptr uintptr = uintptr(0)
			var select_end_ptr uintptr = uintptr(0)

			// 2D pixel positions
			var cursor_pos = Xnk_vec2(float32(0), float32(0))
			var selection_offset_start = Xnk_vec2(float32(0), float32(0))
			var selection_offset_end = Xnk_vec2(float32(0), float32(0))

			var selection_begin int32 = func() int32 {
				if ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start) < ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_end) {
					return (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start
				}
				return (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end
			}()
			var selection_end int32 = func() int32 {
				if ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start) < ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_end) {
					return (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end
				}
				return (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start
			}()

			// calculate total line count + total space + cursor/selection position
			var line_width float32 = 0.0
			if (text != 0) && (len != 0) {
				// utf8 encoding
				var glyph_width float32
				var glyph_len int32 = 0
				*(*Nk_rune)(unsafe.Pointer(bp + 40 /* unicode */)) = Nk_rune(0)
				var text_len int32 = 0
				var glyphs int32 = 0
				var row_begin int32 = 0

				glyph_len = Xnk_utf_decode(text, bp+40 /* &unicode */, len)
				glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, text, glyph_len)
				line_width = float32(0)

				// iterate all lines
				for (text_len < len) && (glyph_len != 0) {
					// set cursor 2D position and line
					if !(cursor_ptr != 0) && (glyphs == (*Nk_text_edit)(unsafe.Pointer(edit)).Cursor) {
						// var glyph_offset int32 at bp+56, 4

						// var out_offset Nk_vec2 at bp+48, 8

						var row_size Nk_vec2
						// var remaining uintptr at bp+44, 4

						// calculate 2d position
						cursor_pos.Y = ((float32(total_lines - 1)) * row_height)
						row_size = nk_text_calculate_text_bounds(font, (text + uintptr(row_begin)),
							(text_len - row_begin), row_height, bp+44, /* &remaining */
							bp+48 /* &out_offset */, bp+56 /* &glyph_offset */, NK_STOP_ON_NEW_LINE)
						cursor_pos.X = row_size.X
						cursor_ptr = (text + uintptr(text_len))
					}

					// set start selection 2D position and line
					if (!(select_begin_ptr != 0) && ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start != (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end)) && (glyphs == selection_begin) {
						// var glyph_offset int32 at bp+72, 4

						// var out_offset Nk_vec2 at bp+64, 8

						var row_size Nk_vec2
						// var remaining uintptr at bp+60, 4

						// calculate 2d position
						selection_offset_start.Y = ((func() float32 {
							if (total_lines - 1) < (0) {
								return float32(0)
							}
							return (float32(total_lines - 1))
						}()) * row_height)
						row_size = nk_text_calculate_text_bounds(font, (text + uintptr(row_begin)),
							(text_len - row_begin), row_height, bp+60, /* &remaining */
							bp+64 /* &out_offset */, bp+72 /* &glyph_offset */, NK_STOP_ON_NEW_LINE)
						selection_offset_start.X = row_size.X
						select_begin_ptr = (text + uintptr(text_len))
					}

					// set end selection 2D position and line
					if (!(select_end_ptr != 0) && ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start != (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end)) && (glyphs == selection_end) {
						// var glyph_offset int32 at bp+88, 4

						// var out_offset Nk_vec2 at bp+80, 8

						var row_size Nk_vec2
						// var remaining uintptr at bp+76, 4

						// calculate 2d position
						selection_offset_end.Y = ((float32(total_lines - 1)) * row_height)
						row_size = nk_text_calculate_text_bounds(font, (text + uintptr(row_begin)),
							(text_len - row_begin), row_height, bp+76, /* &remaining */
							bp+80 /* &out_offset */, bp+88 /* &glyph_offset */, NK_STOP_ON_NEW_LINE)
						selection_offset_end.X = row_size.X
						select_end_ptr = (text + uintptr(text_len))
					}
					if *(*Nk_rune)(unsafe.Pointer(bp + 40 /* unicode */)) == Nk_rune('\n') {
						text_size.X = func() float32 {
							if (text_size.X) < (line_width) {
								return line_width
							}
							return text_size.X
						}()
						total_lines++
						line_width = float32(0)
						text_len++
						glyphs++
						row_begin = text_len
						glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp+40 /* &unicode */, (len - text_len))
						glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, (text + uintptr(text_len)), glyph_len)
						continue
					}

					glyphs++
					text_len = text_len + (glyph_len)
					line_width = line_width + (glyph_width)

					glyph_len = Xnk_utf_decode((text + uintptr(text_len)), bp+40 /* &unicode */, (len - text_len))
					glyph_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height,
						(text + uintptr(text_len)), glyph_len)
					continue
				}
				text_size.Y = (float32(total_lines) * row_height)

				// handle case when cursor is at end of text buffer
				if !(cursor_ptr != 0) && ((*Nk_text_edit)(unsafe.Pointer(edit)).Cursor == (*Nk_text_edit)(unsafe.Pointer(edit)).String.Len) {
					cursor_pos.X = line_width
					cursor_pos.Y = (text_size.Y - row_height)
				}
			}
			{
				// scrollbar
				if cursor_follow != 0 {
					// update scrollbar to follow cursor
					if !((flags & NK_EDIT_NO_HORIZONTAL_SCROLL) != 0) {
						// horizontal scroll
						var scroll_increment float32 = (area.W * 0.25)
						if cursor_pos.X < (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X {
							(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X = float32(func() int32 {
								if (0.0) < (cursor_pos.X - scroll_increment) {
									return (int32(cursor_pos.X - scroll_increment))
								}
								return int32(0.0)
							}())
						}
						if cursor_pos.X >= ((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X + area.W) {
							(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X = float32(func() int32 {
								if (0.0) < ((cursor_pos.X - area.W) + scroll_increment) {
									return (int32((cursor_pos.X - area.W) + scroll_increment))
								}
								return int32(0.0)
							}())
						}
					} else {
						(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X = float32(0)
					}

					if (flags & NK_EDIT_MULTILINE) != 0 {
						// vertical scroll
						if cursor_pos.Y < (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y {
							(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y = func() float32 {
								if (0.0) < (cursor_pos.Y - row_height) {
									return (cursor_pos.Y - row_height)
								}
								return 0.0
							}()
						}
						if cursor_pos.Y >= ((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y + area.H) {
							(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y = ((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y + row_height)
						}
					} else {
						(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y = float32(0)
					}
				}

				// scrollbar widget
				if (flags & NK_EDIT_MULTILINE) != 0 {
					// var ws Nk_flags at bp+92, 4

					var scroll Nk_rect
					var scroll_target float32
					var scroll_offset float32
					var scroll_step float32
					var scroll_inc float32

					scroll = area
					scroll.X = (((bounds.X + bounds.W) - (*Nk_style_edit)(unsafe.Pointer(style)).Border) - (*Nk_style_edit)(unsafe.Pointer(style)).Scrollbar_size.X)
					scroll.W = (*Nk_style_edit)(unsafe.Pointer(style)).Scrollbar_size.X

					scroll_offset = (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y
					scroll_step = (scroll.H * 0.10)
					scroll_inc = (scroll.H * 0.01)
					scroll_target = text_size.Y
					(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y = nk_do_scrollbarv(bp+92 /* &ws */, out, scroll, 0,
						scroll_offset, scroll_target, scroll_step, scroll_inc,
						(style + 64 /* &.scrollbar */), in, font)
				}

			}

			/* draw text */
			{
				var background_color Nk_color
				var text_color Nk_color
				var sel_background_color Nk_color
				var sel_text_color Nk_color
				var cursor_color Nk_color
				var cursor_text_color Nk_color
				var background uintptr
				Xnk_push_scissor(out, *(*Nk_rect)(unsafe.Pointer(bp /* clip */)))

				// select correct colors to draw
				if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_ACTIVED) != 0 {
					background = (style + 40 /* &.active */)
					text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_active
					sel_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_text_hover
					sel_background_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_hover
					cursor_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_hover
					cursor_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_text_hover
				} else if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0 {
					background = (style + 20 /* &.hover */)
					text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_hover
					sel_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_text_hover
					sel_background_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_hover
					cursor_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_text_hover
					cursor_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_hover
				} else {
					background = (style /* &.normal */)
					text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_normal
					sel_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_text_normal
					sel_background_color = (*Nk_style_edit)(unsafe.Pointer(style)).Selected_normal
					cursor_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_normal
					cursor_text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_text_normal
				}
				if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
					background_color = Xnk_rgba(0, 0, 0, 0)
				} else {
					background_color = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
				}

				if (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start == (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end {
					// no selection so just draw the complete text
					var begin uintptr = Xnk_str_get_const((edit + 12 /* &.string */))
					var l int32 = Xnk_str_len_char((edit + 12 /* &.string */))
					nk_edit_draw_text(out, style, (area.X - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X),
						(area.Y - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y), float32(0), begin, l, row_height, font,
						background_color, text_color, Nk_false)
				} else {
					// edit has selection so draw 1-3 text chunks
					if ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start != (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end) && (selection_begin > 0) {
						// draw unselected text before selection
						var begin uintptr = Xnk_str_get_const((edit + 12 /* &.string */))
						if select_begin_ptr != 0 {
						} else {
							X__assert_fail(ts+26454 /* "select_begin_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(26940), uintptr(unsafe.Pointer(&__func__358)))
						}
						nk_edit_draw_text(out, style, (area.X - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X),
							(area.Y - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y), float32(0), begin, (int32((int32(select_begin_ptr) - int32(begin)) / 1)),
							row_height, font, background_color, text_color, Nk_false)
					}
					if (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start != (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end {
						// draw selected text
						if select_begin_ptr != 0 {
						} else {
							X__assert_fail(ts+26454 /* "select_begin_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(26947), uintptr(unsafe.Pointer(&__func__358)))
						}
						if !(select_end_ptr != 0) {
							var begin uintptr = Xnk_str_get_const((edit + 12 /* &.string */))
							select_end_ptr = (begin + uintptr(Xnk_str_len_char((edit + 12 /* &.string */))))
						}
						nk_edit_draw_text(out, style,
							(area.X - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X),
							((area.Y + selection_offset_start.Y) - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y),
							selection_offset_start.X,
							select_begin_ptr, (int32((int32(select_end_ptr) - int32(select_begin_ptr)) / 1)),
							row_height, font, sel_background_color, sel_text_color, Nk_true)
					}
					if ((*Nk_text_edit)(unsafe.Pointer(edit)).Select_start != (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end) && (selection_end < (*Nk_text_edit)(unsafe.Pointer(edit)).String.Len) {
						// draw unselected text after selected text
						var begin uintptr = select_end_ptr
						var end uintptr = (Xnk_str_get_const((edit + 12 /* &.string */)) + uintptr(Xnk_str_len_char((edit + 12 /* &.string */))))
						if select_end_ptr != 0 {
						} else {
							X__assert_fail(ts+26471 /* "select_end_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(26966), uintptr(unsafe.Pointer(&__func__358)))
						}
						nk_edit_draw_text(out, style,
							(area.X - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X),
							((area.Y + selection_offset_end.Y) - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y),
							selection_offset_end.X,
							begin, (int32((int32(end) - int32(begin)) / 1)), row_height, font,
							background_color, text_color, Nk_true)
					}
				}

				// cursor
				if (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start == (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end {
					if ((*Nk_text_edit)(unsafe.Pointer(edit)).Cursor >= Xnk_str_len((edit + 12 /* &.string */))) || ((cursor_ptr != 0) && (int32(*(*int8)(unsafe.Pointer(cursor_ptr))) == '\n')) {
						// draw cursor at end of line
						// var cursor Nk_rect at bp+96, 16

						(*Nk_rect)(unsafe.Pointer(bp + 96 /* &cursor */)).W = (*Nk_style_edit)(unsafe.Pointer(style)).Cursor_size
						(*Nk_rect)(unsafe.Pointer(bp + 96 /* &cursor */)).H = (*Nk_user_font)(unsafe.Pointer(font)).Height
						(*Nk_rect)(unsafe.Pointer(bp + 96 /* &cursor */)).X = ((area.X + cursor_pos.X) - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X)
						(*Nk_rect)(unsafe.Pointer(bp + 96 /* &cursor */)).Y = (((area.Y + cursor_pos.Y) + (row_height / 2.0)) - ((*Nk_rect)(unsafe.Pointer(bp+96 /* &cursor */)).H / 2.0))
						*(*float32)(unsafe.Pointer(bp + 96 /* &cursor */ + 4 /* &.y */)) -= ((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y)
						Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp + 96 /* cursor */)), float32(0), cursor_color)
					} else {
						// draw cursor inside text
						var glyph_len int32
						var label Nk_rect
						// var txt Nk_text at bp+116, 16

						// var unicode Nk_rune at bp+112, 4

						if cursor_ptr != 0 {
						} else {
							X__assert_fail(ts+26486 /* "cursor_ptr" */, ts+2 /* "nuklear/nuklear...." */, uint32(26996), uintptr(unsafe.Pointer(&__func__358)))
						}
						glyph_len = Xnk_utf_decode(cursor_ptr, bp+112 /* &unicode */, 4)

						label.X = ((area.X + cursor_pos.X) - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X)
						label.Y = ((area.Y + cursor_pos.Y) - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y)
						label.W = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, cursor_ptr, glyph_len)
						label.H = row_height

						(*Nk_text)(unsafe.Pointer(bp + 116 /* &txt */)).Padding = Xnk_vec2(float32(0), float32(0))
						(*Nk_text)(unsafe.Pointer(bp + 116 /* &txt */)).Background = cursor_color

						(*Nk_text)(unsafe.Pointer(bp + 116 /* &txt */)).Text = cursor_text_color
						Xnk_fill_rect(out, label, float32(0), cursor_color)
						nk_widget_text(out, label, cursor_ptr, glyph_len, bp+116 /* &txt */, NK_TEXT_LEFT, font)
					}
				}
			}
		} else {
			// not active so just draw text
			var l int32 = Xnk_str_len_char((edit + 12 /* &.string */))
			var begin uintptr = Xnk_str_get_const((edit + 12 /* &.string */))
			var background uintptr
			var background_color Nk_color
			var text_color Nk_color
			Xnk_push_scissor(out, *(*Nk_rect)(unsafe.Pointer(bp /* clip */)))
			if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_ACTIVED) != 0 {
				background = (style + 40 /* &.active */)
				text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_active
			} else if (*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0 {
				background = (style + 20 /* &.hover */)
				text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_hover
			} else {
				background = (style /* &.normal */)
				text_color = (*Nk_style_edit)(unsafe.Pointer(style)).Text_normal
			}
			if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
				background_color = Xnk_rgba(0, 0, 0, 0)
			} else {
				background_color = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
			}
			nk_edit_draw_text(out, style, (area.X - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X),
				(area.Y - (*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y), float32(0), begin, l, row_height, font,
				background_color, text_color, Nk_false)
		}
		Xnk_push_scissor(out, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* old_clip */)))
	}
	return ret
}

var __func__358 = *(*[11]int8)(unsafe.Pointer(ts + 26497 /* "nk_do_edit" */)) /* nuklear.h:26543:1 */

func Xnk_edit_focus(ctx uintptr, flags Nk_flags) { /* nuklear.h:27041:1: */
	var hash Nk_hash
	var win uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27046), uintptr(unsafe.Pointer(&__func__359)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27047), uintptr(unsafe.Pointer(&__func__359)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	hash = (*Nk_window)(unsafe.Pointer(win)).Edit.Seq
	(*Nk_window)(unsafe.Pointer(win)).Edit.Active = Nk_true
	(*Nk_window)(unsafe.Pointer(win)).Edit.Name = hash
	if (flags & NK_EDIT_ALWAYS_INSERT_MODE) != 0 {
		(*Nk_window)(unsafe.Pointer(win)).Edit.Mode = NK_TEXT_EDIT_MODE_INSERT
	}
}

var __func__359 = *(*[14]int8)(unsafe.Pointer(ts + 26508 /* "nk_edit_focus" */)) /* nuklear.h:27042:1 */

func Xnk_edit_unfocus(ctx uintptr) { /* nuklear.h:27058:1: */
	var win uintptr
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27061), uintptr(unsafe.Pointer(&__func__360)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27062), uintptr(unsafe.Pointer(&__func__360)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	(*Nk_window)(unsafe.Pointer(win)).Edit.Active = Nk_false
	(*Nk_window)(unsafe.Pointer(win)).Edit.Name = Nk_hash(0)
}

var __func__360 = *(*[16]int8)(unsafe.Pointer(ts + 26522 /* "nk_edit_unfocus" */)) /* nuklear.h:27059:1 */

func Xnk_edit_string(ctx uintptr, flags Nk_flags, memory uintptr, len uintptr, max int32, filter Nk_plugin_filter) Nk_flags { /* nuklear.h:27070:1: */
	var hash Nk_hash
	var state Nk_flags
	var edit uintptr
	var win uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27078), uintptr(unsafe.Pointer(&__func__361)))
	}
	if memory != 0 {
	} else {
		X__assert_fail(ts+19964 /* "memory" */, ts+2 /* "nuklear/nuklear...." */, uint32(27079), uintptr(unsafe.Pointer(&__func__361)))
	}
	if len != 0 {
	} else {
		X__assert_fail(ts+255 /* "len" */, ts+2 /* "nuklear/nuklear...." */, uint32(27080), uintptr(unsafe.Pointer(&__func__361)))
	}
	if (!(ctx != 0) || !(memory != 0)) || !(len != 0) {
		return Nk_flags(0)
	}

	if !(filter != 0) {
		filter = *(*uintptr)(unsafe.Pointer(&struct {
			f func(uintptr, Nk_rune) Nk_bool
		}{Xnk_filter_default}))
	} else {
		filter = filter
	}
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	hash = (*Nk_window)(unsafe.Pointer(win)).Edit.Seq
	edit = (ctx + 7536 /* &.text_edit */)
	nk_textedit_clear_state((ctx + 7536 /* &.text_edit */), func() uint32 {
		if (flags & NK_EDIT_MULTILINE) != 0 {
			return NK_TEXT_EDIT_MULTI_LINE
		}
		return NK_TEXT_EDIT_SINGLE_LINE
	}(), filter)

	if ((*Nk_window)(unsafe.Pointer(win)).Edit.Active != 0) && (hash == (*Nk_window)(unsafe.Pointer(win)).Edit.Name) {
		if (flags & NK_EDIT_NO_CURSOR) != 0 {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Cursor = Xnk_utf_len(memory, *(*int32)(unsafe.Pointer(len)))
		} else {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Cursor = (*Nk_window)(unsafe.Pointer(win)).Edit.Cursor
		}
		if !((flags & NK_EDIT_SELECTABLE) != 0) {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_start = (*Nk_window)(unsafe.Pointer(win)).Edit.Cursor
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_end = (*Nk_window)(unsafe.Pointer(win)).Edit.Cursor
		} else {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_start = (*Nk_window)(unsafe.Pointer(win)).Edit.Sel_start
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_end = (*Nk_window)(unsafe.Pointer(win)).Edit.Sel_end
		}
		(*Nk_text_edit)(unsafe.Pointer(edit)).Mode = (*Nk_window)(unsafe.Pointer(win)).Edit.Mode
		(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X = float32((*Nk_window)(unsafe.Pointer(win)).Edit.Scrollbar.X)
		(*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y = float32((*Nk_window)(unsafe.Pointer(win)).Edit.Scrollbar.Y)
		(*Nk_text_edit)(unsafe.Pointer(edit)).Active = Nk_true
	} else {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Active = Nk_false
	}

	max = func() int32 {
		if (1) < (max) {
			return max
		}
		return 1
	}()
	*(*int32)(unsafe.Pointer(len)) = func() int32 {
		if (*(*int32)(unsafe.Pointer(len))) < (max - 1) {
			return *(*int32)(unsafe.Pointer(len))
		}
		return (max - 1)
	}()
	Xnk_str_init_fixed((edit + 12 /* &.string */), memory, Nk_size(max))
	(*Nk_text_edit)(unsafe.Pointer(edit)).String.Buffer.Allocated = Nk_size(*(*int32)(unsafe.Pointer(len)))
	(*Nk_text_edit)(unsafe.Pointer(edit)).String.Len = Xnk_utf_len(memory, *(*int32)(unsafe.Pointer(len)))
	state = Xnk_edit_buffer(ctx, flags, edit, filter)
	*(*int32)(unsafe.Pointer(len)) = int32((*Nk_text_edit)(unsafe.Pointer(edit)).String.Buffer.Allocated)

	if (*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0 {
		(*Nk_window)(unsafe.Pointer(win)).Edit.Cursor = (*Nk_text_edit)(unsafe.Pointer(edit)).Cursor
		(*Nk_window)(unsafe.Pointer(win)).Edit.Sel_start = (*Nk_text_edit)(unsafe.Pointer(edit)).Select_start
		(*Nk_window)(unsafe.Pointer(win)).Edit.Sel_end = (*Nk_text_edit)(unsafe.Pointer(edit)).Select_end
		(*Nk_window)(unsafe.Pointer(win)).Edit.Mode = (*Nk_text_edit)(unsafe.Pointer(edit)).Mode
		(*Nk_window)(unsafe.Pointer(win)).Edit.Scrollbar.X = Nk_uint((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.X)
		(*Nk_window)(unsafe.Pointer(win)).Edit.Scrollbar.Y = Nk_uint((*Nk_text_edit)(unsafe.Pointer(edit)).Scrollbar.Y)
	}
	return state
}

var __func__361 = *(*[15]int8)(unsafe.Pointer(ts + 26538 /* "nk_edit_string" */)) /* nuklear.h:27072:1 */

func Xnk_edit_buffer(ctx uintptr, flags Nk_flags, edit uintptr, filter Nk_plugin_filter) Nk_flags { /* nuklear.h:27126:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var style uintptr
	var in uintptr
	var state uint32
	// var bounds Nk_rect at bp, 16

	var ret_flags Nk_flags = Nk_flags(0)
	var prev_state uint8
	var hash Nk_hash

	// make sure correct values
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27141), uintptr(unsafe.Pointer(&__func__362)))
	}
	if edit != 0 {
	} else {
		X__assert_fail(ts+26553 /* "edit" */, ts+2 /* "nuklear/nuklear...." */, uint32(27142), uintptr(unsafe.Pointer(&__func__362)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27143), uintptr(unsafe.Pointer(&__func__362)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27144), uintptr(unsafe.Pointer(&__func__362)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return Nk_flags(0)
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return Nk_flags(state)
	}
	if ((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0 {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}

	// check if edit is currently hot item
	hash = PostIncUint32(&(*Nk_window)(unsafe.Pointer(win)).Edit.Seq, 1)
	if ((*Nk_window)(unsafe.Pointer(win)).Edit.Active != 0) && (hash == (*Nk_window)(unsafe.Pointer(win)).Edit.Name) {
		if (flags & NK_EDIT_NO_CURSOR) != 0 {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Cursor = (*Nk_text_edit)(unsafe.Pointer(edit)).String.Len
		}
		if !((flags & NK_EDIT_SELECTABLE) != 0) {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_start = (*Nk_text_edit)(unsafe.Pointer(edit)).Cursor
			(*Nk_text_edit)(unsafe.Pointer(edit)).Select_end = (*Nk_text_edit)(unsafe.Pointer(edit)).Cursor
		}
		if (flags & NK_EDIT_CLIPBOARD) != 0 {
			(*Nk_text_edit)(unsafe.Pointer(edit)).Clip = (*Nk_context)(unsafe.Pointer(ctx)).Clip
		}
		(*Nk_text_edit)(unsafe.Pointer(edit)).Active = uint8((*Nk_window)(unsafe.Pointer(win)).Edit.Active)
	} else {
		(*Nk_text_edit)(unsafe.Pointer(edit)).Active = Nk_false
	}
	(*Nk_text_edit)(unsafe.Pointer(edit)).Mode = (*Nk_window)(unsafe.Pointer(win)).Edit.Mode

	if !(filter != 0) {
		filter = *(*uintptr)(unsafe.Pointer(&struct {
			f func(uintptr, Nk_rune) Nk_bool
		}{Xnk_filter_default}))
	} else {
		filter = filter
	}
	prev_state = (*Nk_text_edit)(unsafe.Pointer(edit)).Active
	if (flags & NK_EDIT_READ_ONLY) != 0 {
		in = uintptr(0)
	} else {
		in = in
	}
	ret_flags = nk_do_edit((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), flags,
		filter, edit, (style + 2512 /* &.edit */), in, (*Nk_style)(unsafe.Pointer(style)).Font)

	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Cursor_active = *(*uintptr)(unsafe.Pointer((ctx + 360 /* &.style */ + 4 /* &.cursors */) + 1*4))
	}
	if ((*Nk_text_edit)(unsafe.Pointer(edit)).Active != 0) && (int32(prev_state) != int32((*Nk_text_edit)(unsafe.Pointer(edit)).Active)) {
		// current edit is now hot
		(*Nk_window)(unsafe.Pointer(win)).Edit.Active = Nk_true
		(*Nk_window)(unsafe.Pointer(win)).Edit.Name = hash
	} else if (prev_state != 0) && !(int32((*Nk_text_edit)(unsafe.Pointer(edit)).Active) != 0) {
		// current edit is now cold
		(*Nk_window)(unsafe.Pointer(win)).Edit.Active = Nk_false
	}
	return ret_flags
}

var __func__362 = *(*[15]int8)(unsafe.Pointer(ts + 26558 /* "nk_edit_buffer" */)) /* nuklear.h:27128:1 */

func Xnk_edit_string_zero_terminated(ctx uintptr, flags Nk_flags, buffer uintptr, max int32, filter Nk_plugin_filter) Nk_flags { /* nuklear.h:27187:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var result Nk_flags
	*(*int32)(unsafe.Pointer(bp /* len */)) = Xnk_strlen(buffer)
	result = Xnk_edit_string(ctx, flags, buffer, bp /* &len */, max, filter)
	*(*int8)(unsafe.Pointer(buffer + uintptr(func() int32 {
		if (func() int32 {
			if (max - 1) < (0) {
				return 0
			}
			return (max - 1)
		}()) < (*(*int32)(unsafe.Pointer(bp /* len */))) {
			return func() int32 {
				if (max - 1) < (0) {
					return 0
				}
				return (max - 1)
			}()
		}
		return *(*int32)(unsafe.Pointer(bp /* len */))
	}()))) = int8(0)
	return result
}

// ===============================================================
//
//                              PROPERTY
//
// ===============================================================
func nk_drag_behavior(state uintptr, in uintptr, drag Nk_rect, variant uintptr, inc_per_pixel float32) { /* nuklear.h:27207:1: */
	var left_mouse_down int32 = (Bool32((in != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0)))
	var left_mouse_click_in_cursor int32 = (Bool32((in != 0) && (Xnk_input_has_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, drag, Nk_true) != 0)))

	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if Xnk_input_is_mouse_hovering_rect(in, drag) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
	}

	if (left_mouse_down != 0) && (left_mouse_click_in_cursor != 0) {
		var delta float32
		var pixels float32
		pixels = (*Nk_input)(unsafe.Pointer(in)).Mouse.Delta.X
		delta = (pixels * inc_per_pixel)
		switch (*Nk_property_variant)(unsafe.Pointer(variant)).Kind {
		default:
			break
			fallthrough
		case NK_PROPERTY_INT:
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) + int32(delta))
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() int32 {
				if (func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*int32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*int32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_FLOAT:
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) + delta)
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float32 {
				if (func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_DOUBLE:
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) + float64(delta))
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float64 {
				if (func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float64)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float64)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
		}
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, drag) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, drag) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
}

func nk_property_behavior(ws uintptr, in uintptr, property Nk_rect, label Nk_rect, edit Nk_rect, empty Nk_rect, state uintptr, variant uintptr, inc_per_pixel float32) { /* nuklear.h:27246:1: */
	if (in != 0) && (*(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_DEFAULT) {
		if nk_button_behavior(ws, edit, in, NK_BUTTON_DEFAULT) != 0 {
			*(*int32)(unsafe.Pointer(state)) = NK_PROPERTY_EDIT
		} else if Xnk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, label, Nk_true) != 0 {
			*(*int32)(unsafe.Pointer(state)) = NK_PROPERTY_DRAG
		} else if Xnk_input_is_mouse_click_down_in_rect(in, NK_BUTTON_LEFT, empty, Nk_true) != 0 {
			*(*int32)(unsafe.Pointer(state)) = NK_PROPERTY_DRAG
		}
	}
	if *(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_DRAG {
		nk_drag_behavior(ws, in, property, variant, inc_per_pixel)
		if !((*(*Nk_flags)(unsafe.Pointer(ws)) & NK_WIDGET_STATE_ACTIVED) != 0) {
			*(*int32)(unsafe.Pointer(state)) = NK_PROPERTY_DEFAULT
		}
	}
}

func nk_draw_property(out uintptr, style uintptr, bounds uintptr, label uintptr, state Nk_flags, name uintptr, len int32, font uintptr) { /* nuklear.h:27265:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var text Nk_text at bp, 16

	var background uintptr

	// select correct background and text color
	if (state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 40 /* &.active */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_property)(unsafe.Pointer(style)).Label_active
	} else if (state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 20 /* &.hover */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_property)(unsafe.Pointer(style)).Label_hover
	} else {
		background = (style /* &.normal */)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Text = (*Nk_style_property)(unsafe.Pointer(style)).Label_normal
	}

	// draw background
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (background + 4 /* &.data */ /* &.image */), nk_white)
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
	} else {
		(*Nk_text)(unsafe.Pointer(bp /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_property)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect(out, *(*Nk_rect)(unsafe.Pointer(bounds)), (*Nk_style_property)(unsafe.Pointer(style)).Rounding, (*Nk_style_property)(unsafe.Pointer(style)).Border, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
	}

	// draw label
	(*Nk_text)(unsafe.Pointer(bp /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
	nk_widget_text(out, *(*Nk_rect)(unsafe.Pointer(label)), name, len, bp /* &text */, NK_TEXT_CENTERED, font)
}

func nk_do_property(ws uintptr, out uintptr, property Nk_rect, name uintptr, variant uintptr, inc_per_pixel float32, buffer uintptr, len uintptr, state uintptr, cursor uintptr, select_begin uintptr, select_end uintptr, style uintptr, filter uint32, in uintptr, font uintptr, text_edit uintptr, behavior uint32) { /* nuklear.h:27299:1: */
	bp := tlsAlloc(108)
	defer tlsFree(108)
	*(*Nk_rect)(unsafe.Pointer(bp + 68)) = property

	*(*[2]Nk_plugin_filter)(unsafe.Pointer(bp + 100 /* filters */)) = [2]Nk_plugin_filter{
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(uintptr, Nk_rune) Nk_bool
		}{Xnk_filter_decimal})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(uintptr, Nk_rune) Nk_bool
		}{Xnk_filter_float})),
	}
	var active Nk_bool
	var old Nk_bool
	// var num_len int32 at bp+64, 4

	var name_len int32
	// var string [64]int8 at bp, 64

	var size float32

	var dst uintptr = uintptr(0)
	var length uintptr
	var left Nk_rect
	var right Nk_rect
	// var label Nk_rect at bp+84, 16

	var edit Nk_rect
	var empty Nk_rect

	// left decrement button
	left.H = ((*Nk_user_font)(unsafe.Pointer(font)).Height / float32(2))
	left.W = left.H
	left.X = (((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).X + (*Nk_style_property)(unsafe.Pointer(style)).Border) + (*Nk_style_property)(unsafe.Pointer(style)).Padding.X)
	left.Y = ((((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).Y + (*Nk_style_property)(unsafe.Pointer(style)).Border) + ((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).H / 2.0)) - (left.H / float32(2)))

	// text label
	name_len = Xnk_strlen(name)
	size = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, name, name_len)
	(*Nk_rect)(unsafe.Pointer(bp + 84 /* &label */)).X = ((left.X + left.W) + (*Nk_style_property)(unsafe.Pointer(style)).Padding.X)
	(*Nk_rect)(unsafe.Pointer(bp + 84 /* &label */)).W = (size + (float32(2) * (*Nk_style_property)(unsafe.Pointer(style)).Padding.X))
	(*Nk_rect)(unsafe.Pointer(bp + 84 /* &label */)).Y = (((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).Y + (*Nk_style_property)(unsafe.Pointer(style)).Border) + (*Nk_style_property)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_rect)(unsafe.Pointer(bp + 84 /* &label */)).H = ((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).H - ((float32(2) * (*Nk_style_property)(unsafe.Pointer(style)).Border) + (float32(2) * (*Nk_style_property)(unsafe.Pointer(style)).Padding.Y)))

	// right increment button
	right.Y = left.Y
	right.W = left.W
	right.H = left.H
	right.X = (((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).X + (*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).W) - (right.W + (*Nk_style_property)(unsafe.Pointer(style)).Padding.X))

	// edit
	if *(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_EDIT {
		size = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, buffer, *(*int32)(unsafe.Pointer(len)))
		size = size + ((*Nk_style_property)(unsafe.Pointer(style)).Edit.Cursor_size)
		length = len
		dst = buffer
	} else {
		switch (*Nk_property_variant)(unsafe.Pointer(variant)).Kind {
		default:
			break
			fallthrough
		case NK_PROPERTY_INT:
			nk_itoa(bp /* &string[0] */, int32(*(*int32)(unsafe.Pointer(variant + 4 /* &.value */))))
			*(*int32)(unsafe.Pointer(bp + 64 /* num_len */)) = Xnk_strlen(bp /* &string[0] */)
			break
			fallthrough
		case NK_PROPERTY_FLOAT:
			nk_dtoa(bp /* &string[0] */, float64(*(*float32)(unsafe.Pointer(variant + 4 /* &.value */))))
			*(*int32)(unsafe.Pointer(bp + 64 /* num_len */)) = nk_string_float_limit(bp /* &string[0] */, NK_MAX_FLOAT_PRECISION)
			break
			fallthrough
		case NK_PROPERTY_DOUBLE:
			nk_dtoa(bp /* &string[0] */, *(*float64)(unsafe.Pointer(variant + 4 /* &.value */)))
			*(*int32)(unsafe.Pointer(bp + 64 /* num_len */)) = nk_string_float_limit(bp /* &string[0] */, NK_MAX_FLOAT_PRECISION)
			break
		}
		size = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer((font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer(font)).Userdata, (*Nk_user_font)(unsafe.Pointer(font)).Height, bp /* &string[0] */, *(*int32)(unsafe.Pointer(bp + 64 /* num_len */)))
		dst = bp         /* &string[0] */
		length = bp + 64 /* &num_len */
	}

	edit.W = (size + (float32(2) * (*Nk_style_property)(unsafe.Pointer(style)).Padding.X))
	edit.W = func() float32 {
		if (edit.W) < (right.X - ((*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).W)) {
			return edit.W
		}
		return (right.X - ((*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).W))
	}()
	edit.X = (right.X - (edit.W + (*Nk_style_property)(unsafe.Pointer(style)).Padding.X))
	edit.Y = ((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).Y + (*Nk_style_property)(unsafe.Pointer(style)).Border)
	edit.H = ((*Nk_rect)(unsafe.Pointer(bp+68 /* &property */)).H - (float32(2) * (*Nk_style_property)(unsafe.Pointer(style)).Border))

	// empty left space activator
	empty.W = (edit.X - ((*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).W))
	empty.X = ((*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).X + (*Nk_rect)(unsafe.Pointer(bp+84 /* &label */)).W)
	empty.Y = (*Nk_rect)(unsafe.Pointer(bp + 68 /* &property */)).Y
	empty.H = (*Nk_rect)(unsafe.Pointer(bp + 68 /* &property */)).H

	// update property
	old = (Bool32(*(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_EDIT))
	nk_property_behavior(ws, in, *(*Nk_rect)(unsafe.Pointer(bp + 68 /* property */)), *(*Nk_rect)(unsafe.Pointer(bp + 84 /* label */)), edit, empty, state, variant, inc_per_pixel)

	// draw property
	if (*Nk_style_property)(unsafe.Pointer(style)).Draw_begin != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 932 /* &.draw_begin */))))(out, (*Nk_style_property)(unsafe.Pointer(style)).Userdata)
	}
	nk_draw_property(out, style, bp+68 /* &property */, bp+84 /* &label */, *(*Nk_flags)(unsafe.Pointer(ws)), name, name_len, font)
	if (*Nk_style_property)(unsafe.Pointer(style)).Draw_end != 0 {
		(*(*func(uintptr, Nk_handle))(unsafe.Pointer((style + 936 /* &.draw_end */))))(out, (*Nk_style_property)(unsafe.Pointer(style)).Userdata)
	}

	// execute right button
	if nk_do_button_symbol(ws, out, left, (*Nk_style_property)(unsafe.Pointer(style)).Sym_left, behavior, (style+800 /* &.dec_button */), in, font) != 0 {
		switch (*Nk_property_variant)(unsafe.Pointer(variant)).Kind {
		default:
			break
			fallthrough
		case NK_PROPERTY_INT:
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() int32 {
				if (func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*int32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*int32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*int32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*int32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_FLOAT:
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float32 {
				if (func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_DOUBLE:
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float64 {
				if (func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float64)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float64)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float64)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) - *(*float64)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
		}
	}
	// execute left button
	if nk_do_button_symbol(ws, out, right, (*Nk_style_property)(unsafe.Pointer(style)).Sym_right, behavior, (style+672 /* &.inc_button */), in, font) != 0 {
		switch (*Nk_property_variant)(unsafe.Pointer(variant)).Kind {
		default:
			break
			fallthrough
		case NK_PROPERTY_INT:
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() int32 {
				if (func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*int32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*int32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*int32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*int32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_FLOAT:
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float32 {
				if (func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float32)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float32)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_DOUBLE:
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float64 {
				if (func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float64)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float64)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float64)(unsafe.Pointer(variant + 28 /* &.step */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) + *(*float64)(unsafe.Pointer(variant + 28 /* &.step */)))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
		}
	}
	if (old != NK_PROPERTY_EDIT) && (*(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_EDIT) {
		// property has been activated so setup buffer
		nk_memcopy(buffer, dst, Nk_size(*(*int32)(unsafe.Pointer(length))))
		*(*int32)(unsafe.Pointer(cursor)) = Xnk_utf_len(buffer, *(*int32)(unsafe.Pointer(length)))
		*(*int32)(unsafe.Pointer(len)) = *(*int32)(unsafe.Pointer(length))
		length = len
		dst = buffer
		active = 0
	} else {
		active = (Bool32(*(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_EDIT))
	}

	// execute and run text edit field
	nk_textedit_clear_state(text_edit, NK_TEXT_EDIT_SINGLE_LINE, *(*Nk_plugin_filter)(unsafe.Pointer(bp + 100 /* &filters[0] */ + uintptr(filter)*4)))
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).Active = uint8(active)
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Len = *(*int32)(unsafe.Pointer(length))
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).Cursor = func() int32 {
		if (func() int32 {
			if (*(*int32)(unsafe.Pointer(cursor))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(cursor))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()) < (0) {
			return 0
		}
		return func() int32 {
			if (*(*int32)(unsafe.Pointer(cursor))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(cursor))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()
	}()
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).Select_start = func() int32 {
		if (func() int32 {
			if (*(*int32)(unsafe.Pointer(select_begin))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(select_begin))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()) < (0) {
			return 0
		}
		return func() int32 {
			if (*(*int32)(unsafe.Pointer(select_begin))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(select_begin))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()
	}()
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).Select_end = func() int32 {
		if (func() int32 {
			if (*(*int32)(unsafe.Pointer(select_end))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(select_end))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()) < (0) {
			return 0
		}
		return func() int32 {
			if (*(*int32)(unsafe.Pointer(select_end))) < (*(*int32)(unsafe.Pointer(length))) {
				return *(*int32)(unsafe.Pointer(select_end))
			}
			return *(*int32)(unsafe.Pointer(length))
		}()
	}()
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Buffer.Allocated = Nk_size(*(*int32)(unsafe.Pointer(length)))
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Buffer.Memory.Size = Nk_size(NK_MAX_NUMBER_BUFFER)
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Buffer.Memory.Ptr = dst
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Buffer.Size = Nk_size(NK_MAX_NUMBER_BUFFER)
	(*Nk_text_edit)(unsafe.Pointer(text_edit)).Mode = NK_TEXT_EDIT_MODE_INSERT
	nk_do_edit(ws, out, edit, (uint32(NK_EDIT_FIELD | NK_EDIT_AUTO_SELECT)),
		*(*Nk_plugin_filter)(unsafe.Pointer(bp + 100 /* &filters[0] */ + uintptr(filter)*4)), text_edit, (style + 100 /* &.edit */), func() uintptr {
			if *(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_EDIT {
				return in
			}
			return uintptr(0)
		}(), font)

	*(*int32)(unsafe.Pointer(length)) = (*Nk_text_edit)(unsafe.Pointer(text_edit)).String.Len
	*(*int32)(unsafe.Pointer(cursor)) = (*Nk_text_edit)(unsafe.Pointer(text_edit)).Cursor
	*(*int32)(unsafe.Pointer(select_begin)) = (*Nk_text_edit)(unsafe.Pointer(text_edit)).Select_start
	*(*int32)(unsafe.Pointer(select_end)) = (*Nk_text_edit)(unsafe.Pointer(text_edit)).Select_end
	if ((*Nk_text_edit)(unsafe.Pointer(text_edit)).Active != 0) && (Xnk_input_is_key_pressed(in, NK_KEY_ENTER) != 0) {
		(*Nk_text_edit)(unsafe.Pointer(text_edit)).Active = Nk_false
	}

	if (active != 0) && !(int32((*Nk_text_edit)(unsafe.Pointer(text_edit)).Active) != 0) {
		// property is now not active so convert edit text to value
		*(*int32)(unsafe.Pointer(state)) = NK_PROPERTY_DEFAULT
		*(*int8)(unsafe.Pointer(buffer + uintptr(*(*int32)(unsafe.Pointer(len))))) = int8(0)
		switch (*Nk_property_variant)(unsafe.Pointer(variant)).Kind {
		default:
			break
			fallthrough
		case NK_PROPERTY_INT:
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = Xnk_strtoi(buffer, uintptr(0))
			*(*int32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() int32 {
				if (func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*int32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*int32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() int32 {
					if (*(*int32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*int32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*int32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_FLOAT:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION)
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = Xnk_strtof(buffer, uintptr(0))
			*(*float32)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float32 {
				if (func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float32)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float32 {
					if (*(*float32)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float32)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float32)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
			fallthrough
		case NK_PROPERTY_DOUBLE:
			nk_string_float_limit(buffer, NK_MAX_FLOAT_PRECISION)
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = Xnk_strtod(buffer, uintptr(0))
			*(*float64)(unsafe.Pointer(variant + 4 /* &.value */)) = func() float64 {
				if (func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float64)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()) < (*(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))) {
					return *(*float64)(unsafe.Pointer(variant + 12 /* &.min_value */))
				}
				return func() float64 {
					if (*(*float64)(unsafe.Pointer(variant + 4 /* &.value */))) < (*(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))) {
						return *(*float64)(unsafe.Pointer(variant + 4 /* &.value */))
					}
					return *(*float64)(unsafe.Pointer(variant + 20 /* &.max_value */))
				}()
			}()
			break
		}
	}
}

func nk_property_variant_int(value int32, min_value int32, max_value int32, step int32) Nk_property_variant { /* nuklear.h:27475:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var result Nk_property_variant at bp, 36

	(*Nk_property_variant)(unsafe.Pointer(bp /* &result */)).Kind = NK_PROPERTY_INT
	*(*int32)(unsafe.Pointer(bp /* &result */ + 4 /* &.value */)) = value
	*(*int32)(unsafe.Pointer(bp /* &result */ + 12 /* &.min_value */)) = min_value
	*(*int32)(unsafe.Pointer(bp /* &result */ + 20 /* &.max_value */)) = max_value
	*(*int32)(unsafe.Pointer(bp /* &result */ + 28 /* &.step */)) = step
	return *(*Nk_property_variant)(unsafe.Pointer(bp /* result */))
}

func nk_property_variant_float(value float32, min_value float32, max_value float32, step float32) Nk_property_variant { /* nuklear.h:27486:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var result Nk_property_variant at bp, 36

	(*Nk_property_variant)(unsafe.Pointer(bp /* &result */)).Kind = NK_PROPERTY_FLOAT
	*(*float32)(unsafe.Pointer(bp /* &result */ + 4 /* &.value */)) = value
	*(*float32)(unsafe.Pointer(bp /* &result */ + 12 /* &.min_value */)) = min_value
	*(*float32)(unsafe.Pointer(bp /* &result */ + 20 /* &.max_value */)) = max_value
	*(*float32)(unsafe.Pointer(bp /* &result */ + 28 /* &.step */)) = step
	return *(*Nk_property_variant)(unsafe.Pointer(bp /* result */))
}

func nk_property_variant_double(value float64, min_value float64, max_value float64, step float64) Nk_property_variant { /* nuklear.h:27497:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var result Nk_property_variant at bp, 36

	(*Nk_property_variant)(unsafe.Pointer(bp /* &result */)).Kind = NK_PROPERTY_DOUBLE
	*(*float64)(unsafe.Pointer(bp /* &result */ + 4 /* &.value */)) = value
	*(*float64)(unsafe.Pointer(bp /* &result */ + 12 /* &.min_value */)) = min_value
	*(*float64)(unsafe.Pointer(bp /* &result */ + 20 /* &.max_value */)) = max_value
	*(*float64)(unsafe.Pointer(bp /* &result */ + 28 /* &.step */)) = step
	return *(*Nk_property_variant)(unsafe.Pointer(bp /* result */))
}

func nk_property(ctx uintptr, name uintptr, variant uintptr, inc_per_pixel float32, filter uint32) { /* nuklear.h:27509:1: */
	bp := tlsAlloc(100)
	defer tlsFree(100)

	var win uintptr
	var layout uintptr
	var in uintptr
	var style uintptr
	// var bounds Nk_rect at bp, 16

	var s uint32

	var state uintptr = uintptr(0)
	var hash Nk_hash = Nk_hash(0)
	var buffer uintptr = uintptr(0)
	var len uintptr = uintptr(0)
	var cursor uintptr = uintptr(0)
	var select_begin uintptr = uintptr(0)
	var select_end uintptr = uintptr(0)
	var old_state int32
	// var dummy_buffer [64]int8 at bp+16, 64

	*(*int32)(unsafe.Pointer(bp + 88 /* dummy_state */)) = NK_PROPERTY_DEFAULT
	*(*int32)(unsafe.Pointer(bp + 80 /* dummy_length */)) = 0
	*(*int32)(unsafe.Pointer(bp + 84 /* dummy_cursor */)) = 0
	*(*int32)(unsafe.Pointer(bp + 92 /* dummy_select_begin */)) = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* dummy_select_end */)) = 0

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27536), uintptr(unsafe.Pointer(&__func__363)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27537), uintptr(unsafe.Pointer(&__func__363)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27538), uintptr(unsafe.Pointer(&__func__363)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &bounds */, ctx)
	if !(s != 0) {
		return
	}

	// calculate hash from name
	if int32(*(*int8)(unsafe.Pointer(name))) == '#' {
		hash = Xnk_murmur_hash(name, Xnk_strlen(name), PostIncUint32(&(*Nk_window)(unsafe.Pointer(win)).Property.Seq, 1))
		name++ // special number hash
	} else {
		hash = Xnk_murmur_hash(name, Xnk_strlen(name), uint32(42))
	}

	// check if property is currently hot item
	if ((*Nk_window)(unsafe.Pointer(win)).Property.Active != 0) && (hash == (*Nk_window)(unsafe.Pointer(win)).Property.Name) {
		buffer = win + 148 /* &.property */ + 8 /* &.buffer */
		len = (win + 148 /* &.property */ + 72 /* &.length */)
		cursor = (win + 148 /* &.property */ + 76 /* &.cursor */)
		state = (win + 148 /* &.property */ + 100 /* &.state */)
		select_begin = (win + 148 /* &.property */ + 80 /* &.select_start */)
		select_end = (win + 148 /* &.property */ + 84 /* &.select_end */)
	} else {
		buffer = bp + 16       /* &dummy_buffer[0] */
		len = bp + 80          /* &dummy_length */
		cursor = bp + 84       /* &dummy_cursor */
		state = bp + 88        /* &dummy_state */
		select_begin = bp + 92 /* &dummy_select_begin */
		select_end = bp + 96   /* &dummy_select_end */
	}

	// execute property widget
	old_state = *(*int32)(unsafe.Pointer(state))
	(*Nk_context)(unsafe.Pointer(ctx)).Text_edit.Clip = (*Nk_context)(unsafe.Pointer(ctx)).Clip
	if ((int32(s) == NK_WIDGET_ROM) && !((*Nk_window)(unsafe.Pointer(win)).Property.Active != 0)) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	nk_do_property((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), name,
		variant, inc_per_pixel, buffer, len, state, cursor, select_begin,
		select_end, (style + 1572 /* &.property */), filter, in, (*Nk_style)(unsafe.Pointer(style)).Font, (ctx + 7536 /* &.text_edit */),
		(*Nk_context)(unsafe.Pointer(ctx)).Button_behavior)

	if ((in != 0) && (*(*int32)(unsafe.Pointer(state)) != NK_PROPERTY_DEFAULT)) && !((*Nk_window)(unsafe.Pointer(win)).Property.Active != 0) {
		// current property is now hot
		(*Nk_window)(unsafe.Pointer(win)).Property.Active = 1
		nk_memcopy(win+148 /* &.property */ +8 /* &.buffer */, buffer, Nk_size(*(*int32)(unsafe.Pointer(len))))
		(*Nk_window)(unsafe.Pointer(win)).Property.Length = *(*int32)(unsafe.Pointer(len))
		(*Nk_window)(unsafe.Pointer(win)).Property.Cursor = *(*int32)(unsafe.Pointer(cursor))
		(*Nk_window)(unsafe.Pointer(win)).Property.State = *(*int32)(unsafe.Pointer(state))
		(*Nk_window)(unsafe.Pointer(win)).Property.Name = hash
		(*Nk_window)(unsafe.Pointer(win)).Property.Select_start = *(*int32)(unsafe.Pointer(select_begin))
		(*Nk_window)(unsafe.Pointer(win)).Property.Select_end = *(*int32)(unsafe.Pointer(select_end))
		if *(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_DRAG {
			(*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Grab = Nk_true
			(*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Grabbed = Nk_true
		}
	}
	// check if previously active property is now inactive
	if (*(*int32)(unsafe.Pointer(state)) == NK_PROPERTY_DEFAULT) && (old_state != NK_PROPERTY_DEFAULT) {
		if old_state == NK_PROPERTY_DRAG {
			(*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Grab = Nk_false
			(*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Grabbed = Nk_false
			(*Nk_context)(unsafe.Pointer(ctx)).Input.Mouse.Ungrab = Nk_true
		}
		(*Nk_window)(unsafe.Pointer(win)).Property.Select_start = 0
		(*Nk_window)(unsafe.Pointer(win)).Property.Select_end = 0
		(*Nk_window)(unsafe.Pointer(win)).Property.Active = 0
	}
}

var __func__363 = *(*[12]int8)(unsafe.Pointer(ts + 26573 /* "nk_property" */)) /* nuklear.h:27511:1 */

func Xnk_property_int(ctx uintptr, name uintptr, min int32, val uintptr, max int32, step int32, inc_per_pixel float32) { /* nuklear.h:27609:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27613), uintptr(unsafe.Pointer(&__func__364)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27614), uintptr(unsafe.Pointer(&__func__364)))
	}
	if val != 0 {
	} else {
		X__assert_fail(ts+26585 /* "val" */, ts+2 /* "nuklear/nuklear...." */, uint32(27615), uintptr(unsafe.Pointer(&__func__364)))
	}

	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0)) || !(val != 0) {
		return
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_int(*(*int32)(unsafe.Pointer(val)), min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_INT)
	*(*int32)(unsafe.Pointer(val)) = *(*int32)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
}

var __func__364 = *(*[16]int8)(unsafe.Pointer(ts + 26589 /* "nk_property_int" */)) /* nuklear.h:27611:1 */

func Xnk_property_float(ctx uintptr, name uintptr, min float32, val uintptr, max float32, step float32, inc_per_pixel float32) { /* nuklear.h:27623:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27627), uintptr(unsafe.Pointer(&__func__365)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27628), uintptr(unsafe.Pointer(&__func__365)))
	}
	if val != 0 {
	} else {
		X__assert_fail(ts+26585 /* "val" */, ts+2 /* "nuklear/nuklear...." */, uint32(27629), uintptr(unsafe.Pointer(&__func__365)))
	}

	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0)) || !(val != 0) {
		return
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_float(*(*float32)(unsafe.Pointer(val)), min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_FLOAT)
	*(*float32)(unsafe.Pointer(val)) = *(*float32)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
}

var __func__365 = *(*[18]int8)(unsafe.Pointer(ts + 26605 /* "nk_property_floa..." */)) /* nuklear.h:27625:1 */

func Xnk_property_double(ctx uintptr, name uintptr, min float64, val uintptr, max float64, step float64, inc_per_pixel float32) { /* nuklear.h:27637:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27641), uintptr(unsafe.Pointer(&__func__366)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27642), uintptr(unsafe.Pointer(&__func__366)))
	}
	if val != 0 {
	} else {
		X__assert_fail(ts+26585 /* "val" */, ts+2 /* "nuklear/nuklear...." */, uint32(27643), uintptr(unsafe.Pointer(&__func__366)))
	}

	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0)) || !(val != 0) {
		return
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_double(*(*float64)(unsafe.Pointer(val)), min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_FLOAT)
	*(*float64)(unsafe.Pointer(val)) = *(*float64)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
}

var __func__366 = *(*[19]int8)(unsafe.Pointer(ts + 26623 /* "nk_property_doub..." */)) /* nuklear.h:27639:1 */

func Xnk_propertyi(ctx uintptr, name uintptr, min int32, val int32, max int32, step int32, inc_per_pixel float32) Nk_bool { /* nuklear.h:27651:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27655), uintptr(unsafe.Pointer(&__func__367)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27656), uintptr(unsafe.Pointer(&__func__367)))
	}

	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0) {
		return val
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_int(val, min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_INT)
	val = *(*int32)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
	return val
}

var __func__367 = *(*[13]int8)(unsafe.Pointer(ts + 26642 /* "nk_propertyi" */)) /* nuklear.h:27653:1 */

func Xnk_propertyf(ctx uintptr, name uintptr, min float32, val float32, max float32, step float32, inc_per_pixel float32) float32 { /* nuklear.h:27665:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27669), uintptr(unsafe.Pointer(&__func__368)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27670), uintptr(unsafe.Pointer(&__func__368)))
	}

	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0) {
		return val
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_float(val, min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_FLOAT)
	val = *(*float32)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
	return val
}

var __func__368 = *(*[13]int8)(unsafe.Pointer(ts + 26655 /* "nk_propertyf" */)) /* nuklear.h:27667:1 */

func Xnk_propertyd(ctx uintptr, name uintptr, min float64, val float64, max float64, step float64, inc_per_pixel float32) float64 { /* nuklear.h:27679:1: */
	bp := tlsAlloc(36)
	defer tlsFree(36)

	// var variant Nk_property_variant at bp, 36

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27683), uintptr(unsafe.Pointer(&__func__369)))
	}
	if name != 0 {
	} else {
		X__assert_fail(ts+4498 /* "name" */, ts+2 /* "nuklear/nuklear...." */, uint32(27684), uintptr(unsafe.Pointer(&__func__369)))
	}

	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(name != 0) {
		return val
	}
	*(*Nk_property_variant)(unsafe.Pointer(bp /* variant */)) = nk_property_variant_double(val, min, max, step)
	nk_property(ctx, name, bp /* &variant */, inc_per_pixel, NK_FILTER_FLOAT)
	val = *(*float64)(unsafe.Pointer(bp /* &variant */ + 4 /* &.value */))
	return val
}

var __func__369 = *(*[13]int8)(unsafe.Pointer(ts + 26668 /* "nk_propertyd" */)) /* nuklear.h:27681:1 */

// ==============================================================
//
//                          CHART
//
// ===============================================================
func Xnk_chart_begin_colored(ctx uintptr, type1 uint32, color Nk_color, highlight Nk_color, count int32, min_value float32, max_value float32) Nk_bool { /* nuklear.h:27703:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var chart uintptr
	var config uintptr
	var style uintptr
	var background uintptr
	*(*Nk_rect)(unsafe.Pointer(bp /* bounds */)) = Nk_rect{}

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27715), uintptr(unsafe.Pointer(&__func__370)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27716), uintptr(unsafe.Pointer(&__func__370)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27717), uintptr(unsafe.Pointer(&__func__370)))
	}

	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}
	if !(Xnk_widget(bp /* &bounds */, ctx) != 0) {
		chart = ((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout + 224 /* &.chart */)
		nk_zero(chart, uint32(unsafe.Sizeof(Nk_chart{})))
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	config = (ctx + 360 /* &.style */)
	chart = ((*Nk_window)(unsafe.Pointer(win)).Layout + 224 /* &.chart */)
	style = (config + 3084 /* &.chart */)

	// setup basic generic chart
	nk_zero(chart, uint32(unsafe.Sizeof(Nk_chart{})))
	(*Nk_chart)(unsafe.Pointer(chart)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X + (*Nk_style_chart)(unsafe.Pointer(style)).Padding.X)
	(*Nk_chart)(unsafe.Pointer(chart)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y + (*Nk_style_chart)(unsafe.Pointer(style)).Padding.Y)
	(*Nk_chart)(unsafe.Pointer(chart)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W - (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.X))
	(*Nk_chart)(unsafe.Pointer(chart)).H = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H - (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.Y))
	(*Nk_chart)(unsafe.Pointer(chart)).W = func() float32 {
		if ((*Nk_chart)(unsafe.Pointer(chart)).W) < (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.X) {
			return (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.X)
		}
		return (*Nk_chart)(unsafe.Pointer(chart)).W
	}()
	(*Nk_chart)(unsafe.Pointer(chart)).H = func() float32 {
		if ((*Nk_chart)(unsafe.Pointer(chart)).H) < (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.Y) {
			return (float32(2) * (*Nk_style_chart)(unsafe.Pointer(style)).Padding.Y)
		}
		return (*Nk_chart)(unsafe.Pointer(chart)).H
	}()

	/* add first slot into chart */
	{
		var slot uintptr = ((chart + 20 /* &.slots */) + uintptr(PostIncInt32(&(*Nk_chart)(unsafe.Pointer(chart)).Slot, 1))*40)
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Type = type1
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Count = count
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Color = color
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Highlight = highlight
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Min = func() float32 {
			if (min_value) < (max_value) {
				return min_value
			}
			return max_value
		}()
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Max = func() float32 {
			if (min_value) < (max_value) {
				return max_value
			}
			return min_value
		}()
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Range = ((*Nk_chart_slot)(unsafe.Pointer(slot)).Max - (*Nk_chart_slot)(unsafe.Pointer(slot)).Min)
	}

	// draw chart background
	background = (style /* &.background */)
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), (*Nk_style_chart)(unsafe.Pointer(style)).Rounding, (*Nk_style_chart)(unsafe.Pointer(style)).Border_color)
		Xnk_fill_rect((win + 100 /* &.buffer */), nk_shrink_rect(*(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), (*Nk_style_chart)(unsafe.Pointer(style)).Border),
			(*Nk_style_chart)(unsafe.Pointer(style)).Rounding, *(*Nk_color)(unsafe.Pointer(style /* &.background */ + 4 /* &.data */)))
	}
	return 1
}

var __func__370 = *(*[23]int8)(unsafe.Pointer(ts + 26681 /* "nk_chart_begin_c..." */)) /* nuklear.h:27706:1 */

func Xnk_chart_begin(ctx uintptr, type1 uint32, count int32, min_value float32, max_value float32) Nk_bool { /* nuklear.h:27762:1: */
	return Xnk_chart_begin_colored(ctx, type1, (*Nk_context)(unsafe.Pointer(ctx)).Style.Chart.Color,
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Chart.Selected_color, count, min_value, max_value)
}

func Xnk_chart_add_slot_colored(ctx uintptr, type1 uint32, color Nk_color, highlight Nk_color, count int32, min_value float32, max_value float32) { /* nuklear.h:27769:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27773), uintptr(unsafe.Pointer(&__func__371)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27774), uintptr(unsafe.Pointer(&__func__371)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27775), uintptr(unsafe.Pointer(&__func__371)))
	}
	if (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Chart.Slot < NK_CHART_MAX_SLOT {
	} else {
		X__assert_fail(ts+26704 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27776), uintptr(unsafe.Pointer(&__func__371)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return
	}
	if (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Chart.Slot >= NK_CHART_MAX_SLOT {
		return
	}

	/* add another slot into the graph */
	{
		var chart uintptr = ((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout + 224 /* &.chart */)
		var slot uintptr = ((chart + 20 /* &.slots */) + uintptr(PostIncInt32(&(*Nk_chart)(unsafe.Pointer(chart)).Slot, 1))*40)
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Type = type1
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Count = count
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Color = color
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Highlight = highlight
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Min = func() float32 {
			if (min_value) < (max_value) {
				return min_value
			}
			return max_value
		}()
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Max = func() float32 {
			if (min_value) < (max_value) {
				return max_value
			}
			return min_value
		}()
		(*Nk_chart_slot)(unsafe.Pointer(slot)).Range = ((*Nk_chart_slot)(unsafe.Pointer(slot)).Max - (*Nk_chart_slot)(unsafe.Pointer(slot)).Min)
	}
}

var __func__371 = *(*[26]int8)(unsafe.Pointer(ts + 26741 /* "nk_chart_add_slo..." */)) /* nuklear.h:27772:1 */

func Xnk_chart_add_slot(ctx uintptr, type1 uint32, count int32, min_value float32, max_value float32) { /* nuklear.h:27792:1: */
	Xnk_chart_add_slot_colored(ctx, type1, (*Nk_context)(unsafe.Pointer(ctx)).Style.Chart.Color,
		(*Nk_context)(unsafe.Pointer(ctx)).Style.Chart.Selected_color, count, min_value, max_value)
}

func nk_chart_push_line(ctx uintptr, win uintptr, g uintptr, value float32, slot int32) Nk_flags { /* nuklear.h:27799:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var layout uintptr = (*Nk_window)(unsafe.Pointer(win)).Layout
	var i uintptr = (ctx /* &.input */)
	var out uintptr = (win + 100 /* &.buffer */)

	var ret Nk_flags = Nk_flags(0)
	var cur Nk_vec2
	// var bounds Nk_rect at bp, 16

	var color Nk_color
	var step float32
	var range1 float32
	var ratio float32

	if (slot >= 0) && (slot < NK_CHART_MAX_SLOT) {
	} else {
		X__assert_fail(ts+26767 /* "slot >= 0 && slo..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27814), uintptr(unsafe.Pointer(&__func__372)))
	}
	step = ((*Nk_chart)(unsafe.Pointer(g)).W / float32((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Count))
	range1 = ((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Max - (*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Min)
	ratio = ((value - (*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Min) / range1)

	if (*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Index == 0 {
		// first data point does not have a connection
		(*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Last.X = (*Nk_chart)(unsafe.Pointer(g)).X
		(*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Last.Y = (((*Nk_chart)(unsafe.Pointer(g)).Y + (*Nk_chart)(unsafe.Pointer(g)).H) - (ratio * (*Nk_chart)(unsafe.Pointer(g)).H))

		(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X = ((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.X - float32(2))
		(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y = ((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.Y - float32(2))
		(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W = AssignPtrFloat32(bp /* &bounds */ +12 /* &.h */, float32(4))

		color = (*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Color
		if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) && (((((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.X - float32(3)) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.X)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.X) < (((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.X - float32(3)) + float32(6)))) && ((((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.Y - float32(3)) <= ((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.Y)) && (((*Nk_input)(unsafe.Pointer(i)).Mouse.Pos.Y) < (((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.Y - float32(3)) + float32(6))))) {
			if Xnk_input_is_mouse_hovering_rect(i, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */))) != 0 {
				ret = NK_CHART_HOVERING
			} else {
				ret = uint32(0)
			}
			ret = ret | (func() uint32 {
				if ((*Nk_mouse_button)(unsafe.Pointer((i + 260 /* &.mouse */ /* &.buttons */))).Down != 0) && ((*Nk_mouse_button)(unsafe.Pointer((i + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0) {
					return NK_CHART_CLICKED
				}
				return uint32(0)
			}())
			color = (*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Highlight
		}
		Xnk_fill_rect(out, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)), float32(0), color)
		*(*int32)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40 + 36 /* &.index */)) += (1)
		return ret
	}

	// draw a line between the last data point and the new one
	color = (*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Color
	cur.X = ((*Nk_chart)(unsafe.Pointer(g)).X + (step * float32((*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Index)))
	cur.Y = (((*Nk_chart)(unsafe.Pointer(g)).Y + (*Nk_chart)(unsafe.Pointer(g)).H) - (ratio * (*Nk_chart)(unsafe.Pointer(g)).H))
	Xnk_stroke_line(out, (*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.X, (*Nk_chart_slot)(unsafe.Pointer((g+20 /* &.slots */)+uintptr(slot)*40)).Last.Y, cur.X, cur.Y, 1.0, color)

	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X = (cur.X - float32(3))
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y = (cur.Y - float32(3))
	(*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W = AssignPtrFloat32(bp /* &bounds */ +12 /* &.h */, float32(6))

	// user selection of current data point
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		if Xnk_input_is_mouse_hovering_rect(i, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */))) != 0 {
			ret = NK_CHART_HOVERING
			ret = ret | (func() uint32 {
				if !((*Nk_mouse_button)(unsafe.Pointer((i + 260 /* &.mouse */ /* &.buttons */))).Down != 0) && ((*Nk_mouse_button)(unsafe.Pointer((i + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0) {
					return NK_CHART_CLICKED
				}
				return uint32(0)
			}())
			color = (*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Highlight
		}
	}
	Xnk_fill_rect(out, Xnk_rect((cur.X-float32(2)), (cur.Y-float32(2)), float32(4), float32(4)), float32(0), color)

	// save current data point position
	(*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Last.X = cur.X
	(*Nk_chart_slot)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40)).Last.Y = cur.Y
	*(*int32)(unsafe.Pointer((g + 20 /* &.slots */) + uintptr(slot)*40 + 36 /* &.index */)) += (1)
	return ret
}

var __func__372 = *(*[19]int8)(unsafe.Pointer(ts + 26789 /* "nk_chart_push_li..." */)) /* nuklear.h:27801:1 */

func nk_chart_push_column(ctx uintptr, win uintptr, chart uintptr, value float32, slot int32) Nk_flags { /* nuklear.h:27869:1: */
	var out uintptr = (win + 100 /* &.buffer */)
	var in uintptr = (ctx /* &.input */)
	var layout uintptr = (*Nk_window)(unsafe.Pointer(win)).Layout
	var ratio float32
	var ret Nk_flags = Nk_flags(0)
	var color Nk_color
	var item = Nk_rect{}

	if (slot >= 0) && (slot < NK_CHART_MAX_SLOT) {
	} else {
		X__assert_fail(ts+26767 /* "slot >= 0 && slo..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27881), uintptr(unsafe.Pointer(&__func__373)))
	}
	if (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Index >= (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Count {
		return Nk_false
	}
	if (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Count != 0 {
		var padding float32 = (float32((*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Count - 1))
		item.W = (((*Nk_chart)(unsafe.Pointer(chart)).W - padding) / (float32((*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Count)))
	}

	// calculate bounds of current bar chart entry
	color = (*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Color

	item.H = ((*Nk_chart)(unsafe.Pointer(chart)).H * (func() float32 {
		if (value / (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Range) < float32(0) {
			return -(value / (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Range)
		}
		return (value / (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Range)
	}()))
	if value >= float32(0) {
		ratio = ((value + (func() float32 {
			if ((*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Min) < float32(0) {
				return -(*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Min
			}
			return (*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Min
		}())) / (func() float32 {
			if ((*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Range) < float32(0) {
				return -(*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Range
			}
			return (*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Range
		}()))
		item.Y = (((*Nk_chart)(unsafe.Pointer(chart)).Y + (*Nk_chart)(unsafe.Pointer(chart)).H) - ((*Nk_chart)(unsafe.Pointer(chart)).H * ratio))
	} else {
		ratio = ((value - (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Max) / (*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Range)
		item.Y = (((*Nk_chart)(unsafe.Pointer(chart)).Y + ((*Nk_chart)(unsafe.Pointer(chart)).H * (func() float32 {
			if (ratio) < float32(0) {
				return -ratio
			}
			return ratio
		}()))) - item.H)
	}
	item.X = ((*Nk_chart)(unsafe.Pointer(chart)).X + (float32((*Nk_chart_slot)(unsafe.Pointer((chart+20 /* &.slots */)+uintptr(slot)*40)).Index) * item.W))
	item.X = (item.X + (float32((*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Index)))

	// user chart bar selection
	if !(((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) && ((((item.X) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X) < (item.X + item.W))) && (((item.Y) <= ((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y)) && (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y) < (item.Y + item.H)))) {
		ret = NK_CHART_HOVERING
		ret = ret | (func() uint32 {
			if !((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Down != 0) && ((*Nk_mouse_button)(unsafe.Pointer((in + 260 /* &.mouse */ /* &.buttons */))).Clicked != 0) {
				return NK_CHART_CLICKED
			}
			return uint32(0)
		}())
		color = (*Nk_chart_slot)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40)).Highlight
	}
	Xnk_fill_rect(out, item, float32(0), color)
	*(*int32)(unsafe.Pointer((chart + 20 /* &.slots */) + uintptr(slot)*40 + 36 /* &.index */)) += (1)
	return ret
}

var __func__373 = *(*[21]int8)(unsafe.Pointer(ts + 26808 /* "nk_chart_push_co..." */)) /* nuklear.h:27871:1 */

func Xnk_chart_push_slot(ctx uintptr, value float32, slot int32) Nk_flags { /* nuklear.h:27915:1: */
	var flags Nk_flags
	var win uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27920), uintptr(unsafe.Pointer(&__func__374)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27921), uintptr(unsafe.Pointer(&__func__374)))
	}
	if (slot >= 0) && (slot < NK_CHART_MAX_SLOT) {
	} else {
		X__assert_fail(ts+26767 /* "slot >= 0 && slo..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27922), uintptr(unsafe.Pointer(&__func__374)))
	}
	if slot < (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Chart.Slot {
	} else {
		X__assert_fail(ts+26829 /* "slot < ctx->curr..." */, ts+2 /* "nuklear/nuklear...." */, uint32(27923), uintptr(unsafe.Pointer(&__func__374)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || (slot >= NK_CHART_MAX_SLOT) {
		return Nk_false
	}
	if slot >= (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Chart.Slot {
		return Nk_false
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	if (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Chart.Slot < slot {
		return Nk_false
	}
	switch (*Nk_chart_slot)(unsafe.Pointer(((*Nk_window)(unsafe.Pointer(win)).Layout + 224 /* &.chart */ + 20 /* &.slots */) + uintptr(slot)*40)).Type {
	case NK_CHART_LINES:
		flags = nk_chart_push_line(ctx, win, ((*Nk_window)(unsafe.Pointer(win)).Layout + 224 /* &.chart */), value, slot)
		break
	case NK_CHART_COLUMN:
		flags = nk_chart_push_column(ctx, win, ((*Nk_window)(unsafe.Pointer(win)).Layout + 224 /* &.chart */), value, slot)
		break
	default:
		fallthrough
	case NK_CHART_MAX:
		flags = Nk_flags(0)
	}
	return flags
}

var __func__374 = *(*[19]int8)(unsafe.Pointer(ts + 26869 /* "nk_chart_push_sl..." */)) /* nuklear.h:27916:1 */

func Xnk_chart_push(ctx uintptr, value float32) Nk_flags { /* nuklear.h:27941:1: */
	return Xnk_chart_push_slot(ctx, value, 0)
}

func Xnk_chart_end(ctx uintptr) { /* nuklear.h:27946:1: */
	var win uintptr
	var chart uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27951), uintptr(unsafe.Pointer(&__func__375)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(27952), uintptr(unsafe.Pointer(&__func__375)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	chart = ((*Nk_window)(unsafe.Pointer(win)).Layout + 224 /* &.chart */)
	nk_memset(chart, 0, uint32(unsafe.Sizeof(Nk_chart{})))
	return
}

var __func__375 = *(*[13]int8)(unsafe.Pointer(ts + 26888 /* "nk_chart_end" */)) /* nuklear.h:27947:1 */

func Xnk_plot(ctx uintptr, type1 uint32, values uintptr, count int32, offset int32) { /* nuklear.h:27962:1: */
	var i int32 = 0
	var min_value float32
	var max_value float32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27969), uintptr(unsafe.Pointer(&__func__376)))
	}
	if values != 0 {
	} else {
		X__assert_fail(ts+26901 /* "values" */, ts+2 /* "nuklear/nuklear...." */, uint32(27970), uintptr(unsafe.Pointer(&__func__376)))
	}
	if (!(ctx != 0) || !(values != 0)) || !(count != 0) {
		return
	}

	min_value = *(*float32)(unsafe.Pointer(values + uintptr(offset)*4))
	max_value = *(*float32)(unsafe.Pointer(values + uintptr(offset)*4))
	for i = 0; i < count; i++ {
		min_value = func() float32 {
			if (*(*float32)(unsafe.Pointer(values + uintptr((i+offset))*4))) < (min_value) {
				return *(*float32)(unsafe.Pointer(values + uintptr((i+offset))*4))
			}
			return min_value
		}()
		max_value = func() float32 {
			if (*(*float32)(unsafe.Pointer(values + uintptr((i+offset))*4))) < (max_value) {
				return max_value
			}
			return *(*float32)(unsafe.Pointer(values + uintptr((i+offset))*4))
		}()
	}

	if Xnk_chart_begin(ctx, type1, count, min_value, max_value) != 0 {
		for i = 0; i < count; i++ {
			Xnk_chart_push(ctx, *(*float32)(unsafe.Pointer(values + uintptr((i+offset))*4)))
		}
		Xnk_chart_end(ctx)
	}
}

var __func__376 = *(*[8]int8)(unsafe.Pointer(ts + 26908 /* "nk_plot" */)) /* nuklear.h:27964:1 */

func Xnk_plot_function(ctx uintptr, type1 uint32, userdata uintptr, value_getter uintptr, count int32, offset int32) { /* nuklear.h:27987:1: */
	var i int32 = 0
	var min_value float32
	var max_value float32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(27994), uintptr(unsafe.Pointer(&__func__377)))
	}
	if value_getter != 0 {
	} else {
		X__assert_fail(ts+26916 /* "value_getter" */, ts+2 /* "nuklear/nuklear...." */, uint32(27995), uintptr(unsafe.Pointer(&__func__377)))
	}
	if (!(ctx != 0) || !(value_getter != 0)) || !(count != 0) {
		return
	}

	max_value = AssignFloat32(&min_value, (*(*func(uintptr, int32) float32)(unsafe.Pointer(&value_getter)))(userdata, offset))
	for i = 0; i < count; i++ {
		var value float32 = (*(*func(uintptr, int32) float32)(unsafe.Pointer(&value_getter)))(userdata, (i + offset))
		min_value = func() float32 {
			if (value) < (min_value) {
				return value
			}
			return min_value
		}()
		max_value = func() float32 {
			if (value) < (max_value) {
				return max_value
			}
			return value
		}()
	}

	if Xnk_chart_begin(ctx, type1, count, min_value, max_value) != 0 {
		for i = 0; i < count; i++ {
			Xnk_chart_push(ctx, (*(*func(uintptr, int32) float32)(unsafe.Pointer(&value_getter)))(userdata, (i+offset)))
		}
		Xnk_chart_end(ctx)
	}
}

var __func__377 = *(*[17]int8)(unsafe.Pointer(ts + 26929 /* "nk_plot_function" */)) /* nuklear.h:27989:1 */

// ==============================================================
//
//                          COLOR PICKER
//
// ===============================================================
func nk_color_picker_behavior(state uintptr, bounds uintptr, matrix uintptr, hue_bar uintptr, alpha_bar uintptr, color uintptr, in uintptr) Nk_bool { /* nuklear.h:28022:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	// var hsva [4]float32 at bp, 16

	var value_changed Nk_bool = 0
	var hsv_changed Nk_bool = 0

	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(28031), uintptr(unsafe.Pointer(&__func__378)))
	}
	if matrix != 0 {
	} else {
		X__assert_fail(ts+26946 /* "matrix" */, ts+2 /* "nuklear/nuklear...." */, uint32(28032), uintptr(unsafe.Pointer(&__func__378)))
	}
	if hue_bar != 0 {
	} else {
		X__assert_fail(ts+26953 /* "hue_bar" */, ts+2 /* "nuklear/nuklear...." */, uint32(28033), uintptr(unsafe.Pointer(&__func__378)))
	}
	if color != 0 {
	} else {
		X__assert_fail(ts+26961 /* "color" */, ts+2 /* "nuklear/nuklear...." */, uint32(28034), uintptr(unsafe.Pointer(&__func__378)))
	}

	// color matrix
	Xnk_colorf_hsva_fv(bp /* &hsva[0] */, *(*Nk_colorf)(unsafe.Pointer(color)))
	if nk_button_behavior(state, *(*Nk_rect)(unsafe.Pointer(matrix)), in, NK_BUTTON_REPEATER) != 0 {
		*(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 1*4)) = func() float32 {
			if (float32(0)) < (func() float32 {
				if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - (*Nk_rect)(unsafe.Pointer(matrix)).X) / ((*Nk_rect)(unsafe.Pointer(matrix)).W - float32(1))) {
					return 1.0
				}
				return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - (*Nk_rect)(unsafe.Pointer(matrix)).X) / ((*Nk_rect)(unsafe.Pointer(matrix)).W - float32(1)))
			}()) {
				return func() float32 {
					if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - (*Nk_rect)(unsafe.Pointer(matrix)).X) / ((*Nk_rect)(unsafe.Pointer(matrix)).W - float32(1))) {
						return 1.0
					}
					return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X - (*Nk_rect)(unsafe.Pointer(matrix)).X) / ((*Nk_rect)(unsafe.Pointer(matrix)).W - float32(1)))
				}()
			}
			return float32(0)
		}()
		*(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 2*4)) = (1.0 - (func() float32 {
			if (float32(0)) < (func() float32 {
				if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(matrix)).Y) / ((*Nk_rect)(unsafe.Pointer(matrix)).H - float32(1))) {
					return 1.0
				}
				return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(matrix)).Y) / ((*Nk_rect)(unsafe.Pointer(matrix)).H - float32(1)))
			}()) {
				return func() float32 {
					if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(matrix)).Y) / ((*Nk_rect)(unsafe.Pointer(matrix)).H - float32(1))) {
						return 1.0
					}
					return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(matrix)).Y) / ((*Nk_rect)(unsafe.Pointer(matrix)).H - float32(1)))
				}()
			}
			return float32(0)
		}()))
		value_changed = AssignInt32(&hsv_changed, 1)
	}
	// hue bar
	if nk_button_behavior(state, *(*Nk_rect)(unsafe.Pointer(hue_bar)), in, NK_BUTTON_REPEATER) != 0 {
		*(*float32)(unsafe.Pointer(bp /* &hsva[0] */)) = func() float32 {
			if (float32(0)) < (func() float32 {
				if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(hue_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(hue_bar)).H - float32(1))) {
					return 1.0
				}
				return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(hue_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(hue_bar)).H - float32(1)))
			}()) {
				return func() float32 {
					if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(hue_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(hue_bar)).H - float32(1))) {
						return 1.0
					}
					return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(hue_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(hue_bar)).H - float32(1)))
				}()
			}
			return float32(0)
		}()
		value_changed = AssignInt32(&hsv_changed, 1)
	}
	// alpha bar
	if alpha_bar != 0 {
		if nk_button_behavior(state, *(*Nk_rect)(unsafe.Pointer(alpha_bar)), in, NK_BUTTON_REPEATER) != 0 {
			*(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 3*4)) = (1.0 - (func() float32 {
				if (float32(0)) < (func() float32 {
					if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(alpha_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(alpha_bar)).H - float32(1))) {
						return 1.0
					}
					return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(alpha_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(alpha_bar)).H - float32(1)))
				}()) {
					return func() float32 {
						if (1.0) < (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(alpha_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(alpha_bar)).H - float32(1))) {
							return 1.0
						}
						return (((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y - (*Nk_rect)(unsafe.Pointer(alpha_bar)).Y) / ((*Nk_rect)(unsafe.Pointer(alpha_bar)).H - float32(1)))
					}()
				}
				return float32(0)
			}()))
			value_changed = 1
		}
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state))) & NK_WIDGET_STATE_MODIFIED) != 0 {
		(*(*Nk_flags)(unsafe.Pointer(state))) = (Nk_flags(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED))
	} else {
		(*(*Nk_flags)(unsafe.Pointer(state))) = NK_WIDGET_STATE_INACTIVE
	}

	if hsv_changed != 0 {
		*(*Nk_colorf)(unsafe.Pointer(color)) = Xnk_hsva_colorfv(bp /* &hsva[0] */)
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
	}
	if value_changed != 0 {
		(*Nk_colorf)(unsafe.Pointer(color)).A = *(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 3*4))
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_ACTIVE
	}
	// set color picker widget state
	if Xnk_input_is_mouse_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(bounds))) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) = NK_WIDGET_STATE_HOVERED
	}
	if ((*(*Nk_flags)(unsafe.Pointer(state)) & NK_WIDGET_STATE_HOVER) != 0) && !(Xnk_input_is_mouse_prev_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(bounds))) != 0) {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_ENTERED)
	} else if Xnk_input_is_mouse_prev_hovering_rect(in, *(*Nk_rect)(unsafe.Pointer(bounds))) != 0 {
		*(*Nk_flags)(unsafe.Pointer(state)) |= (NK_WIDGET_STATE_LEFT)
	}
	return value_changed
}

var __func__378 = *(*[25]int8)(unsafe.Pointer(ts + 26967 /* "nk_color_picker_..." */)) /* nuklear.h:28026:1 */

func nk_draw_color_picker(o uintptr, matrix uintptr, hue_bar uintptr, alpha_bar uintptr, col Nk_colorf) { /* nuklear.h:28074:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var crosshair_size float32 = 7.0
	var temp Nk_color
	// var hsva [4]float32 at bp, 16

	var line_y float32
	var i int32

	if o != 0 {
	} else {
		X__assert_fail(ts+25237 /* "o" */, ts+2 /* "nuklear/nuklear...." */, uint32(28088), uintptr(unsafe.Pointer(&__func__379)))
	}
	if matrix != 0 {
	} else {
		X__assert_fail(ts+26946 /* "matrix" */, ts+2 /* "nuklear/nuklear...." */, uint32(28089), uintptr(unsafe.Pointer(&__func__379)))
	}
	if hue_bar != 0 {
	} else {
		X__assert_fail(ts+26953 /* "hue_bar" */, ts+2 /* "nuklear/nuklear...." */, uint32(28090), uintptr(unsafe.Pointer(&__func__379)))
	}

	// draw hue bar
	Xnk_colorf_hsva_fv(bp /* &hsva[0] */, col)
	for i = 0; i < 6; i++ {
		Xnk_fill_rect_multi_color(o,
			Xnk_rect((*Nk_rect)(unsafe.Pointer(hue_bar)).X, (((*Nk_rect)(unsafe.Pointer(hue_bar)).Y+(float32(i)*((*Nk_rect)(unsafe.Pointer(hue_bar)).H/6.0)))+0.5),
				(*Nk_rect)(unsafe.Pointer(hue_bar)).W, (((*Nk_rect)(unsafe.Pointer(hue_bar)).H/6.0)+0.5)), hue_colors[i], hue_colors[i],
			hue_colors[(i+1)], hue_colors[(i+1)])
	}
	line_y = float32((int32(((*Nk_rect)(unsafe.Pointer(hue_bar)).Y + (*(*float32)(unsafe.Pointer(bp /* &hsva[0] */)) * (*Nk_rect)(unsafe.Pointer(matrix)).H)) + 0.5)))
	Xnk_stroke_line(o, ((*Nk_rect)(unsafe.Pointer(hue_bar)).X - float32(1)), line_y, (((*Nk_rect)(unsafe.Pointer(hue_bar)).X + (*Nk_rect)(unsafe.Pointer(hue_bar)).W) + float32(2)),
		line_y, float32(1), Xnk_rgb(255, 255, 255))

	// draw alpha bar
	if alpha_bar != 0 {
		var alpha float32 = func() float32 {
			if (float32(0)) < (func() float32 {
				if (1.0) < (col.A) {
					return 1.0
				}
				return col.A
			}()) {
				return func() float32 {
					if (1.0) < (col.A) {
						return 1.0
					}
					return col.A
				}()
			}
			return float32(0)
		}()
		line_y = float32((int32(((*Nk_rect)(unsafe.Pointer(alpha_bar)).Y + ((1.0 - alpha) * (*Nk_rect)(unsafe.Pointer(matrix)).H)) + 0.5)))

		Xnk_fill_rect_multi_color(o, *(*Nk_rect)(unsafe.Pointer(alpha_bar)), white, white, black, black)
		Xnk_stroke_line(o, ((*Nk_rect)(unsafe.Pointer(alpha_bar)).X - float32(1)), line_y, (((*Nk_rect)(unsafe.Pointer(alpha_bar)).X + (*Nk_rect)(unsafe.Pointer(alpha_bar)).W) + float32(2)),
			line_y, float32(1), Xnk_rgb(255, 255, 255))
	}

	// draw color matrix
	temp = Xnk_hsv_f(*(*float32)(unsafe.Pointer(bp /* &hsva[0] */)), 1.0, 1.0)
	Xnk_fill_rect_multi_color(o, *(*Nk_rect)(unsafe.Pointer(matrix)), white, temp, temp, white)
	Xnk_fill_rect_multi_color(o, *(*Nk_rect)(unsafe.Pointer(matrix)), black_trans, black_trans, black, black)

	/* draw cross-hair */
	{
		var p Nk_vec2
		var S float32 = *(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 1*4))
		var V float32 = *(*float32)(unsafe.Pointer(bp /* &hsva[0] */ + 2*4))
		p.X = float32((int32((*Nk_rect)(unsafe.Pointer(matrix)).X + (S * (*Nk_rect)(unsafe.Pointer(matrix)).W))))
		p.Y = float32((int32((*Nk_rect)(unsafe.Pointer(matrix)).Y + ((1.0 - V) * (*Nk_rect)(unsafe.Pointer(matrix)).H))))
		Xnk_stroke_line(o, (p.X - crosshair_size), p.Y, (p.X - float32(2)), p.Y, 1.0, white)
		Xnk_stroke_line(o, ((p.X + crosshair_size) + float32(1)), p.Y, (p.X + float32(3)), p.Y, 1.0, white)
		Xnk_stroke_line(o, p.X, ((p.Y + crosshair_size) + float32(1)), p.X, (p.Y + float32(3)), 1.0, white)
		Xnk_stroke_line(o, p.X, (p.Y - crosshair_size), p.X, (p.Y - float32(2)), 1.0, white)
	}
}

var __func__379 = *(*[21]int8)(unsafe.Pointer(ts + 26992 /* "nk_draw_color_pi..." */))   /* nuklear.h:28077:1 */
var black = Nk_color{A: Nk_byte(255)}                                                    /* nuklear.h:28078:38 */
var white = Nk_color{R: Nk_byte(255), G: Nk_byte(255), B: Nk_byte(255), A: Nk_byte(255)} /* nuklear.h:28079:38 */
var black_trans = Nk_color{}                                                             /* nuklear.h:28080:38 */
var hue_colors = [7]Nk_color{
	Nk_color{R: Nk_byte(255), A: Nk_byte(255)}, Nk_color{R: Nk_byte(255), G: Nk_byte(255), A: Nk_byte(255)}, Nk_color{G: Nk_byte(255), A: Nk_byte(255)}, Nk_color{G: Nk_byte(255), B: Nk_byte(255), A: Nk_byte(255)},
	Nk_color{B: Nk_byte(255), A: Nk_byte(255)}, Nk_color{R: Nk_byte(255), B: Nk_byte(255), A: Nk_byte(255)}, Nk_color{R: Nk_byte(255), A: Nk_byte(255)},
} /* nuklear.h:28095:41 */

func nk_do_color_picker(state uintptr, out uintptr, col uintptr, fmt uint32, bounds Nk_rect, padding Nk_vec2, in uintptr, font uintptr) Nk_bool { /* nuklear.h:28133:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)
	*(*Nk_rect)(unsafe.Pointer(bp)) = bounds

	var ret int32 = 0
	// var matrix Nk_rect at bp+16, 16

	// var hue_bar Nk_rect at bp+32, 16

	// var alpha_bar Nk_rect at bp+48, 16

	var bar_w float32

	if out != 0 {
	} else {
		X__assert_fail(ts+25416 /* "out" */, ts+2 /* "nuklear/nuklear...." */, uint32(28145), uintptr(unsafe.Pointer(&__func__380)))
	}
	if col != 0 {
	} else {
		X__assert_fail(ts+27013 /* "col" */, ts+2 /* "nuklear/nuklear...." */, uint32(28146), uintptr(unsafe.Pointer(&__func__380)))
	}
	if state != 0 {
	} else {
		X__assert_fail(ts+25410 /* "state" */, ts+2 /* "nuklear/nuklear...." */, uint32(28147), uintptr(unsafe.Pointer(&__func__380)))
	}
	if font != 0 {
	} else {
		X__assert_fail(ts+1452 /* "font" */, ts+2 /* "nuklear/nuklear...." */, uint32(28148), uintptr(unsafe.Pointer(&__func__380)))
	}
	if ((!(out != 0) || !(col != 0)) || !(state != 0)) || !(font != 0) {
		return ret
	}

	bar_w = (*Nk_user_font)(unsafe.Pointer(font)).Height
	*(*float32)(unsafe.Pointer(bp /* &bounds */ /* &.x */)) += (padding.X)
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 4 /* &.y */)) += (padding.X)
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 8 /* &.w */)) -= (float32(2) * padding.X)
	*(*float32)(unsafe.Pointer(bp /* &bounds */ + 12 /* &.h */)) -= (float32(2) * padding.Y)

	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).X = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).X
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).Y = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).H = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).H
	(*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).W - ((float32(3) * padding.X) + (float32(2) * bar_w)))

	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &hue_bar */)).W = bar_w
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &hue_bar */)).Y = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &hue_bar */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).H
	(*Nk_rect)(unsafe.Pointer(bp + 32 /* &hue_bar */)).X = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &matrix */)).X + (*Nk_rect)(unsafe.Pointer(bp+16 /* &matrix */)).W) + padding.X)

	(*Nk_rect)(unsafe.Pointer(bp + 48 /* &alpha_bar */)).X = (((*Nk_rect)(unsafe.Pointer(bp+32 /* &hue_bar */)).X + (*Nk_rect)(unsafe.Pointer(bp+32 /* &hue_bar */)).W) + padding.X)
	(*Nk_rect)(unsafe.Pointer(bp + 48 /* &alpha_bar */)).Y = (*Nk_rect)(unsafe.Pointer(bp /* &bounds */)).Y
	(*Nk_rect)(unsafe.Pointer(bp + 48 /* &alpha_bar */)).W = bar_w
	(*Nk_rect)(unsafe.Pointer(bp + 48 /* &alpha_bar */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &matrix */)).H

	ret = nk_color_picker_behavior(state, bp /* &bounds */, bp+16 /* &matrix */, bp+32, /* &hue_bar */
		func() uintptr {
			if int32(fmt) == NK_RGBA {
				return bp + 48 /* &alpha_bar */
			}
			return uintptr(0)
		}(), col, in)
	nk_draw_color_picker(out, bp+16 /* &matrix */, bp+32 /* &hue_bar */, func() uintptr {
		if int32(fmt) == NK_RGBA {
			return bp + 48 /* &alpha_bar */
		}
		return uintptr(0)
	}(), *(*Nk_colorf)(unsafe.Pointer(col)))
	return ret
}

var __func__380 = *(*[19]int8)(unsafe.Pointer(ts + 27017 /* "nk_do_color_pick..." */)) /* nuklear.h:28138:1 */

func Xnk_color_pick(ctx uintptr, color uintptr, fmt uint32) Nk_bool { /* nuklear.h:28179:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)

	var win uintptr
	var layout uintptr
	var config uintptr
	var in uintptr
	var state uint32
	// var bounds Nk_rect at bp, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28190), uintptr(unsafe.Pointer(&__func__381)))
	}
	if color != 0 {
	} else {
		X__assert_fail(ts+26961 /* "color" */, ts+2 /* "nuklear/nuklear...." */, uint32(28191), uintptr(unsafe.Pointer(&__func__381)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28192), uintptr(unsafe.Pointer(&__func__381)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28193), uintptr(unsafe.Pointer(&__func__381)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(color != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	config = (ctx + 360 /* &.style */)
	layout = (*Nk_window)(unsafe.Pointer(win)).Layout
	state = Xnk_widget(bp /* &bounds */, ctx)
	if !(state != 0) {
		return 0
	}
	if (int32(state) == NK_WIDGET_ROM) || (((*Nk_panel)(unsafe.Pointer(layout)).Flags & NK_WINDOW_ROM) != 0) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	return nk_do_color_picker((ctx + 5820 /* &.last_widget_state */), (win + 100 /* &.buffer */), color, fmt, *(*Nk_rect)(unsafe.Pointer(bp /* bounds */)),
		Xnk_vec2(float32(0), float32(0)), in, (*Nk_style)(unsafe.Pointer(config)).Font)
}

var __func__381 = *(*[14]int8)(unsafe.Pointer(ts + 27036 /* "nk_color_pick" */)) /* nuklear.h:28181:1 */

func Xnk_color_picker(ctx uintptr, color Nk_colorf, fmt uint32) Nk_colorf { /* nuklear.h:28207:1: */
	bp := tlsAlloc(16)
	defer tlsFree(16)
	*(*Nk_colorf)(unsafe.Pointer(bp)) = color

	Xnk_color_pick(ctx, bp /* &color */, fmt)
	return *(*Nk_colorf)(unsafe.Pointer(bp /* color */))
}

// ==============================================================
//
//                          COMBO
//
// ===============================================================
func nk_combo_begin(ctx uintptr, win uintptr, size Nk_vec2, is_clicked Nk_bool, header Nk_rect) Nk_bool { /* nuklear.h:28224:1: */
	var popup uintptr
	var is_open int32 = 0
	var is_active int32 = 0
	var body Nk_rect
	var hash Nk_hash

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28233), uintptr(unsafe.Pointer(&__func__382)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28234), uintptr(unsafe.Pointer(&__func__382)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28235), uintptr(unsafe.Pointer(&__func__382)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	popup = (*Nk_window)(unsafe.Pointer(win)).Popup.Win
	body.X = header.X
	body.W = size.X
	body.Y = ((header.Y + header.H) - (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Combo_border)
	body.H = size.Y

	hash = PostIncUint32(&(*Nk_window)(unsafe.Pointer(win)).Popup.Combo_count, 1)
	if popup != 0 {
		is_open = Nk_true
	} else {
		is_open = Nk_false
	}
	is_active = (Bool32(((popup != 0) && ((*Nk_window)(unsafe.Pointer(win)).Popup.Name == hash)) && (int32((*Nk_window)(unsafe.Pointer(win)).Popup.Type) == NK_PANEL_COMBO)))
	if ((((is_clicked != 0) && (is_open != 0)) && !(is_active != 0)) || ((is_open != 0) && !(is_active != 0))) || ((!(is_open != 0) && !(is_active != 0)) && !(is_clicked != 0)) {
		return 0
	}
	if !(nk_nonblock_begin(ctx, uint32(0), body,
		func() Nk_rect {
			if (is_clicked != 0) && (is_open != 0) {
				return Xnk_rect(float32(0), float32(0), float32(0), float32(0))
			}
			return header
		}(), NK_PANEL_COMBO) != 0) {
		return 0
	}

	(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_COMBO
	(*Nk_window)(unsafe.Pointer(win)).Popup.Name = hash
	return 1
}

var __func__382 = *(*[15]int8)(unsafe.Pointer(ts + 27050 /* "nk_combo_begin" */)) /* nuklear.h:28226:1 */

func Xnk_combo_begin_text(ctx uintptr, selected uintptr, len int32, size Nk_vec2) Nk_bool { /* nuklear.h:28258:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)

	var in uintptr
	var win uintptr
	var style uintptr
	var s uint32
	var is_clicked int32 = Nk_false
	// var header Nk_rect at bp, 16

	var background uintptr
	// var text Nk_text at bp+16, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28271), uintptr(unsafe.Pointer(&__func__383)))
	}
	if selected != 0 {
	} else {
		X__assert_fail(ts+27065 /* "selected" */, ts+2 /* "nuklear/nuklear...." */, uint32(28272), uintptr(unsafe.Pointer(&__func__383)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28273), uintptr(unsafe.Pointer(&__func__383)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28274), uintptr(unsafe.Pointer(&__func__383)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(selected != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if int32(s) == NK_WIDGET_INVALID {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_active
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_hover
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_normal
	}
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		// print currently selected text item
		var label Nk_rect
		// var button Nk_rect at bp+32, 16

		// var content Nk_rect at bp+48, 16

		var draw_button_symbol int32
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// represents whether or not the combo's button symbol should be drawn
		draw_button_symbol = (Bool32(int32(sym) != NK_SYMBOL_NONE))

		// calculate button
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &button */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &button */)).X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &button */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &button */)).H = (*Nk_rect)(unsafe.Pointer(bp + 32 /* &button */)).W

		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).X = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &button */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &button */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).W = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &button */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).H = ((*Nk_rect)(unsafe.Pointer(bp+32 /* &button */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))

		// draw selected label
		(*Nk_text)(unsafe.Pointer(bp + 16 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
		label.X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		label.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		label.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		if draw_button_symbol != 0 {
			label.W = (((*Nk_rect)(unsafe.Pointer(bp+32 /* &button */)).X - ((*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X + (*Nk_style)(unsafe.Pointer(style)).Combo.Spacing.X)) - label.X)
		} else {
			label.W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X))
		}
		nk_widget_text((win + 100 /* &.buffer */), label, selected, len, bp+16, /* &text */
			NK_TEXT_LEFT, (*Nk_context)(unsafe.Pointer(ctx)).Style.Font)

		// draw open/close button
		if draw_button_symbol != 0 {
			nk_draw_button_symbol((win + 100 /* &.buffer */), bp+32 /* &button */, bp+48 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
				(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)
		}

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__383 = *(*[20]int8)(unsafe.Pointer(ts + 27074 /* "nk_combo_begin_t..." */)) /* nuklear.h:28260:1 */

func Xnk_combo_begin_label(ctx uintptr, selected uintptr, size Nk_vec2) Nk_bool { /* nuklear.h:28356:1: */
	return Xnk_combo_begin_text(ctx, selected, Xnk_strlen(selected), size)
}

func Xnk_combo_begin_color(ctx uintptr, color Nk_color, size Nk_vec2) Nk_bool { /* nuklear.h:28361:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	var win uintptr
	var style uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var s uint32
	var background uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28372), uintptr(unsafe.Pointer(&__func__384)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28373), uintptr(unsafe.Pointer(&__func__384)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28374), uintptr(unsafe.Pointer(&__func__384)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if int32(s) == NK_WIDGET_INVALID {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
	}

	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		// var content Nk_rect at bp+32, 16

		// var button Nk_rect at bp+16, 16

		var bounds Nk_rect
		var draw_button_symbol int32
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// represents whether or not the combo's button symbol should be drawn
		draw_button_symbol = (Bool32(int32(sym) != NK_SYMBOL_NONE))

		// calculate button
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W

		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))

		// draw color
		bounds.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(4) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		bounds.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		bounds.X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X))
		if draw_button_symbol != 0 {
			bounds.W = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X - ((*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X + (*Nk_style)(unsafe.Pointer(style)).Combo.Spacing.X)) - bounds.X)
		} else {
			bounds.W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (float32(4) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X))
		}
		Xnk_fill_rect((win + 100 /* &.buffer */), bounds, float32(0), color)

		// draw open/close button
		if draw_button_symbol != 0 {
			nk_draw_button_symbol((win + 100 /* &.buffer */), bp+16 /* &button */, bp+32 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
				(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)
		}

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__384 = *(*[21]int8)(unsafe.Pointer(ts + 27094 /* "nk_combo_begin_c..." */)) /* nuklear.h:28362:1 */

func Xnk_combo_begin_symbol(ctx uintptr, symbol uint32, size Nk_vec2) Nk_bool { /* nuklear.h:28446:1: */
	bp := tlsAlloc(48)
	defer tlsFree(48)

	var win uintptr
	var style uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var s uint32
	var background uintptr
	var sym_background Nk_color
	var symbol_color Nk_color

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28459), uintptr(unsafe.Pointer(&__func__385)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28460), uintptr(unsafe.Pointer(&__func__385)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28461), uintptr(unsafe.Pointer(&__func__385)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if int32(s) == NK_WIDGET_INVALID {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_active
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_hover
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_hover
	}

	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		sym_background = Xnk_rgba(0, 0, 0, 0)
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		sym_background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		*(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)) = Nk_rect{}
		// var content Nk_rect at bp+32, 16

		var button Nk_rect
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// calculate button
		button.W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		button.X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		button.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		button.H = button.W

		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).X = (button.X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).Y = (button.Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).W = (button.W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).H = (button.H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))

		// draw symbol
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &bounds */)).H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &bounds */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &bounds */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &bounds */)).W = ((button.X - (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y) - (*Nk_rect)(unsafe.Pointer(bp+16 /* &bounds */)).X)
		nk_draw_symbol((win + 100 /* &.buffer */), symbol, *(*Nk_rect)(unsafe.Pointer(bp + 16 /* bounds */)), sym_background, symbol_color,
			1.0, (*Nk_style)(unsafe.Pointer(style)).Font)

		// draw open/close button
		nk_draw_button_symbol((win + 100 /* &.buffer */), bp+16 /* &bounds */, bp+32 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
			(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__385 = *(*[22]int8)(unsafe.Pointer(ts + 27115 /* "nk_combo_begin_s..." */)) /* nuklear.h:28447:1 */

func Xnk_combo_begin_symbol_text(ctx uintptr, selected uintptr, len int32, symbol uint32, size Nk_vec2) Nk_bool { /* nuklear.h:28533:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)

	var win uintptr
	var style uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var s uint32
	var background uintptr
	var symbol_color Nk_color
	// var text Nk_text at bp+48, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28547), uintptr(unsafe.Pointer(&__func__386)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28548), uintptr(unsafe.Pointer(&__func__386)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28549), uintptr(unsafe.Pointer(&__func__386)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if !(s != 0) {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_active
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_active
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_hover
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_hover
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
		symbol_color = (*Nk_style)(unsafe.Pointer(style)).Combo.Symbol_normal
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_normal
	}
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		// var content Nk_rect at bp+32, 16

		// var button Nk_rect at bp+16, 16

		var label Nk_rect
		var image Nk_rect
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// calculate button
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W

		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))
		nk_draw_button_symbol((win + 100 /* &.buffer */), bp+16 /* &button */, bp+32 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
			(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)

		// draw symbol
		image.X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		image.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		image.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		image.W = image.H
		nk_draw_symbol((win + 100 /* &.buffer */), symbol, image, (*Nk_text)(unsafe.Pointer(bp+48 /* &text */)).Background, symbol_color,
			1.0, (*Nk_style)(unsafe.Pointer(style)).Font)

		// draw label
		(*Nk_text)(unsafe.Pointer(bp + 48 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
		label.X = (((image.X + image.W) + (*Nk_style)(unsafe.Pointer(style)).Combo.Spacing.X) + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		label.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		label.W = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X - (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X) - label.X)
		label.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		nk_widget_text((win + 100 /* &.buffer */), label, selected, len, bp+48 /* &text */, NK_TEXT_LEFT, (*Nk_style)(unsafe.Pointer(style)).Font)

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__386 = *(*[27]int8)(unsafe.Pointer(ts + 27137 /* "nk_combo_begin_s..." */)) /* nuklear.h:28535:1 */

func Xnk_combo_begin_image(ctx uintptr, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:28629:1: */
	bp := tlsAlloc(64)
	defer tlsFree(64)
	*(*Nk_image)(unsafe.Pointer(bp + 16)) = img

	var win uintptr
	var style uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var s uint32
	var background uintptr

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28640), uintptr(unsafe.Pointer(&__func__387)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28641), uintptr(unsafe.Pointer(&__func__387)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28642), uintptr(unsafe.Pointer(&__func__387)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if int32(s) == NK_WIDGET_INVALID {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
	}

	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		*(*Nk_rect)(unsafe.Pointer(bp + 32 /* bounds */)) = Nk_rect{}
		// var content Nk_rect at bp+48, 16

		var button Nk_rect
		var draw_button_symbol int32
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// represents whether or not the combo's button symbol should be drawn
		draw_button_symbol = (Bool32(int32(sym) != NK_SYMBOL_NONE))

		// calculate button
		button.W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		button.X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		button.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		button.H = button.W

		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).X = (button.X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).Y = (button.Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).W = (button.W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 48 /* &content */)).H = (button.H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))

		// draw image
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &bounds */)).H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &bounds */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &bounds */)).X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		if draw_button_symbol != 0 {
			(*Nk_rect)(unsafe.Pointer(bp + 32 /* &bounds */)).W = ((button.X - (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y) - (*Nk_rect)(unsafe.Pointer(bp+32 /* &bounds */)).X)
		} else {
			(*Nk_rect)(unsafe.Pointer(bp + 32 /* &bounds */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X))
		}
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp + 32 /* bounds */)), bp+16 /* &img */, nk_white)

		// draw open/close button
		if draw_button_symbol != 0 {
			nk_draw_button_symbol((win + 100 /* &.buffer */), bp+32 /* &bounds */, bp+48 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
				(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)
		}

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__387 = *(*[21]int8)(unsafe.Pointer(ts + 27164 /* "nk_combo_begin_i..." */)) /* nuklear.h:28630:1 */

func Xnk_combo_begin_image_text(ctx uintptr, selected uintptr, len int32, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:28714:1: */
	bp := tlsAlloc(80)
	defer tlsFree(80)
	*(*Nk_image)(unsafe.Pointer(bp + 48)) = img

	var win uintptr
	var style uintptr
	var in uintptr
	// var header Nk_rect at bp, 16

	var is_clicked int32 = Nk_false
	var s uint32
	var background uintptr
	// var text Nk_text at bp+64, 16

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28727), uintptr(unsafe.Pointer(&__func__388)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28728), uintptr(unsafe.Pointer(&__func__388)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28729), uintptr(unsafe.Pointer(&__func__388)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	style = (ctx + 360 /* &.style */)
	s = Xnk_widget(bp /* &header */, ctx)
	if !(s != 0) {
		return 0
	}

	if (((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Flags & NK_WINDOW_ROM) != 0) || (int32(s) == NK_WIDGET_ROM) {
		in = uintptr(0)
	} else {
		in = (ctx /* &.input */)
	}
	if nk_button_behavior((ctx+5820 /* &.last_widget_state */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), in, NK_BUTTON_DEFAULT) != 0 {
		is_clicked = Nk_true
	}

	// draw combo box header background and border
	if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_ACTIVED) != 0 {
		background = (style + 4572 /* &.combo */ + 40 /* &.active */)
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_active
	} else if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
		background = (style + 4572 /* &.combo */ + 20 /* &.hover */)
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_hover
	} else {
		background = (style + 4572 /* &.combo */ /* &.normal */)
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Text = (*Nk_style)(unsafe.Pointer(style)).Combo.Label_normal
	}
	if int32((*Nk_style_item)(unsafe.Pointer(background)).Type) == NK_STYLE_ITEM_IMAGE {
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Background = Xnk_rgba(0, 0, 0, 0)
		Xnk_draw_image((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (background + 4 /* &.data */ /* &.image */), nk_white)
	} else {
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Background = *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */))
		Xnk_fill_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, *(*Nk_color)(unsafe.Pointer(background + 4 /* &.data */)))
		Xnk_stroke_rect((win + 100 /* &.buffer */), *(*Nk_rect)(unsafe.Pointer(bp /* header */)), (*Nk_style)(unsafe.Pointer(style)).Combo.Rounding, (*Nk_style)(unsafe.Pointer(style)).Combo.Border, (*Nk_style)(unsafe.Pointer(style)).Combo.Border_color)
	}
	{
		// var content Nk_rect at bp+32, 16

		// var button Nk_rect at bp+16, 16

		var label Nk_rect
		var image Nk_rect
		var draw_button_symbol int32
		var sym uint32
		if ((*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state & NK_WIDGET_STATE_HOVER) != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_hover
		} else if is_clicked != 0 {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_active
		} else {
			sym = (*Nk_style)(unsafe.Pointer(style)).Combo.Sym_normal
		}

		// represents whether or not the combo's button symbol should be drawn
		draw_button_symbol = (Bool32(int32(sym) != NK_SYMBOL_NONE))

		// calculate button
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y))
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).X = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_rect)(unsafe.Pointer(bp /* &header */)).H) - (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button_padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).H = (*Nk_rect)(unsafe.Pointer(bp + 16 /* &button */)).W

		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).X = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).Y = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y)
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).W = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).W - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.X))
		(*Nk_rect)(unsafe.Pointer(bp + 32 /* &content */)).H = ((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Button.Padding.Y))
		if draw_button_symbol != 0 {
			nk_draw_button_symbol((win + 100 /* &.buffer */), bp+16 /* &button */, bp+32 /* &content */, (*Nk_context)(unsafe.Pointer(ctx)).Last_widget_state,
				(ctx + 360 /* &.style */ + 4572 /* &.combo */ + 88 /* &.button */), sym, (*Nk_style)(unsafe.Pointer(style)).Font)
		}

		// draw image
		image.X = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		image.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		image.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		image.W = image.H
		Xnk_draw_image((win + 100 /* &.buffer */), image, bp+48 /* &img */, nk_white)

		// draw label
		(*Nk_text)(unsafe.Pointer(bp + 64 /* &text */)).Padding = Xnk_vec2(float32(0), float32(0))
		label.X = (((image.X + image.W) + (*Nk_style)(unsafe.Pointer(style)).Combo.Spacing.X) + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X)
		label.Y = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).Y + (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y)
		label.H = ((*Nk_rect)(unsafe.Pointer(bp /* &header */)).H - (float32(2) * (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.Y))
		if draw_button_symbol != 0 {
			label.W = (((*Nk_rect)(unsafe.Pointer(bp+16 /* &button */)).X - (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X) - label.X)
		} else {
			label.W = ((((*Nk_rect)(unsafe.Pointer(bp /* &header */)).X + (*Nk_rect)(unsafe.Pointer(bp /* &header */)).W) - (*Nk_style)(unsafe.Pointer(style)).Combo.Content_padding.X) - label.X)
		}
		nk_widget_text((win + 100 /* &.buffer */), label, selected, len, bp+64 /* &text */, NK_TEXT_LEFT, (*Nk_style)(unsafe.Pointer(style)).Font)

	}
	return nk_combo_begin(ctx, win, size, is_clicked, *(*Nk_rect)(unsafe.Pointer(bp /* header */)))
}

var __func__388 = *(*[26]int8)(unsafe.Pointer(ts + 27185 /* "nk_combo_begin_i..." */)) /* nuklear.h:28716:1 */

func Xnk_combo_begin_symbol_label(ctx uintptr, selected uintptr, type1 uint32, size Nk_vec2) Nk_bool { /* nuklear.h:28813:1: */
	return Xnk_combo_begin_symbol_text(ctx, selected, Xnk_strlen(selected), type1, size)
}

func Xnk_combo_begin_image_label(ctx uintptr, selected uintptr, img Nk_image, size Nk_vec2) Nk_bool { /* nuklear.h:28819:1: */
	return Xnk_combo_begin_image_text(ctx, selected, Xnk_strlen(selected), img, size)
}

func Xnk_combo_item_text(ctx uintptr, text uintptr, len int32, align Nk_flags) Nk_bool { /* nuklear.h:28825:1: */
	return Xnk_contextual_item_text(ctx, text, len, align)
}

func Xnk_combo_item_label(ctx uintptr, label uintptr, align Nk_flags) Nk_bool { /* nuklear.h:28830:1: */
	return Xnk_contextual_item_label(ctx, label, align)
}

func Xnk_combo_item_image_text(ctx uintptr, img Nk_image, text uintptr, len int32, alignment Nk_flags) Nk_bool { /* nuklear.h:28835:1: */
	return Xnk_contextual_item_image_text(ctx, img, text, len, alignment)
}

func Xnk_combo_item_image_label(ctx uintptr, img Nk_image, text uintptr, alignment Nk_flags) Nk_bool { /* nuklear.h:28841:1: */
	return Xnk_contextual_item_image_label(ctx, img, text, alignment)
}

func Xnk_combo_item_symbol_text(ctx uintptr, sym uint32, text uintptr, len int32, alignment Nk_flags) Nk_bool { /* nuklear.h:28847:1: */
	return Xnk_contextual_item_symbol_text(ctx, sym, text, len, alignment)
}

func Xnk_combo_item_symbol_label(ctx uintptr, sym uint32, label uintptr, alignment Nk_flags) Nk_bool { /* nuklear.h:28853:1: */
	return Xnk_contextual_item_symbol_label(ctx, sym, label, alignment)
}

func Xnk_combo_end(ctx uintptr) { /* nuklear.h:28858:13: */
	Xnk_contextual_end(ctx)
}

func Xnk_combo_close(ctx uintptr) { /* nuklear.h:28862:13: */
	Xnk_contextual_close(ctx)
}

func Xnk_combo(ctx uintptr, items uintptr, count int32, selected int32, item_height int32, size Nk_vec2) int32 { /* nuklear.h:28867:1: */
	var i int32 = 0
	var max_height int32
	var item_spacing Nk_vec2
	var window_padding Nk_vec2

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28875), uintptr(unsafe.Pointer(&__func__389)))
	}
	if items != 0 {
	} else {
		X__assert_fail(ts+27211 /* "items" */, ts+2 /* "nuklear/nuklear...." */, uint32(28876), uintptr(unsafe.Pointer(&__func__389)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(28877), uintptr(unsafe.Pointer(&__func__389)))
	}
	if (!(ctx != 0) || !(items != 0)) || !(count != 0) {
		return selected
	}

	item_spacing = (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Spacing
	window_padding = nk_panel_get_padding((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Type)
	max_height = ((count * item_height) + (count * int32(item_spacing.Y)))
	max_height = max_height + ((int32(item_spacing.Y) * 2) + (int32(window_padding.Y) * 2))
	size.Y = func() float32 {
		if (size.Y) < (float32(max_height)) {
			return size.Y
		}
		return float32(max_height)
	}()
	if Xnk_combo_begin_label(ctx, *(*uintptr)(unsafe.Pointer(items + uintptr(selected)*4)), size) != 0 {
		Xnk_layout_row_dynamic(ctx, float32(item_height), 1)
		for i = 0; i < count; i++ {
			if Xnk_combo_item_label(ctx, *(*uintptr)(unsafe.Pointer(items + uintptr(i)*4)), NK_TEXT_LEFT) != 0 {
				selected = i
			}
		}
		Xnk_combo_end(ctx)
	}
	return selected
}

var __func__389 = *(*[9]int8)(unsafe.Pointer(ts + 27217 /* "nk_combo" */)) /* nuklear.h:28869:1 */

func Xnk_combo_separator(ctx uintptr, items_separated_by_separator uintptr, separator int32, selected int32, count int32, item_height int32, size Nk_vec2) int32 { /* nuklear.h:28897:1: */
	var i int32
	var max_height int32
	var item_spacing Nk_vec2
	var window_padding Nk_vec2
	var current_item uintptr
	var iter uintptr
	var length int32 = 0

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28908), uintptr(unsafe.Pointer(&__func__390)))
	}
	if items_separated_by_separator != 0 {
	} else {
		X__assert_fail(ts+27226 /* "items_separated_..." */, ts+2 /* "nuklear/nuklear...." */, uint32(28909), uintptr(unsafe.Pointer(&__func__390)))
	}
	if !(ctx != 0) || !(items_separated_by_separator != 0) {
		return selected
	}

	// calculate popup window
	item_spacing = (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Spacing
	window_padding = nk_panel_get_padding((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Type)
	max_height = ((count * item_height) + (count * int32(item_spacing.Y)))
	max_height = max_height + ((int32(item_spacing.Y) * 2) + (int32(window_padding.Y) * 2))
	size.Y = func() float32 {
		if (size.Y) < (float32(max_height)) {
			return size.Y
		}
		return float32(max_height)
	}()

	// find selected item
	current_item = items_separated_by_separator
	for i = 0; i < count; i++ {
		iter = current_item
		for (*(*int8)(unsafe.Pointer(iter)) != 0) && (int32(*(*int8)(unsafe.Pointer(iter))) != separator) {
			iter++
		}
		length = (int32((int32(iter) - int32(current_item)) / 1))
		if i == selected {
			break
		}
		current_item = (iter + uintptr(1))
	}

	if Xnk_combo_begin_text(ctx, current_item, length, size) != 0 {
		current_item = items_separated_by_separator
		Xnk_layout_row_dynamic(ctx, float32(item_height), 1)
		for i = 0; i < count; i++ {
			iter = current_item
			for (*(*int8)(unsafe.Pointer(iter)) != 0) && (int32(*(*int8)(unsafe.Pointer(iter))) != separator) {
				iter++
			}
			length = (int32((int32(iter) - int32(current_item)) / 1))
			if Xnk_combo_item_text(ctx, current_item, length, NK_TEXT_LEFT) != 0 {
				selected = i
			}
			current_item = ((current_item + uintptr(length)) + uintptr(1))
		}
		Xnk_combo_end(ctx)
	}
	return selected
}

var __func__390 = *(*[19]int8)(unsafe.Pointer(ts + 27255 /* "nk_combo_separat..." */)) /* nuklear.h:28899:1 */

func Xnk_combo_string(ctx uintptr, items_separated_by_zeros uintptr, selected int32, count int32, item_height int32, size Nk_vec2) int32 { /* nuklear.h:28946:1: */
	return Xnk_combo_separator(ctx, items_separated_by_zeros, 0, selected, count, item_height, size)
}

func Xnk_combo_callback(ctx uintptr, item_getter uintptr, userdata uintptr, selected int32, count int32, item_height int32, size Nk_vec2) int32 { /* nuklear.h:28952:1: */
	bp := tlsAlloc(4)
	defer tlsFree(4)

	var i int32
	var max_height int32
	var item_spacing Nk_vec2
	var window_padding Nk_vec2
	// var item uintptr at bp, 4

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(28961), uintptr(unsafe.Pointer(&__func__391)))
	}
	if item_getter != 0 {
	} else {
		X__assert_fail(ts+27274 /* "item_getter" */, ts+2 /* "nuklear/nuklear...." */, uint32(28962), uintptr(unsafe.Pointer(&__func__391)))
	}
	if !(ctx != 0) || !(item_getter != 0) {
		return selected
	}

	// calculate popup window
	item_spacing = (*Nk_context)(unsafe.Pointer(ctx)).Style.Window.Spacing
	window_padding = nk_panel_get_padding((ctx + 360 /* &.style */), (*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Type)
	max_height = ((count * item_height) + (count * int32(item_spacing.Y)))
	max_height = max_height + ((int32(item_spacing.Y) * 2) + (int32(window_padding.Y) * 2))
	size.Y = func() float32 {
		if (size.Y) < (float32(max_height)) {
			return size.Y
		}
		return float32(max_height)
	}()

	(*(*func(uintptr, int32, uintptr))(unsafe.Pointer(&item_getter)))(userdata, selected, bp /* &item */)
	if Xnk_combo_begin_label(ctx, *(*uintptr)(unsafe.Pointer(bp /* item */)), size) != 0 {
		Xnk_layout_row_dynamic(ctx, float32(item_height), 1)
		for i = 0; i < count; i++ {
			(*(*func(uintptr, int32, uintptr))(unsafe.Pointer(&item_getter)))(userdata, i, bp /* &item */)
			if Xnk_combo_item_label(ctx, *(*uintptr)(unsafe.Pointer(bp /* item */)), NK_TEXT_LEFT) != 0 {
				selected = i
			}
		}
		Xnk_combo_end(ctx)
	}
	return selected
}

var __func__391 = *(*[18]int8)(unsafe.Pointer(ts + 27286 /* "nk_combo_callbac..." */)) /* nuklear.h:28954:1 */

func Xnk_combobox(ctx uintptr, items uintptr, count int32, selected uintptr, item_height int32, size Nk_vec2) { /* nuklear.h:28985:1: */
	*(*int32)(unsafe.Pointer(selected)) = Xnk_combo(ctx, items, count, *(*int32)(unsafe.Pointer(selected)), item_height, size)
}

func Xnk_combobox_string(ctx uintptr, items_separated_by_zeros uintptr, selected uintptr, count int32, item_height int32, size Nk_vec2) { /* nuklear.h:28991:1: */
	*(*int32)(unsafe.Pointer(selected)) = Xnk_combo_string(ctx, items_separated_by_zeros, *(*int32)(unsafe.Pointer(selected)), count, item_height, size)
}

func Xnk_combobox_separator(ctx uintptr, items_separated_by_separator uintptr, separator int32, selected uintptr, count int32, item_height int32, size Nk_vec2) { /* nuklear.h:28997:1: */
	*(*int32)(unsafe.Pointer(selected)) = Xnk_combo_separator(ctx, items_separated_by_separator, separator,
		*(*int32)(unsafe.Pointer(selected)), count, item_height, size)
}

func Xnk_combobox_callback(ctx uintptr, item_getter uintptr, userdata uintptr, selected uintptr, count int32, item_height int32, size Nk_vec2) { /* nuklear.h:29004:1: */
	*(*int32)(unsafe.Pointer(selected)) = Xnk_combo_callback(ctx, item_getter, userdata, *(*int32)(unsafe.Pointer(selected)), count, item_height, size)
}

// ===============================================================
//
//                              TOOLTIP
//
// ===============================================================
func Xnk_tooltip_begin(ctx uintptr, width float32) Nk_bool { /* nuklear.h:29021:1: */
	var x int32
	var y int32
	var w int32
	var h int32
	var win uintptr
	var in uintptr
	var bounds Nk_rect
	var ret int32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(29029), uintptr(unsafe.Pointer(&__func__392)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(29030), uintptr(unsafe.Pointer(&__func__392)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(29031), uintptr(unsafe.Pointer(&__func__392)))
	}
	if (!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0) {
		return 0
	}

	// make sure that no nonblocking popup is currently active
	win = (*Nk_context)(unsafe.Pointer(ctx)).Current
	in = (ctx /* &.input */)
	if ((*Nk_window)(unsafe.Pointer(win)).Popup.Win != 0) && ((int32((*Nk_window)(unsafe.Pointer(win)).Popup.Type) & NK_PANEL_SET_NONBLOCK) != 0) {
		return 0
	}

	w = nk_iceilf(width)
	h = nk_iceilf(nk_null_rect.H)
	x = (nk_ifloorf(((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.X + float32(1))) - int32((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Clip.X))
	y = (nk_ifloorf(((*Nk_input)(unsafe.Pointer(in)).Mouse.Pos.Y + float32(1))) - int32((*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout)).Clip.Y))

	bounds.X = float32(x)
	bounds.Y = float32(y)
	bounds.W = float32(w)
	bounds.H = float32(h)

	ret = Xnk_popup_begin(ctx, NK_POPUP_DYNAMIC,
		ts+27304 /* "__##Tooltip##__" */, (uint32(NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BORDER)), bounds)
	if ret != 0 {
		*(*Nk_flags)(unsafe.Pointer((*Nk_window)(unsafe.Pointer(win)).Layout + 4 /* &.flags */)) &= (CplUint32(NK_WINDOW_ROM))
	}
	(*Nk_window)(unsafe.Pointer(win)).Popup.Type = NK_PANEL_TOOLTIP
	(*Nk_panel)(unsafe.Pointer((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout)).Type = NK_PANEL_TOOLTIP
	return ret
}

var __func__392 = *(*[17]int8)(unsafe.Pointer(ts + 27320 /* "nk_tooltip_begin" */)) /* nuklear.h:29022:1 */

func Xnk_tooltip_end(ctx uintptr) { /* nuklear.h:29060:1: */
	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(29062), uintptr(unsafe.Pointer(&__func__393)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(29063), uintptr(unsafe.Pointer(&__func__393)))
	}
	if !(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0) {
		return
	}
	(*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Seq--
	Xnk_popup_close(ctx)
	Xnk_popup_end(ctx)
}

var __func__393 = *(*[15]int8)(unsafe.Pointer(ts + 27337 /* "nk_tooltip_end" */)) /* nuklear.h:29061:1 */

func Xnk_tooltip(ctx uintptr, text uintptr) { /* nuklear.h:29070:1: */
	var style uintptr
	var padding Nk_vec2
	var text_len int32
	var text_width float32
	var text_height float32

	if ctx != 0 {
	} else {
		X__assert_fail(ts+2791 /* "ctx" */, ts+2 /* "nuklear/nuklear...." */, uint32(29079), uintptr(unsafe.Pointer(&__func__394)))
	}
	if (*Nk_context)(unsafe.Pointer(ctx)).Current != 0 {
	} else {
		X__assert_fail(ts+21912 /* "ctx->current" */, ts+2 /* "nuklear/nuklear...." */, uint32(29080), uintptr(unsafe.Pointer(&__func__394)))
	}
	if (*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout != 0 {
	} else {
		X__assert_fail(ts+21925 /* "ctx->current->la..." */, ts+2 /* "nuklear/nuklear...." */, uint32(29081), uintptr(unsafe.Pointer(&__func__394)))
	}
	if text != 0 {
	} else {
		X__assert_fail(ts+758 /* "text" */, ts+2 /* "nuklear/nuklear...." */, uint32(29082), uintptr(unsafe.Pointer(&__func__394)))
	}
	if ((!(ctx != 0) || !(int32((*Nk_context)(unsafe.Pointer(ctx)).Current) != 0)) || !(int32((*Nk_window)(unsafe.Pointer((*Nk_context)(unsafe.Pointer(ctx)).Current)).Layout) != 0)) || !(text != 0) {
		return
	}

	// fetch configuration data
	style = (ctx + 360 /* &.style */)
	padding = (*Nk_style)(unsafe.Pointer(style)).Window.Padding

	// calculate size of the text and tooltip
	text_len = Xnk_strlen(text)
	text_width = (*(*func(Nk_handle, float32, uintptr, int32) float32)(unsafe.Pointer(((*Nk_style)(unsafe.Pointer(style)).Font + 8 /* &.width */))))((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Userdata,
		(*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height, text, text_len)
	text_width = text_width + (float32(4) * padding.X)
	text_height = ((*Nk_user_font)(unsafe.Pointer((*Nk_style)(unsafe.Pointer(style)).Font)).Height + (float32(2) * padding.Y))

	// execute tooltip and fill with text
	if Xnk_tooltip_begin(ctx, text_width) != 0 {
		Xnk_layout_row_dynamic(ctx, text_height, 1)
		Xnk_text(ctx, text, text_len, NK_TEXT_LEFT)
		Xnk_tooltip_end(ctx)
	}
}

var __func__394 = *(*[11]int8)(unsafe.Pointer(ts + 27352 /* "nk_tooltip" */)) /* nuklear.h:29071:1 */

//
// /// ## License
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
// ///    ------------------------------------------------------------------------------
// ///    This software is available under 2 licenses -- choose whichever you prefer.
// ///    ------------------------------------------------------------------------------
// ///    ALTERNATIVE A - MIT License
// ///    Copyright (c) 2016-2018 Micha Mettke
// ///    Permission is hereby granted, free of charge, to any person obtaining a copy of
// ///    this software and associated documentation files (the "Software"), to deal in
// ///    the Software without restriction, including without limitation the rights to
// ///    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// ///    of the Software, and to permit persons to whom the Software is furnished to do
// ///    so, subject to the following conditions:
// ///    The above copyright notice and this permission notice shall be included in all
// ///    copies or substantial portions of the Software.
// ///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// ///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// ///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// ///    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// ///    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// ///    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// ///    SOFTWARE.
// ///    ------------------------------------------------------------------------------
// ///    ALTERNATIVE B - Public Domain (www.unlicense.org)
// ///    This is free and unencumbered software released into the public domain.
// ///    Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
// ///    software, either in source code form or as a compiled binary, for any purpose,
// ///    commercial or non-commercial, and by any means.
// ///    In jurisdictions that recognize copyright laws, the author or authors of this
// ///    software dedicate any and all copyright interest in the software to the public
// ///    domain. We make this dedication for the benefit of the public at large and to
// ///    the detriment of our heirs and successors. We intend this dedication to be an
// ///    overt act of relinquishment in perpetuity of all present and future rights to
// ///    this software under copyright law.
// ///    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// ///    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// ///    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// ///    AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ///    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// ///    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// ///    ------------------------------------------------------------------------------
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// /// ## Changelog
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none
// /// [date][x.yy.zz]-[description]
// /// -[date]: date on which the change has been pushed
// /// -[x.yy.zz]: Numerical version string representation. Each version number on the right
// ///             resets back to zero if version on the left is incremented.
// ///    - [x]: Major version with API and library breaking changes
// ///    - [yy]: Minor version with non-breaking API and library changes
// ///    - [zz]: Bug fix version with no direct changes to API
// ///
// /// - 2020/10/07 (4.06.0) - Fix nk_combo return type wrongly changed to nk_bool
// /// - 2020/09/05 (4.05.0) - Use the nk_font_atlas allocator for stb_truetype memory management.
// /// - 2020/09/04 (4.04.1) - Replace every boolean int by nk_bool
// /// - 2020/09/04 (4.04.0) - Add nk_bool with NK_INCLUDE_STANDARD_BOOL
// /// - 2020/06/13 (4.03.1) - Fix nk_pool allocation sizes.
// /// - 2020/06/04 (4.03.0) - Made nk_combo header symbols optional.
// /// - 2020/05/27 (4.02.5) - Fix nk_do_edit: Keep scroll position when re-activating edit widget.
// /// - 2020/05/09 (4.02.4) - Fix nk_menubar height calculation bug
// /// - 2020/05/08 (4.02.3) - Fix missing stdarg.h with NK_INCLUDE_STANDARD_VARARGS
// /// - 2020/04/30 (4.02.2) - Fix nk_edit border drawing bug
// /// - 2020/04/09 (4.02.1) - Removed unused nk_sqrt function to fix compiler warnings
// ///                       - Fixed compiler warnings if you bring your own methods for
// ///                        nk_cos/nk_sin/nk_strtod/nk_memset/nk_memcopy/nk_dtoa
// /// - 2020/04/06 (4.01.10) - Fix bug: Do not use pool before checking for NULL
// /// - 2020/03/22 (4.01.9) - Fix bug where layout state wasn't restored correctly after
// ///                        popping a tree.
// /// - 2020/03/11 (4.01.8) - Fix bug where padding is subtracted from widget
// /// - 2020/03/06 (4.01.7) - Fix bug where width padding was applied twice
// /// - 2020/02/06 (4.01.6) - Update stb_truetype.h and stb_rect_pack.h and separate them
// /// - 2019/12/10 (4.01.5) - Fix off-by-one error in NK_INTERSECT
// /// - 2019/10/09 (4.01.4) - Fix bug for autoscrolling in nk_do_edit
// /// - 2019/09/20 (4.01.3) - Fixed a bug wherein combobox cannot be closed by clicking the header
// ///                        when NK_BUTTON_TRIGGER_ON_RELEASE is defined.
// /// - 2019/09/10 (4.01.2) - Fixed the nk_cos function, which deviated significantly.
// /// - 2019/09/08 (4.01.1) - Fixed a bug wherein re-baking of fonts caused a segmentation
// ///                        fault due to dst_font->glyph_count not being zeroed on subsequent
// ///                        bakes of the same set of fonts.
// /// - 2019/06/23 (4.01.0) - Added nk_***_get_scroll and nk_***_set_scroll for groups, windows, and popups.
// /// - 2019/06/12 (4.00.3) - Fix panel background drawing bug.
// /// - 2018/10/31 (4.00.2) - Added NK_KEYSTATE_BASED_INPUT to "fix" state based backends
// ///                        like GLFW without breaking key repeat behavior on event based.
// /// - 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame.
// /// - 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to
// ///                        clear provided buffers. So make sure to either free
// ///                        or clear each passed buffer after calling nk_convert.
// /// - 2018/02/23 (3.00.6) - Fixed slider dragging behavior.
// /// - 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process.
// /// - 2018/01/31 (3.00.4) - Removed name collision with stb_truetype.
// /// - 2018/01/28 (3.00.3) - Fixed panel window border drawing bug.
// /// - 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title.
// /// - 2018/01/07 (3.00.1) - Started to change documentation style.
// /// - 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken
// ///                        because of conversions between float and byte color representation.
// ///                        Color pickers now use floating point values to represent
// ///                        HSV values. To get back the old behavior I added some additional
// ///                        color conversion functions to cast between nk_color and
// ///                        nk_colorf.
// /// - 2017/12/23 (2.00.7) - Fixed small warning.
// /// - 2017/12/23 (2.00.7) - Fixed `nk_edit_buffer` behavior if activated to allow input.
// /// - 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior.
// /// - 2017/12/04 (2.00.6) - Added formated string tooltip widget.
// /// - 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag `NK_WINDOW_NO_INPUT`.
// /// - 2017/11/15 (2.00.4) - Fixed font merging.
// /// - 2017/11/07 (2.00.3) - Fixed window size and position modifier functions.
// /// - 2017/09/14 (2.00.2) - Fixed `nk_edit_buffer` and `nk_edit_focus` behavior.
// /// - 2017/09/14 (2.00.1) - Fixed window closing behavior.
// /// - 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now
// ///                        require the name of the window and must happen outside the window
// ///                        building process (between function call nk_begin and nk_end).
// /// - 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last.
// /// - 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows.
// /// - 2017/08/27 (1.40.7) - Fixed window background flag.
// /// - 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked
// ///                        query for widgets.
// /// - 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked
// ///                        and filled rectangles.
// /// - 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in
// ///                        process of being destroyed.
// /// - 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in
// ///                        window instead of directly in table.
// /// - 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro.
// /// - 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero.
// /// - 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only
// ///                        comes in effect if you pass in zero was row height argument.
// /// - 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change
// ///                        how layouting works. From now there will be an internal minimum
// ///                        row height derived from font height. If you need a row smaller than
// ///                        that you can directly set it by `nk_layout_set_min_row_height` and
// ///                        reset the value back by calling `nk_layout_reset_min_row_height.
// /// - 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix.
// /// - 2017/06/08 (1.39.0) - Added function to retrieve window space without calling a `nk_layout_xxx` function.
// /// - 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer.
// /// - 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped.
// /// - 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries.
// /// - 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space.
// /// - 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size.
// /// - 2017/05/06 (1.38.0) - Added platform double-click support.
// /// - 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends.
// /// - 2017/04/20 (1.37.0) - Extended properties with selection and clipboard support.
// /// - 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing.
// /// - 2017/04/09 (1.36.1) - Fixed #403 with another widget float error.
// /// - 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags.
// /// - 2017/04/09 (1.35.3) - Fixed buffer heap corruption.
// /// - 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows.
// /// - 2017/03/25 (1.35.1) - Fixed windows closing behavior.
// /// - 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377.
// /// - 2017/03/18 (1.34.3) - Fixed long window header titles.
// /// - 2017/03/04 (1.34.2) - Fixed text edit filtering.
// /// - 2017/03/04 (1.34.1) - Fixed group closable flag.
// /// - 2017/02/25 (1.34.0) - Added custom draw command for better language binding support.
// /// - 2017/01/24 (1.33.0) - Added programatic way of remove edit focus.
// /// - 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows.
// /// - 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows.
// /// - 2017/01/21 (1.32.1) - Fixed slider behavior and drawing.
// /// - 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner.
// /// - 2017/01/13 (1.31.0) - Added additional row layouting method to combine both
// ///                        dynamic and static widgets.
// /// - 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit.
// /// - 2016/12/31 (1.29.2) - Fixed closing window bug of minimized windows.
// /// - 2016/12/03 (1.29.1) - Fixed wrapped text with no seperator and C89 error.
// /// - 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters.
// /// - 2016/11/22 (1.28.6) - Fixed window minimized closing bug.
// /// - 2016/11/19 (1.28.5) - Fixed abstract combo box closing behavior.
// /// - 2016/11/19 (1.28.4) - Fixed tooltip flickering.
// /// - 2016/11/19 (1.28.3) - Fixed memory leak caused by popup repeated closing.
// /// - 2016/11/18 (1.28.2) - Fixed memory leak caused by popup panel allocation.
// /// - 2016/11/10 (1.28.1) - Fixed some warnings and C++ error.
// /// - 2016/11/10 (1.28.0) - Added additional `nk_button` versions which allows to directly
// ///                        pass in a style struct to change buttons visual.
// /// - 2016/11/10 (1.27.0) - Added additional `nk_tree` versions to support external state
// ///                        storage. Just like last the `nk_group` commit the main
// ///                        advantage is that you optionally can minimize nuklears runtime
// ///                        memory consumption or handle hash collisions.
// /// - 2016/11/09 (1.26.0) - Added additional `nk_group` version to support external scrollbar
// ///                        offset storage. Main advantage is that you can externalize
// ///                        the memory management for the offset. It could also be helpful
// ///                        if you have a hash collision in `nk_group_begin` but really
// ///                        want the name. In addition I added `nk_list_view` which allows
// ///                        to draw big lists inside a group without actually having to
// ///                        commit the whole list to nuklear (issue #269).
// /// - 2016/10/30 (1.25.1) - Fixed clipping rectangle bug inside `nk_draw_list`.
// /// - 2016/10/29 (1.25.0) - Pulled `nk_panel` memory management into nuklear and out of
// ///                        the hands of the user. From now on users don't have to care
// ///                        about panels unless they care about some information. If you
// ///                        still need the panel just call `nk_window_get_panel`.
// /// - 2016/10/21 (1.24.0) - Changed widget border drawing to stroked rectangle from filled
// ///                        rectangle for less overdraw and widget background transparency.
// /// - 2016/10/18 (1.23.0) - Added `nk_edit_focus` for manually edit widget focus control.
// /// - 2016/09/29 (1.22.7) - Fixed deduction of basic type in non `<stdint.h>` compilation.
// /// - 2016/09/29 (1.22.6) - Fixed edit widget UTF-8 text cursor drawing bug.
// /// - 2016/09/28 (1.22.5) - Fixed edit widget UTF-8 text appending/inserting/removing.
// /// - 2016/09/28 (1.22.4) - Fixed drawing bug inside edit widgets which offset all text
// ///                        text in every edit widget if one of them is scrolled.
// /// - 2016/09/28 (1.22.3) - Fixed small bug in edit widgets if not active. The wrong
// ///                        text length is passed. It should have been in bytes but
// ///                        was passed as glyphes.
// /// - 2016/09/20 (1.22.2) - Fixed color button size calculation.
// /// - 2016/09/20 (1.22.1) - Fixed some `nk_vsnprintf` behavior bugs and removed `<stdio.h>`
// ///                        again from `NK_INCLUDE_STANDARD_VARARGS`.
// /// - 2016/09/18 (1.22.0) - C89 does not support vsnprintf only C99 and newer as well
// ///                        as C++11 and newer. In addition to use vsnprintf you have
// ///                        to include <stdio.h>. So just defining `NK_INCLUDE_STD_VAR_ARGS`
// ///                        is not enough. That behavior is now fixed. By default if
// ///                        both varargs as well as stdio is selected I try to use
// ///                        vsnprintf if not possible I will revert to vsprintf. If
// ///                        varargs but not stdio was defined I will use my own function.
// /// - 2016/09/15 (1.21.2) - Fixed panel `close` behavior for deeper panel levels.
// /// - 2016/09/15 (1.21.1) - Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`.
// /// - 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,
// ///                        and contextual which prevented closing in y-direction if
// ///                        popup did not reach max height.
// ///                        In addition the height parameter was changed into vec2
// ///                        for width and height to have more control over the popup size.
// /// - 2016/09/13 (1.20.3) - Cleaned up and extended type selection.
// /// - 2016/09/13 (1.20.2) - Fixed slider behavior hopefully for the last time. This time
// ///                        all calculation are correct so no more hackery.
// /// - 2016/09/13 (1.20.1) - Internal change to divide window/panel flags into panel flags and types.
// ///                        Suprisinly spend years in C and still happened to confuse types
// ///                        with flags. Probably something to take note.
// /// - 2016/09/08 (1.20.0) - Added additional helper function to make it easier to just
// ///                        take the produced buffers from `nk_convert` and unplug the
// ///                        iteration process from `nk_context`. So now you can
// ///                        just use the vertex,element and command buffer + two pointer
// ///                        inside the command buffer retrieved by calls `nk__draw_begin`
// ///                        and `nk__draw_end` and macro `nk_draw_foreach_bounded`.
// /// - 2016/09/08 (1.19.0) - Added additional asserts to make sure every `nk_xxx_begin` call
// ///                        for windows, popups, combobox, menu and contextual is guarded by
// ///                        `if` condition and does not produce false drawing output.
// /// - 2016/09/08 (1.18.0) - Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`
// ///                        to hopefully easier to understand `NK_SYMBOL_RECT_FILLED` and
// ///                        `NK_SYMBOL_RECT_OUTLINE`.
// /// - 2016/09/08 (1.17.0) - Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`
// ///                        to hopefully easier to understand `NK_SYMBOL_CIRCLE_FILLED` and
// ///                        `NK_SYMBOL_CIRCLE_OUTLINE`.
// /// - 2016/09/08 (1.16.0) - Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`
// ///                        is not defined by supporting the biggest compiler GCC, clang and MSVC.
// /// - 2016/09/07 (1.15.3) - Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error.
// /// - 2016/09/04 (1.15.2) - Fixed wrong combobox height calculation.
// /// - 2016/09/03 (1.15.1) - Fixed gaps inside combo boxes in OpenGL.
// /// - 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and
// ///                        instead made it user provided. The range of types to convert
// ///                        to is quite limited at the moment, but I would be more than
// ///                        happy to accept PRs to add additional.
// /// - 2016/08/30 (1.14.2) - Removed unused variables.
// /// - 2016/08/30 (1.14.1) - Fixed C++ build errors.
// /// - 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly.
// /// - 2016/08/30 (1.13.4) - Tweaked some default styling variables.
// /// - 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would
// ///                        refrain from using slider with a big number of steps.
// /// - 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the
// ///                        window was in Read Only Mode.
// /// - 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just
// ///                        a hack for combo box and menu.
// /// - 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since
// ///                        it is bugged and causes issues in window selection.
// /// - 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now
// ///                        determined by the scrollbar size.
// /// - 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11.0.
// /// - 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection.
// /// - 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code
// ///                        handling panel padding and panel border.
// /// - 2016/08/29 (1.10.0) - Added additional height parameter to `nk_combobox_xxx`.
// /// - 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups.
// /// - 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes.
// /// - 2016/08/26 (1.10.0) - Added window name string prepresentation to account for
// ///                        hash collisions. Currently limited to `NK_WINDOW_MAX_NAME`
// ///                        which in term can be redefined if not big enough.
// /// - 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code.
// /// - 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'
// ///                        to account for key press and release happening in one frame.
// /// - 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate.
// /// - 2016/08/17 (1.09.6) - Removed invalid check for value zero in `nk_propertyx`.
// /// - 2016/08/16 (1.09.5) - Fixed ROM mode for deeper levels of popup windows parents.
// /// - 2016/08/15 (1.09.4) - Editbox are now still active if enter was pressed with flag
// ///                        `NK_EDIT_SIG_ENTER`. Main reasoning is to be able to keep
// ///                        typing after commiting.
// /// - 2016/08/15 (1.09.4) - Removed redundant code.
// /// - 2016/08/15 (1.09.4) - Fixed negative numbers in `nk_strtoi` and remove unused variable.
// /// - 2016/08/15 (1.09.3) - Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background
// ///                        window only as selected by hovering and not by clicking.
// /// - 2016/08/14 (1.09.2) - Fixed a bug in font atlas which caused wrong loading
// ///                        of glyphes for font with multiple ranges.
// /// - 2016/08/12 (1.09.1) - Added additional function to check if window is currently
// ///                        hidden and therefore not visible.
// /// - 2016/08/12 (1.09.1) - nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`
// ///                        instead of the old flag `NK_WINDOW_HIDDEN`.
// /// - 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed
// ///                        the underlying implementation to not cast to float and instead
// ///                        work directly on the given values.
// /// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
// ///                        floating pointer number to string conversion for additional
// ///                        precision.
// /// - 2016/08/09 (1.08.0) - Added additional define to overwrite library internal
// ///                        string to floating point number conversion for additional
// ///                        precision.
// /// - 2016/08/08 (1.07.2) - Fixed compiling error without define `NK_INCLUDE_FIXED_TYPE`.
// /// - 2016/08/08 (1.07.1) - Fixed possible floating point error inside `nk_widget` leading
// ///                        to wrong wiget width calculation which results in widgets falsly
// ///                        becomming tagged as not inside window and cannot be accessed.
// /// - 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and
// ///                        closing a window (NK_WINDOW_CLOSED). A window can be hidden/shown
// ///                        by using `nk_window_show` and closed by either clicking the close
// ///                        icon in a window or by calling `nk_window_close`. Only closed
// ///                        windows get removed at the end of the frame while hidden windows
// ///                        remain.
// /// - 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to
// ///                        `nk_edit_string` which takes, edits and outputs a '\0' terminated string.
// /// - 2016/08/08 (1.05.4) - Fixed scrollbar auto hiding behavior.
// /// - 2016/08/08 (1.05.3) - Fixed wrong panel padding selection in `nk_layout_widget_space`.
// /// - 2016/08/07 (1.05.2) - Fixed old bug in dynamic immediate mode layout API, calculating
// ///                        wrong item spacing and panel width.
// /// - 2016/08/07 (1.05.1) - Hopefully finally fixed combobox popup drawing bug.
// /// - 2016/08/07 (1.05.0) - Split varargs away from `NK_INCLUDE_STANDARD_IO` into own
// ///                        define `NK_INCLUDE_STANDARD_VARARGS` to allow more fine
// ///                        grained controlled over library includes.
// /// - 2016/08/06 (1.04.5) - Changed memset calls to `NK_MEMSET`.
// /// - 2016/08/04 (1.04.4) - Fixed fast window scaling behavior.
// /// - 2016/08/04 (1.04.3) - Fixed window scaling, movement bug which appears if you
// ///                        move/scale a window and another window is behind it.
// ///                        If you are fast enough then the window behind gets activated
// ///                        and the operation is blocked. I now require activating
// ///                        by hovering only if mouse is not pressed.
// /// - 2016/08/04 (1.04.2) - Fixed changing fonts.
// /// - 2016/08/03 (1.04.1) - Fixed `NK_WINDOW_BACKGROUND` behavior.
// /// - 2016/08/03 (1.04.0) - Added color parameter to `nk_draw_image`.
// /// - 2016/08/03 (1.04.0) - Added additional window padding style attributes for
// ///                        sub windows (combo, menu, ...).
// /// - 2016/08/03 (1.04.0) - Added functions to show/hide software cursor.
// /// - 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window
// ///                        to be always in the background of the screen.
// /// - 2016/08/03 (1.03.2) - Removed invalid assert macro for NK_RGB color picker.
// /// - 2016/08/01 (1.03.1) - Added helper macros into header include guard.
// /// - 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to
// ///                        simplify memory management by removing the need to
// ///                        allocate the pool.
// /// - 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled
// ///                        will hide the window scrollbar after NK_SCROLLBAR_HIDING_TIMEOUT
// ///                        seconds without window interaction. To make it work
// ///                        you have to also set a delta time inside the `nk_context`.
// /// - 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs.
// /// - 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`.
// /// - 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument.
// /// - 2016/07/15 (1.01.0) - Removed internal font baking API and simplified
// ///                        font atlas memory management by converting pointer
// ///                        arrays for fonts and font configurations to lists.
// /// - 2016/07/15 (1.00.0) - Changed button API to use context dependend button
// ///                        behavior instead of passing it for every function call.
// /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// /// ## Gallery
// /// ![Figure [blue]: Feature overview with blue color styling](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)
// /// ![Figure [red]: Feature overview with red color styling](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)
// /// ![Figure [widgets]: Widget overview](https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png)
// /// ![Figure [blackwhite]: Black and white](https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png)
// /// ![Figure [filexp]: File explorer](https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png)
// /// ![Figure [opengl]: OpenGL Editor](https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png)
// /// ![Figure [nodedit]: Node Editor](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)
// /// ![Figure [skinning]: Using skinning in Nuklear](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)
// /// ![Figure [bf]: Heavy modified version](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)
// ///
// /// ## Credits
// /// Developed by Micha Mettke and every direct or indirect github contributor. <br /><br />
// ///
// /// Embeds [stb_texedit](https://github.com/nothings/stb/blob/master/stb_textedit.h), [stb_truetype](https://github.com/nothings/stb/blob/master/stb_truetype.h) and [stb_rectpack](https://github.com/nothings/stb/blob/master/stb_rect_pack.h) by Sean Barret (public domain) <br />
// /// Uses [stddoc.c](https://github.com/r-lyeh/stddoc.c) from r-lyeh@github.com for documentation generation <br /><br />
// /// Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). <br />
// ///
// /// Big thank you to Omar Cornut (ocornut@github) for his [imgui library](https://github.com/ocornut/imgui) and
// /// giving me the inspiration for this library, Casey Muratori for handmade hero
// /// and his original immediate mode graphical user interface idea and Sean
// /// Barret for his amazing single header libraries which restored my faith
// /// in libraries and brought me to create some of my own. Finally Apoorva Joshi
// /// for his single header file packer.

var ts1 = "a\x00nuklear/nuklear.h\x00clip\x00nk_unify\x00result\x00nk_triangle_from_direction\x00ptr\x00nk_zero\x00str\x00nk_strlen\x00nk_strtoi\x00nk_strtod\x00n >= 0\x00nk_stricmpn\x00pattern\x00nk_strmatch_fuzzy_text\x00s\x00nk_dtoa\x00u\x00nk_utf_validate\x00i\x00nk_utf_decode_byte\x00c\x00nk_utf_decode\x00nk_utf_len\x00buffer\x00unicode\x00len\x00nk_utf_at\x00b\x00initial_size\x00nk_buffer_init\x00m\x00size\x00nk_buffer_init_fixed\x00temp\x00nk_buffer_realloc\x00b->pool.alloc && b->pool.free\x00nk_buffer_alloc\x00nk_buffer_mark\x00nk_buffer_reset\x00nk_buffer_clear\x00b->pool.free\x00nk_buffer_free\x00nk_buffer_info\x00nk_buffer_memory\x00nk_buffer_memory_const\x00nk_buffer_total\x00nk_str_append_text_char\x00nk_str_append_text_runes\x00nk_str_append_str_runes\x00len >= 0\x00((int)pos + (int)len + ((int)copylen - 1)) >= 0\x00((int)pos + ((int)copylen - 1)) >= 0\x00nk_str_insert_at_char\x00cstr\x00nk_str_insert_at_rune\x00text\x00nk_str_insert_text_utf8\x00nk_str_insert_text_runes\x00nk_str_insert_str_runes\x00((int)s->buffer.allocated - (int)len) >= 0\x00nk_str_remove_chars\x00nk_str_remove_runes\x00nk_str_delete_chars\x00s->len >= pos + len\x00nk_str_delete_runes\x00nk_str_at_char\x00nk_str_at_rune\x00nk_str_at_char_const\x00nk_str_at_const\x00nk_str_get\x00nk_str_get_const\x00nk_str_len\x00nk_str_len_char\x00nk_str_clear\x00nk_str_free\x00cb\x00nk_command_buffer_init\x00nk_command_buffer_reset\x00b->base\x00nk_command_buffer_push\x00nk_push_scissor\x00nk_stroke_line\x00nk_stroke_curve\x00nk_stroke_rect\x00nk_fill_rect\x00nk_fill_rect_multi_color\x00nk_fill_circle\x00nk_fill_arc\x00nk_stroke_triangle\x00nk_fill_triangle\x00nk_stroke_polygon\x00nk_fill_polygon\x00nk_stroke_polyline\x00nk_draw_image\x00nk_push_custom\x00font\x00nk_draw_text\x00list\x00nk_draw_list_init\x00canvas\x00config\x00cmds\x00vertices\x00elements\x00nk_draw_list_setup\x00nk__draw_list_begin\x00nk__draw_list_end\x00nk__draw_list_next\x00list->path_count\x00nk_draw_list_path_last\x00nk_draw_list_push_command\x00list->cmd_count\x00nk_draw_list_command_last\x00nk_draw_list_add_clip\x00nk_draw_list_push_image\x00(list->vertex_count < 65535 && \"To many verticies for 16-bit vertex indicies. Please read comment above on how to solve this problem\")\x00nk_draw_list_alloc_vertices\x00nk_draw_list_alloc_elements\x00format >= NK_FORMAT_COLOR_BEGIN\x00format <= NK_FORMAT_COLOR_END\x000 && \"Invalid vertex layout color format\"\x00nk_draw_vertex_color\x00format < NK_FORMAT_COLOR_BEGIN\x000 && \"invalid vertex layout format\"\x00nk_draw_vertex_element\x000 && \"wrong element attribute\"\x00nk_draw_vertex\x00nk_draw_list_stroke_poly_line\x00nk_draw_list_fill_poly_convex\x00nk_draw_list_path_clear\x00nk_draw_list_path_line_to\x00nk_draw_list_path_arc_to_fast\x00nk_draw_list_path_arc_to\x00nk_draw_list_path_rect_to\x00nk_draw_list_path_curve_to\x00nk_draw_list_path_fill\x00nk_draw_list_path_stroke\x00nk_draw_list_stroke_line\x00nk_draw_list_fill_rect\x00nk_draw_list_stroke_rect\x00nk_draw_list_fill_rect_multi_color\x00nk_draw_list_fill_triangle\x00nk_draw_list_stroke_triangle\x00nk_draw_list_fill_circle\x00nk_draw_list_stroke_circle\x00nk_draw_list_stroke_curve\x00nk_draw_list_push_rect_uv\x00nk_draw_list_add_image\x00nk_draw_list_add_text\x00ctx\x00config->vertex_layout\x00config->vertex_size\x00nk_convert\x00heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight\x000\x00stbrp_setup_heuristic\x00width <= 0xffff && height <= 0xffff\x00stbrp_init_target\x00first->x <= x0\x00node->next->x > x0\x00node->x <= x0\x00stbrp__skyline_find_min_y\x00width % c->align == 0\x00xpos >= 0\x00node->next->x > xpos && node->x <= xpos\x00y <= best_y\x00stbrp__skyline_find_best_pos\x00!(o > b->size || o < 0)\x00stbtt__buf_seek\x00n >= 1 && n <= 4\x00stbtt__buf_get\x00size < 0x40000000\x00stbtt__new_buf\x00offsize >= 1 && offsize <= 4\x00stbtt__cff_get_index\x00stbtt__cff_int\x00b0 >= 28\x00stbtt__cff_skip_operand\x00i >= 0 && i < count\x00stbtt__cff_index_get\x00typ1\x00OTTO\x00true\x00ttcf\x00SVG \x00cmap\x00loca\x00head\x00glyf\x00hhea\x00hmtx\x00kern\x00GPOS\x00CFF \x00maxp\x00unicode_codepoint <= ttUSHORT(data + endCount + 2*item)\x00stbtt_FindGlyphIndex\x00!info->cff.size\x00stbtt__GetGlyfOffset\x00stbtt__GetGlyphShapeTT\x00output_ctx.num_vertices == count_ctx.num_vertices\x00stbtt__GetGlyphShapeT2\x00stbtt__GetCoverageIndex\x00stbtt__GetGlyphClass\x00coverageIndex < pairSetCount\x00glyph1class < class1Count\x00glyph2class < class2Count\x00stbtt__GetGlyphGPOSInfoAdvance\x00OS/2\x00z != ((void *)0)\x00stbtt__new_active\x00y0 < y1\x00e->sy <= e->ey\x00x1 <= x+1\x00x1 >= x\x00x1 <= x\x00x1 >= x+1\x00x1 >= x && x1 <= x+1\x00x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1\x00stbtt__handle_clipped_edge\x00e->ey >= y_top\x00e->sy <= y_bottom && e->ey >= y_top\x00x >= 0 && x < len\x00fabs(area) <= 1.01f\x00stbtt__fill_active_edges_new\x00z->direction\x00z->ey >= scan_y_top\x00stbtt__rasterize_sorted_edges\x00x+gw < pw\x00y+gh < ph\x00stbtt_BakeFontBitmap_internal\x00h_oversample <= 8\x00v_oversample <= 8\x00stbtt_PackSetOversampling\x00pixels[i] == 0\x00stbtt__h_prefilter\x00pixels[i*stride_in_bytes] == 0\x00stbtt__v_prefilter\x00i != 0\x00stbtt_GetGlyphSDF\x00name\x00range\x00nk_range_count\x00t >= f\x00nk_range_glyph_count\x00config_list\x00glyph_count\x00nk_font_baker_memory\x00image_memory\x00width\x00height\x00count\x00alloc\x00rect_n == total_glyph_count\x00char_n == total_glyph_count\x00range_n == total_range_count\x00nk_font_bake_pack\x00baker\x00font_count\x00glyphs_count\x00nk_font_bake\x00img_memory\x00img_width\x00img_height\x00texture_data_mask\x00nk_font_bake_custom_data\x00out_memory\x00in_memory\x00nk_font_bake_convert\x00font->glyphs\x00nk_font_text_width\x00glyph\x00nk_font_query_font_glyph\x00font->info.ranges\x00nk_font_find_glyph\x00glyphs\x00baked_font\x00nk_font_init\x007])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`NkfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc.x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)(h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnOj%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjOM7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(etHg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJsbIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD:k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kTLwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@IwOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$PiDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#\x00..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....XX           -  X.X  - X.....X -        X.....X        -X...X            -            X...XXX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..XX.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.XX..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XXX...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -                 X..X          -  X...X  -         X...X         -  X..X           X..X  -                  XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           ------------        -    X    -           X           -X.....................X-                               ----------------------------------- X...XXXXXXXXXXXXX...X -                                                                 -  X..X           X..X  -                                                                 -   X.X           X.X   -                                                                 -    XX           XX    -           \x00nk__dout + length <= nk__barrier\x00nk__match\x00nk__lit\x00nk__dout == output + olen\x00nk__dout <= output + olen\x00nk_decompress\x00atlas\x00nk_font_atlas_init_default\x00nk_font_atlas_init\x00permanent\x00temporary\x00nk_font_atlas_init_custom\x00atlas->temporary.alloc && atlas->temporary.free\x00atlas->permanent.alloc && atlas->permanent.free\x00nk_font_atlas_begin\x00atlas->permanent.alloc\x00atlas->permanent.free\x00atlas->temporary.alloc\x00atlas->temporary.free\x00config->ttf_blob\x00config->ttf_size\x00config->size > 0.0f\x00atlas->font_num\x00cfg->ttf_blob\x00nk_font_atlas_add\x00memory\x00nk_font_atlas_add_from_memory\x00compressed_data\x00compressed_size\x00decompressed_data\x00nk_font_atlas_add_compressed\x00data_base85\x00nk_font_atlas_add_compressed_base85\x00nk_font_atlas_add_default\x00tmp\x00atlas->glyphs\x00atlas->pixel\x00img_rgba\x00nk_font_atlas_bake\x00nk_font_atlas_end\x00nk_font_atlas_cleanup\x00nk_font_atlas_clear\x00nk_input_begin\x00nk_input_end\x00nk_input_motion\x00nk_input_key\x00nk_input_button\x00nk_input_scroll\x00nk_input_glyph\x00nk_input_char\x00nk_input_unicode\x00NK_COLOR_TEXT\x00NK_COLOR_WINDOW\x00NK_COLOR_HEADER\x00NK_COLOR_BORDER\x00NK_COLOR_BUTTON\x00NK_COLOR_BUTTON_HOVER\x00NK_COLOR_BUTTON_ACTIVE\x00NK_COLOR_TOGGLE\x00NK_COLOR_TOGGLE_HOVER\x00NK_COLOR_TOGGLE_CURSOR\x00NK_COLOR_SELECT\x00NK_COLOR_SELECT_ACTIVE\x00NK_COLOR_SLIDER\x00NK_COLOR_SLIDER_CURSOR\x00NK_COLOR_SLIDER_CURSOR_HOVER\x00NK_COLOR_SLIDER_CURSOR_ACTIVE\x00NK_COLOR_PROPERTY\x00NK_COLOR_EDIT\x00NK_COLOR_EDIT_CURSOR\x00NK_COLOR_COMBO\x00NK_COLOR_CHART\x00NK_COLOR_CHART_COLOR\x00NK_COLOR_CHART_COLOR_HIGHLIGHT\x00NK_COLOR_SCROLLBAR\x00NK_COLOR_SCROLLBAR_CURSOR\x00NK_COLOR_SCROLLBAR_CURSOR_HOVER\x00NK_COLOR_SCROLLBAR_CURSOR_ACTIVE\x00NK_COLOR_TAB_HEADER\x00nk_style_from_table\x00nk_style_set_font\x00font_stack->head < (int)(sizeof(font_stack->elements)/sizeof(font_stack->elements)[0])\x00nk_style_push_font\x00font_stack->head > 0\x00nk_style_pop_font\x00type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])\x00nk_style_push_style_item\x00nk_style_push_float\x00nk_style_push_vec2\x00nk_style_push_flags\x00nk_style_push_color\x00type_stack->head > 0\x00nk_style_pop_style_item\x00nk_style_pop_float\x00nk_style_pop_vec2\x00nk_style_pop_flags\x00nk_style_pop_color\x00nk_style_set_cursor\x00nk_style_load_cursor\x00nk_style_load_all_cursors\x00nk_setup\x00nk_init_fixed\x00pool\x00nk_init_custom\x00nk_init\x00nk_free\x00nk_clear\x00nk_start_buffer\x00win\x00nk_start\x00nk_start_popup\x00nk_finish_popup\x00nk_finish_buffer\x00nk_finish\x00nk__begin\x00nk__next\x00capacity >= 1\x00nk_pool_init\x00size >= sizeof(struct nk_page)\x00nk_pool_init_fixed\x00pool->pages\x00pool->pages->size < pool->capacity\x00nk_pool_alloc\x00elem\x00nk_create_page_element\x00tbl\x00nk_add_value\x00ctx->current\x00ctx->current->layout\x00nk_panel_begin\x00!layout->row.tree_depth\x00nk_panel_end\x00iter != iter->next\x00nk_find_window\x00iter != win\x00nk_insert_window\x00title\x00ctx->style.font && ctx->style.font->width && \"if this triggers you forgot to add a font\"\x00!ctx->current && \"if this triggers you missed a `nk_end` call\"\x00win->seq != ctx->seq\x00nk_begin_titled\x00ctx->current && \"if this triggers you forgot to call `nk_begin`\"\x00nk_end\x00nk_window_get_bounds\x00nk_window_get_position\x00nk_window_get_size\x00nk_window_get_width\x00nk_window_get_height\x00nk_window_get_content_region\x00nk_window_get_content_region_min\x00nk_window_get_content_region_max\x00nk_window_get_content_region_size\x00nk_window_get_canvas\x00nk_window_get_panel\x00nk_window_get_scroll\x00nk_window_has_focus\x00nk_window_is_hovered\x00nk_window_is_any_hovered\x00nk_window_is_collapsed\x00nk_window_is_closed\x00nk_window_is_hidden\x00nk_window_is_active\x00ctx->current != win && \"You cannot close a currently active window\"\x00nk_window_close\x00ctx->current != win && \"You cannot update a currently in procecss window\"\x00nk_window_set_bounds\x00nk_window_set_scroll\x00nk_window_collapse\x00nk_window_collapse_if\x00nk_window_show\x00nk_window_show_if\x00nk_window_set_focus\x00!(panel->type & NK_PANEL_SET_POPUP) && \"popups are not allowed to have popups\"\x00nk_popup_begin\x00!(panel->type & NK_PANEL_SET_POPUP)\x00popup->layout\x00nk_nonblock_begin\x00popup->parent\x00popup->layout->type & NK_PANEL_SET_POPUP\x00nk_popup_close\x00nk_popup_end\x00nk_popup_get_scroll\x00nk_popup_set_scroll\x00nk_contextual_begin\x00nk_contextual_item_text\x00nk_contextual_item_image_text\x00nk_contextual_item_symbol_text\x00nk_contextual_close\x00panel->type & NK_PANEL_SET_POPUP\x00nk_contextual_end\x00layout->at_y == layout->bounds.y\x00nk_menubar_begin\x00nk_menubar_end\x00nk_menu_begin\x00nk_menu_begin_text\x00nk_menu_begin_image\x00nk_menu_begin_symbol\x00nk_menu_begin_image_text\x00nk_menu_begin_symbol_text\x00nk_layout_set_min_row_height\x00nk_layout_reset_min_row_height\x00!(layout->flags & NK_WINDOW_MINIMIZED)\x00!(layout->flags & NK_WINDOW_HIDDEN)\x00!(layout->flags & NK_WINDOW_CLOSED)\x00nk_panel_layout\x00nk_row_layout\x00pixel_width\x00nk_layout_ratio_from_pixel\x00nk_layout_row_begin\x00layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW\x00nk_layout_row_push\x00nk_layout_row_end\x00nk_layout_row\x00nk_layout_row_template_begin\x00layout->row.type == NK_LAYOUT_TEMPLATE\x00layout->row.columns < 16\x00nk_layout_row_template_push_dynamic\x00nk_layout_row_template_push_variable\x00nk_layout_row_template_push_static\x00nk_layout_row_template_end\x00nk_layout_space_begin\x00nk_layout_space_end\x00nk_layout_space_push\x00nk_layout_space_bounds\x00nk_layout_widget_bounds\x00nk_layout_space_to_screen\x00nk_layout_space_to_local\x00nk_layout_space_rect_to_screen\x00nk_layout_space_rect_to_local\x00bounds\x00layout->row.ratio\x00layout->row.index < layout->row.columns\x00layout->row.index < 16\x00nk_layout_widget_space\x00nk_panel_alloc_space\x00nk_layout_peek\x00nk_tree_state_base\x00layout->row.tree_depth\x00nk_tree_state_pop\x00nk_tree_element_image_push_hashed_base\x00win->layout\x00g->parent\x00nk_group_scrolled_end\x00id\x00x_offset\x00y_offset\x00nk_group_begin_titled\x00x_offset_ptr\x00y_offset_ptr\x00nk_group_get_scroll\x00nk_group_set_scroll\x00view\x00nk_list_view_begin\x00view->ctx\x00view->scroll_pointer\x00nk_list_view_end\x00nk_widget_bounds\x00nk_widget_position\x00nk_widget_size\x00nk_widget_width\x00nk_widget_height\x00nk_widget_is_hovered\x00nk_widget_is_mouse_clicked\x00nk_widget_has_mouse_click_down\x00nk_widget\x00nk_widget_fitting\x00nk_spacing\x00o\x00t\x00nk_widget_text\x00nk_widget_text_wrap\x00nk_text_colored\x00nk_text_wrap_colored\x00nk_text\x00nk_text_wrap\x00nk_image_ptr\x00img\x00nk_image_is_subimage\x00nk_image\x00nk_image_color\x00x\x00_\x00+\x00-\x00style\x00state\x00out\x00nk_do_button\x00string\x00nk_do_button_text\x00nk_do_button_symbol\x00nk_do_button_image\x00nk_do_button_text_symbol\x00nk_do_button_text_image\x00nk_button_set_behavior\x00button_stack->head < (int)(sizeof(button_stack->elements)/sizeof(button_stack->elements)[0])\x00nk_button_push_behavior\x00button_stack->head > 0\x00nk_button_pop_behavior\x00nk_button_text_styled\x00nk_button_text\x00nk_button_color\x00nk_button_symbol_styled\x00nk_button_symbol\x00nk_button_image_styled\x00nk_button_image\x00nk_button_symbol_text_styled\x00nk_button_symbol_text\x00nk_button_image_text_styled\x00nk_do_toggle\x00nk_check_text\x00nk_check_flags_text\x00active\x00nk_checkbox_text\x00flags\x00nk_checkbox_flags_text\x00nk_option_text\x00nk_radio_text\x00value\x00nk_do_selectable\x00nk_do_selectable_image\x00nk_do_selectable_symbol\x00nk_selectable_text\x00nk_selectable_image_text\x00nk_selectable_symbol_text\x00nk_do_slider\x00nk_slider_float\x00nk_do_progress\x00cur\x00nk_progress\x00nk_do_scrollbarv\x00nk_do_scrollbarh\x00nk_textedit_text\x00nk_textedit_init_fixed\x00nk_textedit_init\x00nk_textedit_init_default\x00nk_textedit_select_all\x00nk_textedit_free\x00nk_edit_draw_text\x00\n\x00    \x00select_begin_ptr\x00select_end_ptr\x00cursor_ptr\x00nk_do_edit\x00nk_edit_focus\x00nk_edit_unfocus\x00nk_edit_string\x00edit\x00nk_edit_buffer\x00nk_property\x00val\x00nk_property_int\x00nk_property_float\x00nk_property_double\x00nk_propertyi\x00nk_propertyf\x00nk_propertyd\x00nk_chart_begin_colored\x00ctx->current->layout->chart.slot < 4\x00nk_chart_add_slot_colored\x00slot >= 0 && slot < 4\x00nk_chart_push_line\x00nk_chart_push_column\x00slot < ctx->current->layout->chart.slot\x00nk_chart_push_slot\x00nk_chart_end\x00values\x00nk_plot\x00value_getter\x00nk_plot_function\x00matrix\x00hue_bar\x00color\x00nk_color_picker_behavior\x00nk_draw_color_picker\x00col\x00nk_do_color_picker\x00nk_color_pick\x00nk_combo_begin\x00selected\x00nk_combo_begin_text\x00nk_combo_begin_color\x00nk_combo_begin_symbol\x00nk_combo_begin_symbol_text\x00nk_combo_begin_image\x00nk_combo_begin_image_text\x00items\x00nk_combo\x00items_separated_by_separator\x00nk_combo_separator\x00item_getter\x00nk_combo_callback\x00__##Tooltip##__\x00nk_tooltip_begin\x00nk_tooltip_end\x00nk_tooltip\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
